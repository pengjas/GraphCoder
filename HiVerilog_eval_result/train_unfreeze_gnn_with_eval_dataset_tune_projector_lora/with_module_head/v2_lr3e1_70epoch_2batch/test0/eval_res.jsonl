{"task_id": "systolic1x2", "res": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  always@(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n    end\n    else begin\n      b1 <= b0; // pass b0 to next PE\n    end\n  end\n  \nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "stagepipe5", "res": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\n\n// Pipeline stages\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n// Pipeline signals\nwire [31:0] inst, pc, reg_file_data, alu_result, mem_inst;\nwire [4:0] rd, rs1, rs2;\nwire [1:0] op;\n\n// Instance fetch stage\nfetch_stage fetch (\n  .clk(clk),\n  .rst(rst),\n  .inst(inst),\n  .pc(pc),\n  .instr_mem(instr_mem)\n);\n\n// Instance decode stage\ndecode_stage decode (\n  .inst(inst),\n  .rd(rd),\n  .rs1(rs1),\n  .rs2(rs2),\n  .op(op)\n);\n\n// Instance execute stage\nexecute_stage execute (\n  .clk(clk),\n  .rst(rst),\n  .inst(inst),\n  .reg_file_data(reg_file_data),\n  .alu_result(alu_result),\n  .op(op)\n);\n\n// Instance memory stage\nmemory_stage memory (\n  .clk(clk),\n  .inst(inst),\n  .reg_file_data(reg_file_data),\n  .alu_result(alu_result),\n  .mem_inst(mem_inst)\n);\n\n// Instance writeback stage\nwriteback_stage writeback (\n  .clk(clk),\n  .rst(rst),\n  .inst(inst),\n  .mem_inst(mem_inst),\n  .reg_file_data(reg_file_data),\n  .res_reg_file(res_reg_file)\n);\nendmodule\n\n// Fetch stage module\nmodule fetch_stage(\n  input clk,\n  input rst,\n  output reg [31:0] inst,\n  output reg [31:0] pc,\n  input [31:0] instr_mem [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      pc <= 0;\n    else if(inst == 0)\n      pc <= pc + 1; // Fetch next instruction\n  end\n  always @(posedge clk) begin\n    inst <= instr_mem[pc>>2]; // Fetch instruction\n  end\nendmodule\n\n// Decode stage module\nmodule decode_stage(\n  input [31:0] inst,\n  output reg [4:0] rd,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [1:0] op\n);\n  always @(*) begin\n    rs1 = inst[20:16];\n    rs2 = inst[15:11];\n    rd = inst[15:11];\n    case(inst[31:27])\n      3'b00000: op = 2'b00; // ADD\n      3'b00001: op = 2'b01; // SUB\n      default: begin\n        op = 2'b10; // Others are undefined\n        rs1 = 0;\n        rs2 = 0;\n        rd = 0;\n      end\n    endcase\n  end\nendmodule\n\n// Execute stage module\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] inst,\n  input [31:0] reg_file_data [0:31],\n  output reg [31:0] alu_result,\n  input [1:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      alu_result <= 0;\n    else if(inst == 0)\n      alu"}
{"task_id": "systolic1x4", "res": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\nreg [15:0] b1, b2, b3;\n// 4 PEs\nPE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\nPE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nPE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\nPE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n// Cascade b connections \nalways@(posedge clk or posedge rst) begin\n  if (rst) begin\n    b1 <= 0;\n    b2 <= 0;\n    b3 <= 0;\n  end\n  else begin\n    b1 <= b0; // pass b0 to next PE\n    b2 <= b1;\n    b3 <= b2;\n  end\nend\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "stagepipe3", "res": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] inst;\n    wire [31:0] result;\n    // Instruction Fetch & Decode\n    fetch_stage fetch (.clk(clk), .rst(rst), .inst_mem(instr_mem), \n        .pc(out_reg_file), \n        .inst(inst));\n    // Execute\n    execute_stage execute (\n        .clk(clk), \n        .inst(inst), \n        .reg_file(reg_file), \n        .result(result));\n\n    // Writeback\n    writeback_stage writeback (\n        .clk(clk), \n        .result(result), \n        .reg_file(out_reg_file));\n\nendmodule\nmodule fetch_stage(input clk, input rst, input [31:0] inst_mem [0:31], \n    input reg_file [31:0], \n    output reg [31:0] pc,\n    output reg [31:0] inst);\n    always @(posedge clk or posedge rst) begin\n        // Fetch logic\n        if (rst) \n            pc <= 0;\n        if (clk) begin\n            if (inst_mem[pc])\n                inst <= inst_mem[pc];\n            else\n                inst <= 0;\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(input clk, input [31:0] inst, input reg_file [31:0],\n    output reg [31:0] result);\n    always @(posedge clk) begin\n        case (inst[31:30])\n            `ADD_INST: begin\n                result <= reg_file[inst[2:0]] + reg_file[inst[5:3]];\n            end\n            `SUB_INST: begin\n                result <= reg_file[inst[2:0]] - reg_file[inst[5:3]];\n            end\n            default: begin\n                result <= 0;\n            end\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(input clk, input [31:0] result,\n    input reg_file [31:0] reg_file);\n    always @(posedge clk) begin\n        reg_file[0] <= result; // For example purpose. Write to R0\n    end\nendmodule"}
{"task_id": "accu", "res": "`timescale 1ns/1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire add_cnt;\n    wire ready_add;\n    wire [9:0] data_out_reg;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_cnt(add_cnt),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .add_cnt(add_cnt),\n        .count(count),\n        .data_out(data_out_reg)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_cnt(add_cnt),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\n    assign add_cnt = ready_add;\n    assign data_out = data_out_reg;\n\n    endmodule\n\n    module counter (\n        input               clk,\n        input               rst_n,\n        input               add_cnt,\n        output reg [3:0]   count\n    );\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0;\n        end else if (add_cnt) begin\n            if (count == 4'b1111) begin\n                count <= 4'b0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               add_cnt,\n    input   [3:0]       count,\n    output reg [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 10'b0;\n        end else if (add_cnt) begin\n            data_out <= data_out + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               add_cnt,\n    input   [3:0]       count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n        end else if (add_cnt) begin\n            if (count == 4'b1111) begin\n                valid_out <= 1'b1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "res": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;  // 8-bit input operand A\n    input [7:0] B;  // 8-bit input operand B\n    output [7:0] D; // 8-bit output representing the difference A - B\n    output B_out; // Borrow output\n\n    wire [7:0] B_complement; // 8-bit 2's complement of B\n    wire borrow; // Borrow flag\n\n    // Generate the 2's complement of B\n    assign B_complement = ~B + 1;\n\n    // Instantiate the adder; add A and the complemented B\n    adder_8bit adder_inst(\n        .a(A),\n        .b(B_complement),\n        .add_result(D),\n        .borrow(borrow)\n    );\n\n    // Determine if a borrow was generated\n    assign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(a, b, add_result, borrow);\n    input [7:0] a;          // 8-bit input operand A\n    input [7:0] b;          // 8-bit input operand B\n    output [7:0] add_result; // 8-bit output representing the sum of A and B\n    output borrow;          // Borrow flag\n\n    wire [7:0] sum;          // 8-bit wired OR\n    wire [7:0] with_borrow;  // 8-bit with borrow\n\n    assign {with_borrow[6:0], borrow} = a + b + borrow;\n    assign {sum[6:0], borrow} = a + b;\n    assign add_result = with_borrow; // if (borrow) add_result = sum; else add_result = with_borrow;\n\nendmodule"}
{"task_id": "radix2_div", "res": "`timescale 1ns/1ps\n\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n    wire [8:0] ctr;\n    wire [8:0] sr;\n    wire [15:0] q1, q0;\n    wire [8:0] i;\n    wire signed_16_bit_signed_class dividend_abs;\n    wire signed_16_bit_signed_class divisor_neg;\n    wire [15:0] result_final;\n\n    // Instantiate modules\n    abs_value abs_dividend (\n        .sign(sign),\n        .value(dividend),\n        .abs_value(dividend_abs)\n    );\n\n    neg_value neg_divisor (\n        .sign(sign),\n        .value(divisor),\n        .neg_value(divisor_neg)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .dividend_abs(dividend_abs),\n        .neg_divisor(divisor_neg),\n        .result_final(result_final),\n        .q0(q0),\n        .q1(q1),\n        .sr(sr),\n        .ctr(ctr)\n    );\n\n    result_management res_mgmt (\n        .res_valid(res_valid),\n        .result(result),\n        .ctr(ctr),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .result_final(result_final)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire sign,\n    input wire [7:0] value,\n    output reg [15:0] abs_value\n);\n    always @(*) begin\n        if (sign == 1) begin\n            abs_value = {1'b0, value};\n        end else begin\n            abs_value = {8{value[7]}}, value; // 8'h80 for 8'h8\n        end\n    end\nendmodule\n\nmodule neg_value(\n    input wire sign,\n    input wire [7:0] value,\n    output reg [15:0] neg_value\n);\n    always @(*) begin\n        if (sign == 1) begin\n            neg_value = ~value + 1;\n        end else begin\n            neg_value = {8{1'b0}}, value; // 8'h00 for 8'h8\n        end\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg res_valid,\n    input wire [15:0] dividend_abs,\n    input wire [15:0] neg_divisor,\n    output reg [15:0] q0,\n    output reg [15:0] q1,\n    output reg [8:0] sr,\n    output reg ctr,\n    output reg [15:0] result_final\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ctr <= 0;\n            sr <= 0;\n            q0 <= 0;\n            q1 <= 0;\n            result_final <= 0;\n            res_valid <= 1'b0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                res_valid <= 1'b1;\n                ctr <= 0;\n                sr <= {1'b0, dividend_abs[7:1]}; // Shift right by 1 bit\n                q0 <= {1'b0, dividend_abs[7:1]};\n                q1 <= {1'"}
{"task_id": "sub_32bit", "res": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;  // 32-bit input operand A\n    input [31:0] B;  // 32-bit input operand B\n    output [31:0] Diff; // 32-bit output representing the difference A - B\n    output B_out;    // Borrow-out output \n\n    wire [15:0] B_neg; // Negated B for 1's complement\n    wire [15:0] A_hi;  // High half of A\n    wire [15:0] A_lo;  // Low half of A\n    wire [15:0] B_hi;  // High half of B\n    wire [15:0] B_lo;  // Low half of B\n    wire [15:0] Diff_hi;  // High half of difference\n    wire [15:0] Diff_lo;  // Low half of difference\n    wire borrow1, borrow2; // Borrow signals from two 16-bit subtractors\n\n    // Negate B to get 1's complement\n    assign B_neg = ~B[15:0];\n\n    // Instantiate two 16-bit subtractors\n    subtractor_16 S1(\n        .A(A[31:16]),\n        .B(B_neg[15:0]),\n        .Borrow(borrow1),\n        .Diff(Diff_hi)\n    );\n    subtractor_16 S2(\n        .A(A[15:0]),\n        .B(B_neg[31:16]),\n        .Borrow(borrow1 || ~B_hi[15]),\n        .Diff(Diff_lo)\n    );\n\n    // Assemble the final difference\n    assign Diff = {Diff_hi[15:0], Diff_lo[15:0]};\n\n    // Calculate borrow for output B_out\n    assign B_out = ~(borrow1 || ~B_hi[15]);\nendmodule\n\nmodule subtractor_16(A, B, Borrow, Diff);\n    input [15:0] A;         // Input operand A\n    input [15:0] B;         // Input operand B\n    input Borrow;           // Preshared borrow input\n    output reg [15:0] Diff; // Output difference\n    output BorrowOut;       // Borrow output\n\n    wire [14:0] B_neg;      // Negated B\n    wire [14:0] A_hi;       // High half of A\n    wire [14:0] A_lo;       // Low half of A\n    wire [14:0] B_hi;       // High half of B\n    wire [14:0] B_lo;       // Low half of B\n    wire [14:0] Diff_hi;    // High half of difference\n    wire [14:0] Diff_lo;    // Low half of difference\n    wire borrow1, borrow2; // Two borrow signals\n\n    // Negate B to get 1's complement\n    assign B_neg = ~B;\n\n    // Extract high and low halves of A and B\n    assign A_hi = A[31:16];\n    assign A_lo = A[15:0];\n    assign B_hi = B_neg[31:16];\n    assign B_lo = B_neg[15:0];\n\n    // Instantiate four 4-bit subtractors\n    subtractor_4 S1(\n        .A(A_hi),\n        .B(B_hi),\n        .Borrow(borrow1),\n        .Diff(Diff_hi)\n    );\n    subtractor_4 S2(\n        .A(A_hi),\n        .B(B_lo),\n        .Borrow(borrow2),\n        .Diff(Diff_lo[14:8])\n    );\n    subtractor_4 S3(\n        .A(A_lo),\n        .B(B_hi),\n        .Borrow(borrow2 || ~B_hi[3]),\n        .Diff(Diff_lo[7:0])"}
{"task_id": "up_down_counter", "res": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (reset) begin\n            next_count = 16'b0; \n        end else begin\n            if (up_down) begin\n                // Increment the counter if up_down is high\n                if (current_count == 16'b1111_1111_1111_1111) begin\n                    next_count = 16'b0; \n                end else begin\n                    next_count = current_count + 1; \n                end\n            end else begin\n                // Decrement the counter if up_down is low\n                if (current_count == 16'b0) begin\n                    next_count = 16'b1111_1111_1111_1111; \n                end else begin\n                    next_count = current_count - 1; \n                end\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'b0; \n        end else begin\n            current_count <= next_count; \n        end\n    end\n\nendmodule"}
{"task_id": "alu", "res": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    // Submodules for different operations\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire [31:0] slt_result, sltu_result, sll_result, srl_result, sra_result;\n    wire [31:0] lui_result;\n\n    // Instantiate submodules\n    add_submodule add_inst (\n        .a(a),\n        .b(b),\n        .add_result(add_result)\n    );\n    sub_submodule sub_inst (\n        .a(a),\n        .b(b),\n        .sub_result(sub_result)\n    );\n    and_submodule and_inst (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n    or_submodule or_inst (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n    xor_submodule xor_inst (\n        .a(a),\n        .b(b),\n        .xor_result(xor_result)\n    );\n    nor_submodule nor_inst (\n        .a(a),\n        .b(b),\n        .nor_result(nor_result)\n    );\n    slt_submodule slt_inst (\n        .a(a),\n        .b(b),\n        .slt_result(slt_result)\n    );\n    sltu_submodule sltu_inst (\n        .a(a),\n        .b(b),\n        .sltu_result(sltu_result)\n    );\n    sll_submodule sll_inst (\n        .a(a),\n        .b(b),\n        .sll_result(sll_result)\n    );\n    srl_submodule srl_inst (\n        .a(a),\n        .b(b),\n        .srl_result(srl_result)\n    );\n    sra_submodule sra_inst (\n        .a(a),\n        .b(b),\n        .sra_result(sra_result)\n    );\n    lui_submodule lui_inst (\n        .a(a),\n        .lui_result(lui_result)\n    );\n\n    // Select result based on aluc control signal\n    assign r = aluc case 6'd100000 ? add_result : \n        aluc == 6'd100001 ? sub_result :\n        aluc == 6'd100010 ? srl_result :\n        aluc == 6'd100011 ? sra_result :\n        aluc == 6'd100100 ? and_result :\n        aluc == 6'd100101 ? or_result :\n        aluc == 6'd100110 ? xor_result :\n        aluc == 6'd100111 ? nor_result :\n        aluc == 6'd101010 ? slt_result :\n        aluc == 6'd101011 ? sltu_result :\n        aluc == 6'd000000 ? lui_result :\n        aluc == 6'd000010 ? sll_result :\n        aluc == 6'd000110 ? srl_result :\n        aluc == 6'd000111 ? sra_result :\n        aluc == 6'd001000 ? lui_result :\n        aluc == 6'd001010 ? slt_result :\n        aluc == 6'd001"}
{"task_id": "ring_counter", "res": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] state;\n\n    // Submodule for state initialization\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .state_out(state)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .state_in(state),\n        .state_out(out)\n    );\n\nendmodule\n\n// Submodule for state initialization\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] state_out\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            state_out <= 8'b0000_0001; \n    end\n\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state_in,\n    output wire [7:0] state_out\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            state_out <= 8'b0000_0001;\n        else\n            state_out <= {state_in[6:0], state_in[7]}; // Shift the bits to the left by one position\n    end\n\nendmodule"}
{"task_id": "pe", "res": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [31:0] current_value;\n    wire [63:0] ab_mult;\n    // Multiplier module instance\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .y(ab_mult)\n    );\n    // Accumulator module instance\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .new_value(ab_mult[31:0]),\n        .current_value(current_value)\n    );\n    // Assign the accumulated result to the output\n    assign c = current_value;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "res": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [63:0] tmp; // For holding temporary values\n    wire [31:0] divisor; // For holding the adjusted divisor value\n\n    // Instantiating the preparatory module\n    prep_dividend prep (\n        .A(A),\n        .B(B),\n        .prep_A(tmp[31:16]),\n        .prep_B(divisor) // Getting the adjusted divisor value\n    );\n\n    // Instantiating the division operation module\n    div_operation div_op (\n        .A(tmp), // Dividend with upper 16 bits\n        .B(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Module for preparing the dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] prep_A,\n    output reg [31:0] prep_B\n);\n\n    always @(*) begin\n        prep_A = {A[15:0],16'b0}; // Adding high 16 bits to the dividend\n        prep_B = {B,16'b0}; // Adding low 16 bits to the divisor\n    end\n\nendmodule\n\n// Division operation module\nmodule div_operation(\n    input wire [63:0] A, // Dividend with upper 16 bits\n    input wire [31:0] B, // Adjusted divisor\n    output reg [31:0] result, // 32-bit quotient\n    output reg [31:0] odd      // 32-bit remainder\n);\n\n    always @(*) begin\n        if (A[63:48] < B) // If high 8 bits of dividend is less than the divisor\n            result = {{8{1'b0}}, A[47:40]}; // High 8 bits of quotient is 0\n        else if (A[63:48] == B) // If high 8 bits of dividend is equal to the divisor\n            result = {{8{1'b0}}, A[47:40] + 1}; // High 8 bits of quotient is 1\n        else // If high 8 bits of dividend is greater than the divisor\n            result = {{8{1'b0}}, A[47:40] - 1}; // High 8 bits of quotient is 1\n\n        if (A[47:32] < B) // If low 8 bits of dividend is less than the divisor\n            odd = {{24{1'b0}}, A[31:24]}; // Low 8 bits of remainder is 0\n        else if (A[47:32] == B) // If low 8 bits of dividend is equal to the divisor\n            odd = {{24{1'b0}}, A[31:24] + 1}; // Low 8 bits of remainder is 1\n        else // If low 8 bits of dividend is greater than the divisor\n            odd = {{24{1'b0}}, A[31:24] - 1}; // Low 8 bits of remainder is 1\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "res": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;         // 64-bit input operand A\n    input [63:0] B;         // 64-bit input operand B\n    output [63:0] D;        // 64-bit output representing the difference A - B\n    output B_out;           // Borrow-out output\n\n    wire [63:0] B_out_tmp;  // Temporary variable to hold B_out value\n\n    // Instantiate two 32-bit subtractors\n    subtractor_32bit sub0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_tmp[31:0])\n    );\n\n    subtractor_32bit sub1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out_tmp[63:32])\n    );\n\n    // Assign B_out\n    assign B_out = B_out_tmp[63];\n\nendmodule\n\nmodule subtractor_32bit(A, B, D, B_out);\n    input [31:0] A;         // 32-bit input operand A\n    input [31:0] B;         // 32-bit input operand B\n    output [31:0] D;        // 32-bit output representing the difference A - B\n    output B_out;           // Borrow-out output\n\n    wire [31:0] B_out_tmp;  // Temporary variable to hold B_out value\n\n    // Instantiate four 8-bit subtractors\n    subtractor_8bit sub0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_tmp[7:0])\n    );\n\n    subtractor_8bit sub1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_tmp[15:8])\n    );\n\n    subtractor_8bit sub2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .D(D[23:16]),\n        .B_out(B_out_tmp[23:16])\n    );\n\n    subtractor_8bit sub3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .D(D[31:24]),\n        .B_out(B_out_tmp[31:24])\n    );\n\n    // Assign B_out\n    assign B_out = B_out_tmp[31];\n\nendmodule\n\nmodule subtractor_8bit(A, B, D, B_out);\n    input [7:0] A;          // 8-bit input operand A\n    input [7:0] B;          // 8-bit input operand B\n    output [7:0] D;         // 8-bit output representing the difference A - B\n    output B_out;           // Borrow-out output\n\n    wire [7:0] B_out_tmp;   // Temporary variable to hold B_out value\n\n    // Instantiate two 4-bit subtractors\n    subtractor_4bit sub0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_tmp[3:0])\n    );\n\n    subtractor_4bit sub1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_tmp[7:4])"}
{"task_id": "counter_12", "res": "`timescale 1ns/1ps\n\n// Main counter module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n    wire new_count;\n\n    // Instance of the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .new_count(new_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg new_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else begin\n            if (valid_count) begin\n                if (count_value == 4'd11) begin\n                    count_value <= 4'b0000;\n                end else begin\n                    count_value <= count_value + 1'b1;\n                end\n            end\n        end\n    end\n\n    // Pause the counting when valid_count is zero\n    assign new_count = valid_count && !(count_value == 4'd11);\nendmodule\n\n// Output register module\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else begin\n            if (valid_count) begin\n                out <= count_value;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "res": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction storage\n    wire [7:0] ins_p1_out, ins_p2_out;\n\n    instruction_storage ins1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p1_out)\n    );\n\n    instruction_storage ins2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p2_out)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins1.rst <= 1'b1;\n            ins2.rst <= 1'b1;\n        end else begin\n            ins1.rst <= 1'b0;\n            ins2.rst <= 1'b0;\n        end\n    end\n\n    assign ins = ins_p1_out[7:5];\n    assign ad1 = ins_p1_out[4:0];\n    assign ad2 = ins_p2_out;\n\nendmodule\n\nmodule instruction_storage (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] ins_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0;\n        end else begin\n            case (fetch)\n                2'b01: ins_out <= data;\n                2'b10: ins_out <= data;\n                default: ins_out <= ins_out;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "res": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control module\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [31:0] tmp_a;\n    reg [31:0] tmp_b;\n    integer i;\n\n    always @(*) begin\n        // Initialize temporary variables\n        tmp_a = {16'b0, A};        // Concatenate A to a 32-bit value\n        tmp_b = {B, 16'b0};        // Concatenate B to a 32-bit value\n        quotient = 0;              // Reset quotient\n        remainder = 0;             // Reset remainder\n\n        // Division algorithm\n        for (i = 0; i < 16; i = i + 1) begin\n            tmp_a = tmp_a << 1;    // Shift left to process the next bit\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b; // Subtract divisor from dividend\n                quotient[i] = 1;        // Set quotient bit to 1\n            end else begin\n                quotient[i] = 0;        // Set quotient bit to 0\n            end\n        end\n\n        remainder = tmp_a[31:16]; // Assign remainder from the higher bits of tmp_a\n    end\nendmodule"}
{"task_id": "JC_counter", "res": "`timescale 1ns/1ns\n\n// Main module for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] Q_internal;\n\n    // Instance of the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal)\n    );\n\n    // Instance of the logic module to determine the next state\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Submodule for the register to store the current state of the counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q <= 64'b0;\n    end\nendmodule\n\n// Submodule for the logic that determines the next state of the counter\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output reg [63:0]   Q_next\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q_next <= 64'b0;\n        else if (!Q[0]) \n            Q_next <= {1'b1, Q[63:1]};\n        else \n            Q_next <= {1'b0, Q[63:1]};\n    end\nendmodule"}
{"task_id": "sub_16bit", "res": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;  // 16-bit input A\n    input [16:1] B;  // 16-bit input B\n    output [16:1] D; // 16-bit difference output\n    output B_out;    // Borrow out\n\n    wire b4, b8;\n\n    // Instantiate four 4-bit subtractors\n    subtractor_4bit sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .B_out(b4),\n        .D(D[4:1]),\n        .borrow_in(1'b1) // Initialize borrow to 1\n    );\n\n    subtractor_4bit sub2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .B_out(b8),\n        .D(D[8:5]),\n        .borrow_in(b4) // Pass 1st subtractor's borrow to 2nd one\n    );\n\n    subtractor_4bit sub3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .B_out(),\n        .D(D[12:9]),\n        .borrow_in(b8) // Pass 2nd subtractor's borrow to 3rd one\n    );\n\n    subtractor_4bit sub4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .B_out(B_out),\n        .D(D[16:13]),\n        .borrow_in(1'b1) // Initialize borrow for 4th subtractor\n    );\nendmodule\n\nmodule subtractor_4bit(A, B, D, B_out, borrow_in);\n    input [4:1] A;         // Input operand A\n    input [4:1] B;         // Input operand B\n    output [4:1] D;        // Difference output\n    output B_out;          // Borrow out\n    input borrow_in;       // Input borrow signal\n\n    wire [4:1] B_out_buf;  // Intermediate borrow signal storage\n\n    always @(*) begin\n        D = A - B;          // Difference calculation\n        B_out_buf = (A[1] || (A[2:1] == B[2:1] && A[3:2] == B[3:2] && A[4:3] == B[4:3])) ? borrow_in : ~B[4]; // Update borrow signal\n    end\n\n    assign B_out = B_out_buf[4]; // Assign output borrow signal\nendmodule"}
{"task_id": "square_wave", "res": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire count_enable;\n    wire [7:0] count_value;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(count_enable),\n        .freq(freq),\n        .count(count_value)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count_value),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    // Control logic for enabling the counter\n    assign count_enable = (freq > 0);\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    initial begin\n        count = 0;\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial begin\n        wave_out = 0;\n    end\n\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            wave_out <= ~wave_out;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit", "res": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;  \n    wire cout;       \n\n    // Instantiate the 32-bit subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .cout(cout)\n    );\n\n    // Determine the comparison outputs\n    assign A_greater = (~cout && diff != 32'b0);\n    assign A_equal = (A == B);\n    assign A_less = cout;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First operand\n    input [31:0] B,   // Second operand\n    output [31:0] diff, // Difference output\n    output cout       // Carry output (borrow for subtraction)\n);\n\n    // Perform the subtraction\n    assign {cout, diff} = A - B;\n\nendmodule"}
{"task_id": "freq_div", "res": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire reset;\n\n    assign reset = RST;\n\n    // 50 MHz clock\n    clk_div_2 clk_div_50 (\n        .clk(CLK_in),\n        .reset(reset),\n        .clk_out(CLK_50)\n    );\n\n    // 10 MHz clock\n    clk_div_10 clk_div_10 (\n        .clk(CLK_in),\n        .reset(reset),\n        .clk_out(CLK_10)\n    );\n\n    // 1 MHz clock\n    clk_div_100 clk_div_1 (\n        .clk(CLK_in),\n        .reset(reset),\n        .clk_out(CLK_1)\n    );\n\nendmodule\n\n// 50 MHz clock division\nmodule clk_div_2 (\n    input clk,\n    input reset,\n    output reg clk_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset || (clk_out == 0)) begin\n            clk_out <= 1;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\n// 10 MHz clock division\nmodule clk_div_10 (\n    input clk,\n    input reset,\n    output reg clk_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset || (clk_out == 0)) begin\n            clk_out <= 1;\n        end else if (clk_out < 4) begin\n            clk_out <= clk_out + 1;\n        end else begin\n            clk_out <= 1;\n        end\n    end\nendmodule\n\n// 1 MHz clock division\nmodule clk_div_100 (\n    input clk,\n    input reset,\n    output reg clk_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset || (clk_out == 0)) begin\n            clk_out <= 1;\n        end else if (clk_out < 49) begin\n            clk_out <= clk_out + 1;\n        end else begin\n            clk_out <= 1;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "res": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State Control Module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .wave(wave_reg),\n        .state(state)\n    );\n\n    // Waveform Generation Module\n    waveform_gen wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave_reg)\n    );\n\n    assign wave = wave_reg;\n\nendmodule\n\n// State Control Module\nmodule state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00:\n                    if (wave == 5'b11111) // 31\n                        state <= 2'b01;\n                2'b01:\n                    if (wave == 5'b00000) // 0\n                        state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\n// Waveform Generation Module\nmodule waveform_gen (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            case (state)\n                2'b00:\n                    wave <= wave + 1;\n                2'b01:\n                    wave <= wave - 1;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "res": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;  // 32-bit input operand A\n    input [32:1] B;  // 32-bit input operand B\n    output [32:1] S; // 32-bit output representing the sum of A and B\n    output C32; // Carry-out output\n\n    wire [32:1] C;\n\n    // Instantiate 16-bit CLA instances\n    CLA1 CLA1_inst (\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(C[16]),\n        .S(S[16:1]),\n        .Cout(C[17])\n    );\n    CLA1 CLA2_inst (\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C[32]),\n        .S(S[32:17]),\n        .Cout(C32)\n    );\n\n    // Assign the first carry out (for A[15:1])\n    assign C[16] = A[15] ^ B[15];\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [15:1] A;// 16-bit input operand A\n    input [15:1] B;// 16-bit input operand B\n    input Cin;    // Carry input\n    output [15:1] S; // 16-bit output representing the sum of A and B\n    output Cout;   // Carry output\n\n    wire [15:1] Bout;\n\n    full_adder FA1 (.A(A[1]), .B(B[1]), .Cin(Cin), .S(S[1]), .Cout(Bout[1]));\n    from 15 to 2:\n        full_adder FAi (.A(A[i]), .B(B[i]), .Cin(Bout[i-1]), .S(S[i]), .Cout(Bout[i]));\n    endfrom\n\n    assign Cout = Bout[15]; // Assign the last carry out\nendmodule"}
{"task_id": "shift8", "res": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiating three D flip-flops\n    my_dff8 u0 ( .clk(clk), .d(d), .q(q0) );\n    my_dff8 u1 ( .clk(clk), .d(q0), .q(q1) );\n    my_dff8 u2 ( .clk(clk), .d(q1), .q(q2) );\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;      // No delay\n            2'b01: q = q0;     // 1 cycle delay\n            2'b10: q = q1;     // 2 cycles delay\n            2'b11: q = q2;     // 3 cycles delay\n            default: q = 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d; // D flip-flop behavior\n    end\nendmodule"}
{"task_id": "shift_reg", "res": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1; // Intermediate outputs from flip-flops\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));   // First flip-flop\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));  // Second flip-flop\n    my_dff u2 (.clk(clk), .d(q1), .q(q));    // Third flip-flop\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d; // On the rising edge of clk, assign d to q\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "res": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    // Parameter for fractional division factor\n    parameter MUL2_DIV_CLK = 7;\n\n    // Internal wires for clock signals\n    wire clk_4cycles;\n    wire clk_3cycles;\n    wire clk_adjusted;\n\n    // Instantiate the counter submodule\n    counter #(MUL2_DIV_CLK) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(clk_4cycles)\n    );\n\n    // Instantiate the clock average generator submodule\n    clk_average u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(clk_4cycles),\n        .avg_clk(clk_3cycles)\n    );\n\n    // Instantiate the clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .avg_clk(clk_3cycles),\n        .adjusted_clk(clk_adjusted)\n    );\n\n    // Final output: OR the adjusted clock signal with the divided clock signal\n    assign clk_div = clk_adjusted | clk_4cycles;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 3'd0;\n        end else if (cnt_value == MUL2_DIV_CLK - 1) begin\n            cnt_value <= 3'd0;\n        end else begin\n            cnt_value <= cnt_value + 1'd1;\n        end\n    end\nendmodule\n\n// Clock average generator submodule\nmodule clk_average (\n    input clk,\n    input rst_n,\n    input [2:0] cnt_value,\n    output reg avg_clk\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            avg_clk <= 1'b0;\n        end else if (cnt_value == 0) begin\n            avg_clk <= 1'b1;\n        end else if (cnt_value == 1) begin\n            avg_clk <= 1'b0;\n        end else begin\n            avg_clk <= avg_clk;\n        end\n    end\nendmodule\n\n// Clock adjustment submodule\nmodule clk_adjustment (\n    input clk,\n    input rst_n,\n    input avg_clk,\n    output reg adjusted_clk\n);\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            adjusted_clk <= 1'b0;\n        end else if (avg_clk) begin\n            adjusted_clk <= 1'b1;\n        end else begin\n            adjusted_clk <= ~adjusted_clk;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "res": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x;\n \n  //4-bit barrel shifter\n  //in put, ctrl, out\n  mux2X1 P1 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], ctrl[1], ctrl[0], x);\n  mux2X1 P2 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P1);\n  mux2X1 P3 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P2);\n  mux2X1 P4 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P3);\n  mux2X1 P5 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P4);\n  mux2X1 P6 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P5);\n  mux2X1 P7 (in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], ctrl[2], P6);\n  assign out = P7;\n\nendmodule\n\n//2-bit multiplexer\nmodule mux2X1 (a, b, c, out, sel, y);\n  input a,b,c,a;\n  input sel;\n  output out;\n  assign out=(sel)?b:((~sel)?a:c);\nendmodule"}
{"task_id": "adder_16bit_csa", "res": "`timescale 1ns / 1ps\n\nmodule adder_16bit_csa(a, b, cin, sum, cout);\ninput [15:0] a,b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_out, csa_slice2_out, csa_slice3_out;\n\nripple_carry_adder rca1(\n  .a(a[15:12]),\n  .b(b[15:12]),\n  .cin(cin),\n  .sum(sum[15:12]),\n  .cout(csa_slice1_out[0]));\n\ncarry_select_adder_16bit csa_slice1(\n  .a(a[11:8]),\n  .b(b[11:8]),\n  .cin(csa_slice1_out[0]),\n  .sum(csa_slice1_out[1]),\n  .cout(csa_slice1_out[2]));\n\ncarry_select_adder_16bit csa_slice2(\n  .a(a[7:4]),\n  .b(b[7:4]),\n  .cin(csa_slice1_out[1]),\n  .sum(csa_slice2_out[0]),\n  .cout(csa_slice2_out[1]));\n\ncarry_select_adder_16bit csa_slice3(\n  .a(a[3:0]),\n  .b(b[3:0]),\n  .cin(csa_slice2_out[0]),\n  .sum(csa_slice3_out[0]),\n  .cout(csa_slice3_out[1]));\n\nripple_carry_adder rca2(\n  .a(a[15:12]),\n  .b(b[15:12]),\n  .cin(csa_slice3_out[1]),\n  .sum(sum[15:12]),\n  .cout(cout));\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n  input [3:0] a,b;\n  input cin;\n  output [3:0] sum;\n  output cout;\n\n  wire c1, c2, c3, c4;\n\n  full_adder fa1(.a(a[3]), .b(b[3]), .cin(cin), .sum(sum[3]), .cout(c1));\n  full_adder fa2(.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n  full_adder fa3(.a(a[1]), .b(b[1]), .cin(c2), .sum(sum[1]), .cout(c3));\n  full_adder fa4(.a(a[0]), .b(b[0]), .cin(c3), .sum(sum[0]), .cout(cout));\n  full_adder fa5(.a(1'b0),  .b(1'b0), .cin(1'b0), .sum(sum[4]), .cout(c4));\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n  input [15:0] a;\n  input [15:0] b;\n  input cin;\n  output [15:0] sum;\n  output cout;\n\n  wire c1, c2, c3, c4, c5, c6, c7, c8;\n\n  carry_select_adder cs1(.a(a[15:12]), .b(b[15:12]), .cin(cin), .sum(sum[15:12]), .cout(c1));\n  carry_select_adder cs2(.a(a[11:8]), .b(b[11:8]), .cin(c1), .sum(sum[14:11]), .cout(c2));\n  carry_select_adder cs3(.a(a[7:4]), .b("}
{"task_id": "freq_divbyodd", "res": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for the odd divisor\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n    wire [2:0] cnt1, cnt2; // 3-bit counters\n\n    // Instantiate the positive edge counter\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt1),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt2),\n        .clk_div(clk_div2)\n    );\n\n    // Combine the divided clocks\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n\n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b1;\n            end else begin\n                clk_div <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n\n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b0;\n            end else begin\n                clk_div <= 1'b1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit", "res": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire Co_temp;\n    wire [7:0] a_split[2], b_split[2], y_split[2];\n\n    // Instantiate two 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_split[0]),\n        .Co(Co_temp)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp),\n        .y(y_split[1]),\n        .Co(Co)\n    );\n\n    // Concatenate the outputs to get y\n    assign y = {y_split[1], y_split[0]};\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire Co_temp;\n\n    // 8-bit full adder\n    add8_submodule add8_submodule_inst (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .y(y),\n        .Co(Co_temp)\n    );\n\n    // Determine Carry out from the last full adder\n    assign Co = Co_temp ^ (a[0] & b[0]);\nendmodule\n\nmodule add8_submodule (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    wire ns, c, p;\n\n    assign {c, p} = a ^ b;\n\n    assign Co = Cin ^ c;\n    assign y = p | (c && Cin);\nendmodule"}
{"task_id": "freq_divbyeven", "res": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for division factor\n    parameter NUM_DIV = 6;\n\n    // Internal wire for the counter value\n    wire [3:0] cnt_value;\n    // Internal wire for the divided clock signal\n    wire clk_div_internal;\n\n    // Instantiate the counter submodule\n    counter #(NUM_DIV) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value)\n    );\n\n    // Instantiate the clock divider submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value),\n        .clk_div(clk_div_internal)\n    );\n\n    // Assign the internal divided clock to the output\n    assign clk_div = clk_div_internal;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter NUM_DIV = 6)(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 4'd0;\n        end else if (cnt_value < NUM_DIV / 2 - 1) begin\n            cnt_value <= cnt_value + 1'b1;\n        end else begin\n            cnt_value <= 4'd0;\n        end\n    end\nendmodule\n\n// Clock divider submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] cnt_value,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n        end else if (cnt_value == 0) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit", "res": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "res": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    // Internal wires and registers\n    wire [15:0] areg;\n    wire [15:0] breg;\n    wire [31:0] yout_r;\n    wire done_r;\n    // Instantiate control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ctrl_sigs(ctrl_sigs),\n        .done(done_r)\n    );\n    // Instantiate register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ctrl_sigs(ctrl_sigs),\n        .ain(ain),\n        .bin(bin),\n        .areg(areg),\n        .breg(breg)\n    );\n    // Instantiate multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ctrl_sigs(ctrl_sigs),\n        .areg(areg),\n        .breg(breg),\n        .yout(yout_r)\n    );\n    // Output assignments\n    assign yout = yout_r;\n    assign done = done_r;\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] count,\n    output reg done,\n    output reg [15:0] areg,\n    output reg [15:0] breg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            areg <= 0;\n            breg <= 0;\n            done <= 0;\n        end\n        else begin\n            if (start) begin\n                if (count == 0) begin\n                    count <= 4;\n                    areg <= 0;\n                    breg <= 0;\n                    done <= 0;\n                end\n                else begin\n                    count <= count - 1;\n                end\n            end\n            else begin\n                count <= 0;\n                areg <= 0;\n                breg <= 0;\n                done <= 0;\n            end\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [3:0] count,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] areg,\n    output reg [15:0] breg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            areg <= 0;\n            breg <= 0;\n        end\n        else begin\n            if (count == 0) begin\n                areg <= ain;\n                breg <= bin;\n            end\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input [3:0] count,\n    input [15:0] areg,\n    input [15:0] breg,\n    output reg [31:0] yout\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            yout <= 0;\n        end\n        else begin\n            if (count == 0)"}
