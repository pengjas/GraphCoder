{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] B_out_comp;\n\n    assign B_comp = ~B + 1;\n    assign B_out_comp = ~B_comp[7];\n\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .D(D),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] carry;\n\n    full_adder fa0 (\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(carry[0]),\n        .D(D[0]),\n        .Cout(carry[1])\n    );\n\n    full_adder fa1 (\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry[1]),\n        .D(D[1]),\n        .Cout(carry[2])\n    );\n\n    full_adder fa2 (\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry[2]),\n        .D(D[2]),\n        .Cout(carry[3])\n    );\n\n    full_adder fa3 (\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry[3]),\n        .D(D[3]),\n        .Cout(carry[4])\n    );\n\n    full_adder fa4 (\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry[4]),\n        .D(D[4]),\n        .Cout(carry[5])\n    );\n\n    full_adder fa5 (\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry[5]),\n        .D(D[5]),\n        .Cout(carry[6])\n    );\n\n    full_adder fa6 (\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry[6]),\n        .D(D[6]),\n        .Cout(carry[7])\n    );\n\n    full_adder fa7 (\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry[7]),\n        .D(D[7]),\n        .Cout(B_out)\n    );\nendmodule\n\nmodule full_adder(A, B, Cin, D, Cout);\n    input A, B, Cin;\n    output D, Cout;\n\n    assign D = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_Diff;\n    wire S1_B_out;\n    wire [15:0] S2_Diff;\n    wire S2_B_out;\n\n    sub_16bit S1(A[15:0], B[15:0], S1_Diff, S1_B_out);\n    sub_16bit S2(A[31:16], B[31:16], S2_Diff, S2_B_out);\n\n    assign Diff[15:0] = S1_Diff;\n    assign Diff[31:16] = S2_Diff;\n    assign B_out = S1_B_out & S2_B_out;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1_Diff;\n    wire S1_B_out;\n    wire [7:0] S2_Diff;\n    wire S2_B_out;\n\n    sub_8bit S1(A[7:0], B[7:0], S1_Diff, S1_B_out);\n    sub_8bit S2(A[15:8], B[15:8], S2_Diff, S2_B_out);\n\n    assign Diff[7:0] = S1_Diff;\n    assign Diff[15:8] = S2_Diff;\n    assign B_out = S1_B_out & S2_B_out;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1_Diff;\n    wire S1_B_out;\n    wire [3:0] S2_Diff;\n    wire S2_B_out;\n\n    sub_4bit S1(A[3:0], B[3:0], S1_Diff, S1_B_out);\n    sub_4bit S2(A[7:4], B[7:4], S2_Diff, S2_B_out);\n\n    assign Diff[3:0] = S1_Diff;\n    assign Diff[7:4] = S2_Diff;\n    assign B_out = S1_B_out & S2_B_out;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1_Diff;\n    wire S1_B_out;\n    wire [1:0] S2_Diff;\n    wire S2_B_out;\n\n    sub_2bit S1(A[1:0], B[1:0], S1_Diff, S1_B_out);\n    sub_2bit S2(A[3:2], B[3:2], S2_Diff, S2_B_out);\n\n    assign Diff[1:0] = S1_Diff;\n    assign Diff[3:2] = S2_Diff;\n    assign B_out = S1_B_out & S2_B_out;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0] S1_Diff;\n    wire S1_B_out;\n    wire [0] S2_Diff;"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] A_lo, A_hi, B_lo, B_hi;\n    wire [15:0] A_lo_lo, A_lo_hi, B_lo_lo, B_lo_hi;\n    wire [7:0] A_lo_lo_lo, A_lo_lo_hi, B_lo_lo_lo, B_lo_lo_hi;\n    wire [31:0] B_lo_hi_lo, B_lo_hi_hi;\n    wire [15:0] B_hi_lo, B_hi_hi;\n    wire [7:0] B_hi_lo_lo, B_hi_lo_hi;\n    wire [31:0] B_hi_hi_lo, B_hi_hi_hi;\n    wire [31:0] D_lo, D_hi;\n    wire B_out_lo, B_out_hi;\n\n    submodule sub0(A_lo, A_hi, B_lo, B_hi, D_lo, B_out_lo);\n        input [31:0] A_lo, A_hi, B_lo, B_hi;\n        output [31:0] D_lo;\n        output B_out_lo;\n\n        wire [7:0] A_lo_lo, A_lo_hi, B_lo_lo, B_lo_hi;\n        wire [3:0] A_lo_lo_lo, A_lo_lo_hi, B_lo_lo_lo, B_lo_lo_hi;\n        wire [7:0] B_lo_hi_lo, B_lo_hi_hi;\n        wire [3:0] B_hi_lo_lo, B_hi_lo_hi;\n        wire [7:0] B_hi_hi_lo, B_hi_hi_hi;\n        wire [31:0] D_lo;\n        wire B_out_lo;\n\n        assign A_lo_lo = A_lo[7:0];\n        assign A_lo_hi = A_lo[15:8];\n        assign A_hi_lo = A_hi[7:0];\n        assign A_hi_hi = A_hi[15:8];\n        assign B_lo_lo = B_lo[7:0];\n        assign B_lo_hi = B_lo[15:8];\n        assign B_hi_lo = B_hi[7:0];\n        assign B_hi_hi = B_hi[15:8];\n        assign B_lo_lo_lo = B_lo_lo[3:0];\n        assign B_lo_lo_hi = B_lo_lo[7:4];\n        assign B_lo_hi_lo = B_lo_hi[3:0];\n        assign B_lo_hi_hi = B_lo_hi[7:4];\n        assign B_hi_lo_lo = B_hi_lo[3:0];\n        assign B_hi_lo_hi = B_hi_lo[7:4];\n        assign B_hi_hi_lo = B_hi_hi[3:0];\n        assign B_hi_hi_hi = B_hi_hi[7:4];\n\n        assign D_lo = A_lo_lo - B_lo_lo - B_out_lo;\n        assign B_out_lo = (A_lo_lo < B_lo_lo) ? 1 : 0;\n\n        assign D_hi = A_hi_hi - B_hi_hi - B_out_hi;\n        assign B_out_hi = (A_hi_hi < B_hi_hi) ? 1 : 0;\n    endmodule\n\n    submodule sub1(A_lo, A_hi, B_lo, B_hi, D_lo, B_out_lo);\n        input [31:0] A_lo, A_hi, B_lo, B_hi;\n        output [31:0] D_lo;\n        output B_out_"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:1] A_sub;\n    wire [3:1] B_sub;\n    wire [3:1] D_sub;\n    wire B_out_sub;\n\n    submodule sub1(A[16:4], B[16:4], D_sub[3:1], B_out_sub);\n        wire [3:1] A_sub;\n        wire [3:1] B_sub;\n        wire [3:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor1(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    submodule sub2(A[16:8], B[16:8], D_sub[3:1], B_out_sub);\n        wire [3:1] A_sub;\n        wire [3:1] B_sub;\n        wire [3:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor2(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    submodule sub3(A[16:4], B[16:4], D_sub[3:1], B_out_sub);\n        wire [3:1] A_sub;\n        wire [3:1] B_sub;\n        wire [3:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor3(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    submodule sub4(A[16:8], B[16:8], D_sub[3:1], B_out_sub);\n        wire [3:1] A_sub;\n        wire [3:1] B_sub;\n        wire [3:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor4(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    assign A_sub = A[16:13];\n    assign B_sub = B[16:13];\n    assign D_sub = A_sub - B_sub;\n    assign B_out_sub = D_sub[3];\n\n    assign D = {D_sub[2:0], B_out_sub};\n    assign B_out = D_sub[3];\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:1] A;\n    input [3:1] B;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] A_sub;\n    wire [3:1] B_sub;\n    wire [3:1] D_sub;\n    wire B_out_sub;\n\n    submodule sub1(A[3:2], B[3:2], D_sub[1:1], B_out_sub);\n        wire [1:1] A_sub;\n        wire [1:1] B_sub;\n        wire [1:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor1(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    submodule sub2(A[3:1], B[3:1], D_sub[1:1], B_out_sub);\n        wire [1:1] A_sub;\n        wire [1:1] B_sub;\n        wire [1:1] D_sub;\n        wire B_out_sub;\n\n        full_subtractor full_subtractor2(A_sub, B_sub, D_sub, B_out_sub);\n    endsubmodule\n\n    submodule sub3(A[3"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry;\n\n    // Subtractor module\n    submodule (subtractor_32bit) sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result == 32'b0);\n    assign A_equal = (sub_result == 32'b0) && (carry == 1'b0);\n    assign A_less = (sub_result == 32'b0) && (carry == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result, \n    output carry     \n);\n\n    // Subtraction logic\n    assign sub_result = A - B;\n    assign carry = (A[31] == B[31]) && (sub_result[31] == 1'b0);\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A, B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C15, C14, C13, C12, C11, C10, C9, C8, C7, C6, C5, C4, C3, C2, C1;\n\n    // CLA1\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .C1(C15), .C2(C14), .C3(C13), .C4(C12), .C5(C11), .C6(C10), .C7(C9), .C8(C8), .C9(C7), .C10(C6), .C11(C5), .C12(C4), .C13(C3), .C14(C2), .C15(C1), .C16(C16), .S(S[16:1]));\n\n    // CLA2\n    CLA2 CLA2 (.A(A[32:17]), .B(B[32:17]), .C1(C16[15]), .C2(C16[14]), .C3(C16[13]), .C4(C16[12]), .C5(C16[11]), .C6(C16[10]), .C7(C16[9]), .C8(C16[8]), .C9(C16[7]), .C10(C16[6]), .C11(C16[5]), .C12(C16[4]), .C13(C16[3]), .C14(C16[2]), .C15(C16[1]), .C16(C16[0]), .C32(C32));\n\n    // Carry-out\n    assign C32 = C15 | C14 | C13 | C12 | C11 | C10 | C9 | C8 | C7 | C6 | C5 | C4 | C3 | C2 | C1;\n\nendmodule\n\nmodule CLA1(A,B,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16,S);\n    input [16:1] A,B;\n    input C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15;\n    output [16:1] S;\n    output C16;\n\n    wire [16:1] P,G;\n    assign P = A ^ B;\n    assign G = A & B;\n    assign S = P ^ C16;\n    assign C16 = G | (P & C1) | (G & C2) | (P & C3 & C4) | (G & C5 & C6) | (P & C7 & C8) | (G & C9 & C10) | (P & C11 & C12) | (G & C13 & C14) | (P & C15);\nendmodule\n\nmodule CLA2(A,B,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16,C32);\n    input [32:17] A,B;\n    input C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n    output C32;"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    // Counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    // Counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'h0000;\n        end else begin\n            if (up_down) begin\n                count <= count + 1;\n            end else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_reg\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'h0000;\n        end else begin\n            count_reg <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] r;\n    wire zero;\n    wire carry;\n    wire negative;\n    wire overflow;\n    wire flag;\n\n    // Addition module\n    add_sub_module add_sub_inst(\n        .a(a),\n        .b(b),\n        .carry_out(carry),\n        .r(r),\n        .zero(zero)\n    );\n\n    // Subtraction module\n    add_sub_module sub_inst(\n        .a(a),\n        .b(b),\n        .carry_out(carry),\n        .r(r),\n        .zero(zero)\n    );\n\n    // Logical operations module\n    logical_module logical_inst(\n        .a(a),\n        .b(b),\n        .r(r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow)\n    );\n\n    // Flag module\n    flag_module flag_inst(\n        .a(a),\n        .b(b),\n        .r(r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .flag(flag)\n    );\n\n    // Select the operation based on aluc\n    always @(*) begin\n        case (aluc)\n            6'b100000: r = add_sub_inst.r;\n            6'b100001: r = add_sub_inst.r;\n            6'b100010: r = sub_inst.r;\n            6'b100011: r = sub_inst.r;\n            6'b100100: r = logical_inst.r;\n            6'b100101: r = logical_inst.r;\n            6'b100110: r = logical_inst.r;\n            6'b100111: r = logical_inst.r;\n            6'b101010: r = logical_inst.r;\n            6'b101011: r = logical_inst.r;\n            6'b000000: r = sll_inst.r;\n            6'b000010: r = srl_inst.r;\n            6'b000011: r = sra_inst.r;\n            6'b000100: r = sllv_inst.r;\n            6'b000110: r = srlv_inst.r;\n            6'b000111: r = srav_inst.r;\n            6'b001111: r = lui_inst.r;\n        endcase\n    end\n\nendmodule\n\n// Addition and subtraction module\nmodule add_sub_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero\n);\n\n    wire [31:0] r;\n    wire [31:0] b_neg;\n    wire carry;\n\n    assign b_neg = ~b + 1;\n\n    always @(*) begin\n        case (aluc)\n            6'b100000: r = a + b;\n            6'b100001: r = a + b_neg;\n            default: r = 32'b0;\n        endcase\n    end\n\n    assign zero = (r == 32'b0);\n\nendmodule\n\n// Logical operations module\nmodule logical_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    // State Initialization submodule\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State Transition submodule\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\n// Counter logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end else if (valid_count) begin\n        count <= count + 1;\n    end\nend\n\n// Output register\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    // Multiplier submodule\n    reg [63:0] product;\n    always @(posedge clk) begin\n        if (rst) begin\n            product <= 0;\n        end else begin\n            product <= a * b;\n        end\n    end\n\n    // Accumulator submodule\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\n    // Output port\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    // Multiplier logic\n    reg [63:0] product_reg;\n    always @(posedge clk) begin\n        if (rst) begin\n            product_reg <= 0;\n        end else begin\n            product_reg <= a * b;\n        end\n    end\n\n    assign product = product_reg;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output [31:0] c\n);\n\n    // Accumulator logic\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\n    assign c = current_value;\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= Q;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output [63:0]       Q_next\n);\n\nassign Q_next = {Q[62:0], ~Q[63]};\n\nendmodule\n\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= Q;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_p1;\nreg [4:0] ad1_p1;\nreg [7:0] ad2_p1;\n\nreg [2:0] ins_p2;\nreg [4:0] ad1_p2;\nreg [7:0] ad2_p2;\n\nwire [2:0] ins_p1_out;\nwire [4:0] ad1_p1_out;\nwire [7:0] ad2_p1_out;\n\nwire [2:0] ins_p2_out;\nwire [4:0] ad1_p2_out;\nwire [7:0] ad2_p2_out;\n\nassign ins_p1_out = ins_p1;\nassign ad1_p1_out = ad1_p1;\nassign ad2_p1_out = ad2_p1;\n\nassign ins_p2_out = ins_p2;\nassign ad1_p2_out = ad1_p2;\nassign ad2_p2_out = ad2_p2;\n\nassign ins = (fetch == 2'b01) ? ins_p1_out : ins_p2_out;\nassign ad1 = (fetch == 2'b01) ? ad1_p1_out : ad1_p2_out;\nassign ad2 = (fetch == 2'b01) ? ad2_p1_out : ad2_p2_out;\n\nalways @(posedge clk) begin\n    if (rst == 1'b0) begin\n        ins_p1 <= 3'b000;\n        ad1_p1 <= 5'b00000;\n        ad2_p1 <= 8'b00000000;\n        \n        ins_p2 <= 3'b000;\n        ad1_p2 <= 5'b00000;\n        ad2_p2 <= 8'b00000000;\n    end else begin\n        if (fetch == 2'b01) begin\n            ins_p1 <= data[7:5];\n            ad1_p1 <= data[4:0];\n            ad2_p1 <= data;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data[7:5];\n            ad1_p2 <= data[4:0];\n            ad2_p2 <= data;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    reg [1:0] clk_div_2_cnt;\n    reg [3:0] clk_div_10_cnt;\n    reg [4:0] clk_div_100_cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_2_cnt <= 2'b00;\n            clk_div_10_cnt <= 4'b0000;\n            clk_div_100_cnt <= 5'b00000;\n        end else begin\n            if (clk_div_2_cnt == 2'b11) begin\n                clk_div_2_cnt <= 2'b00;\n            end else begin\n                clk_div_2_cnt <= clk_div_2_cnt + 2'b01;\n            end\n\n            if (clk_div_10_cnt == 4'b1001) begin\n                clk_div_10_cnt <= 4'b0000;\n            end else begin\n                clk_div_10_cnt <= clk_div_10_cnt + 4'b0001;\n            end\n\n            if (clk_div_100_cnt == 5'b10011) begin\n                clk_div_100_cnt <= 5'b00000;\n            end else begin\n                clk_div_100_cnt <= clk_div_100_cnt + 5'b00001;\n            end\n        end\n    end\n\n    assign CLK_50 = clk_div_2_cnt[1];\n    assign CLK_10 = clk_div_10_cnt[3];\n    assign CLK_1 = clk_div_100_cnt[4];\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n// Counter Module\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\n// Wave Generator Module\nwire [7:0] wave_generator_count;\n\nassign wave_generator_count = (freq > 0) ? count : 0;\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(wave_generator_count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out <= 1;\n    end else begin\n        wave_out <= 0;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    reg [3:0] counter;\n    reg [3:0] clk_average;\n    reg [3:0] clk_adjustment;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 4'b0;\n            clk_average <= 4'b0;\n            clk_adjustment <= 4'b0;\n        end else begin\n            counter <= counter + 1;\n            if (counter == MUL2_DIV_CLK - 1) begin\n                counter <= 4'b0;\n            end\n            clk_average <= {clk_average[2:0], clk_average[3]};\n            clk_adjustment <= {clk_adjustment[2:0], clk_adjustment[3]};\n        end\n    end\n\n    assign clk_div = clk_average[0] | clk_adjustment[0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  counter\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 4'b0;\n        end else begin\n            if (counter == 4'b1111) begin\n                counter <= 4'b0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg  [3:0]  clk_average\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_average <= 4'b0;\n        end else begin\n            clk_average <= {clk_average[2:0], clk_div};\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg  [3:0]  clk_adjustment\n);\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_adjustment <= 4'b0;\n        end else begin\n            clk_adjustment <= {clk_adjustment[2:0], clk_div};\n        end\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b00001) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  // First Processing Element\n  reg [31:0] pe0_out;\n  always @(posedge clk) begin\n    if (rst) begin\n      pe0_out <= 32'b0;\n    end else begin\n      pe0_out <= a0 * b0;\n    end\n  end\n\n  // Second Processing Element\n  reg [31:0] pe1_out;\n  always @(posedge clk) begin\n    if (rst) begin\n      pe1_out <= 32'b0;\n      b1 <= 16'b0;\n    end else begin\n      pe1_out <= a1 * b1;\n      b1 <= b0;\n    end\n  end\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry[0];\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] carry;\n\n    full_adder fa0 (.A(A[0]), .B(B[0]), .Cin(1'b0), .D(D[0]), .Cout(carry[0]));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .Cin(carry[0]), .D(D[1]), .Cout(carry[1]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .Cin(carry[1]), .D(D[2]), .Cout(carry[2]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .Cin(carry[2]), .D(D[3]), .Cout(carry[3]));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .Cin(carry[3]), .D(D[4]), .Cout(carry[4]));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .Cin(carry[4]), .D(D[5]), .Cout(carry[5]));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .Cin(carry[5]), .D(D[6]), .Cout(carry[6]));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .Cin(carry[6]), .D(D[7]), .Cout(B_out));\nendmodule\n\nmodule full_adder(A, B, Cin, D, Cout);\n    input A, B, Cin;\n    output D, Cout;\n\n    assign {Cout, D} = A + B + Cin;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    // 4-to-1 multiplexer\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q;\n            2'b10: q <= q;\n            2'b11: q <= q;\n            default: q <= 8'b0;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    reg q0, q1, q2;\n\n    always @(posedge clk) begin\n        q0 <= d;\n        q1 <= q0;\n        q2 <= q1;\n    end\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [$clog2(NUM_DIV) - 1:0] pos_counter;\n    reg [$clog2(NUM_DIV) - 1:0] neg_counter;\n    reg clk_div1, clk_div2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            pos_counter <= 0;\n            neg_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else begin\n            if (pos_counter < NUM_DIV - 1) begin\n                pos_counter <= pos_counter + 1;\n            end else begin\n                pos_counter <= 0;\n            end\n\n            if (neg_counter < NUM_DIV - 1) begin\n                neg_counter <= neg_counter + 1;\n            end else begin\n                neg_counter <= 0;\n            end\n\n            clk_div1 <= (pos_counter == NUM_DIV - 1);\n            clk_div2 <= (neg_counter == NUM_DIV - 1);\n        end\n    end\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter < NUM_DIV - 1) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter < NUM_DIV - 1) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1;\n    wire [15:0] S2;\n    wire [15:0] Diff1;\n    wire [15:0] Diff2;\n    wire B_out1;\n    wire B_out2;\n\n    sub_16bit S1(A[31:16], B[31:16], Diff1, B_out1);\n    sub_16bit S2(A[15:0], B[15:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1;\n    wire [7:0] S2;\n    wire [7:0] Diff1;\n    wire [7:0] Diff2;\n    wire B_out1;\n    wire B_out2;\n\n    sub_8bit S1(A[15:8], B[15:8], Diff1, B_out1);\n    sub_8bit S2(A[7:0], B[7:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1;\n    wire [3:0] S2;\n    wire [3:0] Diff1;\n    wire [3:0] Diff2;\n    wire B_out1;\n    wire B_out2;\n\n    sub_4bit S1(A[7:4], B[7:4], Diff1, B_out1);\n    sub_4bit S2(A[3:0], B[3:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1;\n    wire [1:0] S2;\n    wire [1:0] Diff1;\n    wire [1:0] Diff2;\n    wire B_out1;\n    wire B_out2;\n\n    sub_2bit S1(A[3:2], B[3:2], Diff1, B_out1);\n    sub_2bit S2(A[1:0], B[1:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0:0] S1;\n    wire [0:0] S2;\n    wire [0:0] Diff1;\n    wire [0:0] Diff2;\n    wire B_out1;\n    wire B_out2;\n\n    sub_1bit S1(A[1:1], B[1:"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n  reg [31:0] rd_val;\n  reg [31:0] op;\n\n  wire [31:0] fetch_stage_out;\n  wire [31:0] decode_stage_out;\n  wire [31:0] execute_stage_out;\n  wire [31:0] memory_stage_out;\n  wire [31:0] writeback_stage_out;\n\n  stagepipe5_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(fetch_stage_out)\n  );\n\n  stagepipe5_decode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_stage_out),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .rd_val(rd_val),\n    .op(op)\n  );\n\n  stagepipe5_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .op(op),\n    .execute_stage_out(execute_stage_out)\n  );\n\n  stagepipe5_memory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .execute_stage_out(execute_stage_out),\n    .memory_stage_out(memory_stage_out)\n  );\n\n  stagepipe5_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .rd_val(rd_val),\n    .memory_stage_out(memory_stage_out),\n    .writeback_stage_out(writeback_stage_out)\n  );\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 32'h00000000;\n    end else begin\n      pc <= pc + 32'h00000004;\n    end\n  end\n\n  assign res_reg_file[31:0] = writeback_stage_out;\n\nendmodule\n\nmodule stagepipe5_fetch(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  output [31:0] instr\n);\n\n  reg [31:0] instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr_reg <= 32'h00000000;\n    end else begin\n      instr_reg <= instr_mem[pc[31:2]];\n    end\n  end\n\n  assign instr = instr_reg;\n\nendmodule\n\nmodule stagepipe5_decode(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [31:0] rs1_val,\n  output [31:0] rs2_val,\n  output [31:0] rd_val,\n  output [31:0] op\n);\n\n  reg [31:0] rs1_val_reg;\n  reg [31:0] rs2_val_reg;\n  reg [31:0] rd_val_reg;\n  reg [31:0] op_reg;\n\n  always @(posedge clk) begin\n    if (r"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter == 0) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [7:0] shifted_out;\n    wire [3:0] sel;\n\n    assign sel = {ctrl[2], ctrl[1], ctrl[0]};\n\n    // Stage 1\n    assign shifted_in[7:4] = (sel[3] == 1) ? in[3:0] : in[7:4];\n    assign shifted_in[3:0] = (sel[2] == 1) ? in[7:4] : in[3:0];\n    assign shifted_out[7:4] = (sel[3] == 1) ? shifted_in[3:0] : shifted_in[7:4];\n    assign shifted_out[3:0] = (sel[2] == 1) ? shifted_in[7:4] : shifted_in[3:0];\n\n    // Stage 2\n    assign shifted_in[7:4] = (sel[2] == 1) ? shifted_out[3:0] : shifted_out[7:4];\n    assign shifted_in[3:0] = (sel[1] == 1) ? shifted_out[7:4] : shifted_out[3:0];\n    assign shifted_out[7:4] = (sel[2] == 1) ? shifted_in[3:0] : shifted_in[7:4];\n    assign shifted_out[3:0] = (sel[1] == 1) ? shifted_in[7:4] : shifted_in[3:0];\n\n    // Stage 3\n    assign shifted_in[7:4] = (sel[1] == 1) ? shifted_out[3:0] : shifted_out[7:4];\n    assign shifted_in[3:0] = (sel[0] == 1) ? shifted_out[7:4] : shifted_out[3:0];\n    assign shifted_out[7:4] = (sel[1] == 1) ? shifted_in[3:0] : shifted_in[7:4];\n    assign shifted_out[3:0] = (sel[0] == 1) ? shifted_in[7:4] : shifted_in[3:0];\n\n    assign out = shifted_out;\n\nendmodule\n\nmodule mux2X1 (in1, in2, sel, out);\n    input in1, in2;\n    input sel;\n    output out;\n\n    assign out = (sel == 1) ? in2 : in1;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:32], B[63:32], D[63:32], B_out);\n    submodule sub1(A[31:0], B[31:0], D[31:0], B_out);\n\n    submodule sub0(A[63:32], B[63:32], D[63:32], B_out);\n    submodule sub1(A[31:0], B[31:0], D[31:0], B_out);\n\n    assign D[63:32] = A[63:32] - B[63:32];\n    assign D[31:0] = A[31:0] - B[31:0];\n    assign B_out = (A[31:0] < B[31:0]) ? 1 : 0;\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [31:0] B_out;\n\n    submodule sub0(A[15:0], B[15:0], D[15:0], B_out);\n    submodule sub1(A[15:0], B[15:0], D[15:0], B_out);\n\n    submodule sub0(A[15:0], B[15:0], D[15:0], B_out);\n    submodule sub1(A[15:0], B[15:0], D[15:0], B_out);\n\n    assign D[15:0] = A[15:0] - B[15:0];\n    assign B_out = (A[15:0] < B[15:0]) ? 1 : 0;\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_out;\n\n    submodule sub0(A[7:0], B[7:0], D[7:0], B_out);\n    submodule sub1(A[7:0], B[7:0], D[7:0], B_out);\n\n    submodule sub0(A[7:0], B[7:0], D[7:0], B_out);\n    submodule sub1(A[7:0], B[7:0], D[7:0], B_out);\n\n    assign D[7:0] = A[7:0] - B[7:0];\n    assign B_out = (A[7:0] < B[7:0]) ? 1 : 0;\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      c0_reg <= 32'b0;\n      c1_reg <= 32'b0;\n      c2_reg <= 32'b0;\n      c3_reg <= 32'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= {c0_reg[30:0], a0 * b0};\n      c1_reg <= {c1_reg[30:0], a1 * b1};\n      c2_reg <= {c2_reg[30:0], a2 * b2};\n      c3_reg <= {c3_reg[30:0], a3 * b3};\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n\nmodule top_module(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  systolic1x4 pe0(\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .a1(a1),\n    .a2(a2),\n    .a3(a3),\n    .b0(b0),\n    .c0(c0),\n    .c1(c1),\n    .c2(c2),\n    .c3(c3)\n  );\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    submodule sub1(A[16:1], B[16:1], D[16:1], B_out);\n    submodule sub2(A[16:4], B[16:4], D[16:4], B_out);\n    submodule sub3(A[16:8], B[16:8], D[16:8], B_out);\n    submodule sub4(A[16:12], B[16:12], D[16:12], B_out);\n\n    assign D[16:1] = {D_out, B_out};\n\n    endmodule\n\n    module submodule(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    full_subtractor full_subtractor_inst1(A[16:1], B[16:1], D[16:1], B_out);\n    full_subtractor full_subtractor_inst2(A[16:4], B[16:4], D[16:4], B_out);\n    full_subtractor full_subtractor_inst3(A[16:8], B[16:8], D[16:8], B_out);\n    full_subtractor full_subtractor_inst4(A[16:12], B[16:12], D[16:12], B_out);\n\n    endmodule\n\n    module full_subtractor(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    assign A_out = A[3:0] - B[3:0];\n    assign B_out = (A[3:0] < B[3:0]) ? 1 : 0;\n    assign D_out = A[7:4] - B[7:4];\n    assign D[7:4] = (A[7:4] < B[7:4]) ? D_out : (D_out + 1);\n    assign D[11:8] = (A[11:8] < B[11:8]) ? D_out : (D_out + 1);\n    assign D[15:12] = (A[15:12] < B[15:12]) ? D_out : (D_out + 1);\n\n    endmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    reg [31:0] pc;\n    reg [31:0] instr;\n    reg [31:0] op1;\n    reg [31:0] op2;\n    reg [31:0] result;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [2:0] funct3;\n    reg [6:0] funct7;\n    reg [1:0] opcode;\n    reg [5:0] imm;\n    reg [31:0] reg_file_out [0:31];\n\n    wire [31:0] instr_mem_out;\n    wire [31:0] reg_file_out_out;\n\n    assign instr_mem_out = instr_mem[pc];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc <= 0;\n            instr <= 0;\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            funct3 <= 0;\n            funct7 <= 0;\n            opcode <= 0;\n            imm <= 0;\n            reg_file_out <= 0;\n        end else begin\n            pc <= pc + 1;\n            instr <= instr_mem_out;\n            op1 <= reg_file[instr[20:15]];\n            op2 <= reg_file[instr[15:10]];\n            result <= 0;\n            rd <= instr[11:7];\n            rs1 <= instr[19:15];\n            rs2 <= instr[24:20];\n            funct3 <= instr[14:12];\n            funct7 <= instr[31:25];\n            opcode <= instr[6:0];\n            imm <= instr[31:20];\n            reg_file_out <= reg_file;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            reg_file_out_out <= 0;\n        end else begin\n            case (opcode)\n                2'b00: begin\n                    result <= op1 + op2;\n                end\n                2'b10: begin\n                    result <= op1 - op2;\n                end\n                default: begin\n                    result <= 0;\n                end\n            endcase\n            reg_file_out_out <= result;\n        end\n    end\n\n    assign out_reg_file = reg_file_out_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [1:0] opcode,\n    output [5:0] imm\n);\n    reg [31:0] pc;\n    reg [31:0] instr_mem_out;\n    reg [31:0] op1_out;\n    reg [31:0] op2_out;\n    reg [31:0] result_out;\n    reg [4:0] rd_out;\n    reg [4:0] rs1_out;\n    reg [4:0]"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    // Submodule to perform 32-bit subtraction\n    submodule subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry_out(carry_out)\n    );\n\n    // Combinational logic to determine greater, equal, or less than\n    assign A_greater = (sub_result == 32'b0);\n    assign A_equal = (sub_result == 32'b0) && (carry_out == 1'b0);\n    assign A_less = (sub_result != 32'b0) && (carry_out == 1'b0);\n\nendmodule\n\n// Submodule to perform 32-bit subtraction\nmodule submodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Output of subtraction\n    output carry_out        // Carry out of subtraction\n);\n\n    // Combinational logic to perform subtraction\n    assign sub_result = A - B;\n    assign carry_out = (A[31] == B[31]) ? 1'b0 : (A[31] > B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A, B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire [8:1] C8;\n    wire [4:1] C4;\n    wire [2:1] C2;\n    wire [1:1] C1;\n\n    wire [32:1] S16;\n    wire [16:1] S8;\n    wire [8:1] S4;\n    wire [4:1] S2;\n    wire [2:1] S1;\n\n    wire [32:1] C16_out;\n    wire [16:1] C8_out;\n    wire [8:1] C4_out;\n    wire [4:1] C2_out;\n    wire [2:1] C1_out;\n\n    wire [32:1] C32_out;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .C(C16[1]), .S(S16[16:1]));\n    CLA1 CLA2 (.A(A[8:1]), .B(B[8:1]), .C(C8[1]), .S(S8[8:1]));\n    CLA1 CLA3 (.A(A[4:1]), .B(B[4:1]), .C(C4[1]), .S(S4[4:1]));\n    CLA1 CLA4 (.A(A[2:1]), .B(B[2:1]), .C(C2[1]), .S(S2[2:1]));\n    CLA1 CLA5 (.A(A[1:1]), .B(B[1:1]), .C(C1[1]), .S(S1[1:1]));\n\n    assign C16 = {C1, C2, C4, C8};\n    assign C32 = C16[16];\n\n    assign S = {S1, S2, S4, S8, S16};\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0] counter;\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0000;\n            data_accumulator <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else if (valid_in) begin\n            counter <= counter + 1;\n            data_accumulator <= data_accumulator + data_in;\n            if (counter == 4) begin\n                valid_output <= 1'b1;\n                counter <= 4'b0000;\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else if (valid_in) begin\n            counter_reg <= counter_reg + 1;\n            if (counter_reg == 4) begin\n                valid_output <= 1'b1;\n                counter_reg <= 4'b0000;\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [9:0] data_accumulator_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator_reg <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else if (valid_in) begin\n            data_accumulator_reg <= data_accumulator_reg + data_in;\n            valid_output <= 1'b1;\n        end\n    end\n\n    assign data_out = data_accumulator_reg;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else if (valid_in) begin\n            counter_reg <= counter_reg + 1;\n            if (counter_reg == 4) begin\n                valid_output <= 1'b1;\n                counter_reg <= 4'b0000;\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;\n    assign valid_out ="}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] sum1;\n    wire [3:0] sum2;\n    wire [3:0] sum3;\n    wire [3:0] sum4;\n    wire [3:0] sum5;\n    wire [3:0] sum6;\n    wire [3:0] sum7;\n    wire [3:0] sum8;\n    wire [3:0] sum9;\n    wire [3:0] sum10;\n    wire [3:0] sum11;\n    wire [3:0] sum12;\n    wire [3:0] sum13;\n    wire [3:0] sum14;\n    wire [3:0] sum15;\n    wire [3:0] sum16;\n    wire [3:0] sum17;\n    wire [3:0] sum18;\n    wire [3:0] sum19;\n    wire [3:0] sum20;\n    wire [3:0] sum21;\n    wire [3:0] sum22;\n    wire [3:0] sum23;\n    wire [3:0] sum24;\n    wire [3:0] sum25;\n    wire [3:0] sum26;\n    wire [3:0] sum27;\n    wire [3:0] sum28;\n    wire [3:0] sum29;\n    wire [3:0] sum30;\n    wire [3:0] sum31;\n    wire [3:0] sum32;\n    wire [3:0] sum33;\n    wire [3:0] sum34;\n    wire [3:0] sum35;\n    wire [3:0] sum36;\n    wire [3:0] sum37;\n    wire [3:0] sum38;\n    wire [3:0] sum39;\n    wire [3:0] sum40;\n    wire [3:0] sum41;\n    wire [3:0] sum42;\n    wire [3:0] sum43;\n    wire [3:0] sum44;\n    wire [3:0] sum45;\n    wire [3:0] sum46;\n    wire [3:0] sum47;\n    wire [3:0] sum48;\n    wire [3:0] sum49;\n    wire [3:0] sum50;\n    wire [3:0] sum51;\n    wire [3:0] sum52;\n    wire [3:0] sum53;\n    wire [3:0] sum54;\n    wire [3:0] sum55;\n    wire [3:0] sum56;\n    wire [3:0] sum57;\n    wire [3:0] sum58;\n    wire [3:0] sum59;\n    wire [3:0] sum60;\n    wire [3:0] sum61;\n    wire [3:0] sum62;\n    wire [3:0] sum63;\n    wire [3:0] sum64;\n    wire [3:0] sum65;\n    wire [3:0] sum66;\n    wire [3:0] sum67;\n    wire [3:0] sum68;\n    wire [3:0] sum69;\n    wire [3:0] sum70;\n    wire [3:0] sum71;\n    wire [3:0] sum72;\n    wire [3:0] sum73;\n    wire [3:0] sum74;\n    wire [3:0] sum75;\n    wire [3:0] sum76;\n    wire [3:0] sum77;\n    wire [3:0] sum78;\n    wire [3:0] sum79;\n    wire [3:0] sum80;\n    wire [3:0] sum81"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor_mod;\n    wire [3:0] counter;\n    wire [15:0] shift_reg;\n    wire [15:0] quotient;\n    wire [7:0] remainder;\n\n    // Absolute Value Calculation\n    abs_value abs_dividend (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative Divisor Calculation\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor_mod)\n    );\n\n    // Division Control Logic\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result Management\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result)\n    );\n\nendmodule\n\n// Absolute Value Calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Negative Divisor Calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Division Control Logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [15:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder\n);\n\n    reg [3:0] counter_reg;\n    reg [15:0] shift_reg_reg;\n    reg [15:0] quotient_reg;\n    reg [7:0] remainder_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= 4'd0;\n            shift_reg_reg <= 16'd0;\n            quotient_reg <= 16'd0;\n            remainder_reg <= 8'd0;\n        end else begin\n            if (opn_valid) begin\n                counter_reg <= 4'd0;\n                shift_reg_reg <= 16'd0;\n                quotient_reg"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] add8_Co;\n\n    // 8-bit adder\n    add8_inst1 add8_inst1_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(add8_Co[0])\n    );\n\n    add8_inst2 add8_inst2_inst (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(add8_Co[0]),\n        .y(y[15:8]),\n        .Co(add8_Co[1])\n    );\n\n    assign Co = add8_Co[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n\n    div_operation div_operation_inst (\n        .prep_A(prep_A),\n        .prep_B(prep_B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Prepare dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] prep_A, // 32-bit dividend\n    output wire [15:0] prep_B  // 16-bit divisor\n);\n\n    assign prep_A = {A[31:16], A[15:0]};\n    assign prep_B = {B[15:0], 16'h0};\n\nendmodule\n\n// Perform division operation\nmodule div_operation(\n    input wire [31:0] prep_A, // 32-bit dividend\n    input wire [15:0] prep_B, // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    reg [31:0] shifted_A;\n    reg [31:0] shifted_B;\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    integer i;\n\n    always @(*) begin\n        shifted_A = prep_A;\n        shifted_B = prep_B;\n        quotient = 32'h0;\n        remainder = 32'h0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_A >= shifted_B) begin\n                quotient[i] = 1'b1;\n                shifted_A = shifted_A - shifted_B;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n\n            shifted_B = shifted_B << 1;\n        end\n\n        remainder = shifted_A;\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n\n    full_adder FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(FA0_sum),\n        .cout(FA0_cout)\n    );\n\n    full_adder FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(FA0_cout),\n        .sum(FA1_sum),\n        .cout(FA1_cout)\n    );\n\n    full_adder FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(FA1_cout),\n        .sum(FA2_sum),\n        .cout(FA2_cout)\n    );\n\n    full_adder FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(FA2_cout),\n        .sum(FA3_sum),\n        .cout(FA3_cout)\n    );\n\n    full_adder FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(FA3_cout),\n        .sum(FA4_sum),\n        .cout(FA4_cout)\n    );\n\n    full_adder FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(FA4_cout),\n        .sum(FA5_sum),\n        .cout(FA5_cout)\n    );\n\n    full_adder FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(FA5_cout),\n        .sum(FA6_sum),\n        .cout(FA6_cout)\n    );\n\n    full_adder FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(FA6_cout),\n        .sum(FA7_sum),\n        .cout(FA7_cout)\n    );\n\n    assign sum = FA7_sum;\n    assign cout = FA7_cout;\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n// Control unit submodule\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\n// Control unit submodule implementation\n// This module performs the division algorithm\n// and updates the quotient and remainder\n// inputs:\n//   A: 16-bit dividend\n//   B: 8-bit divisor\n// outputs:\n//   result: 16-bit quotient\n//   odd: 16-bit remainder\n\nreg [15:0] temp_result;\nreg [15:0] temp_odd;\nreg [15:0] temp_dividend;\nreg [7:0] temp_divisor;\nreg [3:0] temp_count;\n\nalways @(*) begin\n    temp_result = 16'b0;\n    temp_odd = 16'b0;\n    temp_dividend = A;\n    temp_divisor = B;\n    temp_count = 4'b0;\n    \n    while (temp_count < 4'b1111) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_dividend = temp_dividend - temp_divisor;\n            temp_result[temp_count] = 1'b1;\n        end else begin\n            temp_result[temp_count] = 1'b0;\n        end\n        \n        temp_count = temp_count + 1;\n        temp_divisor = temp_divisor << 1;\n    end\n    \n    temp_odd = temp_dividend;\nend\n\nendmodule\n\n// Control unit submodule\n// This module connects the input and output ports\n// and instantiates the divider submodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n// Divider submodule\ndivider divider (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n// Control Unit\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_reg <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'b0000;\n            product <= 32'b0;\n            done_reg <= 1'b0;\n        end else begin\n            if (shift_count == 4'b1111) begin\n                done_reg <= 1'b1;\n            end else begin\n                shift_count <= shift_count + 1;\n                product <= product + (bin >> shift_count);\n            end\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'b0;\n        reg_b <= 16'b0;\n    end else begin\n        if (start) begin\n            reg_a <= ain;\n            reg_b <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [15:0] mul_a;\nreg [15:0] mul_b;\nreg [31:0] mul_product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        mul_a <= 16'b0;\n        mul_b <= 16'b0;\n        mul_product <= 32'b0;\n    end else begin\n        if (shift_count == 4'b0000) begin\n            mul_a <= reg_a;\n            mul_b <= reg_b;\n            mul_product <= 32'b0;\n        end else begin\n            mul_a <= mul_a >> 1;\n            mul_b <= mul_b >> 1;\n            mul_product <= mul_product + (mul_b & {16'b0, mul_a[0]});\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_reg;\n\nendmodule"}
