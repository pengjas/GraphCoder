{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\n    input [7:0] A, B;\n    input C_in;\n    output [7:0] D;\n    output C_out;\n\n    wire [7:0] sum;\n    wire carry;\n\n    assign {carry, sum} = A + B + C_in;\n    assign D = sum;\n    assign C_out = carry;\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\n    input A, B, C_in;\n    output D;\n    output C_out;\n\n    wire carry;\n\n    assign {carry, D} = A + B + C_in;\n    assign C_out = carry;\nendmodule\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out;\n    wire [15:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_16bit S1 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_16bit S2 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff[15:0] = S1_out;\n    assign Diff[31:16] = S2_out;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1_out;\n    wire [7:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_8bit S1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_8bit S2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff[7:0] = S1_out;\n    assign Diff[15:8] = S2_out;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1_out;\n    wire [3:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_4bit S1 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_4bit S2 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff[3:0] = S1_out;\n    assign Diff[7:4] = S2_out;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1_out;\n    wire [1:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_2bit S1 (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_2bit S2 (\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff[1:0] = S1_out;\n    assign Diff[3:2] = S2_"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire B0, B1;\n\n    submodule sub0(A[31:0], B[31:0], D0, B0);\n    submodule sub1(A[31:0], B[31:0], D1, B1);\n\n    assign D[63:32] = D1;\n    assign D[31:0] = D0;\n    assign B_out = B1;\n\n    submodule sub2(A[15:0], B[15:0], D0, B0);\n    submodule sub3(A[15:0], B[15:0], D1, B1);\n\n    submodule sub4(A[7:0], B[7:0], D0, B0);\n    submodule sub5(A[7:0], B[7:0], D1, B1);\n\n    submodule sub6(A[3:0], B[3:0], D0, B0);\n    submodule sub7(A[3:0], B[3:0], D1, B1);\n\n    submodule sub8(A[0], B[0], D0, B0);\n    submodule sub9(A[0], B[0], D1, B1);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] D0, D1;\n    wire B0, B1;\n\n    submodule sub0(A[15:0], B[15:0], D0, B0);\n    submodule sub1(A[15:0], B[15:0], D1, B1);\n\n    assign D[31:16] = D1;\n    assign D[15:0] = D0;\n    assign B_out = B1;\n\n    submodule sub2(A[7:0], B[7:0], D0, B0);\n    submodule sub3(A[7:0], B[7:0], D1, B1);\n\n    submodule sub4(A[3:0], B[3:0], D0, B0);\n    submodule sub5(A[3:0], B[3:0], D1, B1);\n\n    submodule sub6(A[1:0], B[1:0], D0, B0);\n    submodule sub7(A[1:0], B[1:0], D1, B1);\n\n    submodule sub8(A[0], B[0], D0, B0);\n    submodule sub9(A[0], B[0], D1, B1);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] D0, D1;\n    wire B0, B1;\n\n    submodule sub0(A[3:0], B[3:0], D0, B0);\n    submodule sub1(A[3:0], B[3:0], D1, B1);\n\n    assign D[7:4] = D1;\n    assign D[3:0] = D0;\n    assign B_out = B1;\n\n    submodule sub2(A[1:0], B[1:0], D0, B0);\n    submodule sub3(A[1:0], B[1:0], D1, B1);\n\n    submodule sub4(A[0], B[0], D0, B0);\n    submodule sub5(A[0], B[0], D1, B1);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [3:0] A, B;"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    submodule sub1(A[16:1], B[16:1], D_out, A_out, B_out);\n    submodule sub2(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub3(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub4(A_out, B[16:1], D_out, A_out, B_out);\n\n    assign D = D_out;\n    assign B_out = B_out;\nendmodule\n\nmodule submodule(A, B, D, A_out, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output [3:0] A_out, B_out;\n\n    wire [3:0] A_out_temp, B_out_temp;\n    wire [3:0] D_out_temp;\n\n    full_subtractor_4bit full_subtractor_4bit_1(A[16:1], B[16:1], D_out_temp, A_out_temp, B_out_temp);\n    full_subtractor_4bit full_subtractor_4bit_2(A_out_temp, B[16:1], D_out_temp, A_out, B_out_temp);\n    full_subtractor_4bit full_subtractor_4bit_3(A_out, B[16:1], D_out_temp, A_out, B_out_temp);\n    full_subtractor_4bit full_subtractor_4bit_4(A_out, B_out_temp, D_out_temp, A_out, B_out);\n\n    assign D = D_out_temp;\n    assign A_out = A_out_temp;\n    assign B_out = B_out_temp;\nendmodule\n\nmodule full_subtractor_4bit(A, B, D, A_out, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output [3:0] A_out, B_out;\n\n    wire [3:0] A_out_temp, B_out_temp;\n    wire [3:0] D_out_temp;\n\n    submodule sub1(A[3:0], B[3:0], D_out_temp, A_out_temp, B_out_temp);\n    submodule sub2(A_out_temp, B[3:0], D_out_temp, A_out, B_out_temp);\n    submodule sub3(A_out, B[3:0], D_out_temp, A_out, B_out);\n    submodule sub4(A_out, B_out_temp, D_out_temp, A_out, B_out);\n\n    assign D = D_out_temp;\n    assign A_out = A_out_temp;\n    assign B_out = B_out_temp;\nendmodule\n\nmodule submodule(A, B, D, A_out, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output [3:0] A_out, B_out;\n\n    wire [3:0] A_out_temp, B_out_temp;\n    wire [3:0] D_out_temp;\n\n    full_subtractor_4bit full_subtractor_4bit_1(A[3:0], B[3:0], D_out_temp, A_out_temp, B_out_temp);\n    full_subtractor_4bit full_subtractor_4bit_2(A_out_temp, B[3:0], D_out_temp, A_out, B_out"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    // Subtractor module\n    module subtractor_32bit(\n        input [31:0] A,   // First 32-bit input operand\n        input [31:0] B,   // Second 32-bit input operand\n        output [31:0] sub_result, \n        output carry_out  \n    );\n        assign sub_result = A - B;\n        assign carry_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n    endmodule\n\n    // Instantiate subtractor module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry_out(carry_out)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result != 0) ? 1'b1 : 1'b0;\n    assign A_equal = (sub_result == 0) ? 1'b1 : 1'b0;\n    assign A_less = (carry_out == 1) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [32:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15,S16;\n    wire C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n\n    wire [16:1] S1_16,S2_16,S3_16,S4_16,S5_16,S6_16,S7_16,S8_16,S9_16,S10_16,S11_16,S12_16,S13_16,S14_16,S15_16,S16_16;\n    wire [16:1] C1_16,C2_16,C3_16,C4_16,C5_16,C6_16,C7_16,C8_16,C9_16,C10_16,C11_16,C12_16,C13_16,C14_16,C15_16,C16_16;\n\n    wire [8:1] S1_8,S2_8,S3_8,S4_8,S5_8,S6_8,S7_8,S8_8;\n    wire [8:1] C1_8,C2_8,C3_8,C4_8,C5_8,C6_8,C7_8,C8_8;\n\n    wire [4:1] S1_4,S2_4,S3_4,S4_4;\n    wire [4:1] C1_4,C2_4,C3_4,C4_4;\n\n    wire [2:1] S1_2,S2_2;\n    wire [2:1] C1_2,C2_2;\n\n    wire [1:1] S1_1,S2_1;\n    wire [1:1] C1_1,C2_1;\n\n    wire [32:1] S_32;\n    wire [32:1] C_32;\n\n    assign S_32 = {S16,S15,S14,S13,S12,S11,S10,S9,S8,S7,S6,S5,S4,S3,S2,S1};\n    assign C_32 = {C16,C15,C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1};\n\n    assign S = S_32;\n    assign C32 = C_32[32];\n\n    CLA1 CLA1_inst(A[16:1],B[16:1],S1_16,C1_16);\n    CLA2 CLA2_inst(A[8:1],B[8:1],S2_8,C2_8);\n    CLA2 CLA3_inst(A[4:1],B[4:1],S3_4,C3_4);\n    CLA2 CLA4_inst(A[2:1],B[2:1],S4_2,C4_2);\n    CLA2 CLA5_inst(A[1:1],B[1:1],S5_1,C5_1);\n\n    assign S1_16 = S1_8 + S2_8;\n    assign C1_16 = C1_8 + C2_8;\n\n    assign S1"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n    wire [3:0] carry_slice;\n\n    // Ripple carry adder for the first 4 bits\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, sum_slice[0], carry[0]);\n    ripple_carry_adder rca2(a[7:4], b[7:4], carry[0], sum_slice[1], carry[1]);\n    ripple_carry_adder rca3(a[11:8], b[11:8], carry[1], sum_slice[2], carry[2]);\n    ripple_carry_adder rca4(a[15:12], b[15:12], carry[2], sum_slice[3], cout);\n\n    // Carry select adder for the first 4 bits\n    carry_select_adder csa1(sum_slice[0], carry[0], cin, sum[0], carry_slice[0]);\n    carry_select_adder csa2(sum_slice[1], carry_slice[0], carry[1], sum[1], carry_slice[1]);\n    carry_select_adder csa3(sum_slice[2], carry_slice[1], carry[2], sum[2], carry_slice[2]);\n    carry_select_adder csa4(sum_slice[3], carry_slice[2], carry[3], sum[3], cout);\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule carry_select_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign {cout, sum} = (a & b) | (cin & (a | b));\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] r_add, r_sub, r_and, r_or, r_xor, r_nor, r_slt, r_sltu, r_sll, r_srl, r_sra, r_sllv, r_srlv, r_srav, r_lui;\n    wire zero_add, zero_sub, zero_and, zero_or, zero_xor, zero_nor, zero_slt, zero_sltu, zero_sll, zero_srl, zero_sra, zero_sllv, zero_srlv, zero_srav, zero_lui;\n    wire carry_add, carry_sub, carry_and, carry_or, carry_xor, carry_nor, carry_slt, carry_sltu, carry_sll, carry_srl, carry_sra, carry_sllv, carry_srlv, carry_srav, carry_lui;\n    wire negative_add, negative_sub, negative_and, negative_or, negative_xor, negative_nor, negative_slt, negative_sltu, negative_sll, negative_srl, negative_sra, negative_sllv, negative_srlv, negative_srav, negative_lui;\n    wire overflow_add, overflow_sub, overflow_and, overflow_or, overflow_xor, overflow_nor, overflow_slt, overflow_sltu, overflow_sll, overflow_srl, overflow_sra, overflow_sllv, overflow_srlv, overflow_srav, overflow_lui;\n    wire flag_add, flag_sub, flag_and, flag_or, flag_xor, flag_nor, flag_slt, flag_sltu, flag_sll, flag_srl, flag_sra, flag_sllv, flag_srlv, flag_srav, flag_lui;\n\n    // Addition\n    add_submodule add_submodule(\n        .a(a),\n        .b(b),\n        .aluc(aluc),\n        .r(r_add),\n        .zero(zero_add),\n        .carry(carry_add),\n        .negative(negative_add),\n        .overflow(overflow_add),\n        .flag(flag_add)\n    );\n\n    // Subtraction\n    sub_submodule sub_submodule(\n        .a(a),\n        .b(b),\n        .aluc(aluc),\n        .r(r_sub),\n        .zero(zero_sub),\n        .carry(carry_sub),\n        .negative(negative_sub),\n        .overflow(overflow_sub),\n        .flag(flag_sub)\n    );\n\n    // AND\n    and_submodule and_submodule(\n        .a(a),\n        .b(b),\n        .aluc(aluc),\n        .r(r_and),\n        .zero(zero_and),\n        .carry(carry_and),\n        .negative(negative_and),\n        .overflow(overflow_and),\n        .flag(flag_and)\n    );\n\n    // OR\n    or_submodule or_submodule(\n        .a(a),\n        .b(b),\n        .aluc(aluc),\n        .r(r_or),\n        .zero(zero_or),\n        .carry(carry_or),\n        .negative(negative_or),\n        .overflow(overflow_or),\n        .flag(flag_or)\n    );\n\n    // XOR\n    xor_submodule xor_submodule(\n        .a(a),\n        .b(b),\n        .aluc(aluc),\n        .r(r_xor),\n        .zero(zero_xor),\n        .carry(carry_xor),\n        .negative(negative_xor),\n        .overflow(overflow_x"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    // Counter logic submodule\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    // Counter register submodule\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count)\n    );\n\nendmodule\n\n// Counter logic submodule\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'd0;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule\n\n// Counter register submodule\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'd0;\n        end else begin\n            count <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    // State Initialization submodule\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State Transition submodule\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    // Multiplier submodule\n    reg [63:0] result;\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= a * b;\n        end\n    end\n\n    // Accumulator submodule\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result[31:0];\n        end\n    end\n\n    // Output port\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n\n    reg [63:0] temp_result;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            temp_result <= 0;\n        end else begin\n            temp_result <= a * b;\n        end\n    end\n\n    assign result = temp_result;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result[31:0];\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= in;\n    end\nend\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= Q;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output [63:0]       Q_next\n);\n\nassign Q_next = {Q[62:0], ~Q[63]};\n\nendmodule\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_p1;\nreg [4:0] ad1_p1;\nreg [7:0] ad2_p1;\n\nreg [2:0] ins_p2;\nreg [4:0] ad1_p2;\nreg [7:0] ad2_p2;\n\nwire [2:0] ins_p1_out;\nwire [4:0] ad1_p1_out;\nwire [7:0] ad2_p1_out;\n\nwire [2:0] ins_p2_out;\nwire [4:0] ad1_p2_out;\nwire [7:0] ad2_p2_out;\n\nassign ins = (fetch == 2'b01) ? ins_p1_out : ins_p2_out;\nassign ad1 = (fetch == 2'b01) ? ad1_p1_out : ad1_p2_out;\nassign ad2 = (fetch == 2'b01) ? ad2_p1_out : ad2_p2_out;\n\nalways @(posedge clk) begin\n    if (rst == 1'b0) begin\n        ins_p1 <= 3'b0;\n        ad1_p1 <= 5'b0;\n        ad2_p1 <= 8'b0;\n        \n        ins_p2 <= 3'b0;\n        ad1_p2 <= 5'b0;\n        ad2_p2 <= 8'b0;\n    end else begin\n        if (fetch == 2'b01) begin\n            ins_p1 <= data[7:5];\n            ad1_p1 <= data[4:0];\n            ad2_p1 <= data;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data[7:5];\n            ad1_p2 <= data[4:0];\n            ad2_p2 <= data;\n        end\n    end\nend\n\nendmodule\n\nmodule instr_reg_submodule (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_out;\nreg [4:0] ad1_out;\nreg [7:0] ad2_out;\n\nalways @(posedge clk) begin\n    if (rst == 1'b0) begin\n        ins_out <= 3'b0;\n        ad1_out <= 5'b0;\n        ad2_out <= 8'b0;\n    end else begin\n        ins_out <= data[7:5];\n        ad1_out <= data[4:0];\n        ad2_out <= data;\n    end\nend\n\nassign ins = ins_out;\nassign ad1 = ad1_out;\nassign ad2 = ad2_out;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    reg [1:0] clk_div_2;\n    reg [3:0] clk_div_10;\n    reg [5:0] clk_div_100;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_2 <= 2'b00;\n            clk_div_10 <= 4'b0000;\n            clk_div_100 <= 6'b000000;\n        end else begin\n            clk_div_2 <= clk_div_2 + 1;\n            if (clk_div_2 == 2'b11) begin\n                clk_div_2 <= 2'b00;\n            end\n            clk_div_10 <= clk_div_10 + 1;\n            if (clk_div_10 == 4'b1001) begin\n                clk_div_10 <= 4'b0000;\n            end\n            clk_div_100 <= clk_div_100 + 1;\n            if (clk_div_100 == 6'b100100) begin\n                clk_div_100 <= 6'b000000;\n            end\n        end\n    end\n\n    assign CLK_50 = clk_div_2[1];\n    assign CLK_10 = clk_div_10[3];\n    assign CLK_1 = clk_div_100[5];\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter (\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wave_generator (\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= 1;\n    end else begin\n        wave_out_reg <= 0;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_int1;\nwire clk_div_int2;\n\nreg [MUL2_DIV_CLK-1:0] counter;\nreg [MUL2_DIV_CLK-1:0] clk_div_int1_reg;\nreg [MUL2_DIV_CLK-1:0] clk_div_int2_reg;\n\nassign clk_div_int1 = counter[MUL2_DIV_CLK-1];\nassign clk_div_int2 = counter[MUL2_DIV_CLK-2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        clk_div_int1_reg <= 0;\n        clk_div_int2_reg <= 0;\n    end else begin\n        counter <= counter + 1;\n        clk_div_int1_reg <= clk_div_int1;\n        clk_div_int2_reg <= clk_div_int2;\n    end\nend\n\nassign clk_div = clk_div_int1_reg | clk_div_int2_reg;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK-1:0] counter\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        if (counter == MUL2_DIV_CLK) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_div_int1,\n    input               clk_div_int2,\n    output reg          clk_div_int1_reg,\n    output reg          clk_div_int2_reg\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_int1_reg <= 0;\n        clk_div_int2_reg <= 0;\n    end else begin\n        clk_div_int1_reg <= clk_div_int1;\n        clk_div_int2_reg <= clk_div_int2;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_div_int1,\n    input               clk_div_int2,\n    output reg          clk_div_int1_reg,\n    output reg          clk_div_int2_reg\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_int1_reg <= 0;\n        clk_div_int2_reg <= 0;\n    end else begin\n        clk_div_int1_reg <= clk_div_int1;\n        clk_div_int2_reg <= clk_div_int2;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign B_comp = ~B + 1;\n    assign sum = A + B_comp;\n    assign carry = (A[7] & B[7]) | (A[7] & ~sum[7]) | (B[7] & ~sum[7]);\n    assign D = sum;\n    assign B_out = carry[7];\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] carry;\n\n    assign carry[0] = A[0] ^ B[0];\n    assign D[0] = A[0] ^ B[0] ^ 1'b0;\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin\n            assign carry[i] = (A[i] & B[i]) | (A[i] & carry[i-1]) | (B[i] & carry[i-1]);\n            assign D[i] = A[i] ^ B[i] ^ carry[i-1];\n        end\n    endgenerate\n\n    assign B_out = carry[7];\nendmodule\n\nmodule full_adder(A, B, Cin, sum, Cout);\n    input A, B, Cin;\n    output sum, Cout;\n\n    assign sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule\n\nmodule adder_8bit_modular(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign B_comp = ~B + 1;\n    assign sum = A + B_comp;\n    assign carry = (A[7] & B[7]) | (A[7] & ~sum[7]) | (B[7] & ~sum[7]);\n    assign D = sum;\n    assign B_out = carry[7];\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  // First Processing Element (PE)\n  reg [31:0] pe0_out;\n  always @(posedge clk) begin\n    if (rst) begin\n      pe0_out <= 0;\n    end else begin\n      pe0_out <= a0 * b0;\n    end\n  end\n\n  // Second Processing Element (PE)\n  reg [31:0] pe1_out;\n  always @(posedge clk) begin\n    if (rst) begin\n      pe1_out <= 0;\n      b1 <= 0;\n    end else begin\n      pe1_out <= a1 * b1;\n      b1 <= b0;\n    end\n  end\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            if (wave == 5'b00000) begin\n                wave <= 5'b00001;\n            end else if (wave == 5'b00001) begin\n                wave <= 5'b00010;\n            end else if (wave == 5'b00010) begin\n                wave <= 5'b00011;\n            end else if (wave == 5'b00011) begin\n                wave <= 5'b00100;\n            end else if (wave == 5'b00100) begin\n                wave <= 5'b00101;\n            end else if (wave == 5'b00101) begin\n                wave <= 5'b00110;\n            end else if (wave == 5'b00110) begin\n                wave <= 5'b00111;\n            end else if (wave == 5'b00111) begin\n                wave <= 5'b01000;\n            end else if (wave == 5'b01000) begin\n                wave <= 5'b01001;\n            end else if (wave == 5'b01001) begin\n                wave <= 5'b01010;\n            end else if (wave == 5'b01010) begin\n                wave <= 5'b01011;\n            end else if (wave == 5'b01011) begin\n                wave <= 5'b01100;\n            end else if (wave == 5'b01100) begin\n                wave <= 5'b01101;\n            end else if (wave == 5'b01101) begin\n                wave <= 5'b01110;\n            end else if (wave == 5'b01110) begin\n                wave <= 5'b01111;\n            end else if (wave == 5'b01111) begin\n                wave <= 5'b10000;\n            end else if (wave == 5'b10000) begin\n                wave <= 5'b10001;\n            end else if (wave == 5'b10001) begin\n                wave <= 5'b10010;\n            end else if (wave == 5'b10010) begin\n                wave <= 5'b10011;\n            end else if (wave == 5'b10011) begin\n                wave <= 5'b10100;\n            end else if (wave == 5'b10100) begin\n                wave <= 5'b10101;\n            end else if (wave == 5'b10101) begin\n                wave <= 5'b10110;\n            end else if (wave == 5'b10110) begin\n                wave <= 5'b10111;\n            end else if (wave == 5'b10111) begin\n                wave <= 5'b11000;\n            end else if (wave == 5'b11000) begin\n                wave <= 5'b11001;\n            end else if (wave == 5'b11001) begin\n                wave <= 5'b11010;\n            end else if (wave == 5'b11010) begin\n                wave <= 5'b11011;\n            end else if (wave == 5'b11011) begin\n                wave <= 5'b11100;\n            end else if (wave == 5'b11100) begin\n                wave"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n\n    sub_16bit S1(A[15:0], B[15:0], S1);\n    sub_16bit S2(A[31:16], B[31:16], S2);\n\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = S1[15] ^ S2[15];\nendmodule\n\nmodule sub_16bit(A, B, Diff);\n    input [15:0] A, B;\n    output [15:0] Diff;\n\n    wire C_out;\n\n    assign Diff = A - B;\n    assign C_out = (A < B) ? 1 : 0;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    // Instantiate 3 D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    // 4-to-1 multiplexer\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= {q[0], q[1], q[2], d[3], d[4], d[5], d[6], d[7]};\n            2'b10: q <= {q[1], q[2], q[3], d[4], d[5], d[6], d[7], d[0]};\n            2'b11: q <= {q[2], q[3], q[4], d[5], d[6], d[7], d[0], d[1]};\n            default: q <= 8'b0;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [3:0] pos_counter;\n    reg [3:0] neg_counter;\n    reg clk_div1;\n    reg clk_div2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            pos_counter <= 0;\n            neg_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else begin\n            if (pos_counter == NUM_DIV - 1) begin\n                pos_counter <= 0;\n                clk_div1 <= 1;\n            end else begin\n                pos_counter <= pos_counter + 1;\n                clk_div1 <= 0;\n            end\n\n            if (neg_counter == NUM_DIV - 1) begin\n                neg_counter <= 0;\n                clk_div2 <= 1;\n            end else begin\n                neg_counter <= neg_counter + 1;\n                clk_div2 <= 0;\n            end\n        end\n    end\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    // Instantiate D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n  reg [31:0] rd_val;\n  reg [31:0] op;\n  reg [31:0] alu_out;\n  reg [31:0] mem_out;\n  reg [31:0] writeback_out;\n\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_in;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(fetch_out)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .rd_val(rd_val),\n    .op(op)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .mem_out(memory_out)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .mem_out(mem_out),\n    .writeback_in(writeback_in)\n  );\n\n  assign res_reg_file = writeback_in;\n\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n\n  reg [31:0] instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr_reg <= 32'b0;\n    end else begin\n      instr_reg <= instr_mem[pc];\n    end\n  end\n\n  assign instr = instr_reg;\n\nendmodule\n\nmodule stage_decode(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [31:0] rs1_val,\n  output [31:0] rs2_val,\n  output [31:0] rd_val,\n  output [31:0] op\n);\n\n  reg [31:0] instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr_reg <= 32'b0;\n    end else begin\n      instr_reg <= instr;\n    end\n  end\n\n  assign rs1_val = instr_reg[31:27];\n  assign rs2_val = instr_reg[26:22];\n  assign rd_val = instr_reg[21:17];\n  assign op = instr_reg[15:0];\n\nendmodule\n\nmodule stage_execute(\n  input clk,\n  input rst,\n  input [31:0] rs1_val,\n  input [31:0] rs2_val,\n  input [3"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] shifted_in;\n    wire [7:0] shifted_out;\n    wire [7:0] shifted_out_2;\n    wire [7:0] shifted_out_3;\n    wire [7:0] shifted_out_4;\n    \n    wire [2:0] sel;\n    \n    assign sel = ctrl;\n    \n    // Stage 1\n    mux2X1 mux1 (shifted_in, in, sel);\n    assign shifted_out = (ctrl[2] == 1'b1) ? shifted_in : in;\n    \n    // Stage 2\n    mux2X1 mux2 (shifted_out_2, shifted_out, sel);\n    assign shifted_out_3 = (ctrl[1] == 1'b1) ? shifted_out_2 : shifted_out;\n    \n    // Stage 3\n    mux2X1 mux3 (shifted_out_4, shifted_out_3, sel);\n    assign shifted_out_4 = (ctrl[0] == 1'b1) ? shifted_out_3 : shifted_out_3;\n    \n    // Final output\n    assign out = shifted_out_4;\n    \nendmodule\n\nmodule mux2X1 (out, a, sel);\n    input [1:0] sel;\n    input [1:0] a;\n    output [1:0] out;\n    \n    assign out = (sel == 2'b00) ? a[0] :\n                (sel == 2'b01) ? a[1] :\n                (sel == 2'b10) ? a[2] :\n                (sel == 2'b11) ? a[3] :\n                (sel == 2'b01) ? a[4] :\n                (sel == 2'b10) ? a[5] :\n                (sel == 2'b11) ? a[6] :\n                (sel == 2'b01) ? a[7] :\n                (sel == 2'b10) ? a[8] :\n                (sel == 2'b11) ? a[9] :\n                (sel == 2'b01) ? a[10] :\n                (sel == 2'b10) ? a[11] :\n                (sel == 2'b11) ? a[12] :\n                (sel == 2'b01) ? a[13] :\n                (sel == 2'b10) ? a[14] :\n                (sel == 2'b11) ? a[15] :\n                (sel == 2'b01) ? a[16] :\n                (sel == 2'b10) ? a[17] :\n                (sel == 2'b11) ? a[18] :\n                (sel == 2'b01) ? a[19] :\n                (sel == 2'b10) ? a[20] :\n                (sel == 2'b11) ? a[21] :\n                (sel == 2'b01) ? a[22] :\n                (sel == 2'b10) ? a[23] :\n                (sel == 2'b11) ? a[24] :\n                (sel == 2'b01) ? a[25] :\n                (sel == 2'b10) ? a[26] :\n                (sel == 2'b11) ? a[27] :\n                (sel == 2'b01) ? a[28] :\n                (sel == 2'b10) ? a[29] :\n                (sel == 2'b11) ? a[30] :\n                (sel == 2'b01) ? a[31] :\n                (sel == 2'b10) ? a["}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] A1, B1, D1;\n    wire B_out1;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:8], B[15:8], D[15:8], B_out);\n    submodule sub4(A[7:0], B[7:0], D[7:0], B_out);\n\n    assign D = {D1, D1};\n    assign B_out = B_out1;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:8], B[15:8], D[15:8], B_out);\n    submodule sub4(A[7:0], B[7:0], D[7:0], B_out);\n\n    assign D1 = {sub4.D, sub3.D, sub2.D, sub1.D, sub0.D};\n    assign B_out1 = {sub4.B_out, sub3.B_out, sub2.B_out, sub1.B_out, sub0.B_out};\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] A1, B1, D1;\n    wire B_out1;\n\n    submodule sub0(A[15:8], B[15:8], D[15:8], B_out);\n    submodule sub1(A[7:0], B[7:0], D[7:0], B_out);\n\n    assign D = {D1, D1};\n    assign B_out = B_out1;\n\n    submodule sub0(A[15:8], B[15:8], D[15:8], B_out);\n    submodule sub1(A[7:0], B[7:0], D[7:0], B_out);\n\n    assign D1 = {sub1.D, sub0.D};\n    assign B_out1 = {sub1.B_out, sub0.B_out};\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] A1, B1, D1;\n    wire B_out1;\n\n    submodule sub0(A[7:4], B[7:4], D[7:4], B_out);\n    submodule sub1(A[3:0], B[3:0], D[3:0], B_out);\n\n    assign D = {D1, D1};\n    assign B_out = B_out1;\n\n    submodule sub0(A[7:4], B[7:4], D[7:4], B_out);\n    submodule sub1(A[3:0], B[3:0], D[3:0], B_out);\n\n    assign D1 = {sub1.D, sub0.D};\n    assign B_out1 = {sub1."}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'd0;\n      b2 <= 16'd0;\n      b3 <= 16'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c1_reg <= c1;\n      c2_reg <= c2;\n      c3_reg <= c3;\n    end\n  end\n\n  assign c1 = a1 * b1;\n  assign c2 = a2 * b2;\n  assign c3 = a3 * b3;\n\n  assign c0 = a0 * b0;\n\nendmodule\n\nmodule top_module(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  systolic1x4 pe0(\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .a1(a1),\n    .a2(a2),\n    .a3(a3),\n    .b0(b0),\n    .c0(c0),\n    .c1(c1),\n    .c2(c2),\n    .c3(c3)\n  );\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:1] C;\n    wire [3:1] B_out_temp;\n\n    // 4-bit full subtractor block\n    sub1 sub1_inst (\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C(C[1]),\n        .D(D[16:13]),\n        .B_out(B_out_temp[1])\n    );\n\n    sub2 sub2_inst (\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C(C[2]),\n        .D(D[12:9]),\n        .B_out(B_out_temp[2])\n    );\n\n    sub3 sub3_inst (\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C(C[3]),\n        .D(D[8:5]),\n        .B_out(B_out_temp[3])\n    );\n\n    sub4 sub4_inst (\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C(C[4]),\n        .D(D[4:1]),\n        .B_out(B_out_temp[4])\n    );\n\n    assign B_out = B_out_temp[1] ^ B_out_temp[2] ^ B_out_temp[3] ^ B_out_temp[4];\nendmodule\n\n// 4-bit full subtractor block\nmodule sub1(A, B, C, D, B_out);\n    input [3:1] A, B;\n    input C;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] G, P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign D = P ^ C;\n    assign B_out = (P & C) | (G & ~C);\nendmodule\n\nmodule sub2(A, B, C, D, B_out);\n    input [3:1] A, B;\n    input C;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] G, P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign D = P ^ C;\n    assign B_out = (P & C) | (G & ~C);\nendmodule\n\nmodule sub3(A, B, C, D, B_out);\n    input [3:1] A, B;\n    input C;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] G, P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign D = P ^ C;\n    assign B_out = (P & C) | (G & ~C);\nendmodule\n\nmodule sub4(A, B, C, D, B_out);\n    input [3:1] A, B;\n    input C;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] G, P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign D = P ^ C;\n    assign B_out = (P & C) | (G & ~C);\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    reg [31:0] pc;\n    reg [31:0] instr;\n    reg [31:0] op1;\n    reg [31:0] op2;\n    reg [31:0] result;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [5:0] funct;\n    reg [1:0] op;\n    reg [1:0] alu_op;\n    reg [1:0] mem_op;\n    reg [1:0] mem_wr;\n    reg [1:0] mem_rd;\n    reg [1:0] mem_addr;\n    reg [1:0] mem_data;\n    reg [1:0] mem_instr;\n    reg [1:0] mem_pc;\n    reg [1:0] mem_reg;\n    reg [1:0] mem_out;\n    reg [1:0] mem_in;\n    reg [1:0] mem_op_wr;\n    reg [1:0] mem_op_rd;\n    reg [1:0] mem_op_addr;\n    reg [1:0] mem_op_data;\n    reg [1:0] mem_op_instr;\n    reg [1:0] mem_op_pc;\n    reg [1:0] mem_op_reg;\n    reg [1:0] mem_op_out;\n    reg [1:0] mem_op_in;\n    reg [1:0] mem_op_wr_reg;\n    reg [1:0] mem_op_rd_reg;\n    reg [1:0] mem_op_addr_reg;\n    reg [1:0] mem_op_data_reg;\n    reg [1:0] mem_op_instr_reg;\n    reg [1:0] mem_op_pc_reg;\n    reg [1:0] mem_op_reg_reg;\n    reg [1:0] mem_op_out_reg;\n    reg [1:0] mem_op_in_reg;\n    reg [1:0] mem_op_wr_reg_reg;\n    reg [1:0] mem_op_rd_reg_reg;\n    reg [1:0] mem_op_addr_reg_reg;\n    reg [1:0] mem_op_data_reg_reg;\n    reg [1:0] mem_op_instr_reg_reg;\n    reg [1:0] mem_op_pc_reg_reg;\n    reg [1:0] mem_op_reg_reg_reg;\n    reg [1:0] mem_op_out_reg_reg;\n    reg [1:0] mem_op_in_reg_reg;\n    reg [1:0] mem_op_wr_reg_reg_reg;\n    reg [1:0] mem_op_rd_reg_reg_reg;\n    reg [1:0] mem_op_addr_reg_reg_reg;\n    reg [1:0] mem_op_data_reg_reg_reg;\n    reg [1:0] mem_op_instr_reg_reg_reg;\n    reg [1:0] mem_op_pc_reg_reg_reg;\n    reg [1:0] mem_op_reg_reg_reg_reg;\n    reg [1:0] mem_op_out_reg_reg_reg;\n    reg [1:0] mem_op_in_reg_reg_reg_reg;\n\n    wire [1:0] mem_op_wr_reg_reg_reg_reg;\n    wire [1:0] mem_op_rd_reg_reg_reg_reg;\n    wire [1:0] mem_op_addr_reg_reg_reg_reg;\n    wire [1:0] mem_op_data_reg_reg_reg_reg"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry;\n\n    // Subtraction logic\n    assign sub_result = A - B;\n    assign carry = (~A[31] & B[31]) | (A[31] & ~B[31]);\n\n    // Comparison logic\n    assign A_greater = (sub_result[31] == 1) ? 1'b1 : 1'b0;\n    assign A_equal = (sub_result == 0) ? 1'b1 : 1'b0;\n    assign A_less = (carry == 1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result, \n    output carry     \n);\n\n    assign sub_result = A - B;\n    assign carry = (~A[31] & B[31]) | (A[31] & ~B[31]);\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0] counter;\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0000;\n            data_accumulator <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter <= counter + 1;\n                data_accumulator <= data_accumulator + data_in;\n                if (counter == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter_reg <= counter_reg + 1;\n                if (counter_reg == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                data_accumulator <= data_accumulator + data_in;\n                if (counter == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter_reg <= counter_reg + 1;\n                if (counter_reg == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire [8:1] C8;\n    wire [4:1] C4;\n    wire [2:1] C2;\n    wire C1;\n\n    wire [32:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15,S16;\n    wire [16:1] C161,C162,C163,C164,C165,C166,C167,C168,C169,C1610,C1611,C1612,C1613,C1614,C1615,C1616;\n    wire [8:1] C81,C82,C83,C84,C85,C86,C87,C88,C89,C810,C811,C812,C813,C814,C815,C816;\n    wire [4:1] C41,C42,C43,C44,C45,C46,C47,C48,C49,C410,C411,C412,C413,C414,C415,C416;\n    wire [2:1] C21,C22,C23,C24,C25,C26,C27,C28,C29,C210,C211,C212,C213,C214,C215,C216;\n    wire C11,C12,C13,C14,C15,C16,C17,C18,C19,C110,C111,C112,C113,C114,C115,C116;\n\n    wire [32:1] S17,S18,S19,S20,S21,S22,S23,S24,S25,S26,S27,S28,S29,S30,S31,S32;\n    wire [16:1] C1617,C1618,C1619,C1620,C1621,C1622,C1623,C1624,C1625,C161010,C161111,C161212,C161313,C161414,C161515,C161616;\n    wire [8:1] C817,C818,C819,C820,C821,C822,C823,C824,C825,C81010,C81111,C81212,C81313,C81414,C81515,C81616;\n    wire [4:1] C417,C418,C419,C420,C421,C422,C423,C424,C425,C41010,C41111,C41212,C41313,C41414,C41515,C41616;\n    wire [2:1] C217,C218,C219,C220,C221,C222,C223,C224,C225,"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    // Ripple carry adder for the first 4 bits\n    wire [3:0] rca1_sum;\n    wire rca1_cout;\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, rca1_sum, rca1_cout);\n\n    // Carry select adder for the first 4 bits\n    wire [3:0] csa_slice1_sum;\n    wire csa_slice1_cout;\n    carry_select_adder csa_slice1(rca1_sum, rca1_cout, cin, csa_slice1_sum, csa_slice1_cout);\n\n    // Ripple carry adder for the second 4 bits\n    wire [3:0] rca2_sum;\n    wire rca2_cout;\n    ripple_carry_adder rca2(a[7:4], b[7:4], csa_slice1_cout, rca2_sum, rca2_cout);\n\n    // Carry select adder for the second 4 bits\n    wire [3:0] csa_slice2_sum;\n    wire csa_slice2_cout;\n    carry_select_adder csa_slice2(rca2_sum, rca2_cout, csa_slice1_cout, csa_slice2_sum, csa_slice2_cout);\n\n    // Ripple carry adder for the third 4 bits\n    wire [3:0] rca3_sum;\n    wire rca3_cout;\n    ripple_carry_adder rca3(a[11:8], b[11:8], csa_slice2_cout, rca3_sum, rca3_cout);\n\n    // Carry select adder for the third 4 bits\n    wire [3:0] csa_slice3_sum;\n    wire csa_slice3_cout;\n    carry_select_adder csa_slice3(rca3_sum, rca3_cout, csa_slice2_cout, csa_slice3_sum, csa_slice3_cout);\n\n    // Ripple carry adder for the last 4 bits\n    wire [3:0] rca4_sum;\n    wire rca4_cout;\n    ripple_carry_adder rca4(a[15:12], b[15:12], csa_slice3_cout, rca4_sum, rca4_cout);\n\n    // Carry select adder for the last 4 bits\n    wire [3:0] csa_slice4_sum;\n    wire csa_slice4_cout;\n    carry_select_adder csa_slice4(rca4_sum, rca4_cout, csa_slice3_cout, csa_slice4_sum, csa_slice4_cout);\n\n    // Output sum and carry-out\n    assign sum = {csa_slice4_sum, csa_slice3_sum, csa_slice2_sum, csa_slice1_sum};\n    assign cout = csa_slice4_cout;\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign sum = a + b + cin;\n    assign carry = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n    assign cout = carry[3];\nendmodule\n\nmodule carry_select_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    // Absolute Value Calculation\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    assign abs_dividend = (sign) ? -dividend : dividend;\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    // Negative Divisor Calculation\n    wire [7:0] neg_divisor_mod;\n    assign neg_divisor_mod = (sign) ? -divisor : divisor;\n\n    // Division Control Logic\n    reg [3:0] counter;\n    reg [7:0] shift_reg;\n    wire div_complete;\n    assign div_complete = (counter == 4'd0);\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 8'd0;\n        end else if (opn_valid && !res_valid) begin\n            counter <= 4'd0;\n            shift_reg <= abs_dividend;\n        end else if (opn_valid && res_valid) begin\n            counter <= counter + 4'd1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\n\n    // Result Management\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    assign quotient = shift_reg[7:1];\n    assign remainder = (sign) ? -shift_reg[0] : shift_reg[0];\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid && !res_valid) begin\n            res_valid <= 1'b1;\n        end else if (res_ready) begin\n            res_valid <= 1'b0;\n        end\n    end\n    assign result = {remainder, quotient};\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    output reg [7:0] abs_dividend\n);\n\n    always @(*) begin\n        if (dividend[7] == 1'b1) begin\n            abs_dividend = -dividend;\n        end else begin\n            abs_dividend = dividend;\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] neg_divisor_mod\n);\n\n    always @(*) begin\n        if (sign == 1'b1) begin\n            neg_divisor_mod = -divisor;\n        end else begin\n            neg_divisor_mod = divisor;\n        end\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire [3:0] counter,\n    input wire div_complete,\n    output reg [3:0] shift_reg\n);\n\n    always @(*) begin\n        if (div_complete) begin\n            shift_reg = 4'd0;\n        end else begin\n            shift_reg = counter + 4'd1;\n        end\n    end\n\nendmodule\n\nmodule result_management(\n    input wire [15:0] result,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire rst,\n    output reg res_valid\n);\n\n    always @(*) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (counter == 4'd0) begin\n            res_valid <= 1'b1;\n        end else if (res_ready) begin\n            res_valid <= 1'b0;\n        end\n    end"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n    wire [15:0] y_8bit;\n\n    // 8-bit adder for the lower 8 bits\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8bit[7:0]),\n        .Co(Co_8bit[0])\n    );\n\n    // 8-bit adder for the upper 8 bits\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit[0]),\n        .y(y_8bit[15:8]),\n        .Co(Co_8bit[1])\n    );\n\n    // Output the sum of the two 8-bit adders\n    assign y = y_8bit;\n    assign Co = Co_8bit[1];\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for the lower 8 bits\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Prepare dividend and divisor for division\nprep_dividend prep_dividend_inst (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\n// Perform division\ndiv_operation div_operation_inst (\n    .A(result),\n    .B(odd),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\n// Prepare dividend and divisor for division\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Prepare dividend and divisor for division\nassign result = {A[31:16], 16'b0};\nassign odd = {A[15:0], 16'b0};\n\nendmodule\n\n// Perform division\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Perform division\nassign result = A >> 16;\nassign odd = A & 16'hFFFF;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n\n    full_adder FA0(a[0], b[0], cin, sum[0], FA0_cout);\n    full_adder FA1(a[1], b[1], FA0_cout, sum[1], FA1_cout);\n    full_adder FA2(a[2], b[2], FA1_cout, sum[2], FA2_cout);\n    full_adder FA3(a[3], b[3], FA2_cout, sum[3], FA3_cout);\n    full_adder FA4(a[4], b[4], FA3_cout, sum[4], FA4_cout);\n    full_adder FA5(a[5], b[5], FA4_cout, sum[5], FA5_cout);\n    full_adder FA6(a[6], b[6], FA5_cout, sum[6], FA6_cout);\n    full_adder FA7(a[7], b[7], FA6_cout, sum[7], cout);\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n// Control unit submodule\ndiv_ctrl ctrl (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\n// Control unit submodule\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [3:0] i;\nreg [15:0] temp_result;\nreg [15:0] temp_odd;\n\nalways @(*) begin\n    // Initialize variables\n    dividend = A;\n    divisor = B;\n    result = 0;\n    odd = 0;\n    temp_result = 0;\n    temp_odd = 0;\n\n    // Perform division\n    for (i = 0; i < 16; i = i + 1) begin\n        // Shift dividend\n        dividend = {dividend[14:0], 1'b0};\n\n        // Compare with divisor\n        if (dividend >= divisor) begin\n            // Subtract divisor from dividend\n            dividend = dividend - divisor;\n\n            // Set bit in quotient\n            result[i] = 1'b1;\n        end else begin\n            // Set bit in quotient\n            result[i] = 1'b0;\n        end\n\n        // Shift divisor\n        divisor = {divisor[6:0], 1'b0};\n\n        // Shift temp_result and temp_odd\n        temp_result = {temp_result[14:0], 1'b0};\n        temp_odd = {temp_odd[14:0], 1'b0};\n\n        // Set bit in temp_result and temp_odd\n        if (dividend >= divisor) begin\n            temp_result[i] = 1'b1;\n            temp_odd[i] = 1'b1;\n        end else begin\n            temp_result[i] = 1'b0;\n            temp_odd[i] = 1'b0;\n        end\n    end\n\n    // Update odd\n    odd = temp_odd;\nend\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n// Control Unit\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else if (start) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else if (shift_count == 4'b1111) begin\n        done_flag <= 1'b1;\n    end else begin\n        shift_count <= shift_count + 1;\n        product <= product + (bin[shift_count] ? ain : 32'b0);\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'b0;\n        reg_b <= 16'b0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Multiplier Unit\nreg [15:0] mul_a;\nreg [15:0] mul_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        mul_a <= 16'b0;\n        mul_b <= 16'b0;\n    end else if (start) begin\n        mul_a <= reg_a;\n        mul_b <= reg_b;\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
