{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  assign b1 = rst ? 0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= c_reg + a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 16'b0;\n        end else begin\n            if (up_down) begin\n                next_count <= next_count + 1;\n            end else begin\n                next_count <= next_count - 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  assign b1 = rst ? 0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= c_reg + a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the submodules for initialization and state transition\n    ring_counter_init init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    ring_counter_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Assign the output\n    assign out = transition_out;\n\nendmodule\n\nmodule ring_counter_init (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @ (posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] transition_out\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= init_out;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_complement;\n    wire [7:0] B_out_temp;\n\n    assign B_complement = ~B;\n\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_complement),\n        .C_in(1'b0),\n        .D(D),\n        .C_out(B_out_temp)\n    );\n\n    assign B_out = B_out_temp[7];\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\n    input [7:0] A;\n    input [7:0] B;\n    input C_in;\n    output [7:0] D;\n    output C_out;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    full_adder fa0 (.A(A[0]), .B(B[0]), .C_in(C_in), .S(sum[0]), .C_out(carry[0]));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .C_in(carry[0]), .S(sum[1]), .C_out(carry[1]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .C_in(carry[1]), .S(sum[2]), .C_out(carry[2]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .C_in(carry[2]), .S(sum[3]), .C_out(carry[3]));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .C_in(carry[3]), .S(sum[4]), .C_out(carry[4]));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .C_in(carry[4]), .S(sum[5]), .C_out(carry[5]));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .C_in(carry[5]), .S(sum[6]), .C_out(carry[6]));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .C_in(carry[6]), .S(sum[7]), .C_out(carry[7]));\n\n    assign D = sum;\n    assign C_out = carry[7];\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;\n    output S, C_out;\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, slt_out, sltu_out, sll_out, srl_out, sra_out, sllv_out, srlv_out, srav_out, lui_out;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_neg, sub_neg, and_neg, or_neg, xor_neg, nor_neg, slt_neg, sltu_neg, sll_neg, srl_neg, sra_neg, sllv_neg, srlv_neg, srav_neg, lui_neg;\n    wire [31:0] add_ovf, sub_ovf, and_ovf, or_ovf, xor_ovf, nor_ovf, slt_ovf, sltu_ovf, sll_ovf, srl_ovf, sra_ovf, sllv_ovf, srlv_ovf, srav_ovf, lui_ovf;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Addition\n    add addu(\n        .a(a),\n        .b(b),\n        .r(add_out),\n        .carry(add_carry),\n        .neg(add_neg),\n        .ovf(add_ovf)\n    );\n\n    // Subtraction\n    subtsb subu(\n        .a(a),\n        .b(b),\n        .r(sub_out),\n        .carry(sub_carry),\n        .neg(sub_neg),\n        .ovf(sub_ovf)\n    );\n\n    // Logical operations\n    and andu(\n        .a(a),\n        .b(b),\n        .r(and_out),\n        .carry(and_carry),\n        .neg(and_neg),\n        .ovf(and_ovf)\n    );\n\n    or oru(\n        .a(a),\n        .b(b),\n        .r(or_out),\n        .carry(or_carry),\n        .neg(or_neg),\n        .ovf(or_ovf)\n    );\n\n    xor xoru(\n        .a(a),\n        .b(b),\n        .r(xor_out),\n        .carry(xor_carry),\n        .neg(xor_neg),\n        .ovf(xor_ovf)\n    );\n\n    nor noru(\n        .a(a),\n        .b(b),\n        .r(nor_out),\n        .carry(nor_carry),\n        .neg(nor_neg),\n        .ovf(nor_ovf)\n    );\n\n    // Shift operations\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_out),\n        .carry(sllv_carry),\n        .neg(sllv_neg),\n        .ovf(sllv_ovf)\n    );\n\n    srlv srlv_inst(\n        .a(a),\n        .b"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] pc;\n  wire [31:0] alu_res;\n\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .alu_res(alu_res)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .alu_op(alu_op),\n    .alu_src1(alu_src1),\n    .alu_src2(alu_src2),\n    .alu_dst(alu_dst)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .alu_op(alu_op),\n    .alu_src1(alu_src1),\n    .alu_src2(alu_src2),\n    .alu_dst(alu_dst),\n    .alu_res_mem(alu_res_mem)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .alu_res_mem(alu_res_mem),\n    .alu_dst(alu_dst),\n    .res_reg_file(res_reg_file)\n  );\n\n  reg [31:0] pc_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc;\n  end\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] pc_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc_reg + 1;\n  end\n  assign pc = pc_reg;\n  assign instr = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] alu_res,\n  output [5:0] alu_op,\n  output [4:0] alu_src1,\n  output [4:0] alu_src2,\n  output [4:0] alu_dst\n);\n  reg [5:0] op_reg;\n  reg [4:0] src1_reg, src2_reg, dst_reg;\n  reg [31:0] res_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op_reg <= 0;\n      src1_reg <= 0;\n      src2_reg <= 0;\n      dst_reg <= 0;\n      res_reg <= 0;\n    end else begin\n      op_reg <= instr_mem[pc][31:27];\n      src1_reg <= instr_mem[pc][26:22];\n      src2_reg <= instr_mem[pc][21:17];\n      dst_reg <= instr_mem[pc][16:"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the submodule for state initialization\n    ring_counter_init init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the submodule for state transition\n    ring_counter_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Assign the output\n    assign out = transition_out;\n\nendmodule\n\n// Submodule for state initialization\nmodule ring_counter_init (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @ (posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\n// Submodule for state transition\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] transition_out\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= init_out;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_complement;\n    wire [7:0] B_out_wire;\n\n    assign B_complement = ~B;\n\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_complement),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    assign B_out = B_out_wire[7];\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] carry;\n\n    full_adder fa0 (.A(A[0]), .B(B[0]), .Cin(carry[0]), .Sum(D[0]), .Cout(carry[1]));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .Cin(carry[1]), .Sum(D[1]), .Cout(carry[2]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .Cin(carry[2]), .Sum(D[2]), .Cout(carry[3]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .Cin(carry[3]), .Sum(D[3]), .Cout(carry[4]));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .Cin(carry[4]), .Sum(D[4]), .Cout(carry[5]));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .Cin(carry[5]), .Sum(D[5]), .Cout(carry[6]));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .Cin(carry[6]), .Sum(D[6]), .Cout(carry[7]));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .Cin(carry[7]), .Sum(D[7]), .Cout(B_out));\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "counter_12", "response": "module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count_out;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instantiate the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out, S2_out;\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B_out)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] A_neg, B_neg;\n    wire [15:0] A_B_diff;\n    wire [15:0] A_B_diff_neg;\n    wire [15:0] borrow;\n\n    assign A_neg = ~A + 1;\n    assign B_neg = ~B + 1;\n\n    assign A_B_diff = A_neg + B;\n    assign A_B_diff_neg = A + B_neg;\n\n    assign Diff = A_B_diff_neg;\n    assign B_out = (A_B_diff[15] == 0) ? 0 : 1;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, slt_out, sltu_out, sll_out, srl_out, sra_out, sllv_out, srlv_out, srav_out, lui_out;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    add addu (\n        .a(a),\n        .b(b),\n        .r(add_out),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n\n    sub subu (\n        .a(a),\n        .b(b),\n        .r(sub_out),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n\n    and andu (\n        .a(a),\n        .b(b),\n        .r(and_out),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow),\n        .flag(and_flag)\n    );\n\n    or oru (\n        .a(a),\n        .b(b),\n        .r(or_out),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow),\n        .flag(or_flag)\n    );\n\n    xor xoru (\n        .a(a),\n        .b(b),\n        .r(xor_out),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow),\n        .flag(xor_flag)\n    );\n\n    nor noru (\n        .a(a),\n        .b(b),\n        .r(nor_out),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow),\n        .flag(nor_flag)\n    );\n\n    slt sltu (\n        .a(a),\n        .b(b),\n        .r(slt_out),\n        .carry(slt_carry),\n        .negative(slt_negative),\n        .overflow(slt_overflow),\n    );\n\n    sll sllu (\n        .a(a),\n        .b(b),\n        .r(s"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] pc;\n  wire [31:0] alu_res;\n\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr_mem[pc]),\n    .rs1(pc),\n    .rs2(pc),\n    .rd(pc),\n    .op(pc)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .reg_file(reg_file),\n    .alu_res(alu_res)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_mem(alu_res)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[19:15];\n      rs2 <= instr[24:20];\n      rd <= instr[11:7];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_res <= 0;\n    else begin\n      case (op)\n        6'b00000: alu_res <= reg_file[rs1] + reg_file[rs2];\n        6'b000010: alu_res <= reg_file[rs1] - reg_file[rs2];\n        default: alu_res <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output reg ["}
{"task_id": "counter_12", "response": "module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count_out;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instantiate the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nwire [63:0] mult_result;\nreg [31:0] current_value;\n\n// Instantiating the multiplier submodule\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator submodule\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .result(mult_result[31:0]),\n    .current_value(current_value)\n);\n\n// Connecting the outputs\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n\nassign result = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + result;\n    end\nend\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nwire [63:0] mult_result;\nreg [31:0] current_value;\n\n// Instantiating the multiplier submodule\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator submodule\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .result(mult_result),\n    .current_value(current_value)\n);\n\n// Connecting the outputs\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n\nassign result = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + result[31:0];\n    end\nend\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  wire [31:0] c1_out, c2_out, c3_out;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n  \n  pe pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  pe pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_out)\n  );\n  \n  pe pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2_out)\n  );\n  \n  pe pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3_out)\n  );\n  \n  assign c1 = c1_out;\n  assign c2 = c2_out;\n  assign c3 = c3_out;\n  \nendmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 32'b0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "JC_counter", "response": "module for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Output the current state of the counter\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]       Q,\n    output reg [63:0]  next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], ~Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out;\n    wire S1_borrow;\n    wire [15:0] S2_out;\n    wire S2_borrow;\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(S1_borrow)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(S2_borrow)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = S2_borrow | S1_borrow;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1_out;\n    wire S1_borrow;\n    wire [7:0] S2_out;\n    wire S2_borrow;\n\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(S1_borrow)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2_out),\n        .B_out(S2_borrow)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = S2_borrow | S1_borrow;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1_out;\n    wire S1_borrow;\n    wire [3:0] S2_out;\n    wire S2_borrow;\n\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(S1_borrow)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2_out),\n        .B_out(S2_borrow)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = S2_borrow | S1_borrow;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1_out;\n    wire S1_borrow;\n    wire [1:0] S2_out;\n    wire S2_borrow;\n\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(S1_borrow)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2_out),\n        .B_out(S2_borrow)\n    );\n\n    assign Diff = {S2_"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  wire [31:0] c0_out, c1_out, c2_out, c3_out;\n  \n  PE pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0_out)\n  );\n  \n  PE pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1_out)\n  );\n  \n  PE pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2_out)\n  );\n  \n  PE pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3_out)\n  );\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n  \n  assign c0 = c0_out;\n  assign c1 = c1_out;\n  assign c2 = c2_out;\n  assign c3 = c3_out;\n  \nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "JC_counter", "response": "module for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Assign the output\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]       Q,\n    output reg [63:0]  next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], ~Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instruction register for fetching from RAM/ROM\n    reg [7:0] ins_ram;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_ram <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_ram <= data;\n        end\n    end\n\n    // Instruction register for fetching from register\n    reg [7:0] ins_reg;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_reg <= data;\n        end\n    end\n\n    // Instruction register for fetching from RAM/ROM\n    reg [7:0] ins_rom;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_rom <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_rom <= data;\n        end\n    end\n\n    // Instruction register for fetching from register\n    reg [7:0] ins_reg2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg2 <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_reg2 <= data;\n        end\n    end\n\n    // Instruction register for fetching from RAM/ROM\n    reg [7:0] ins_ram2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_ram2 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_ram2 <= data;\n        end\n    end\n\n    // Instruction register for fetching from register\n    reg [7:0] ins_reg3;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg3 <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_reg3 <= data;\n        end\n    end\n\n    // Instruction register for fetching from RAM/ROM\n    reg [7:0] ins_rom2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_rom2 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_rom2 <= data;\n        end\n    end\n\n    // Instruction register for fetching from register\n    reg [7:0] ins_reg4;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg4 <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_reg4 <= data;\n        end\n    end\n\n    // Instruction register for fetching from RAM/ROM\n    reg [7:0] ins_ram3;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_ram3 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_ram3 <= data;\n        end\n    end\n\n    // Instruction register for fetching from register\n    reg [7:0] ins_reg5;\n    always @(posedge clk or negedge rst) begin\n        if"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == 3) begin\n                CLK_out <= ~CLK_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] A_low, A_high, B_low, B_high;\n    wire [15:0] A_low_low, A_low_high, B_low_low, B_low_high;\n    wire [7:0] A_low_low_low, A_low_low_high, B_low_low_low, B_low_low_high;\n    wire [31:0] D_low, D_high;\n    wire B_out_low, B_out_high;\n\n    // Instantiate the 32-bit subtractor module for A and B\n    sub32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Instantiate the 16-bit subtractor module for A_low and B_low\n    sub16bit sub2(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub16bit sub3(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Instantiate the 8-bit subtractor module for A_low_low and B_low_low\n    sub8bit sub4(\n        .A(A_low_low),\n        .B(B_low_low),\n        .D(D_low_low),\n        .B_out(B_out_low)\n    );\n\n    sub8bit sub5(\n        .A(A_low_high),\n        .B(B_low_high),\n        .D(D_low_high),\n        .B_out(B_out_high)\n    );\n\n    // Instantiate the 4-bit subtractor module for A_low_low_low and B_low_low_low\n    sub4bit sub6(\n        .A(A_low_low_low),\n        .B(B_low_low_low),\n        .D(D_low_low_low),\n        .B_out(B_out_low)\n    );\n\n    sub4bit sub7(\n        .A(A_low_low_high),\n        .B(B_low_low_high),\n        .D(D_low_low_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign the outputs\n    assign D = {D_high, D_low};\n    assign B_out = B_out_high | B_out_low;\n\nendmodule\n\nmodule sub32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] A_low, A_high, B_low, B_high;\n    wire [7:0] A_low_low, A_low_high, B_low_low, B_low_high;\n    wire [31:0] D_low, D_high;\n    wire B_out_low, B_out_high;\n\n    // Instantiate the 16-bit subtractor module for A and B\n    sub16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub16bit sub1(\n        .A("}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\nwire [4:0] rd;\nwire [4:0] rs1, rs2;\nwire [5:0] funct;\nwire [5:0] opcode;\n\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .fetched_instr(fetched_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .reg_file(reg_file),\n    .op1(op1),\n    .op2(op2),\n    .result(result),\n    .rd(rd),\n    .rs1(rs1),\n    .rs2(rs2),\n    .funct(funct),\n    .opcode(opcode)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result(result),\n    .rd(rd),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetched_instr <= 32'b0;\n        end else begin\n            fetched_instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [5:0] rs2,\n    output reg [5:0] funct,\n    output reg [5:0] opcode\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 32'b0;\n            op2 <= 32'b0;\n            result <= 32'b0;\n            rd <= 5'b0;\n            rs1 <= 5'b0;\n            rs2 <= 5'b0;\n            funct <= 6'b0;\n            opcode <= 6'b0;\n        end else begin\n            op1 <= reg_file[rs1];\n            op2 <= reg_file[rs2];\n            funct <= fetched_instr[5:0];\n            opcode <= fetched_instr[31:26];\n            case (opcode)\n                6'b000000: result <= op1 + op2;\n                6'b000010: result <= op1 - op2;\n                default: result <= 32'b0;\n            endcase\n            rd <= fetched_instr[10:6];\n            rs1 <= fetched_instr[25:21];\n            rs2 <= fetched_instr[20:16];\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else if (counter == 2) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instruction register for first source\n    reg [2:0] ins_p1;\n    reg [4:0] ad1_p1;\n    reg [7:0] ad2_p1;\n\n    // Instruction register for second source\n    reg [2:0] ins_p2;\n    reg [4:0] ad1_p2;\n    reg [7:0] ad2_p2;\n\n    // Instruction register for third source\n    reg [2:0] ins_p3;\n    reg [4:0] ad1_p3;\n    reg [7:0] ad2_p3;\n\n    // Instruction register for fourth source\n    reg [2:0] ins_p4;\n    reg [4:0] ad1_p4;\n    reg [7:0] ad2_p4;\n\n    // Instruction register for fifth source\n    reg [2:0] ins_p5;\n    reg [4:0] ad1_p5;\n    reg [7:0] ad2_p5;\n\n    // Instruction register for sixth source\n    reg [2:0] ins_p6;\n    reg [4:0] ad1_p6;\n    reg [7:0] ad2_p6;\n\n    // Instruction register for seventh source\n    reg [2:0] ins_p7;\n    reg [4:0] ad1_p7;\n    reg [7:0] ad2_p7;\n\n    // Instruction register for eighth source\n    reg [2:0] ins_p8;\n    reg [4:0] ad1_p8;\n    reg [7:0] ad2_p8;\n\n    // Instruction register for ninth source\n    reg [2:0] ins_p9;\n    reg [4:0] ad1_p9;\n    reg [7:0] ad2_p9;\n\n    // Instruction register for tenth source\n    reg [2:0] ins_p10;\n    reg [4:0] ad1_p10;\n    reg [7:0] ad2_p10;\n\n    // Instruction register for eleventh source\n    reg [2:0] ins_p11;\n    reg [4:0] ad1_p11;\n    reg [7:0] ad2_p11;\n\n    // Instruction register for twelfth source\n    reg [2:0] ins_p12;\n    reg [4:0] ad1_p12;\n    reg [7:0] ad2_p12;\n\n    // Instruction register for thirteenth source\n    reg [2:0] ins_p13;\n    reg [4:0] ad1_p13;\n    reg [7:0] ad2_p13;\n\n    // Instruction register for fourteenth source\n    reg [2:0] ins_p14;\n    reg [4:0] ad1_p14;\n    reg [7:0] ad2_p14;\n\n    // Instruction register for fifteenth source\n    reg [2:0] ins_p15;\n    reg [4:0] ad1_p15;\n    reg [7:0] ad2_p15;\n\n    // Instruction register for sixteenth source\n    reg [2:0] ins_p16;\n    reg [4:0] ad1_p16;\n    reg [7:0] ad2_p16;\n\n    // Instruction register for seventeenth source\n    reg [2:0] ins_p17;\n    reg [4:"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] A_low, A_high, B_low, B_high;\n    wire [7:0] A_low_low, A_low_high, B_low_low, B_low_high;\n    wire [7:0] A_high_low, A_high_high, B_high_low, B_high_high;\n    wire [3:0] B_out_low, B_out_high;\n\n    assign A_low = A[15:0];\n    assign A_high = A[31:16];\n    assign B_low = B[15:0];\n    assign B_high = B[31:16];\n\n    assign A_low_low = A_low[7:0];\n    assign A_low_high = A_low[15:8];\n    assign B_low_low = B_low[7:0];\n    assign B_low_high = B_low[15:8];\n    assign A_high_low = A_high[7:0];\n    assign A_high_high = A_high[15:8];\n    assign B_high_low = B_high[7:0];\n    assign B_high_high = B_high[15:8];\n\n    sub_16bit sub0 (\n        .A(A_low),\n        .B(B_low),\n        .D(D[15:0]),\n        .B_out(B_out_low)\n    );\n\n    sub_16bit sub1 (\n        .A(A_high),\n        .B(B_high),\n        .D(D[31:16]),\n        .B_out(B_out_high)\n    );\n\n    sub_8bit sub2 (\n        .A(A_low_low),\n        .B(B_low_low),\n        .D(D[7:0]),\n        .B_out(B_out_low[0])\n    );\n\n    sub_8bit sub3 (\n        .A(A_low_high),\n        .B(B_low_high),\n        .D(D[15:8]),\n        .B_out(B_out_low[1])\n    );\n\n    sub_8bit sub4 (\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D[23:16]),\n        .B_out(B_out_high[0])\n    );\n\n    sub_8bit sub5 (\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D[31:24]),\n        .B_out(B_out_high[1])\n    );\n\n    assign B_out = B_out_low[0] & B_out_low[1] & B_out_high[0] & B_out_high[1];\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] A_low, A_high, B_low, B_high;\n    wire [3:0] B_out_low, B_out_high;\n\n    assign A_low = A[7:0];\n    assign A_high = A[15:8];\n    assign B_low = B[7:0];\n    assign B_high = B[15:8];\n\n    sub_8bit sub0 (\n        .A(A_low),\n        .B(B_low),\n        .D(D[7:0]),\n        .B_out(B_out_low[0])\n    );\n\n    sub_8bit sub1 (\n        .A(A_low),\n        .B(B_high),"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out <= ~wave_out;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\n\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31:28]),\n    .fetched_instr(fetched_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .op1(reg_file[fetched_instr[25:21]]),\n    .op2(reg_file[fetched_instr[20:16]]),\n    .result(result)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result(result),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            fetched_instr <= 32'b0;\n        else\n            fetched_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            result <= 32'b0;\n        else begin\n            case(fetched_instr[5:0])\n                6'b000000: result <= op1 + op2;\n                6'b000010: result <= op1 - op2;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_reg_file <= 32'b0;\n        else\n            out_reg_file[fetched_instr[25:21]] <= result;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire clk_div_int;\n    wire clk_div_frac;\n\n    // Counter submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    // Clock average generator submodule\n    clk_average u_clk_average (\n        .clk(clk_div_int),\n        .clk_div(clk_div_frac)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_div(clk_div_frac),\n        .clk_div_int(clk_div_int)\n    );\n\n    // Logical OR to generate final clock signal\n    assign clk_div = clk_div_int | clk_div_frac;\n\nendmodule\n\n// Counter submodule\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == MUL2_DIV_CLK) begin\n            count <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Clock average generator submodule\nmodule clk_average(\n    input               clk,\n    input               clk_div,\n    output reg          clk_div_frac\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (count == 2'b10) begin\n            clk_div_frac <= clk_div;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Clock adjustment submodule\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div,\n    input               clk_div_int,\n    output reg          clk_div_frac\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (count == 2'b10) begin\n            clk_div_frac <= clk_div_int;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\n// Counter module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\n// Data accumulator module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (count == 4)\n            data_out <= data_in + data_out;\n    end\n\nendmodule\n\n// Valid output module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Instantiate the state control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    // Instantiate the waveform generation module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] B_out_sub;\n\n    bls_sub4 sub1(A[1:0], B[1:0], D[1:0], B_out_sub[0]);\n    bls_sub4 sub2(A[3:2], B[3:2], D[3:2], B_out_sub[1]);\n    bls_sub4 sub3(A[5:4], B[5:4], D[5:4], B_out_sub[2]);\n    bls_sub4 sub4(A[7:6], B[7:6], D[7:6], B_out_sub[3]);\n\n    assign B_out = B_out_sub[0] & B_out_sub[1] & B_out_sub[2] & B_out_sub[3];\nendmodule\n\nmodule bls_sub4(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_sub;\n\n    bls_sub3 sub1(A[2:0], B[2:0], D[2:0], B_out_sub[0]);\n    bls_sub3 sub2(A[5:3], B[5:3], D[5:3], B_out_sub[1]);\n    bls_sub3 sub3(A[8:6], B[8:6], D[8:6], B_out_sub[2]);\n    bls_sub3 sub4(A[11:9], B[11:9], D[11:9], B_out_sub[3]);\n\n    assign B_out = B_out_sub[0] & B_out_sub[1] & B_out_sub[2] & B_out_sub[3];\nendmodule\n\nmodule bls_sub3(A, B, D, B_out);\n    input [2:0] A;\n    input [2:0] B;\n    output [2:0] D;\n    output B_out;\n\n    wire [2:0] B_out_sub;\n\n    bls_sub2 sub1(A[1:0], B[1:0], D[1:0], B_out_sub[0]);\n    bls_sub2 sub2(A[3:2], B[3:2], D[3:2], B_out_sub[1]);\n    bls_sub2 sub3(A[5:4], B[5:4], D[5:4], B_out_sub[2]);\n\n    assign B_out = B_out_sub[0] & B_out_sub[1] & B_out_sub[2];\nendmodule\n\nmodule bls_sub2(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_sub;\n\n    bls_sub1 sub1(A[0], B[0], D[0], B_out_sub[0]);\n    bls_sub1 sub2(A[1], B[1], D[1], B_out_sub[1]);\n\n    assign B_out = B_out_sub[0] & B_out_sub[1];\nendmodule\n\nmodule bls_sub1(A, B, D, B_out);\n    input A;\n    input B;\n    output D;\n    output B_out;\n\n    wire B_out_sub;\n\n    assign D = A ^ B;\n    assign B_out = (A & ~B) | (~A & B);\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj;\n\n    // Counter submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4)\n    );\n\n    // Clock average generator submodule\n    clk_average u_clk_average (\n        .clk(clk_4),\n        .clk_avg(clk_avg)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_avg(clk_avg),\n        .clk_adj(clk_adj)\n    );\n\n    // Logical OR of the two intermediate clock signals\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == MUL2_DIV_CLK - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    output reg clk_avg\n);\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (count == 2) begin\n            clk_avg <= 1;\n            count <= 0;\n        end else begin\n            clk_avg <= 0;\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_avg,\n    output reg clk_adj\n);\n    always @(posedge clk) begin\n        clk_adj <= clk_avg;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Instantiate the state control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    // Instantiate the waveform generation module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns/1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulated_data;\n\n    // Counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .count(count),\n        .accumulated_data(accumulated_data)\n    );\n\n    // Valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (valid_in && (count == 4))\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end else if (valid_in && (count == 4)) begin\n            valid_out <= 1;\n            data_out <= accumulated_data;\n        end else begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] borrow_out;\n\n    // Instantiate 4-bit BLS for A[3:0] and B[3:0]\n    BLS_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow_out[0])\n    );\n\n    // Instantiate 4-bit BLS for A[7:4] and B[7:4]\n    BLS_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow_out[1])\n    );\n\n    // Instantiate 4-bit BLS for A[11:8] and B[11:8]\n    BLS_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(borrow_out[2])\n    );\n\n    // Instantiate 4-bit BLS for A[15:12] and B[15:12]\n    BLS_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(borrow_out[3])\n    );\n\n    // Combine the borrow-out outputs from each 4-bit BLS block\n    assign B_out = borrow_out[0] | borrow_out[1] | borrow_out[2] | borrow_out[3];\nendmodule\n\nmodule BLS_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow_out;\n\n    // Subtract A and B\n    assign D = A - B;\n\n    // Determine borrow-out\n    assign B_out = (A[3] & ~B[3]) | (A[3] & B[3] & ~D[3]) | (~A[3] & B[3] & D[3]);\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] out0, out1, out2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(out0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(out0),\n        .q(out1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(out1),\n        .q(out2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= out0;\n            2'b10: q <= out1;\n            2'b11: q <= out2;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry;\n\n    // Subtraction module instantiation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result != 0) && (carry == 0);\n    assign A_equal = (sub_result == 0);\n    assign A_less = (sub_result == 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output carry\n);\n    assign {carry, sub_result} = A - B;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [2:0] delay;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(delay[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(delay[0]),\n        .q(delay[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(delay[1]),\n        .q(delay[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= delay[0];\n            2'b10: q <= delay[1];\n            2'b11: q <= delay[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry_out;\n\n    // Subtractor module instantiation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry_out(carry_out)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result != 0) && (carry_out == 0);\n    assign A_equal = (sub_result == 0);\n    assign A_less = (carry_out == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output carry_out\n);\n\n    assign {carry_out, sub_result} = A - B;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "response": "`timescale 1ns / 1ps\n\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [3:0] counter;\nwire [15:0] quotient;\nwire [7:0] remainder;\n\n// Absolute value calculation\nabs_value abs_dividend_inst (\n    .dividend(dividend),\n    .sign(sign),\n    .result(abs_dividend)\n);\n\n// Negative divisor calculation\nneg_value neg_divisor_inst (\n    .divisor(divisor),\n    .sign(sign),\n    .result(neg_divisor)\n);\n\n// Division control logic\ndivider_control ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Result management\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -dividend;\n        else\n            result = dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -divisor;\n        else\n            result = divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (opn_valid) begin\n            counter <= 4'd0;\n            shift_reg <= dividend;\n            quotient <= 16'd0;\n            remainder <= abs_dividend;\n        end else if (res_ready) begin\n            if (counter < 4'd7) begin\n                counter <= counter + 1;\n                shift_reg <= shift_reg >> 1;\n                quotient <= quotient << 1;\n                remainder <= remainder - (shift_reg & neg_divisor);\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] remainder,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'd0;\n            res_valid <= 1'b0;\n        end else if (res_ready) begin"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:0] S1,S2,S3,S4;\n    wire C1,C2,C3,C4;\n\n    CLA1 CLA1(.A(A[15:0]),.B(B[15:0]),.S(S1),.C(C1));\n    CLA1 CLA2(.A(A[31:16]),.B(B[31:16]),.S(S2),.C(C2));\n    CLA1 CLA3(.A(A[47:32]),.B(B[47:32]),.S(S3),.C(C3));\n    CLA1 CLA4(.A(A[63:48]),.B(B[63:48]),.S(S4),.C(C4));\n\n    assign S = {S4,S3,S2,S1};\n    assign C32 = C4;\nendmodule\n\nmodule CLA1(A,B,S,C);\n    input [15:0] A,B;\n    output [15:0] S;\n    output C;\n    wire [15:0] P,G;\n    assign P = A ^ B;\n    assign G = A & B;\n    assign S = P ^ {16{C}};\n    assign C = (P & G) | (P & ~G);\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    wire clk_div_en;\n\n    // Counter submodule\n    counter_modular u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    // Clock divider submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div)\n    );\n\n    assign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nendmodule\n\nmodule counter_modular(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == (NUM_DIV / 2 - 1)) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (clk_div_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out)\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted;\n    wire [7:0] mux2X1;\n\n    assign mux2X1 = {mux2X1[6:0], mux2X1[7]};\n\n    assign shifted = (ctrl[2] ? shifted << 4 :\n                    ctrl[1] ? shifted << 2 :\n                    ctrl[0] ? shifted << 1 : shifted);\n\n    assign out = (ctrl[2] ? mux2X1 :\n               ctrl[1] ? mux2X1 :\n               ctrl[0] ? mux2X1 :\n               in);\n\n    function [7:0] mux2X1 (input [7:0] a, input [7:0] b);\n        case (ctrl[2:0])\n            3'b000: return a;\n            3'b001: return b;\n            3'b010: return {b[6:0], b[7]};\n            3'b011: return {b[6:0], b[7]};\n            3'b100: return {b[5:0], b[6:0], b[7]};\n            3'b101: return {b[5:0], b[6:0], b[7]};\n            3'b110: return {b[4:0], b[5:0], b[6:0], b[7]};\n            3'b111: return {b[4:0], b[5:0], b[6:0], b[7]};\n        endcase\n    endfunction\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:0] S1,S2,S3;\n    wire C1,C2,C3;\n\n    CLA1 CLA1(.A(A[15:0]),.B(B[15:0]),.S(S1),.C(C1));\n    CLA1 CLA2(.A(A[31:16]),.B(B[31:16]),.S(S2),.C(C2));\n    CLA1 CLA3(.A(A[47:32]),.B(B[47:32]),.S(S3),.C(C3));\n\n    assign S = {S3,S2,S1};\n    assign C32 = C3;\nendmodule\n\nmodule CLA1(A,B,S,C);\n    input [15:0] A,B;\n    output [15:0] S;\n    output C;\n    wire [16:0] temp;\n\n    assign temp = A + B;\n    assign S = temp[15:0];\n    assign C = temp[16];\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    wire clk_div_en;\n\n    // Counter submodule\n    counter_4bit u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    // Clock divider submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div)\n    );\n\n    assign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nendmodule\n\n// Counter submodule\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == (NUM_DIV / 2 - 1)) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\n// Clock divider submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (clk_div_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "response": "`timescale 1ns / 1ps\n\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] quotient;\nwire [7:0] remainder;\n\n// Absolute value calculation\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(dividend),\n    .output(abs_dividend)\n);\n\n// Negative divisor calculation\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(divisor),\n    .output(neg_divisor)\n);\n\n// Division control logic\ndivider_control ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .abs_dividend(abs_dividend),\n    .neg_divisor(neg_divisor),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Result management\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else if (sign)\n        output <= -input;\n    else\n        output <= input;\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else if (sign)\n        output <= input;\n    else\n        output <= -input;\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n\nreg [7:0] counter;\nreg [7:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else if (opn_valid) begin\n        counter <= 0;\n        shift_reg <= abs_dividend;\n        quotient <= 0;\n        remainder <= shift_reg;\n    end else if (counter < 8) begin\n        counter <= counter + 1;\n        shift_reg <= shift_reg >> 1;\n        quotient <= quotient << 1;\n        remainder <= remainder - (shift_reg & neg_divisor);\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [7:0] quotient,\n    input wire [7:0] remainder,\n    output reg [15:"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out)\n{\n    wire [7:0] shifted;\n    wire [7:0] mux2X1_out;\n    wire [7:0] mux2X1_in;\n    wire [7:0] mux2X1_sel;\n\n    // Stage 1\n    assign mux2X1_in = in;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 2\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 3\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 4\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 5\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 6\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    // Stage 7\n    assign mux2X1_in = shifted;\n    assign mux2X1_sel = {ctrl[2], ctrl[1], ctrl[0]};\n    assign mux2X1_out = mux2X1(mux2X1_in, mux2X1_sel);\n    assign shifted = mux2X1_out;\n\n    assign out = shifted;\n\n    function [7:0] mux2X1;\n        input [7:0] in1;\n        input [7:0] in2;\n        input sel;\n        begin\n            if (sel)\n                return in2;\n            else\n                return in1;\n        end\n    endfunction\n\n    function [7:0] mux2X1mux;\n        input [7:0] in1;\n        input [7:0] in2;\n        input sel;\n        begin\n            return mux2X1(in1, sel) ^ mux2X1(in2, sel);\n        end\n    endfunction\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] csa_sum;\n    wire [3:0] csa_cout;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(csa_sum[0]),\n        .cout(csa_cout[0])\n    );\n\n    // Instantiate the first 4-bit carry select adder slice\n    carry_select_adder_slice csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(csa_cout[0]),\n        .sum(csa_sum[1]),\n        .cout(csa_cout[1])\n    );\n\n    // Instantiate the second 4-bit carry select adder slice\n    carry_select_adder_slice csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(csa_cout[1]),\n        .sum(csa_sum[2]),\n        .cout(csa_cout[2])\n    );\n\n    // Instantiate the third 4-bit carry select adder slice\n    carry_select_adder_slice csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(csa_cout[2]),\n        .sum(csa_sum[3]),\n        .cout(csa_cout[3])\n    );\n\n    // Assign the sum and carry-out\n    assign sum = {csa_sum[3], csa_sum[2], csa_sum[1], csa_sum[0]};\n    assign cout = csa_cout[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign sum = a + b + cin;\n    assign carry = (a & b) | (a & cin) | (b & cin);\n    assign cout = (a & b) | (cin & (a | b));\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] rca_sum;\n    wire [3:0] rca_cout;\n\n    ripple_carry_adder rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(rca_sum),\n        .cout(rca_cout)\n    );\n\n    assign sum = rca_sum;\n    assign cout = rca_cout;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n\n    // Instantiate the submodules\n    prep_dividend prep_op (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n    always @(*) begin\n        dividend = {A, 16'b0};\n        divisor = B;\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    integer i;\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = quotient << 1;\n                quotient = quotient | 1;\n            end else begin\n                quotient = quotient << 1;\n            end\n            remainder = remainder << 1;\n        end\n        result = quotient;\n        odd = remainder;\n    end\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] csa_out;\n    wire [3:0] csa_carry;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, csa_out[0], csa_carry[0]);\n\n    // Instantiate the 4-bit carry select adder slices\n    carry_select_adder_slice csa_slice1(a[7:4], b[7:4], csa_carry[0], csa_out[1], csa_carry[1]);\n    carry_select_adder_slice csa_slice2(a[11:8], b[11:8], csa_carry[1], csa_out[2], csa_carry[2]);\n    carry_select_adder_slice csa_slice3(a[15:12], b[15:12], csa_carry[2], csa_out[3], cout);\n\n    // Assign the output\n    assign sum = {csa_out[3], csa_out[2], csa_out[1], csa_out[0]};\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign {carry[0], sum[0]} = a[0] + b[0] + cin;\n    assign {carry[1], sum[1]} = a[1] + b[1] + carry[0];\n    assign {carry[2], sum[2]} = a[2] + b[2] + carry[1];\n    assign {carry[3], sum[3]} = a[3] + b[3] + carry[2];\n    assign cout = carry[3];\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder rca1(a, b, cin, sum[0], carry[0]);\n    ripple_carry_adder rca2(a, b, carry[0], sum[1], carry[1]);\n    ripple_carry_adder rca3(a, b, carry[1], sum[2], carry[2]);\n    ripple_carry_adder rca4(a, b, carry[2], sum[3], cout);\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n\n    // Instantiate the submodules\n    prep_dividend prep_op (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n\n    always @(*) begin\n        dividend = {A, 16'b0};\n        divisor = B;\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        result = 32'b0;\n        odd = 32'b0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                result = result << 1;\n                odd = odd << 1;\n                odd = odd | 1'b1;\n            end else begin\n                result = result << 1;\n                odd = odd << 1;\n            end\n\n            shifted_divisor = shifted_divisor << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] add8_out1, add8_out2;\n    wire carry_out1, carry_out2;\n\n    // Instantiate two 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(add8_out1),\n        .Co(carry_out1)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry_out1),\n        .y(add8_out2),\n        .Co(carry_out2)\n    );\n\n    // Output the sum and carry-out\n    assign y = {add8_out2, add8_out1};\n    assign Co = carry_out2;\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // Control unit module\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Control unit module\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [3:0] counter;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        counter = 0;\n        result = 0;\n        odd = 0;\n    end\n\n    // Division algorithm\n    always @(*) begin\n        if (dividend >= divisor) begin\n            result = result << 1;\n            dividend = dividend - divisor;\n            counter = counter + 1;\n        end\n    end\n\n    // Update quotient and remainder\n    always @(posedge counter) begin\n        odd = dividend;\n        result = result + 1;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // Control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (dividend >= divisor) begin\n            quotient = quotient + 1;\n            dividend = dividend - divisor;\n        end\n    end\n\n    // Update remainder\n    always @(*) begin\n        remainder = dividend;\n    end\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // Instantiate 8-bit adders\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    add8_inst1 add8_inst3 (\n        .a(y0),\n        .b(y1),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    add8_inst2 add8_inst4 (\n        .a(y2),\n        .b(y3),\n        .Cin(Co2),\n        .y(y4),\n        .Co(Co3)\n    );\n\n    add8_inst1 add8_inst5 (\n        .a(y4),\n        .b(y5),\n        .Cin(Co3),\n        .y(y6),\n        .Co(Co4)\n    );\n\n    add8_inst2 add8_inst6 (\n        .a(y6),\n        .b(y7),\n        .Cin(Co4),\n        .y(y7),\n        .Co(Co5)\n    );\n\n    // Output\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co5;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = {1'b0, a} + {1'b0, b} + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = {1'b0, a} + {1'b0, b} + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .cout(carry[0]), .sum(sum[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .cout(carry[1]), .sum(sum[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .cout(carry[2]), .sum(sum[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .cout(carry[3]), .sum(sum[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .cout(carry[4]), .sum(sum[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .cout(carry[5]), .sum(sum[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .cout(carry[6]), .sum(sum[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .cout(carry[7]), .sum(sum[7]));\n\n    assign cout = carry[7];\n\nendmodule\n\nmodule FA(input a, b, cin, output sum, output cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] fa_sum;\n    wire fa_cout;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(fa_sum[0]), .cout(fa_cout));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(fa_cout), .sum(fa_sum[1]), .cout(fa_cout));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(fa_cout), .sum(fa_sum[2]), .cout(fa_cout));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(fa_cout), .sum(fa_sum[3]), .cout(fa_cout));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(fa_cout), .sum(fa_sum[4]), .cout(fa_cout));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(fa_cout), .sum(fa_sum[5]), .cout(fa_cout));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(fa_cout), .sum(fa_sum[6]), .cout(fa_cout));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(fa_cout), .sum(fa_sum[7]), .cout(fa_cout));\n\n    assign sum = fa_sum;\n    assign cout = fa_cout;\n\nendmodule\n\nmodule full_adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "response": "`timescale 1ns / 1ps\n\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] shift_reg; // Shift register for the multiplier.\n    wire [31:0] product;   // Product register.\n    wire [15:0] shifted_bin; // Shifted multiplier.\n    wire [31:0] temp_product; // Temporary product register.\n\n    // Control Unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_reg(shift_reg)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .ain(ain),\n        .bin(bin),\n        .shift_reg(shift_reg),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = (shift_reg == 16'h0000);\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg done\n);\n\n    reg [15:0] shift_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 16'h0000;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 16'h0001;\n            done <= 0;\n        end else if (shift_count == 16'h0000) begin\n            done <= 1;\n        end else begin\n            shift_count <= shift_count - 1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] shift_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_reg <= 16'h0000;\n        end else if (start) begin\n            shift_reg <= bin;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [15:0] shift_reg,\n    output reg [31:0] product\n);\n\n    reg [31:0] temp_product;\n    reg [15:0] shifted_bin;\n\n    always @(posedge clk) begin\n        shifted_bin <= bin << shift_reg;\n        temp_product <= 0;\n        for (integer i = 0; i < 16; i = i + 1) begin\n            if (ain[i]) begin\n                temp_product <= temp_product + shifted_bin;\n            end\n            shifted_bin = shifted_bin << 1;\n        end\n        product <= temp_product;\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "`timescale 1ns / 1ps\n\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    reg [31:0] product; // Product register\n    reg [3:0] shift_count; // Shift count register\n    reg [15:0] a_reg, b_reg; // Registers for a and b\n    reg done_reg; // Completion flag\n\n    // Control unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done_reg <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n            done_reg <= 0;\n            a_reg <= ain;\n            b_reg <= bin;\n        end else if (shift_count < 16) begin\n            shift_count <= shift_count + 1;\n            done_reg <= 0;\n        end else begin\n            done_reg <= 1;\n        end\n    end\n\n    // Register unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= 0;\n        end else begin\n            product <= product + (b_reg[shift_count] ? a_reg : 0);\n        end\n    end\n\n    // Multiplier unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n        end else if (shift_count < 16) begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\n    // Output assignment\n    assign yout = product;\n    assign done = done_reg;\n\nendmodule\n\nmodule shift_accumulator (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] shift_count,\n    output reg [31:0] product\n);\n\n    always @(posedge clk) begin\n        if (shift_count == 0) begin\n            product <= 0;\n        end else begin\n            product <= product + (b[shift_count] ? a : 0);\n        end\n    end\n\nendmodule"}
