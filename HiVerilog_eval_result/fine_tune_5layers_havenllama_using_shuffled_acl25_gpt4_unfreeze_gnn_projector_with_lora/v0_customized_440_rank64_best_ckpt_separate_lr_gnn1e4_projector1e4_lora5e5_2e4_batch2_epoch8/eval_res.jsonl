{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_neg = ~B;\n    assign D_temp = A + B_neg;\n    assign B_out_temp = A[7] & B[7];\n\n    assign D = D_temp;\n    assign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] B_carry;\n\n    assign B_neg = ~B;\n    assign B_carry = {1'b0, B};\n\n    full_adder_8bit adder_inst0(\n        .a(A),\n        .b(B_neg),\n        .carry_in(1'b0),\n        .sum(D),\n        .carry_out(B_out)\n    );\n\n    full_adder_8bit adder_inst1(\n        .a(A),\n        .b(B_carry),\n        .carry_in(B_out),\n        .sum(D),\n        .carry_out(B_out)\n    );\n\nendmodule\n\nmodule full_adder_8bit(a, b, carry_in, sum, carry_out);\n    input [7:0] a;\n    input [7:0] b;\n    input carry_in;\n    output [7:0] sum;\n    output carry_out;\n\n    wire [7:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .carry_in(carry_in),\n        .sum(sum[0]),\n        .carry_out(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .carry_in(carry[0]),\n        .sum(sum[1]),\n        .carry_out(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .carry_in(carry[1]),\n        .sum(sum[2]),\n        .carry_out(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .carry_in(carry[2]),\n        .sum(sum[3]),\n        .carry_out(carry[3])\n    );\n\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .carry_in(carry[3]),\n        .sum(sum[4]),\n        .carry_out(carry[4])\n    );\n\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .carry_in(carry[4]),\n        .sum(sum[5]),\n        .carry_out(carry[5])\n    );\n\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .carry_in(carry[5]),\n        .sum(sum[6]),\n        .carry_out(carry[6])\n    );\n\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .carry_in(carry[6]),\n        .sum(sum[7]),\n        .carry_out(carry[7])\n    );\n\n    assign carry_out = carry[7];\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a;\n    input b;\n    input carry_in;\n    output sum;\n    output carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] B_carry;\n\n    assign B_neg = ~B + 1;\n    assign B_carry = {1'b0, B_neg};\n\n    assign D = A - B_carry;\n    assign B_out = (A[7] == B_carry[7]);\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_inverted;\n    wire [7:0] D_out;\n    wire B_out_internal;\n\n    assign B_inverted = ~B;\n    assign D_out = A - B_inverted;\n    assign B_out_internal = A[7] ^ B[7];\n\n    assign B_out = B_out_internal;\n    assign D = D_out;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] B_out_wire;\n\n    assign B_neg = ~B + 1;\n\n    // Instantiate the full adder module for each bit\n    full_adder fa0(A[0], B_neg[0], D[0], B_out_wire[0]);\n    full_adder fa1(A[1], B_neg[1], D[1], B_out_wire[1]);\n    full_adder fa2(A[2], B_neg[2], D[2], B_out_wire[2]);\n    full_adder fa3(A[3], B_neg[3], D[3], B_out_wire[3]);\n    full_adder fa4(A[4], B_neg[4], D[4], B_out_wire[4]);\n    full_adder fa5(A[5], B_neg[5], D[5], B_out_wire[5]);\n    full_adder fa6(A[6], B_neg[6], D[6], B_out_wire[6]);\n    full_adder fa7(A[7], B_neg[7], D[7], B_out_wire[7]);\n\n    // Output the borrow for the subtraction\n    assign B_out = B_out_wire[7];\n\nendmodule\n\nmodule full_adder(A, B, D, B_out);\n    input A;\n    input B;\n    output D;\n    output B_out;\n\n    assign D = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] B_carry;\n\n    assign B_neg = ~B + 1;\n    assign B_carry = {1'b0, B};\n\n    adder_8bit adder_inst1(\n        .a(A),\n        .b(B),\n        .c_in(1'b0),\n        .sum(D),\n        .c_out(B_out)\n    );\n\n    adder_8bit adder_inst2(\n        .a(A),\n        .b(B_neg),\n        .c_in(B_carry[7]),\n        .sum(D),\n        .c_out(B_out)\n    );\n\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, c_out);\n    input [7:0] a;\n    input [7:0] b;\n    input c_in;\n    output [7:0] sum;\n    output c_out;\n\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_neg = ~B + 1;\n\n    full_adder adder_inst1(A[0], B_neg[0], B_out_temp);\n    full_adder adder_inst2(A[1], B_neg[1], D_temp[1], B_out_temp);\n    full_adder adder_inst3(A[2], B_neg[2], D_temp[2], B_out_temp);\n    full_adder adder_inst4(A[3], B_neg[3], D_temp[3], B_out_temp);\n    full_adder adder_inst5(A[4], B_neg[4], D_temp[4], B_out_temp);\n    full_adder adder_inst6(A[5], B_neg[5], D_temp[5], B_out_temp);\n    full_adder adder_inst7(A[6], B_neg[6], D_temp[6], B_out_temp);\n    full_adder adder_inst8(A[7], B_neg[7], D, B_out);\n\nendmodule\n\nmodule full_adder(A, B, C_out, C_in);\n    input A, B;\n    output C_out, C_in;\n\n    assign C_out = A ^ B;\n    assign C_in = A & B;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] B_out_wire;\n\n    assign B_neg = ~B;\n\n    full_adder fa0(A[0], B_neg[0], 1'b0, D[0], B_out_wire[0]);\n    full_adder fa1(A[1], B_neg[1], B_out_wire[0], D[1], B_out_wire[1]);\n    full_adder fa2(A[2], B_neg[2], B_out_wire[1], D[2], B_out_wire[2]);\n    full_adder fa3(A[3], B_neg[3], B_out_wire[2], D[3], B_out_wire[3]);\n    full_adder fa4(A[4], B_neg[4], B_out_wire[3], D[4], B_out_wire[4]);\n    full_adder fa5(A[5], B_neg[5], B_out_wire[4], D[5], B_out_wire[5]);\n    full_adder fa6(A[6], B_neg[6], B_out_wire[5], D[6], B_out_wire[6]);\n    full_adder fa7(A[7], B_neg[7], B_out_wire[6], D[7], B_out);\n\nendmodule\n\nmodule full_adder(a, b, c_in, d_out, c_out);\n    input a, b, c_in;\n    output d_out, c_out;\n\n    assign d_out = a ^ b ^ c_in;\n    assign c_out = (a & b) | (c_in & (a ^ b));\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  assign b1 = (rst) ? 0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  assign p = a * b;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_inv;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_inv = ~B;\n    assign D_temp = A + B_inv;\n    assign B_out_temp = (A[7] & ~B[7]) | (A[7] & B[7]) | (~A[7] & B[7]);\n\n    assign D = D_temp;\n    assign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  assign b1 = rst ? 16'h0000 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] product;\n\n  always @(posedge clk) begin\n    product <= a * b;\n  end\n\n  assign p = product;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_not;\n    wire [7:0] A_not;\n    wire [7:0] A_and_B;\n    wire [7:0] A_xor_B;\n    wire [7:0] A_xor_B_not;\n    wire [7:0] A_and_B_not;\n    wire [7:0] A_and_B_not_xor_B;\n    wire [7:0] A_and_B_not_xor_B_not;\n\n    assign B_not = ~B;\n    assign A_not = ~A;\n    assign A_and_B = A & B;\n    assign A_xor_B = A ^ B;\n    assign A_xor_B_not = A_xor_B;\n    assign A_and_B_not = A & B_not;\n    assign A_and_B_not_xor_B = A_and_B_not ^ B;\n    assign A_and_B_not_xor_B_not = A_and_B_not ^ B_not;\n\n    assign D = A_and_B_not_xor_B_not;\n    assign B_out = A_and_B[0] | (A_and_B[1] & A_and_B_not[1]) | (A_and_B[2] & A_and_B_not[2]) | (A_and_B[3] & A_and_B_not[3]) | (A_and_B[4] & A_and_B_not[4]) | (A_and_B[5] & A_and_B_not[5]) | (A_and_B[6] & A_and_B_not[6]) | (A_and_B[7] & A_and_B_not[7]);\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_module add_sub_module (\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    sub_module sub_module (\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .borrow(carry)\n    );\n    and_module and_module (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    or_module or_module (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    xor_module xor_module (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    nor_module nor_module (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    slt_module slt_module (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    sltu_module sltu_module (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    sll_module sll_module (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    srl_module srl_module (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    srav_module srav_module (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    lui_module lui_module (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                  (aluc == 6'b100001) ? sub_result :\n                  (aluc == 6'b100100) ? and_result :\n                  (aluc == 6'b100101) ? or_result :\n                  (aluc == 6'b100110) ? xor_result :\n                  (aluc == 6'b100111) ? nor_result :\n                  (aluc == 6'b101010) ? slt_result :\n                  (aluc == 6'b101011) ? sltu_result :\n                  (aluc == 6'b000000) ? sll_result :\n                  (aluc == 6'b000010) ? srl_result :\n                  (aluc == 6'b0000110) ? srav_result :\n                  (aluc == 6'b000111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (aluc == 6'b10000) ? 1 : 0;\n    assign negative = (r[31] ^ r[30] ^ r[31]);\n    assign overflow = (aluc == 6'b10000) ? (r[31] ^ a[31] ^ b[31]) : 0;\n    assign flag = (aluc == 6'b101010) ? (r[31] : 0"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down),\n        .current_count(count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? current_count + 1 : current_count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 0;\n        else\n            current_count <= next_count;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_neg = ~B + 1;\n    assign D_temp = A + B_neg;\n    assign B_out_temp = (A < B) ? 1 : 0;\n\n    assign D = D_temp;\n    assign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed output of the second PE\n  assign b1 = (rst) ? 16'h0000 : b0;\n\n  // Output of the systolic array\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 32'h00000000;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down),\n        .current_count(count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? current_count + 1 : current_count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 0;\n        else\n            current_count <= next_count;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_inv;\n    wire [7:0] B_out_wire;\n\n    assign B_inv = ~B;\n    assign B_out = B_out_wire[7];\n\n    full_adder_8bit adder_inst1(\n        .a(A),\n        .b(B),\n        .cin(1'b0),\n        .cout(B_out_wire[0]),\n        .sum(D[0])\n    );\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin : adder_loop\n            full_adder_8bit adder_inst(\n                .a(A[i-1]),\n                .b(B[i-1]),\n                .cin(B_out_wire[i-1]),\n                .cout(B_out_wire[i]),\n                .sum(D[i])\n            );\n        end\n    endgenerate\nendmodule\n\nmodule full_adder_8bit(a, b, cin, cout, sum);\n    input a, b, cin;\n    output cout, sum;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  assign b1 = rst ? 16'h0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] p_reg;\n\n  always @(posedge clk) begin\n    p_reg <= a * b;\n  end\n\n  assign p = p_reg;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_neg = ~B + 1;\n    assign D_temp = A + B_neg;\n    assign B_out_temp = (A < B) ? 1 : 0;\n\n    assign D = D_temp;\n    assign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_inverted;\n    wire [7:0] B_neg;\n    wire [7:0] B_neg_inverted;\n\n    assign B_inverted = ~B;\n    assign B_neg = ~B_inverted + 1;\n    assign B_neg_inverted = ~B_neg;\n\n    assign D = A + B_neg_inverted;\n    assign B_out = (A[7] & B_neg[7]) | (A[7] & B_neg[7]) | (A[7] & B_neg[7]) | (A[7] & B_neg[7]);\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  // First PE\n  pe0 pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  // Second PE\n  pe1 pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  // Delayed input for second PE\n  assign b1 = (rst) ? 16'h0 : b0;\n\n  // Outputs\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule pe0 (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  assign p = a * b;\nendmodule\n\nmodule pe1 (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  assign p = a * b;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    and_or_xor_nor and_or_xor_module(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    sll_srl_sra_sltu_sltu_slt_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_sltu_slt"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_neg;\n    wire [7:0] D_temp;\n    wire B_out_temp;\n\n    assign B_neg = ~B + 1;\n    assign D_temp = A + B_neg;\n    assign B_out_temp = (A < B) ? 1'b1 : 1'b0;\n\n    assign D = D_temp;\n    assign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  assign b1 = rst ? 16'h0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] p_reg;\n\n  always @(posedge clk) begin\n    p_reg <= a * b;\n  end\n\n  assign p = p_reg;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ns\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n  wire [31:0] b0_reg;\n\n  reg [31:0] b0_reg_next;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b0_reg_next <= 0;\n    else\n      b0_reg_next <= b0;\n  end\n\n  assign b1 = b0_reg;\n  assign b0 = b0_reg_next;\n\n  pe pe0 (\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  pe pe1 (\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count_in(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count_in,\n    output reg [15:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count_out <= 0;\n        else\n            count_out <= count_in;\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    // AND\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    // OR\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    // XOR\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    // NOR\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    // SLT\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    // SLTU\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    // SLL\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    // SRL\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    // SRA\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    // LUI\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b000111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (r[32] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] == a[31] && r[31] != b[31]);\n    assign flag = (aluc == 6'b101010) ? (a[31] < b[31] :"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_high, A_low;\n    wire [15:0] B_high, B_low;\n    wire [15:0] diff_high, diff_low;\n\n    assign A_high = A[31:16];\n    assign A_low = A[15:0];\n    assign B_high = B[31:16];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_high),\n        .B(B_high),\n        .Diff(diff_high),\n        .B_out(B_out[31:16])\n    );\n\n    sub_16bit S2(\n        .A(A_low),\n        .B(B_low),\n        .Diff(diff_low),\n        .B_out(B_out[15:0])\n    );\n\n    assign Diff = {diff_high, diff_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] diff_high, diff_low;\n\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(diff_high),\n        .B_out(B_out[15:8])\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(diff_low),\n        .B_out(B_out[7:0])\n    );\n\n    assign Diff = {diff_high, diff_low};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] diff_high, diff_low;\n\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(diff_high),\n        .B_out(B_out[7:4])\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(diff_low),\n        .B_out(B_out[3:0])\n    );\n\n    assign Diff = {diff_high, diff_low};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] diff_high, diff_low;\n\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(diff_high),\n        .B_out(B_out[3:2])\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(diff_low),\n        .B_out(B_out[1:0])\n    );\n\n    assign Diff = {diff_high, diff_low};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ns\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Assign b1 on the rising edge of clk\n  always @(posedge clk) begin\n    if (!rst) begin\n      b1 <= 16'b0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n\n  always @(posedge clk) begin\n    if (!rst) begin\n      product <= 32'b0;\n    end else begin\n      product <= a * b;\n    end\n  end\n\n  assign c = product;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, A_high;\n    wire [15:0] B_low, B_high;\n    wire [15:0] Diff_low, Diff_high;\n\n    assign A_low = A[15:0];\n    assign A_high = A[31:16];\n    assign B_low = B[15:0];\n    assign B_high = B[31:16];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit S2(\n        .A(A_high),\n        .B(B_high),\n        .Diff(Diff_high),\n        .B_out(B_out[31:16])\n    );\n\n    assign Diff = {Diff_high, Diff_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] borrow;\n\n    assign Diff = A - B;\n    assign B_out = A - B - borrow;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed input for second PE\n  assign b1 = (rst) ? 16'h0000 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  reg [31:0] accumulator;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 32'h00000000;\n      accumulator <= 32'h00000000;\n    end else begin\n      product <= a * b;\n      accumulator <= accumulator + product;\n    end\n  end\n\n  assign c = accumulator;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, A_high, B_low, B_high;\n    wire [15:0] diff_low, diff_high;\n\n    assign A_low = A[15:0];\n    assign A_high = A[31:16];\n    assign B_low = B[15:0];\n    assign B_high = B[31:16];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(diff_low),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit S2(\n        .A(A_high),\n        .B(B_high),\n        .Diff(diff_high),\n        .B_out(B_out[31:16])\n    );\n\n    assign Diff = {diff_high, diff_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] diff;\n\n    assign diff = A - B;\n    assign B_out = B;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    reg [15:0] current_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 0;\n        else if (up_down)\n            current_count <= current_count + 1;\n        else\n            current_count <= current_count - 1;\n    end\n\n    assign count = current_count;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count_out <= 0;\n        else\n            count_out <= count;\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .borrow(carry)\n    );\n    and_or_xor_nor and_or_submodule(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    sll_srl_sra_sltu sll_srl_sltu_submodule(\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    lui_submodule lui_submodule(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100010) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (aluc == 6'b100000) ? carry :\n                 (aluc == 6'b100001) ? carry :\n                 (aluc == 6'b10010) ? carry :\n                 (aluc == 6'b100101) ? carry :\n                 (aluc == 6'b100110) ? carry :\n                 (aluc == 6'b100111) ? carry :\n                 (aluc == 6'b101010) ? carry :\n                 (aluc == 6'b101011) ? carry :\n                 (aluc == 6'b00000) ? carry :\n                 (aluc == 6'b00001) ? carry :\n                 (aluc == 6'b00010) ? carry :\n                 (aluc == 6'b00011) ? carry :\n                 (aluc == 6'b001111) ? carry : 0;\n\n    assign negative = (r[31] ^ r[30] ^ r[31:1]);\n    assign overflow = (aluc == 6'b100000) ? (r[31] ^ a[31] ^ b[31]) :\n                 (aluc == 6'b1000001) ? (r[31] ^ a[31] ^ b[31]) :\n                 (aluc"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n  wire [31:0] b0_delayed;\n\n  // Instantiate the first PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Instantiate the second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delay the input b0 by one clock cycle\n  always @(posedge clk) begin\n    if (!rst)\n      b0_delayed <= 32'b0;\n    else\n      b0_delayed <= b0;\n  end\n\n  // Update b1 on the rising edge of the clock\n  always @(posedge clk) begin\n    if (!rst)\n      b1 <= 16'b0;\n    else\n      b1 <= b0;\n  end\n\n  // Connect outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[31:16] - B[31:16]};\n    assign B_out = {B_out_low, A[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n    wire [7:0] Diff_low;\n    wire [7:0] B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[15:8] - B[15:8]};\n    assign B_out = {B_out_low, A[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    assign Diff = A - B;\n    assign B_out = A;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Assign the output of the first PE to the second PE's input\n  assign b1 = b0;\n\n  // Assign the outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] temp;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      temp <= 0;\n    else\n      temp <= a * b;\n  end\n  assign c = temp;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  // First PE\n  pe0 pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  // Second PE\n  pe1 pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  // Delayed output of B0\n  assign b1 = (rst) ? 16'h0000 : b0;\n\n  // Outputs\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule pe0 (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  assign p = a * b;\nendmodule\n\nmodule pe1 (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] p_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      p_reg <= 32'h00000000;\n    else\n      p_reg <= p_reg + a * b;\n  end\n\n  assign p = p_reg;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst(\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    // Subtraction\n    sub_module sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    // AND\n    and_module and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    // OR\n    or_module or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    // XOR\n    xor_module xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    // NOR\n    nor_module nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    // SLT\n    slt_module slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    // SLTU\n    sltu_module sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    // SLL\n    sll_module sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    // SRL\n    srl_module srl_inst(\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    // SRA\n    srav_module srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    // LUI\n    lui_module lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b000111) ? lui_result : 32'b0;\n\n    assign zero = (r == 32'b0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] == 1 && (a[31] == b[31]) && (a[31] != r[31]);\n    assign flag = (aluc == 6'b10"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  // Second PE\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed output of B0\n  always @(posedge clk) begin\n    if (!rst)\n      b1 <= 16'b0;\n    else\n      b1 <= b0;\n  end\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] temp;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      temp <= 32'b0;\n    else\n      temp <= temp + (a * b);\n  end\n\n  assign c = temp;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[31:16]};\n    assign B_out = {B_out_low, B[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n    wire [7:0] Diff_low;\n    wire [7:0] B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[15:8]};\n    assign B_out = {B_out_low, B[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] A_low;\n    wire [3:0] B_low;\n    wire [3:0] Diff_low;\n    wire [3:0] B_out_low;\n\n    assign A_low = A[3:0];\n    assign B_low = B[3:0];\n\n    sub_4bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[7:4]};\n    assign B_out = {B_out_low, B[7:4]};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] A_low;\n    wire [1:0] B_low;\n    wire [1:0] Diff_low;\n    wire [1:0] B_out_low;\n\n    assign A_low = A[1:0];\n    assign B_low = B[1:0];\n\n    sub_2bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[3:2]};\n    assign B_out = {B_out_low, B[3:2]};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [31:0] b1;\n  assign b1 = rst ? 0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk) begin\n    product <= a * b;\n  end\n  assign c = product;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    // AND\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    // OR\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    // XOR\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    // NOR\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    // SLT\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    // SLTU\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    // SLL\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    // SRL\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    // SRA\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    // LUI\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1) ^ (r[30:0] != 0);\n    assign overflow = (r[31] == 0) && (a[31] == 1) && (b[31] == 0) && (r[30] == 1);"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[31:16] - B[31:16]};\n    assign B_out = {B_out_low, B[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n    wire [7:0] Diff_low;\n    wire [7:0] B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[15:8] - B[15:8]};\n    assign B_out = {B_out_low, B[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    assign Diff = A - B;\n    assign B_out = B;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  // First PE\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .p(p0)\n  );\n\n  // Second PE\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .p(p1)\n  );\n\n  // Assign b1\n  assign b1 = b0;\n\n  // Output\n  assign c0 = p0;\n  assign c1 = p1;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] product;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      product <= 0;\n    else\n      product <= a * b;\n  end\n  assign p = product;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n\n    // Instantiate the submodule for initializing the counter\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .init_out(init_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init_out;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Submodule for initializing the counter to its starting state\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Submodule for cyclic state transition\n    state_transition state_trans (\n        .clk(clk),\n        .out(out),\n        .init(init)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodule for initializing the counter\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition state_trans (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, srav_carry, lui_carry;\n\n    // Addition module\n    add add_module(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .c(add_carry)\n    );\n\n    // Subtraction module\n    sub sub_module(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .c(sub_carry)\n    );\n\n    // Logical operations module\n    logic_ops logic_module(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .c(and_carry)\n    );\n\n    // Shift left logical operations module\n    shift_left shift_left_module(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .c(sll_carry)\n    );\n\n    // Shift right logical operations module\n    shift_right shift_right_module(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .c(srl_carry)\n    );\n\n    // Shift right arithmetic operations module\n    shift_right_arith shift_right_arith_module(\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .c(srav_carry)\n    );\n\n    // Load upper immediate module\n    load_upper_immediate load_upper_immediate_module(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .c(lui_carry)\n    );\n\n    // Select the result based on the aluc control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    // Compute the flags\n    assign zero = (r == 0);\n    assign carry = (aluc == 6'b10000) ? add_carry :\n                 (aluc == 6'b10001) ? sub_carry :\n                 (aluc == 6'b100100) ? and_carry :\n                 (aluc == 6'b100101) ? or_carry :\n                 (aluc == 6'"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_high, A_low, B_high, B_low;\n    wire [15:0] diff_high, diff_low;\n\n    // Instantiate the 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(diff_high),\n        .B_out(B_high)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(diff_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs\n    assign Diff = {diff_high, diff_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] diff_high, diff_low;\n    wire [15:0] B_high, B_low;\n\n    // Instantiate the 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(diff_high),\n        .B_out(B_high)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(diff_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs\n    assign Diff = {diff_high, diff_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] diff_high, diff_low;\n    wire [7:0] B_high, B_low;\n\n    // Instantiate the 4-bit subtractor blocks\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(diff_high),\n        .B_out(B_high)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(diff_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs\n    assign Diff = {diff_high, diff_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] diff_high, diff_low;\n    wire [3:0] B_high, B_low;\n\n    // Instantiate the 2-bit subtractor blocks\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(diff_high),\n        .B_out(B_high)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(diff_low),"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(instr)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .rd(rd),\n    .op(op),\n    .alu_result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file),\n    .reg_file(reg_file),\n    .next_pc(next_pc)\n  );\n\n  // Pipeline register\n  reg [31:0] pipeline_reg [0:4];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n      pipeline_reg[4] <= 0;\n    end else begin\n      pipeline_reg[0] <= instr_mem[pc];\n      pipeline_reg[1] <= pipeline_reg[0];\n      pipeline_reg[2] <= pipeline_reg[1];\n      pipeline_reg[3] <= pipeline_reg[2];\n      pipeline_reg[4] <= pipeline_reg[3];\n    end\n  end\n\n  assign instr = pipeline_reg[0];\n  assign next_pc = pc + 1;\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc_reg + 1;\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_mem[pc_reg];\n\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {rs2, rs1, rd, op} = instr;\n\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodule for initialization\n    initial_state init_module (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition transition_module (\n        .clk(clk),\n        .reset(reset),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodules for initialization and state transition\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    state_transition state_trans (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n    wire [7:0] transition;\n\n    // Instantiate the submodule for initializing the counter\n    initial_state init_submodule (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition transition_submodule (\n        .clk(clk),\n        .reset(reset),\n        .init(init),\n        .out(transition)\n    );\n\n    // Connect the output to the transition module\n    assign out = transition;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 8'b00000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_high, B_high;\n    wire [15:0] A_low, B_low;\n\n    // Instantiate the two 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(A_high),\n        .B_out(B_high)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(A_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs of the two blocks\n    assign Diff = {A_high, A_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] A_high, B_high;\n    wire [15:0] A_low, B_low;\n\n    // Instantiate the 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(A_high),\n        .B_out(B_high)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(A_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs of the two blocks\n    assign Diff = {A_high, A_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] A_high, B_high;\n    wire [7:0] A_low, B_low;\n\n    // Instantiate the 4-bit subtractor blocks\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(A_high),\n        .B_out(B_high)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(A_low),\n        .B_out(B_low)\n    );\n\n    // Combine the outputs of the two blocks\n    assign Diff = {A_high, A_low};\n    assign B_out = {B_high, B_low};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] A_high, B_high;\n    wire [3:0] A_low, B_low;\n\n    // Instantiate the 2-bit subtractor blocks\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(A_high),\n        .B_out(B_high)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(A"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n\n    // Instantiate the submodule for initializing the counter\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .init_out(init_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init_out;\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr_mem[pc]),\n    .alu_result(alu_result)\n  );\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Assign the outputs\n  assign res_reg_file = writeback.res_reg_file;\n  assign pc = next_pc;\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc\n);\n  reg [31:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc_reg + 1;\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = pc + 1;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output [31:0] alu_result\n);\n  wire [4:0] opcode;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n\n  assign opcode = instr[31:28];\n  assign rs1 = instr[27:24];\n  assign rs2 = instr[23:20];\n  assign rd = instr[19:15];\n\n  // Instantiate the ALU\n  alu alu_inst (\n    .opcode(opcode),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .rd(alu_result)\n  );\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      res_reg_file <= 0;\n    else\n      res_reg_file <= alu_result;\n  end\nendmodule\n\n// Memory stage\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    // AND\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    // OR\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    // XOR\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    // NOR\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    // SLT\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    // SLTU\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    // SLL\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    // SRL\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    // SRA\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    // LUI\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b000111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1) ^ (r[30:0] != 0);\n    assign overflow = (r[31] == 1) ^ (a[31] == b[31] && r[31:0] != a[30:0];\n    assign flag = ("}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n    wire [7:0] transition;\n\n    // Instantiate the submodules for initialization and state transition\n    initial_state init_submodule (\n        .reset(reset),\n        .out(init)\n    );\n\n    state_transition transition_submodule (\n        .clk(clk),\n        .init(init),\n        .out(transition)\n    );\n\n    // Output the current state of the ring counter\n    assign out = transition;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset or posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= out;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the initialization submodule\n    initializer init_module (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the state transition submodule\n    state_transition transition (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initializer (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= (out == 8'b1111_1111) ? init : out << 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodule for initializing the counter\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition state_trans (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[31:16]};\n    assign B_out = {B_out_low, B[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n    wire [7:0] Diff_low;\n    wire [7:0] B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[15:8]};\n    assign B_out = {B_out_low, B[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] A_low;\n    wire [3:0] B_low;\n    wire [3:0] Diff_low;\n    wire [3:0] B_out_low;\n\n    assign A_low = A[3:0];\n    assign B_low = B[3:0];\n\n    sub_4bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[7:4]};\n    assign B_out = {B_out_low, B[7:4]};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] A_low;\n    wire [1:0] B_low;\n    wire [1:0] Diff_low;\n    wire [1:0] B_out_low;\n\n    assign A_low = A[1:0];\n    assign B_low = B[1:0];\n\n    sub_2bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    assign Diff = {Diff_low, A[3:2]};\n    assign B_out = {B_out_low, B[3:2]};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr_fetched(alu_result)\n  );\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr_fetched(alu_result),\n    .reg_file(reg_file),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0])\n  );\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0]),\n    .alu_result(alu_result)\n  );\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_mem(res_reg_file)\n  );\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_mem(res_reg_file),\n    .reg_file(reg_file)\n  );\n\n  // Update the program counter\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr_fetched\n);\n  reg [31:0] next_pc;\n  reg [31:0] instr_fetched_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n      instr_fetched_reg <= 0;\n    end else begin\n      next_pc <= pc + 1;\n      instr_fetched_reg <= instr_mem[pc];\n    end\n  end\n\n  assign instr_fetched = instr_fetched_reg;\n\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_fetched,\n  input [31:0] reg_file [0:31],\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [15:0] op\n);\n  assign rs1 = instr_fetched[31:28];\n  assign rs2 = instr_fetched[27:24];\n  assign rd = instr_fetched[23:20];\n  assign op = instr_fetched[15:0];\n\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [15:0] op,\n  output [31:0] alu_result\n);\n  wire [31:0] rs1_val"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n\n    // Instantiate the submodule for initial state\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .out(out),\n        .init_out(init_out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] out,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= (out == 8'b1111_1111) ? init_out : out << 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_out;\n\n    // Instantiate the initialization submodule\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition submodule\n    state_transition transition (\n        .clk(clk),\n        .init_out(init_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init_out;\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .borrow(carry)\n    );\n    // Logical operations\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (aluc == 6'b10000) ? carry :\n                 (aluc == 6'b10001) ? 1'b0 :\n                 (aluc == 6'b100100) ? carry :\n                 (aluc == 6'b1001010) ? 1'b0 :\n                 (aluc == 6'b1001110) ? carry :\n                 (aluc =="}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodules\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    state_transition state_trans (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n    wire [7:0] transition;\n\n    // Instantiate the submodules\n    initial_state init_submodule (\n        .reset(reset),\n        .out(init)\n    );\n\n    state_transition state_submodule (\n        .clk(clk),\n        .init(init),\n        .out(transition)\n    );\n\n    // Output assignment\n    assign out = transition;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init;\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, B_low;\n    wire [15:0] Diff_low;\n\n    // Instantiate the 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_low),\n        .B_out(B_low)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    // Output the difference\n    assign Diff = {Diff_low, B_low};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] A_low, B_low;\n    wire [15:0] Diff_low;\n\n    // Instantiate the 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff_low),\n        .B_out(B_low)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[7:0]),\n        .B_out(B_out[7:0])\n    );\n\n    // Output the difference\n    assign Diff = {Diff_low, B_low};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [3:0] A_low, B_low;\n    wire [3:0] Diff_low;\n\n    // Instantiate the 4-bit subtractor blocks\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff_low),\n        .B_out(B_low)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[3:0]),\n        .B_out(B_out[3:0])\n    );\n\n    // Output the difference\n    assign Diff = {Diff_low, B_low};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output [3:0] B_out;\n\n    wire [1:0] A_low, B_low;\n    wire [1:0] Diff_low;\n\n    // Instantiate the 2-bit subtractor blocks\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff_low),\n        .B_out(B_low)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[1:0]),\n        .B_out(B_out[1:0])\n    );\n\n    // Output the difference\n    assign Diff = {Diff_low, B_low};\n\nendmodule\n\nmodule sub_2bit"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(alu_result)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(alu_result),\n    .pc(pc),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0])\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0]),\n    .result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file),\n    .reg_file(reg_file)\n  );\n\n  // Pipeline register\n  reg [31:0] pipeline_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg <= 0;\n    end else begin\n      pipeline_reg <= alu_result;\n    end\n  end\n\n  assign alu_result = pipeline_reg;\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] next_pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n    end else begin\n      next_pc <= pc + 1;\n    end\n  end\n\n  assign instr = instr_mem[next_pc];\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [31:0] pc,\n  output [31:0] rs1,\n  output [31:0] rs2,\n  output [31:0] rd,\n  output [15:0] op\n);\n  assign {rs2, rs1, rd, op} = instr;\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [31:0] rd,\n  input [15:0] op,\n  output [31:0] result\n);\n  reg [31:0] result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      result_reg <= 0;\n    end else begin\n      case (op)\n        16'h0000: result_reg <= rs1 + rs2; // Add"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init;\n\n    // Instantiate the submodule for initial state\n    initial_state init_state (\n        .reset(reset),\n        .out(init)\n    );\n\n    // Instantiate the submodule for state transition\n    state_transition state_trans (\n        .clk(clk),\n        .init(init),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= init >> 1;\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_hi, A_lo, B_hi, B_lo;\n    wire [15:0] Diff_hi, Diff_lo;\n\n    assign A_hi = A[31:16];\n    assign A_lo = A[15:0];\n    assign B_hi = B[31:16];\n    assign B_lo = B[15:0];\n\n    subtractor_16bit S1(\n        .A(A_hi),\n        .B(B_hi),\n        .Diff(Diff_hi),\n        .B_out(B_out[31:16])\n    );\n\n    subtractor_16bit S2(\n        .A(A_lo),\n        .B(B_lo),\n        .Diff(Diff_lo),\n        .B_out(B_out[15:0])\n    );\n\n    assign Diff = {Diff_hi, Diff_lo};\n\nendmodule\n\nmodule subtractor_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] borrow;\n\n    assign Diff = A - B;\n    assign B_out = A - B - borrow;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A1, B1, Diff1, B_out1;\n\n    // Instantiate the 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff1),\n        .B_out(B_out1)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] A_neg, B_neg;\n\n    assign A_neg = ~A + 1;\n    assign B_neg = ~B + 1;\n\n    assign Diff = A_neg + B_neg;\n    assign B_out = A_neg - B_neg;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n    and_or_xor_nor and_or_submodule(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    slt_sltu_sll_srl_srav_submodule(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .sltu_result(sltu_result),\n        .sll_result(sll_result),\n        .srl_result(srl_result),\n        .srav_result(srav_result)\n    );\n    lui_submodule(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign carry = (r[32] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == b[31]) && (r[31] != a[31]));\n    assign flag = (aluc == 6'b101010) ? (a[31] && b[31]) : 0;\n\nendmodule\n\nmodule add_sub_submodule(input [31:0] a, b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule and_or_xor_nor_submodule(input [31:0] a, b, output [31:0] r);\n    assign r = a & b | a | ~b;\nendmodule\n\nmodule slt_sltu_sll_srl_srav_submodule(input [31:0] a, b, output [31:0] slt_result, sltu_result, sll_result, srl_result, srav_result);\n    assign slt_result = a < b;\n    assign sltu_result = a < b || (a == b && a[31]);\n    assign sll_result = a << 1;\n    assign srl_result = a >> 1;\n    assign srav_result = a + b - (a < b);\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n  wire [31:0] fetched_instr;\n  wire [31:0] decoded_instr;\n  wire [31:0] executed_instr;\n  wire [31:0] memory_result;\n  wire [31:0] writeback_result;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(next_pc),\n    .fetched_instr(fetched_instr)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .decoded_instr(decoded_instr)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .decoded_instr(decoded_instr),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .memory_result(memory_result)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .memory_result(memory_result),\n    .writeback_result(writeback_result)\n  );\n\n  // Connect the pipeline stages\n  assign next_pc = fetched_instr[31:28] + 4'b0001;\n  assign decoded_instr = fetched_instr;\n  assign alu_result = execute_stage.alu_result;\n  assign memory_result = execute_stage.alu_result;\n  assign writeback_result = memory_stage.memory_result;\n  assign res_reg_file = writeback_stage.writeback_result;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] fetched_instr\n);\n  reg [31:0] current_pc;\n  reg [31:0] fetched_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      current_pc <= 32'b0;\n      fetched_instr <= 32'b0;\n    end else begin\n      current_pc <= pc;\n      fetched_instr <= instr_mem[current_pc];\n    end\n  end\n\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [31:0] decoded_instr\n);\n  reg [31:0] decoded_instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      decoded_instr_reg <= 32'b0;\n    end else begin\n      decoded_instr_reg <= fetched_instr;\n    end\n  end\n\n  assign decoded_instr = decoded_instr_reg;\n\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] decoded_instr,\n  output [31:0] alu_result\n);\n\n  wire [31:0] rs1_val, rs2_val;\n  wire [5:0] opcode;\n\n  assign rs1_val"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[31:16]),\n        .B_out(B_out[31:16])\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] diff_low;\n    wire [15:0] b_out_low;\n\n    assign diff_low = A - B;\n    assign b_out_low = B_out[15:0];\n\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(diff_low[7:0]),\n        .B_out(b_out_low[7:0])\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(diff_low[15:8]),\n        .B_out(b_out_low[15:8])\n    );\n\n    assign Diff = {diff_low, B_out[15:0]};\n    assign B_out = {b_out_low, B_out[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output [7:0] B_out;\n\n    wire [7:0] diff_low;\n    wire [7:0] b_out_low;\n\n    assign diff_low = A - B;\n    assign b_out_low = B_out[7:0];\n\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(diff_low[3:0]),\n        .B_out(b_out_low[3:0])\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(diff_low[7:4]),\n        .B_out(b_out_low[7:4])\n    );\n\n    sub_4bit S3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Diff(diff_low[11:8]),\n        .B_out(b_out_low[11:8])\n    );\n\n    sub_4bit S4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Diff(diff_low[15:12]),\n        .B_out(b_out_low[15:12])\n    );\n\n    assign Diff = {diff_low, B_out[7:0]};\n    assign B_out = {b_out_low, B_out[15:8]};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(carry)\n    );\n    and_or_xor_nor and_or_submodule(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    slt_sltu_sll_srl_srav slt_sltu_sll_srl_submodule(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .carry(carry)\n    );\n    lui_submodule lui_submodule(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign negative = (r[31] ^ r[30] ^ r[31:1]);\n    assign overflow = (r[31] ^ a[31] ^ b[31] ^ r[31]);\n    assign flag = (aluc == 6'b101010) ? (r[31] ^ a[31] ^ b[31]) : 0;\n\nendmodule\n\nmodule add_sub(input [31:0] a, b, output [31:0] r, output carry);\n    assign r = a + b + carry;\nendmodule\n\nmodule and_or_xor_nor(input [31:0] a, b, output [31:0] r);\n    assign r = a & b | a | ~b;\nendmodule\n\nmodule slt_sltu_sll_srl_srav(input [31:0] a, b, output [31:0] r, output carry);\n    assign r = (a[31] ^ b[31]) ? ~(b - a - 1) : a - b;\nendmodule\n\nmodule lui_submodule(input [31:0] a, b, output [31:0] r);\n    assign r = a + b + 1;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  \n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .alu_result(alu_result)\n  );\n  \n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .pc(pc),\n    .reg_file(reg_file)\n  );\n  \n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .pc(pc),\n    .reg_file(reg_file)\n  );\n  \n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .pc(pc),\n    .reg_file(reg_file)\n  );\n  \n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .pc(pc),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n  \nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] alu_result,\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      alu_result <= 0;\n    end else begin\n      alu_result <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] pc,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      rs1 <= alu_result[31:27];\n      rs2 <= alu_result[26:22];\n      rd <= alu_result[21:17];\n      op <= alu_result[15:11];\n      res_reg_file[rd] <= (op == 6'b000001) ? reg_file[rs1] + reg_file[rs2] : reg_file[rs1] - reg_file[rs2];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] pc,\n  input [31:0] reg_file [0:31]\n);\n  // No operation\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] pc,\n  input [31:0] reg_file [0:31]\n);\n  // No operation\nendmodule\n\nmodule writeback_stage(\n  input clk,"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    // Instantiate the 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    // Connect the outputs\n    assign Diff = {Diff_low, A[31:16]};\n    assign B_out = {B_out_low, B[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output [15:0] B_out;\n\n    wire [15:0] diff_temp;\n\n    assign diff_temp = A - B;\n    assign Diff = diff_temp;\n    assign B_out = B;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .pc(pc),\n    .instr(alu_result)\n  );\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(alu_result),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0])\n  );\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0]),\n    .result(alu_result)\n  );\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Increment the program counter\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] current_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      current_instr <= 0;\n    else\n      current_instr <= instr_mem[pc];\n  end\n\n  assign instr = current_instr;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [15:0] op\n);\n  assign rs1 = instr[31:28];\n  assign rs2 = instr[27:24];\n  assign rd = instr[23:20];\n  assign op = instr[15:0];\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [15:0] op,\n  output [31:0] result\n);\n  reg [31:0] alu_result;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      case (op)\n        16'h00: alu_result <= rs1 + rs2; // Addition\n        16'h01: alu_result <= rs1 - rs2; // Subtraction\n        default: alu_"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] Diff_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    // Instantiate the 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A_low),\n        .B(B_low),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    // Output the difference and borrow\n    assign Diff = {Diff_low, A[15:0] - B[15:0]};\n    assign B_out = {B_out_low, 1'b0};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] Diff_low;\n    wire B_out_low;\n\n    // Instantiate the 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    // Instantiate the 8-bit subtractor blocks\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[15:8]),\n        .B_out(B_out_high)\n    );\n\n    // Output the difference and borrow\n    assign Diff = {Diff_low, A[15:8] - B[15:8]};\n    assign B_out = B_out_low | B_out_high;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] Diff_low;\n    wire B_out_low;\n\n    // Instantiate the 4-bit subtractor blocks\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    // Instantiate the 4-bit subtractor blocks\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[7:4]),\n        .B_out(B_out_high)\n    );\n\n    // Output the difference and borrow\n    assign Diff = {Diff_low, A[7:4] - B[7:4]};\n    assign B_out = B_out_low | B_out_high;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] Diff_low;\n    wire B_out_low;\n\n    // Instantiate the 2-bit subtractor blocks\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff_low),\n        .B_out(B_out_low)\n    );\n\n    // Instantiate the 2-bit subtractor blocks\n    sub_2bit S"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result)\n    );\n\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result)\n    );\n\n    // Logical operations\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result)\n    );\n\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result)\n    );\n\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    assign zero = (r == 32'b0);\n    assign carry = (r[32] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[32] != (a[31] ^ b[31]));\n    assign flag = (aluc == 6'b101010) ? (a[31] && b[31] : 1'b0);\n\nendmodule add_module(input [31:0] a, b, output [3"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_low, B_low;\n    wire [31:0] A_high, B_high;\n    wire [15:0] A_low_low, B_low_low;\n    wire [15:0] A_low_high, B_low_high;\n    wire [7:0] A_high_low, B_high_low;\n    wire [7:0] A_high_high, B_high_high;\n\n    assign A_low = A[31:0];\n    assign A_high = A[63:32];\n    assign B_low = B[31:0];\n    assign B_high = B[63:32];\n\n    assign A_low_low = A_low[15:0];\n    assign A_low_high = A_low[31:16];\n    assign B_low_low = B_low[15:0];\n    assign B_low_high = B_low[31:16];\n    assign A_high_low = A_high[7:0];\n    assign A_high_low = A_high[15:8];\n    assign A_high_high = A_high[23:16];\n    assign B_high_low = B_high[7:0];\n    assign B_high_high = B_high[23:16];\n\n    submodule sub0(\n        .A(A_low_low),\n        .B(B_low_low),\n        .D(D[31:0]),\n        .B_out(B_out[31:0])\n    );\n\n    submodule sub1(\n        .A(A_low_high),\n        .B(B_low_high),\n        .D(D[63:32]),\n        .B_out(B_out[63:32])\n    );\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr_mem[pc]),\n    .rs1(decode.rs1),\n    .rs2(decode.rs2),\n    .rd(decode.rd),\n    .op(decode.op)\n  );\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(decode.rs1),\n    .rs2(decode.rs2),\n    .rd(decode.rd),\n    .op(decode.op),\n    .alu_result(alu_result)\n  );\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_reg_file(memory.res_reg_file)\n  );\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(memory.res_reg_file),\n    .reg_file(reg_file),\n    .res_reg_file(writeback.res_reg_file)\n  );\n\n  // Connect the pipeline stages\n  assign next_pc = pc + 1;\n  assign pc = fetch.pc;\n  assign alu_result = execute.alu_result;\n  assign res_reg_file = writeback.res_reg_file;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc,\n  output reg [31:0] next_pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      next_pc <= 0;\n    end else begin\n      pc <= next_pc;\n      next_pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[19:15];\n      rs2 <= instr[24:20];\n      rd <= instr[11:7];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        6'b000000: al"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] sub0_out;\n    wire [63:0] sub1_out;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(sub0_out)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(sub1_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n    assign B_out = B_out;\n\nendmodule\n\nmodule sub_32bit(A, B, D);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n\n    wire [15:0] sub0_out;\n    wire [15:0] sub1_out;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(sub0_out)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(sub1_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_16bit(A, B, D);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n\n    wire [7:0] sub0_out;\n    wire [7:0] sub1_out;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(sub0_out)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(sub1_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_8bit(A, B, D);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n\n    assign D = A - B;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instantiate the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(carry)\n    );\n    and_or_xor_nor and_or_module(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    slt_sltu_sll_srl_srav slt_sltu_sll_srl_module(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .carry(carry)\n    );\n    lui_lui lui_module(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000001) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] != a[31] && (r[31] != b[31]) && (a[31] != b[31]);\n    assign flag = (aluc == 6'b101010) ? (a[31] && !b[31]) : 0;\n\nendmodule\n\nmodule add_sub(input [31:0] a, input [31:0] b, output [31:0] r, output carry);\n    assign r = a + b + carry;\nendmodule\n\nmodule and_or_xor_nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b | a | b;\nendmodule\n\nmodule slt_sltu_sll_srl_srav(input [31:0] a, input [31:0] b, output [31:0] r, output carry);\n    assign r = (a < b) ? 1 : 0;\n    assign carry = (a < b) ? 1 : 0;\nendmodule\n\nmodule lui_lui(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc_plus_1;\n  wire [31:0] next_instr;\n  wire [31:0] next_reg_file;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc_plus_1(pc_plus_1),\n    .next_instr(next_instr)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .next_instr(next_instr),\n    .alu_result(alu_result)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .next_reg_file(next_reg_file)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .next_reg_file(next_reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Update the program counter\n  assign pc_plus_1 = pc_plus_1 + 1;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc_plus_1,\n  output reg [31:0] next_instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_plus_1 <= 0;\n      next_instr <= 0;\n    end else begin\n      pc_plus_1 <= pc_plus_1 + 1;\n      next_instr <= instr_mem[pc_plus_1];\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] next_instr,\n  output reg [31:0] alu_result\n);\n  wire [4:0] opcode;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] funct;\n\n  assign opcode = next_instr[31:26];\n  assign rs1 = next_instr[25:21];\n  assign rs2 = next_instr[20:16];\n  assign rd = next_instr[15:11];\n  assign funct = next_instr[5:0];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (opcode)\n        6'b000000: alu_result <= reg_file[rs1] + reg_file[rs2]; // Addition\n        6'b0000001: alu_result <= reg_file[rs1] - reg_file[rs2]; // Subtraction\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] next_reg_file\n);\n  always @(posedge clk or posedge"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!valid_count) begin\n            out <= out;\n        end else begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_low, A_high;\n    wire [31:0] B_low, B_high;\n    wire [31:0] D_low, D_high;\n    wire [31:0] B_out_low, B_out_high;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, A_high;\n    wire [15:0] B_low, B_high;\n    wire [15:0] D_low, D_high;\n    wire [15:0] B_out_low, B_out_high;\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_low, A_high;\n    wire [7:0] B_low, B_high;\n    wire [7:0] D_low, D_high;\n    wire [7:0] B_out_low, B_out_high;\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_low, A_high;"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n\n    add_sub add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(carry)\n    );\n    sub_sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(carry)\n    );\n    and_or_xor_nor and_or_submodule(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n    slt_sltu_sll_srl_srav_submodule(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .sltu_result(sltu_result),\n        .sll_result(sll_result),\n        .srl_result(srl_result),\n        .srav_result(srav_result)\n    );\n    lui_submodule(\n        .a(a),\n        .b(b),\n        .r(lui_result)\n    );\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b101010) ? slt_result :\n                 (aluc == 6'b101011) ? sltu_result :\n                 (aluc == 6'b000000) ? sll_result :\n                 (aluc == 6'b000010) ? srl_result :\n                 (aluc == 6'b000011) ? srav_result :\n                 (aluc == 6'b001111) ? lui_result : 0;\n\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] != a[31] && (r[31] != b[31]) && (a[31] != b[31]);\n    assign flag = (aluc == 6'b101010) ? (r[31] == 1) : 0;\n\nendmodule\n\nmodule add_sub_submodule(input [31:0] a, b, output [31:0] r, output carry);\n    assign r = a + b + carry;\n    assign carry = (a[31] & b[31]) | (a[31] & ~b[31]) | (~a[31] & ~b[31] & carry);\nendmodule\n\nmodule and_or_xor_nor_submodule(input [31:0] a, b, output [31:0] r);\n    assign r = a & b | ~a | ~b;\nendmodule\n\nmodule slt_sltu_sll_srl_srav_submodule(input [31:0] a, b, output [31:0] r, output slt_result, sltu_result, sll_result, srl_result, srav_result);\n    assign slt_result = (a < b"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instruction(alu_result)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instruction(alu_result),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0])\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0]),\n    .result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .result(alu_result),\n    .memory_result(alu_result)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .memory_result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Increment the program counter\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instruction\n);\n  reg [31:0] current_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      current_instr <= 0;\n    end else begin\n      current_instr <= instr_mem[pc];\n    end\n  end\n\n  assign instruction = current_instr;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instruction,\n  output [3:0] rs1,\n  output [3:0] rs2,\n  output [3:0] rd,\n  output [15:0] op\n);\n  assign rs1 = instruction[31:28];\n  assign rs2 = instruction[27:24];\n  assign rd = instruction[23:20];\n  assign op = instruction[15:0];\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [3:0] rs1,\n  input [3:0] rs2,\n  input [3:0] rd,\n  input [15:0] op,\n  output [31:0] result\n);\n  reg [31:0] alu_result;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        16'h0000: alu_result <= rs1 + rs2; // Addition\n        16'h000"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_low, B_low;\n    wire [15:0] A_high, B_high;\n    wire [7:0] A_low_low, B_low_low;\n    wire [7:0] A_low_high, B_low_high;\n    wire [3:0] A_high_low, B_high_low;\n    wire [3:0] A_high_high, B_high_high;\n\n    // Instantiate the 32-bit subtractor module\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out[31:0])\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out[63:32])\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, B_low;\n    wire [7:0] A_high, B_high;\n    wire [7:0] A_low_low, B_low_low;\n    wire [7:0] A_low_high, B_low_high;\n    wire [3:0] A_high_low, B_high_low;\n    wire [3:0] A_high_high, B_high_high;\n\n    // Instantiate the 16-bit subtractor module\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out[31:16])\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_low, B_low;\n    wire [7:0] A_high, B_high;\n    wire [3:0] A_low_low, B_low_low;\n    wire [3:0] A_low_high, B_low_high;\n    wire [3:0] A_high_low, B_high_low;\n    wire [3:0] A_high_high, B_high_high;\n\n    // Instantiate the 8-bit subtractor module\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out[7:0])\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out[15:8])\n    );\n\n    sub_8bit sub2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        ."}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instantiate the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]     Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output [63:0] next_Q\n);\n\n    assign next_Q = current_Q & (~current_Q + 1);\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_res;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_res(alu_res)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .alu_res(alu_res),\n    .rd(rd),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Pipeline register\n  reg [31:0] pipeline_reg [0:4];\n\n  // Assign outputs\n  assign res_reg_file = pipeline_reg[4];\n\n  // Update pipeline register\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n      pipeline_reg[4] <= 0;\n      pc <= 0;\n    end else begin\n      pipeline_reg[0] <= instr_mem[pc];\n      pipeline_reg[1] <= pipeline_reg[0];\n      pipeline_reg[2] <= pipeline_reg[1];\n      pipeline_reg[3] <= pipeline_reg[2];\n      pipeline_reg[4] <= pipeline_reg[3];\n      pc <= next_pc;\n    end\n  end\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  output [31:0] instr\n);\n  assign instr_mem[pc] = instr;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[19:15];\n      rs2 <= instr[24:20];\n      rd <= instr[11:7];\n      op <= instr[31:26];\n    end"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, srav_carry, lui_carry;\n\n    // Addition\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .c(add_carry)\n    );\n    // Subtraction\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .c(sub_carry)\n    );\n    // AND\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .c(and_carry)\n    );\n    // OR\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .c(or_carry)\n    );\n    // XOR\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .c(xor_carry)\n    );\n    // NOR\n    nor_module nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .c(nor_carry)\n    );\n    // SLT\n    slt_module slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .c(slt_carry)\n    );\n    // SLTU\n    sltu_module sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .c(sltu_carry)\n    );\n    // SLL\n    sll_module sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .c(sll_carry)\n    );\n    // SRL\n    srl_module srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .c(srl_carry)\n    );\n    // SRA\n    srav_module srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .c(srav_carry)\n    );\n    // LUI\n    lui_module lui_inst (\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .c(lui_carry)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_result :\n                 (aluc == 6'b100001) ? sub_result :\n                 (aluc == 6'b100100) ? and_result :\n                 (aluc == 6'b100101) ? or_result :\n                 (aluc == 6'b100110) ? xor_result :\n                 (aluc == 6'b100111) ? nor_result :\n                 (aluc == 6'b1010110) ? slt_result :\n                 (aluc == 6'b10101) ? s"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Assign the output of the logic module to the register module\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n    always @(*) begin\n        next_state = current_state;\n        if(current_state[0] == 1'b1) begin\n            next_state = 64'b0;\n        end else begin\n            next_state = current_state + 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_hi, A_lo, B_hi, B_lo;\n    wire [15:0] A_hi_hi, A_hi_lo, B_hi_hi, B_hi_lo;\n    wire [7:0] A_hi_hi_hi, A_hi_hi_lo, B_hi_hi_hi, B_hi_hi_lo;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out[31:0])\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out[63:32])\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_hi, A_lo, B_hi, B_lo;\n    wire [7:0] A_hi_hi, A_hi_lo, B_hi_hi, B_hi_lo;\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out[31:16])\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_hi, A_lo, B_hi, B_lo;\n    wire [3:0] A_hi_hi, A_hi_lo, B_hi_hi, B_hi_lo;\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out[7:0])\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out[15:8])\n    );\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_hi, A_lo, B_hi, B_lo;\n    wire [1:0] A_hi_hi, A_hi_lo, B_hi_hi, B_hi_lo;\n\n    // Instantiate the 4-bit subtractor modules\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    JC_logic logic_inst(\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]     Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output reg [63:0] next_Q\n);\n\n    always @(*) begin\n        next_Q = current_Q & (~current_Q + 1);\n    end\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module for_the_Johnson_Counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= next_state;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]      next_state\n);\n\n    assign next_state = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] accumulator_result;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result),\n        .current_value(accumulator_result)\n    );\n\n    // Connect the outputs\n    assign c = accumulator_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(alu_result)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(alu_result),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0])\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(alu_result[31:28]),\n    .rs2(alu_result[27:24]),\n    .rd(alu_result[23:20]),\n    .op(alu_result[15:0]),\n    .alu_result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file),\n    .reg_file(reg_file),\n    .pc(pc)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] next_pc;\n  reg [31:0] current_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n      current_instr <= 0;\n    end else begin\n      next_pc <= pc + 4;\n      current_instr <= instr_mem[pc];\n    end\n  end\n\n  assign instr = current_instr;\n\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [3:0] rs1,\n  output [3:0] rs2,\n  output [4:0] rd,\n  output [15:0] op\n);\n  assign rs1 = instr[31:28];\n  assign rs2 = instr[27:24];\n  assign rd = instr[23:20];\n  assign op = instr[15:0];\n\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [3:0] rs1,\n  input [3:0] rs2,\n  input [4:0] rd,\n  input [15:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] result;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      result <= 0;\n    end else begin\n      case (op)\n        16'h00: result <= rs1 + rs2;\n        16'h01: result <= rs1 - rs2;\n        default: result <= 0;\n      endcase\n    end\n  end\n\n  assign alu_result = {rd, result};\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    JC_logic logic_inst(\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]     Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n\n    always @(*) begin\n        next_state = current_state;\n        next_state[0] = current_state[63] ^ current_state[62] ^ current_state[61] ^ current_state[60];\n        next_state[63:1] = current_state[62:1];\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_high, B_high;\n    wire [15:0] A_low, B_low;\n    wire [7:0] A_low_high, B_low_high;\n    wire [3:0] A_low_low, B_low_low;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out[31:0])\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out[63:32])\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, B_low;\n    wire [7:0] A_low_high, B_low_high;\n    wire [3:0] A_low_low, B_low_low;\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out[31:16])\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_high, B_high;\n    wire [3:0] A_low, B_low;\n    wire [1:0] A_low_high, B_low_high;\n    wire [0:0] A_low_low, B_low_low;\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out[7:0])\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out[15:8])\n    );\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_high, B_high;\n    wire [1:0] A_low, B_low;\n    wire [0:0] A_low_high, B_low_high;\n    wire [0:0] A_low_low, B_low_low;\n\n    // Instantiate the 4-bit subtractor modules\n    sub_4bit sub0(\n        .A(A[3:0]),\n        ."}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the output to the accumulator\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module for_the_Johnson_Counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register and logic modules\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    JC_logic logic_inst(\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Assign the output\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n\n    always @(*) begin\n        next_state = current_state;\n        if (current_state[0] == 1'b1) begin\n            next_state = {current_state[62:0], 1'b0};\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    JC_logic logic_inst(\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]     Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output reg [63:0] next_Q\n);\n\n    always @(*) begin\n        next_Q = current_Q;\n        next_Q[0] = current_Q[63];\n    end\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_res;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] instr;\n  wire [4:0] op;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .op(op),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .op(op),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .alu_res(alu_res)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Update the program counter\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= next_pc;\n    end\n  end\n\n  // Assign the next program counter\n  assign next_pc = pc + 1;\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  output [31:0] instr\n);\n  assign instr = instr_mem[pc];\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] op,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd\n);\n  assign {op, rs1, rs2, rd} = instr;\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] op,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  output [31:0] alu_res\n);\n  wire [31:0] add_res;\n  wire [31:0] sub_res;\n\n  // Addition operation\n  assign add_res = rs1 + rs2;\n\n  // Subtraction operation\n  assign sub_res = rs1 - rs2;\n\n  // Select the operation based on the opcode\n  assign alu_res = (op == 5'b00000) ? add_res : sub_res;\nendmodule\n\n// Memory stage\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output [31:0] res_reg_file [0:31]\n);\n  assign res_reg_file = alu_res;"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output reg [63:0] next_Q\n);\n    always @(*) begin\n        next_Q = current_Q;\n        next_Q[0] = current_Q[63];\n    end\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] accumulator_result;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result),\n        .current_value(accumulator_result)\n    );\n\n    // Connect the outputs\n    assign c = accumulator_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_high, A_low, B_high, B_low;\n    wire [15:0] A_high_low, A_low_low, B_high_low, B_low_low;\n    wire [7:0] A_high_low_low, A_low_low_low, B_high_low_low, B_low_low_low;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out[31:0])\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out[63:32])\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_high, A_low, B_high, B_low;\n    wire [7:0] A_high_low, A_low_low, B_high_low, B_low_low;\n    wire [3:0] A_high_low_low, A_low_low_low, B_high_low_low, B_low_low_low;\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out[15:0])\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out[31:16])\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_high, A_low, B_high, B_low;\n    wire [3:0] A_high_low, A_low_low, B_high_low, B_low_low;\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out[7:0])\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out[15:8])\n    );\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_high, A_low, B_high, B_low;\n    wire [1:0] A_high_low, A_low_low, B_high_low, B_low_low;\n\n    // Instanti"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]       Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= next_Q;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    input [63:0]       next_Q,\n    output reg [63:0]       Q\n);\n\n    always @(posedge Q[0]) begin\n        if (Q[0])\n            Q <= next_Q;\n    end\nend\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    assign product = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Connect the output of the logic module to the register module\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n\n    always @(*) begin\n        next_state = current_state;\n        if (current_state[0] == 1'b1) begin\n            next_state = {current_state[62:0], 1'b0};\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] instr;\n  wire [4:0] op;\n  wire [4:0] rs1, rs2;\n  wire [4:0] rd;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(instr)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .op(op),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .op(op),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .alu_result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .next_pc(next_pc)\n  );\n\n  // Update the program counter\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= next_pc;\n    end\n  end\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem[0:31],\n  output [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] current_pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      current_pc <= 0;\n    end else begin\n      current_pc <= current_pc + 1;\n    end\n  end\n\n  assign instr = instr_mem[current_pc];\n  assign pc = current_pc;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] op,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd\n);\n  assign op = instr[31:28];\n  assign rs1 = instr[27:24];\n  assign rs2 = instr[23:20];\n  assign rd = instr[19:15];\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] op,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        5'b0000: al"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    JC_logic logic_inst (\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    reg [63:0] Q_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_reg <= 64'b0;\n        else\n            Q_reg <= Q;\n    end\n\n    assign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output [63:0] next_Q\n);\n\n    assign next_Q = {current_Q[62:0], current_Q[63]};\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_hi, A_lo, B_hi, B_lo;\n    wire [15:0] A_hi_lo, B_hi_lo;\n    wire [7:0] A_hi_lo_lo, B_hi_lo_lo;\n\n    // Instantiate the 32-bit subtractor module\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_hi_lo)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_lo)\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_hi, A_lo, B_hi, B_lo;\n    wire [7:0] A_hi_lo, B_hi_lo;\n    wire [3:0] A_hi_lo_lo, B_hi_lo_lo;\n\n    // Instantiate the 16-bit subtractor module\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_hi_lo)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_lo)\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_hi, A_lo, B_hi, B_lo;\n    wire [3:0] A_hi_lo, B_hi_lo;\n    wire [1:0] A_hi_lo_lo, B_hi_lo_lo;\n\n    // Instantiate the 8-bit subtractor module\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_hi_lo)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_lo)\n    );\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_hi, A_lo, B_hi, B_lo;\n    wire [1:0] A_hi_lo, B_hi_lo;\n    wire [0] A_hi_lo_lo, B_hi_lo_lo;\n\n    // Instantiate the 4-bit subtractor module\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Assign the output of the logic module to the register module\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n    always @(*) begin\n        next_state = current_state;\n        if (current_state[0] == 1'b0) begin\n            next_state[0] = 1'b1;\n        end else begin\n            next_state = {current_state[62:0], current_state[63]};\n        end\n    end\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result[31:0]),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result;\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Assign the output to the register output\n    assign Q = current_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= next_state;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output [63:0] next_state\n);\n\n    assign next_state = current_state ^ {current_state[63], current_state[62:0]};\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n\n  // Fetch stage\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc),\n    .instr(alu_result)\n  );\n\n  // Decode stage\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(alu_result),\n    .pc(pc),\n    .next_pc(next_pc),\n    .reg_file(reg_file),\n    .alu_result(alu_result)\n  );\n\n  // Execute stage\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .alu_result(alu_result)\n  );\n\n  // Memory stage\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .alu_result(alu_result)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc,\n  output [31:0] instr\n);\n  reg [31:0] pc_reg;\n  reg [31:0] next_pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      next_pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      pc_reg <= next_pc_reg;\n      next_pc_reg <= pc_reg + 1;\n      instr_reg <= instr_mem[pc_reg];\n    end\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = next_pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [31:0] pc,\n  input [31:0] next_pc,\n  input [31:0] reg_file [0:31],\n  output [31:0] alu_result\n);\n  wire [4:0] opcode;\n  wire [4:0] rs1, rs2, rd;\n  wire [31:0] imm;\n\n  assign opcode = instr[31:28];\n  assign rs1 = instr[27:22];\n  assign rs2 = instr[21:16];\n  assign rd = instr[15:11];\n  assign imm = instr[31:20];\n\n  // ALU\n  alu alu (\n    .opcode(opcode),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .rd(reg_file[rd]),\n    .imm(imm),\n    .alu_result(alu_result)\n  );\n\n  // Writeback\n  always @(posed"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    // Assign the output\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= Q + 1;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output [63:0] next_Q\n);\n\n    assign next_Q = current_Q & (~current_Q + 1);\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] diff;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(diff[31:0]),\n        .B_out(B_out)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(diff[63:32]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [31:0] diff;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(diff[15:0]),\n        .B_out(B_out)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(diff[31:16]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] diff;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(diff[7:0]),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(diff[15:8]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] diff;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(diff[3:0]),\n        .B_out(B_out)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(diff[7:4]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] diff;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(diff[1:0]),\n        .B_out(B_out)\n    );\n\n    sub_2bit sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(diff[3:2]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0] A, B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] diff;\n\n    sub_1bit sub0(\n        .A(A[0]),\n        .B(B[0]),\n        .D(diff[0]),\n        .B_out(B_out)\n    );"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] next_Q;\n    wire [63:0] current_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .current_Q(current_Q),\n        .next_Q(next_Q)\n    );\n\n    // Assign the output\n    assign Q = next_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= Q + 1;\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_Q,\n    output [63:0] next_Q\n);\n    assign next_Q = current_Q[0] ? current_Q + 1 : current_Q;\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] accumulator_result;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result[31:0]),\n        .current_value(accumulator_result)\n    );\n\n    // Connect the outputs\n    assign c = accumulator_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 2'b11) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 4'b1001) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 7'b11111111) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_low, A_high;\n    wire [31:0] B_low, B_high;\n    wire [31:0] D_low, D_high;\n    wire [31:0] B_out_low, B_out_high;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign the outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_low, A_high;\n    wire [15:0] B_low, B_high;\n    wire [15:0] D_low, D_high;\n    wire [15:0] B_out_low, B_out_high;\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign the outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_low, A_high;\n    wire [7:0] B_low, B_high;\n    wire [7:0] D_low, D_high;\n    wire [7:0] B_out_low, B_out_high;\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D_high),\n        .B_out(B_out_high)\n    );\n\n    // Assign the outputs\n    assign D = {D_high, D_low};\n    assign B_out = {B_out_high, B_out_low};\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_low, A"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n    wire [31:0] current_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(current_value)\n    );\n\n    // Connect the outputs\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] accumulator_result;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result),\n        .current_value(accumulator_result)\n    );\n\n    // Connect the outputs\n    assign c = accumulator_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter == 4) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else\n            counter <= counter + 1;\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter == 49) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else\n            counter <= counter + 1;\n    end\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] accumulator_result;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(mult_result),\n        .current_value(accumulator_result)\n    );\n\n    // Connect the outputs\n    assign c = accumulator_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] sub0_out;\n    wire [63:0] sub1_out;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(sub0_out),\n        .B_out(B_out)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(sub1_out),\n        .B_out(B_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [31:0] sub0_out;\n    wire [31:0] sub1_out;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(sub0_out),\n        .B_out(B_out)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(sub1_out),\n        .B_out(B_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] sub0_out;\n    wire [15:0] sub1_out;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(sub0_out),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(sub1_out),\n        .B_out(B_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] sub0_out;\n    wire [7:0] sub1_out;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(sub0_out),\n        .B_out(B_out)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(sub1_out),\n        .B_out(B_out)\n    );\n\n    assign D = sub0_out + sub1_out;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] sub0_out;\n    wire [3:0] sub1_out;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(sub0_out),\n        .B_out(B_out"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  reg [15:0] b1, b2, b3;\n  wire [31:0] c1_temp, c2_temp, c3_temp;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_temp)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2_temp)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3_temp)\n  );\n\n  assign c1 = c1_temp;\n  assign c2 = c2_temp;\n  assign c3 = c3_temp;\n\nendmodule\n\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 9) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 99) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register instructions\n    ins_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register for RAM/ROM instructions\n    ins_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ins1[4:0] : ins2[4:0];\n    assign ad2 = (fetch == 2'b10) ? ins2 : ins1;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n        end else begin\n            ins <= data;\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n        end else begin\n            ins <= data;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register from RAM/ROM\n    ins_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register from register\n    ins_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ins1[4:0] : ad1;\n    assign ad2 = (fetch == 2'b10) ? ins2[7:0] : ad2;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                counter <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                counter <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] A_high;\n    wire [31:0] B_high;\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [7:0] A_low_high;\n    wire [7:0] B_low_high;\n    wire [7:0] A_low_low;\n    wire [7:0] B_low_low;\n\n    assign A_high = A[63:32];\n    assign B_high = B[63:32];\n    assign A_low = A[31:16];\n    assign B_low = B[31:16];\n    assign A_low_high = A[15:8];\n    assign B_low_high = B[15:8];\n    assign A_low_low = A[7:0];\n    assign B_low_low = B[7:0];\n\n    sub_32bit sub0(\n        .A(A_high),\n        .B(B_high),\n        .D(D[63:32]),\n        .B_out(B_out)\n    );\n\n    sub_16bit sub1(\n        .A(A_low),\n        .B(B_low),\n        .D(D[31:16]),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub2(\n        .A(A_low_high),\n        .B(B_low_high),\n        .D(D[15:8]),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub3(\n        .A(A_low_low),\n        .B(B_low_low),\n        .D(D[7:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] A_high;\n    wire [15:0] B_high;\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n\n    assign A_high = A[31:16];\n    assign B_high = B[31:16];\n    assign A_low = A[15:8];\n    assign B_low = B[15:8];\n\n    sub_16bit sub0(\n        .A(A_high),\n        .B(B_high),\n        .D(D[31:16]),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub1(\n        .A(A_low),\n        .B(B_low),\n        .D(D[15:8]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] A_high;\n    wire [7:0] B_high;\n    wire [3:0] A_low;\n    wire [3:0] B_low;\n\n    assign A_high = A[15:8];\n    assign B_high = B[15:8];\n    assign A_low = A[3:0];\n    assign B_low = B[3:0];\n\n    sub_4bit sub0(\n        .A(A_high),\n        .B(B_high),\n        .D(D[15:8]),\n        .B_out(B_out)\n    );\n\n    sub_4"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for register source\n    reg [7:0] ins_reg_p1;\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_reg_p2;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_reg_p1 <= 0;\n            ins_reg_p2 <= 0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg_p1 <= data;\n            end else if (fetch == 2'b10) begin\n                ins_reg_p2 <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_reg_p1;\n    assign ins_p2 = ins_reg_p2;\n\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[7:5], ins_p2[7:5]};\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_div_50_out, clk_div_10_out, clk_div_1_out;\n\n    clk_div clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_50_out)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_10_out)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_1_out)\n    );\n\n    assign CLK_50 = clk_div_50_out;\n    assign CLK_10 = clk_div_10_out;\n    assign CLK_1 = clk_div_1_out;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    // Instruction register for register instructions\n    reg [7:0] ins_p1;\n    reg [7:0] ins_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'b0;\n            ins_p2 <= 8'b0;\n        end\n        else begin\n            case (fetch)\n                2'b01: ins_p1 <= data;\n                2'b10: ins_p2 <= data;\n                default: ;\n            endcase\n        end\n    end\n\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[7:5], ins_p2[7:5]};\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] A_high, B_high;\n    wire [15:0] A_low, B_low;\n    wire [7:0] A_low_high, B_low_high;\n\n    assign A_high = A[63:32];\n    assign A_low = A[31:0];\n    assign B_high = B[63:32];\n    assign B_low = B[31:0];\n    assign A_low_high = A_low[15:8];\n    assign B_low_high = B_low[15:8];\n\n    sub_32bit sub0(A_high, B_high, D[63:32]);\n    sub_32bit sub1(A_low, B_low, D[31:0]);\n\n    sub_16bit sub0_low(A_low_high, B_low_high, D[15:0]);\n    sub_16bit sub1_low(A_low[7:0], B_low[7:0], D[7:0]);\n\n    sub_8bit sub0_low_high(A_low_high, B_low_high, D[15:8]);\n    sub_8bit sub1_low_high(A_low_high, B_low_high, D[7:0]);\n\n    assign B_out = D[63];\n\nendmodule\n\nmodule sub_32bit(A, B, D);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n\n    wire [15:0] A_high, B_high;\n    wire [7:0] A_low, B_low;\n\n    assign A_high = A[31:16];\n    assign A_low = A[15:0];\n    assign B_high = B[31:16];\n    assign B_low = B[15:0];\n\n    sub_16bit sub0(A_high, B_high, D[31:16]);\n    sub_16bit sub1(A_low, B_low, D[15:0]);\nendmodule\n\nmodule sub_16bit(A, B, D);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n\n    wire [7:0] A_high, B_high;\n    wire [3:0] A_low, B_low;\n\n    assign A_high = A[15:8];\n    assign A_low = A[3:0];\n    assign B_high = B[15:8];\n    assign B_low = B[3:0];\n\n    sub_8bit sub0(A_high, B_high, D[15:8]);\n    sub_8bit sub1(A_low, B_low, D[3:0]);\nendmodule\n\nmodule sub_8bit(A, B, D);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n\n    assign D = A - B;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register\n    ins_reg_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register for RAM/ROM\n    ins_reg_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ins1[4:0] : ins2[4:0];\n    assign ad2 = (fetch == 2'b10) ? ins2 : ins1;\n\nendmodule\n\nmodule ins_reg_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n        end else begin\n            ins <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 2) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 9) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 99) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register source\n    ins_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register for RAM/ROM source\n    ins_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? data[4:0] : ins1[4:0];\n    assign ad2 = (fetch == 2'b10) ? data : ins2;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register from RAM/ROM\n    ins_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register from register\n    ins_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    // Output logic\n    assign ins = fetch[1] ? ins2[2:0] : ins1[2:0];\n    assign ad1 = fetch[1] ? ins2[4:0] : ins1[4:0];\n    assign ad2 = fetch[1] ? ins2 : ins1;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n        end else begin\n            ins <= data;\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n        end else begin\n            ins <= data;\n        end\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_low;\n    wire [31:0] B_low;\n    wire [31:0] D_low;\n    wire [31:0] B_out_low;\n\n    assign A_low = A[31:0];\n    assign B_low = B[31:0];\n\n    sub_32bit sub0(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    assign D = {D_low, A[63:32]};\n    assign B_out = {B_out_low, B[63:32]};\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] A_low;\n    wire [15:0] B_low;\n    wire [15:0] D_low;\n    wire [15:0] B_out_low;\n\n    assign A_low = A[15:0];\n    assign B_low = B[15:0];\n\n    sub_16bit sub0(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    assign D = {D_low, A[31:16]};\n    assign B_out = {B_out_low, B[31:16]};\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] A_low;\n    wire [7:0] B_low;\n    wire [7:0] D_low;\n    wire [7:0] B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit sub0(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    assign D = {D_low, A[15:8]};\n    assign B_out = {B_out_low, B[15:8]};\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output [7:0] B_out;\n\n    wire [3:0] A_low;\n    wire [3:0] B_low;\n    wire [3:0] D_low;\n    wire [3:0] B_out_low;\n\n    assign A_low = A[3:0];\n    assign B_low = B[3:0];\n\n    sub_4bit sub0(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_out_low)\n    );\n\n    assign D = {D_low, A[7:4]};\n    assign B_out = {B_out_low, B[7:4]};\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register source\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register for RAM/ROM source\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? data[4:0] : ins1[4:0];\n    assign ad2 = (fetch == 2'b10) ? data : ins2;\n\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [7:0] ins\n);\n    reg [7:0] current;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            current <= 0;\n        else\n            current <= data;\n    end\n\n    assign ins = current;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_div_50;\n    wire clk_div_10;\n    wire clk_div_1;\n\n    clk_div clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_50)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_10)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_1)\n    );\n\n    assign CLK_50 = clk_div_50;\n    assign CLK_10 = clk_div_10;\n    assign CLK_1 = clk_div_1;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else begin\n            if (counter == 3) begin\n                counter <= 0;\n                CLK_out <= ~CLK_out;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for port 1\n    reg [7:0] ins_r1;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_r1 <= 0;\n        end else if (fetch == 2'b01) begin\n            ins_r1 <= data;\n        end\n    end\n\n    // Instruction register for port 2\n    reg [7:0] ins_r2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_r2 <= 0;\n        end else if (fetch == 2'b10) begin\n            ins_r2 <= data;\n        end\n    end\n\n    // Output assignments\n    assign ins_p1 = ins_r1;\n    assign ins_p2 = ins_r2;\n    assign ins = {ins_p2[7:5], ins_p1[7:5]};\n    assign ad1 = ins_p2[4:0];\n    assign ad2 = ins_p1;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register source\n    reg [7:0] ins_p1;\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_p2;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_p1 <= 8'b0;\n            ins_p2 <= 8'b0;\n        end\n        else begin\n            case (fetch)\n                2'b01: ins_p1 <= data;\n                2'b10: ins_p2 <= data;\n                default: ;\n            endcase\n        end\n    end\n\n    assign ins = {ins_p2[7:5], ins_p1[7:5]};\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output [63:0] B_out;\n\n    wire [31:0] A_lo, A_hi, B_lo, B_hi;\n    wire [15:0] A_lo_lo, A_lo_hi, A_hi_lo, A_hi_hi;\n    wire [15:0] B_lo_lo, B_lo_hi, B_hi_lo, B_hi_hi;\n    wire [7:0] A_lo_lo_lo, A_lo_lo_hi, A_lo_hi_lo, A_lo_hi_hi;\n    wire [7:0] B_lo_lo_lo, B_lo_lo_hi, B_lo_hi_lo, B_lo_hi_hi;\n    wire [7:0] A_hi_hi_lo, A_hi_hi_hi;\n    wire [7:0] B_hi_hi_lo, B_hi_hi_hi;\n\n    // Instantiate the 32-bit subtractor modules\n    sub_32bit sub0(A_lo, B_lo, D[31:0], B_out[31:0]);\n    sub_32bit sub1(A_hi, B_hi, D[63:32], B_out[63:32]);\n\n    // Instantiate the 16-bit subtractor modules\n    sub_16bit sub0_lo(A_lo_lo, B_lo_lo, D[15:0], B_out[15:0]);\n    sub_16bit sub0_hi(A_lo_hi, B_lo_hi, D[31:16], B_out[31:16]);\n    sub_16bit sub1_lo(A_hi_lo, B_hi_lo, D[47:32], B_out[47:32]);\n    sub_16bit sub1_hi(A_hi_hi, B_hi_hi, D[63:48], B_out[63:48]);\n\n    // Instantiate the 8-bit subtractor modules\n    sub_8bit sub0_lo_lo(A_lo_lo_lo, B_lo_lo_lo, D[7:0], B_out[7:0]);\n    sub_8bit sub0_lo_hi(A_lo_lo_hi, B_lo_lo_hi, D[15:8], B_out[15:8]);\n    sub_8bit sub0_hi_lo(A_lo_hi_lo, B_lo_hi_lo, D[23:16], B_out[23:16]);\n    sub_8bit sub0_hi_hi(A_lo_hi_hi, B_lo_hi_hi, D[31:24], B_out[31:24]);\n\n    // Instantiate the 4-bit subtractor modules\n    sub_4bit sub0_lo_lo_lo(A_lo_lo_lo, B_lo_lo_lo, D[3:0], B_out[3:0]);\n    sub_4bit sub0_lo_lo_hi(A_lo_lo_hi, B_lo_lo_hi, D[7:4], B_out[7:4]);\n    sub_4bit sub0_lo_hi_lo(A_lo_hi_lo, B_lo_hi_lo, D[11:8], B_out[11:8]);\n    sub_4bit sub0_lo_hi_hi(A_lo_hi_hi, B_lo_hi_hi, D[15:12], B_out[15:12]);\n    sub_4bit sub0_hi_lo_lo(A_hi_lo_lo, B_hi_lo_lo, D[19:16], B_out[19:16]);\n    sub_4bit sub0_hi_lo_hi(A_hi_lo_hi, B_hi"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 2'b00;\n            CLK_out <= 1'b0;\n        end else begin\n            if (counter == 2'b11) begin\n                counter <= 2'b00;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 4'b0000;\n            CLK_out <= 1'b0;\n        end else begin\n            if (counter == 4'b1001) begin\n                counter <= 4'b0000;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 7'b00000000;\n            CLK_out <= 1'b0;\n        end else begin\n            if (counter == 7'b11111111) begin\n                counter <= 7'b0000000;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for register source\n    reg [7:0] ins_reg_p1;\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_reg_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg_p1 <= 8'b0;\n            ins_reg_p2 <= 8'b0;\n        end\n        else begin\n            if (fetch == 2'b01) begin\n                ins_reg_p1 <= data;\n            end\n            else if (fetch == 2'b10) begin\n                ins_reg_p2 <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_reg_p1;\n    assign ins_p2 = ins_reg_p2;\n\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[7:5], ins_p2[7:5]};\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  input clk,\n  input rst,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter == 4) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else\n            counter <= counter + 1;\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter == 49) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else\n            counter <= counter + 1;\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for register input\n    reg [7:0] ins_reg;\n\n    // Instruction register for RAM/ROM input\n    reg [7:0] ins_ram_reg;\n\n    // Instruction register for RAM/ROM input\n    reg [7:0] ins_rom_reg;\n\n    // Instruction register for register input\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_reg <= 8'b0;\n            ins_ram_reg <= 8'b0;\n            ins_rom_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_ram_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM input\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_ram_reg <= 8'b0;\n            ins_rom_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_ram_reg <= data;\n            end else if (fetch == 2'b01) begin\n                ins_rom_reg <= data;\n            end\n        end\n    end\n\n    // Outputs\n    assign ins = ins_reg;\n    assign ad1 = ins_reg[4:0];\n    assign ad2 = ins_ram_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] borrow;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow[0])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow[1])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(borrow[2])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(borrow[3])\n    );\n\n    // Combine the borrow outputs to get the final borrow-out\n    assign B_out = borrow[0] & borrow[1] & borrow[2] & borrow[3];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    full_subtractor fs1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(borrow[0])\n    );\n\n    full_subtractor fs2(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(borrow[1])\n    );\n\n    full_subtractor fs3(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(borrow[2])\n    );\n\n    full_subtractor fs4(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] diff;\n    wire [3:0] borrow;\n\n    assign diff = A - B;\n    assign B_out = A[3] & B[3] | diff[3];\n\n    assign D = {diff[2:0], borrow[0]};\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  wire [31:0] c0_temp, c1_temp, c2_temp, c3_temp;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0_temp)\n  );\n\n  PE pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1_temp)\n  );\n\n  PE pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2_temp)\n  );\n\n  PE pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3_temp)\n  );\n\n  assign c0 = c0_temp;\n  assign c1 = c1_temp;\n  assign c2 = c2_temp;\n  assign c3 = c3_temp;\n\nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for port 1\n    instr_reg_sub ins_p1_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1)\n    );\n\n    // Instruction register for port 2\n    instr_reg_sub ins_p2_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2)\n    );\n\n    // Output assignment\n    assign ins = fetch[1] ? ins_p2[7:5] : ins_p1[7:5];\n    assign ad1 = fetch[1] ? ins_p2[4:0] : ins_p1[4:0];\n    assign ad2 = fetch[1] ? data : ins_p2;\n\nendmodule\n\nmodule instr_reg_sub (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 4'b1111)\n            CLK_out <= ~CLK_out;\n        else\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 7'b11111111)\n            CLK_out <= ~CLK_out;\n        else\n            count <= count + 1;\n    end\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub4bit sub1(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15:12])\n    );\n\n    sub4bit sub2(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11:8])\n    );\n\n    sub4bit sub3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7:4])\n    );\n\n    sub4bit sub4(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    full_subtractor fs1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_wire[3:2])\n    );\n\n    full_subtractor fs2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_wire[1:0])\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_wire;\n\n    full_subtractor fs1(\n        .A(A[1]),\n        .B(B[1]),\n        .D(D[1]),\n        .B_out(B_out_wire[1])\n    );\n\n    full_subtractor fs2(\n        .A(A[0]),\n        .B(B[0]),\n        .D(D[0]),\n        .B_out(B_out_wire[0])\n    );\n\n    assign B_out = B_out_wire[1] ^ B_out_wire[0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register instructions\n    instr_reg_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register for RAM/ROM instructions\n    instr_reg_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ins1[4:0] : ins2[4:0];\n    assign ad2 = (fetch == 2'b10) ? ins2[7:0] : ins1[7:0];\n\nendmodule\n\nmodule instr_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'b0;\n        end else begin\n            ins <= data;\n        end\n    end\n\nendmodule\n\nmodule instr_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'b0;\n        end else begin\n            ins <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Instruction register for register source\n    reg [7:0] ins_p1;\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'b0;\n            ins_p2 <= 8'b0;\n        end\n        else begin\n            case (fetch)\n                2'b01: ins_p1 <= data;\n                2'b10: ins_p2 <= data;\n                default: ;\n            endcase\n        end\n    end\n\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[7:0], ins_p2[7:0]};\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_div_50, clk_div_10, clk_div_1;\n\n    clk_div clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_50)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_10)\n    );\n\n    clk_div clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_1)\n    );\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  wire [31:0] c0_int, c1_int, c2_int, c3_int;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0_int)\n  );\n  PE pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1_int)\n  );\n  PE pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2_int)\n  );\n  PE pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3_int)\n  );\n\n  assign c0 = c0_int;\n  assign c1 = c1_int;\n  assign c2 = c2_int;\n  assign c3 = c3_int;\n\nendmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire enable;\n\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    assign enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub4_16bit sub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    sub4_16bit sub2(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(B_out)\n    );\n\n    sub4_16bit sub3(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(B_out)\n    );\n\n    sub4_16bit sub4(\n        .A(D),\n        .B(B),\n        .D(D),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub4_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    sub4_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[0])\n    );\n\n    sub4_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[1])\n    );\n\n    sub4_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[2])\n    );\n\n    sub4_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[3])\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule sub4_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] B_out_wire;\n\n    sub4_2bit sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_wire[0])\n    );\n\n    sub4_2bit sub2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_wire[1])\n    );\n\n    assign B_out = B_out_wire[1];\n\nendmodule\n\nmodule sub4_2bit(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [0:0] B_out_wire;\n\n    sub4_1bit sub1(\n        .A(A[0]),\n        .B(B[0]),\n        .D(D[0]),\n        .B_out(B_out_wire[0])\n    );\n\n    sub4_1bit sub2(\n        .A(A[1]),\n        .B(B[1]),\n        .D(D[1]),\n        .B_out(B_out_wire[1])\n    );\n\n    assign B_out"}
{"task_id": "square_wave", "response": "wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq > 0);\n\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .frequency(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] frequency,\n    output wave_out\n);\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (count == (frequency / 2)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire toggle;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1)\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (count == freq - 1)\n            wave_out_reg <= ~wave_out_reg;\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] borrow;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(borrow[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] carry;\n\n    full_subtractor fsub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .C_out(carry[0])\n    );\n\n    full_subtractor fsub2(\n        .A(A),\n        .B(B),\n        .D(D),\n        .C_out(carry[1])\n    );\n\n    full_subtractor fsub3(\n        .A(A),\n        .B(B),\n        .D(D),\n        .C_out(carry[2])\n    );\n\n    full_subtractor fsub4(\n        .A(A),\n        .B(B),\n        .D(D),\n        .C_out(carry[3])\n    );\n\n    assign B_out = carry[3];\nendmodule\n\nmodule full_subtractor(A, B, D, C_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output C_out;\n\n    wire [3:0] borrow;\n\n    assign D = A - B - borrow;\n    assign C_out = (A < B) ? 1 : borrow[3];\n    assign borrow = {borrow[2:0], A[3]};\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire toggle;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1)\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg toggle;\n\n    always @(posedge clk) begin\n        if (count == freq - 1)\n            toggle <= ~toggle;\n    end\n\n    assign wave_out = toggle;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_1 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire toggle;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1)\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg toggle;\n\n    always @(posedge clk) begin\n        if (count == freq - 1)\n            toggle <= ~toggle;\n    end\n\n    assign wave_out = toggle;\n\nendmodule"}
{"task_id": "square_wave", "response": "wire [7:0] count;\n    wire [7:0] next_count;\n\n    assign wave_out = count[0];\n\n    always @(posedge clk) begin\n        if (freq > 0) begin\n            count <= next_count;\n        end\n    end\n\n    assign next_count = (count == (freq - 1)) ? 0 : count + 1;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[31:28])\n                4'b0000: begin // ADD\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[55:32];\n                    result <= op1 + op2;\n                end\n                4'b0001: begin // SUB\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[55:32];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= reg_file[result[4:0]];\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [3:0] B_out_sub1, B_out_sub2, B_out_sub3, B_out_sub4;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_sub1)\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_sub2)\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_sub3)\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_sub4)\n    );\n\n    // Combine the borrow-out signals from each sub-block\n    assign B_out = B_out_sub1 & B_out_sub2 & B_out_sub3 & B_out_sub4;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [2:0] B_out_sub1, B_out_sub2;\n\n    // Instantiate the 2-bit full subtractor blocks\n    sub_2bit sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_sub1)\n    );\n\n    sub_2bit sub2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_sub2)\n    );\n\n    // Combine the borrow-out signals from each sub-block\n    assign B_out = B_out_sub1 & B_out_sub2;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire B_out_sub1;\n\n    // Instantiate the 1-bit full subtractor block\n    sub_1bit sub1(\n        .A(A[0]),\n        .B(B[0]),\n        .D(D[0]),\n        .B_out(B_out_sub1)\n    );\n\n    // Combine the borrow-out signals from each sub-block\n    assign B_out = B_out_sub1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\n    input A;\n    input B;\n    output D;\n    output B_out;\n\n    wire B_out_sub1;\n\n    // Instantiate the full subtractor block\n    full_subtractor sub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_sub1)\n    );\n\n    // Combine the borrow-out signals from each sub-block\n    assign B_out = B_out_sub1;\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input A;\n    input B;\n    output D;\n    output B_out;"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [3:0] counter;\n    wire clk_div_int1, clk_div_int2;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .clk_div(clk_div_int1),\n        .clk_div_int2(clk_div_int2)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div_int2(clk_div_int2),\n        .clk_div_int1(clk_div_int1)\n    );\n\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               clk_div,\n    output reg          clk_div_int2\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (clk_div) begin\n            counter <= counter + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (counter == 2) begin\n            clk_div_int2 <= 1;\n            counter <= 0;\n        end else begin\n            clk_div_int2 <= 0;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div_int2,\n    output reg          clk_div_int1\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (clk_div_int2) begin\n            counter <= counter + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (counter == 2) begin\n            clk_div_int1 <= 1;\n            counter <= 0;\n        end else begin\n            clk_div_int1 <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire toggle;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n    reg toggle;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            toggle <= ~toggle;\n    end\n\n    assign wave_out = toggle;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire enable;\n\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    assign enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave_out_reg <= ~wave_out_reg;\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [3:0] counter;\n    wire clk_4, clk_3;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4),\n        .clk_div_2(clk_3)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_div(clk_div)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div(clk_div),\n        .clk_div_2(clk_3)\n    );\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    clk_div,\n    output reg         clk_div_2\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n            clk_div_2 <= 0;\n        end else begin\n            if (clk_div == MUL2_DIV_CLK) begin\n                clk_div <= 0;\n                clk_div_2 <= 1;\n            end else begin\n                clk_div <= clk_div + 1;\n                clk_div_2 <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               clk_4,\n    input               clk_3,\n    output reg          clk_div\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 2'b11) begin\n            clk_div <= clk_4;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div,\n    input               clk_div_2,\n    output reg          clk_div_neg\n);\n\n    always @(posedge clk) begin\n        clk_div_neg <= clk_div_2;\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq > 0);\n\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[31:26])\n                6'b000000: begin // ADD\n                    op1 <= fetched_instr[5:0];\n                    op2 <= fetched_instr[31:26];\n                    result <= op1 + op2;\n                end\n                6'b001010: begin // SUB\n                    op1 <= fetched_instr[5:0];\n                    op2 <= fetched_instr[31:26];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] out_reg_file_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file_reg <= 0;\n        end else begin\n            out_reg_file_reg <= result;\n        end\n    end\n    assign out_reg_file = out_reg_file_reg;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Cin(1'b0),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Cin(B_out_wire[3]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Cin(B_out_wire[7]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Cin(B_out_wire[11]),\n        .D(D[15:12]),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, Cin, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    input Cin;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] C;\n\n    full_subtractor fs1(\n        .A(A),\n        .B(B),\n        .Cin(Cin),\n        .D(D),\n        .Cout(C)\n    );\n\n    full_subtractor fs2(\n        .A(C),\n        .B(4'b0000),\n        .Cin(1'b0),\n        .D(C),\n        .Cout(B_out)\n    );\nendmodule\n\nmodule full_subtractor(A, B, Cin, D, Cout);\n    input [3:0] A;\n    input [3:0] B;\n    input Cin;\n    output [3:0] D;\n    output Cout;\n\n    wire [3:0] C;\n\n    assign C[0] = A[0] ^ B[0] ^ Cin;\n    assign D[0] = A[0] ^ B[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < 4; i = i + 1) begin : bit_loop\n            assign C[i] = A[i] ^ B[i] ^ C[i-1];\n            assign D[i] = A[i] ^ B[i];\n        end\n    endgenerate\n\n    assign Cout = C[3];\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire enable;\n\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    assign enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave <= ~wave;\n    end\n\n    assign wave_out = wave;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out;\n\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            wave_out <= ~wave_out;\n        end\n    end\n\n    assign wave_out = wave_out;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15])\n    );\n\n    // Output the borrow-out\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    // Instantiate the 4-bit full subtractor block\n    full_subtractor fs(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    // Output the borrow-out\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign D = A - B;\n    assign B_out = borrow[3];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    wire clk_4, clk_3;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div(clk_4),\n        .clk_div_2(clk_3)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div(clk_3),\n        .clk_div_2(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [1:0] clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 2'b00;\n        end else begin\n            clk_div <= clk_div + 2'b01;\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div,\n    input               clk_div_2,\n    output reg          clk_div_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 2'b10) begin\n            clk_div_out <= clk_div;\n            counter <= 2'b00;\n        end else begin\n            counter <= counter + 2'b01;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div,\n    input               clk_div_2,\n    output reg          clk_div_out\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 2'b10) begin\n            clk_div_out <= clk_div_2;\n            counter <= 2'b00;\n        end else begin\n            counter <= counter + 2'b01;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .fetched_instr(fetched_instr),\n        .pc(pc)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr,\n    output reg [4:0] pc\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n            fetched_instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[6:0])\n                6'b000000: begin // ADD\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 + op2;\n                end\n                6'b001010: begin // SUB\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file[result[4:0]] <= result;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    // Counter module\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .count(count)\n    );\n\n    // Square wave generator module\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    // Enable signal based on frequency value\n    assign enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n    reg wave;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave <= ~wave;\n    end\n\n    assign wave_out = wave;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire toggle;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg toggle;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            toggle <= ~toggle;\n    end\n\n    assign wave_out = toggle;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [3:0] B_out_sub1;\n    wire [3:0] B_out_sub2;\n    wire [3:0] B_out_sub3;\n    wire [3:0] B_out_sub4;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_sub1)\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_sub2)\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_sub3)\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_sub4)\n    );\n\n    assign B_out = B_out_sub1 & B_out_sub2 & B_out_sub3 & B_out_sub4;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_sub1;\n    wire [3:0] B_out_sub2;\n\n    full_subtractor fs1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_sub1)\n    );\n\n    full_subtractor fs2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_sub2)\n    );\n\n    assign B_out = B_out_sub1 & B_out_sub2;\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_sub1;\n\n    full_subtractor fs1(\n        .A(A[0]),\n        .B(B[0]),\n        .D(D[0]),\n        .B_out(B_out_sub1)\n    );\n\n    assign D[1] = A[1] ^ B[1] ^ B_out_sub1;\n    assign B_out = A[1] & B[1] | A[1] & B_out_sub1 | B[1] & B_out_sub1;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    parameter MUL2_DIV_CLK = 7;\n\n    reg [MUL2_DIV_CLK-1:0] counter;\n    wire clk_div_int1, clk_div_int2;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .clk_div(clk_div_int1),\n        .clk_div_int2(clk_div_int2)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div_int2(clk_div_int2),\n        .clk_div(clk_div_int1)\n    );\n\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK-1:0] clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               clk_div,\n    output reg          clk_div_int2\n);\n    reg [1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_int2 <= 0;\n        end else begin\n            if (counter == 2'b11) begin\n                clk_div_int2 <= clk_div;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div_int2,\n    output reg          clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div_int2;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[6:0])\n                6'b000000: begin // ADD\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 + op2;\n                end\n                6'b001010: begin // SUB\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= reg_file[result[4:0]];\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] waveform;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            waveform <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    waveform <= waveform + 1;\n                    if (waveform == 5'b11111) state <= 2'b01;\n                end\n                2'b01: begin\n                    waveform <= waveform - 1;\n                    if (waveform == 5'b00000) state <= 2'b10;\n                end\n                2'b10: begin\n                    waveform <= waveform + 1;\n                    if (waveform == 5'b11111) state <= 2'b11;\n                end\n                2'b11: begin\n                    waveform <= waveform - 1;\n                    if (waveform == 5'b00000) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = waveform;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire clk_4, clk_3;\n    reg [3:0] counter;\n    wire clk_avg, clk_adj;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(counter)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .counter(counter),\n        .clk_out(clk_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_avg(clk_avg),\n        .clk_out(clk_adj)\n    );\n\n    assign clk_4 = counter[3];\n    assign clk_3 = counter[2];\n\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    clk_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_out <= 0;\n        else\n            clk_out <= clk_out + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input [3:0]        counter,\n    output reg         clk_out\n);\n    always @(posedge clk) begin\n        if (counter[0])\n            clk_out <= 1;\n        else if (counter[1])\n            clk_out <= 0;\n        else if (counter[2])\n            clk_out <= 1;\n        else if (counter[3])\n            clk_out <= 0;\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_avg,\n    output reg         clk_out\n);\n    always @(posedge clk) begin\n        clk_out <= clk_avg;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State machine to control waveform generation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b01111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b01111) state <= 2'b11;\n                end\n                2'b11: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    // Output waveform\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [3:0] B_out_sub1, B_out_sub2, B_out_sub3, B_out_sub4;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_sub1)\n    );\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_sub2)\n    );\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_sub3)\n    );\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_sub4)\n    );\n\n    // Combine the outputs of the 4-bit subtractors to get the final borrow-out\n    assign B_out = B_out_sub1 | B_out_sub2 | B_out_sub3 | B_out_sub4;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [2:0] B_out_sub1, B_out_sub2;\n\n    // Instantiate the 2-bit full subtractor blocks\n    sub_2bit sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_sub1)\n    );\n    sub_2bit sub2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_sub2)\n    );\n\n    // Combine the outputs of the 2-bit subtractors to get the final borrow-out\n    assign B_out = B_out_sub1 | B_out_sub2;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [0] B_out_sub1;\n\n    // Instantiate the 1-bit full subtractor block\n    sub_1bit sub1(\n        .A(A[0]),\n        .B(B[0]),\n        .D(D[0]),\n        .B_out(B_out_sub1)\n    );\n\n    // Combine the outputs of the 1-bit subtractors to get the final borrow-out\n    assign B_out = B_out_sub1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\n    input A;\n    input B;\n    output D;\n    output B_out;\n\n    wire B_out_sub1;\n\n    // Instantiate the full subtractor block\n    full_subtractor sub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_sub1)\n    );\n\n    // Combine the outputs of the full subtractors to get the final borrow-out\n    assign B_out = B_out_sub1;\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .fetched_instr(fetched_instr),\n        .pc(pc)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr,\n    output reg [4:0] pc\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n            fetched_instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[6:0])\n                6'b000000: begin // ADD\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 + op2;\n                end\n                6'b000100: begin // SUB\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= reg_file;\n            out_reg_file[result[4:0]] <= result;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State machine for waveform generation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output waveform\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] borrow;\n\n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow[0])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow[1])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(borrow[2])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(borrow[3])\n    );\n\n    assign B_out = borrow[3];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    full_subtractor sub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(borrow[0])\n    );\n\n    assign B_out = borrow[0];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign D = A - B - borrow;\n    assign B_out = borrow[3];\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire [MUL2_DIV_CLK:0] clk_div_int;\n    wire clk_div_avg;\n    wire clk_div_adj;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_out(clk_div_int)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div_in(clk_div_int),\n        .clk_div_out(clk_div_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div_in(clk_div_avg),\n        .clk_div_out(clk_div_adj)\n    );\n\n    assign clk_div = clk_div_adj | clk_div_int;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK:0] clk_div_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_out <= 0;\n        else\n            clk_div_out <= clk_div_out + 1;\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input [MUL2_DIV_CLK:0] clk_div_in,\n    output              clk_div_out\n);\n\n    reg [MUL2_DIV_CLK:0] clk_div_reg;\n    reg clk_div_out_reg;\n\n    always @(posedge clk) begin\n        clk_div_reg <= clk_div_in;\n        clk_div_out_reg <= (clk_div_reg[MUL2_DIV_CLK] == 1) ? 1'b1 : 1'b0;\n    end\n\n    assign clk_div_out = clk_div_out_reg;\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input [MUL2_DIV_CLK:0] clk_div_in,\n    output              clk_div_out\n);\n\n    reg [MUL2_DIV_CLK:0] clk_div_reg;\n    reg clk_div_out_reg;\n\n    always @(posedge clk) begin\n        clk_div_reg <= clk_div_in;\n        clk_div_out_reg <= (clk_div_reg[MUL2_DIV_CLK] == 1) ? 1'b1 : 1'b0;\n    end\n\n    assign clk_div_out = clk_div_out_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[31:28])\n                4'b0000: begin // ADD\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[55:32];\n                    result <= op1 + op2;\n                end\n                4'b0001: begin // SUB\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[55:32];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= reg_file[result[4:0]];\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b11;\n                end\n                2'b11: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15])\n    );\n\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    full_subtractor fsub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign B_out = B[0];\n\n    assign D = A - B - B_out;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b11111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b000000) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b11111) state <= 2'b11;\n                end\n                2'b11: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b11111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b000000) state <= 2'b10;\n                end\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15])\n    );\n\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    bls_4bit bls1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule bls_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign D = A - B;\n    assign B_out = borrow[3];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [3:0] counter;\n    wire clk_div_int1, clk_div_int2;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1),\n        .clk_div_int1(clk_div_int1),\n        .clk_div_int2(clk_div_int2)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div_int1(clk_div_int1),\n        .clk_div_int2(clk_div_int2),\n        .clk_div_int1_neg(clk_div_int1_neg),\n        .clk_div_int2_neg(clk_div_int2_neg)\n    );\n\n    assign clk_div = clk_div_int1_neg | clk_div_int2_neg;\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]   clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg          clk_div_int1,\n    output reg          clk_div_int2\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_int1 <= 0;\n            clk_div_int2 <= 0;\n        end else begin\n            counter <= counter + 1;\n            if (counter == MUL2_DIV_CLK) begin\n                counter <= 0;\n                clk_div_int1 <= clk_div;\n                clk_div_int2 <= clk_div;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div_int1,\n    input               clk_div_int2,\n    output reg          clk_div_int1_neg,\n    output reg          clk_div_int2_neg\n);\n\n    always @(posedge clk) begin\n        clk_div_int1_neg <= ~clk_div_int1;\n        clk_div_int2_neg <= ~clk_div_int2;\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .fetched_instr(fetched_instr),\n        .pc(pc)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result),\n        .pc(pc)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr,\n    output reg [4:0] pc\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n            fetched_instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result,\n    input [4:0] pc\n);\n    wire [4:0] opcode;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [31:0] imm;\n    wire [31:0] op1_value;\n    wire [31:0] op2_value;\n\n    assign opcode = fetched_instr[31:28];\n    assign rd = fetched_instr[24:20];\n    assign rs1 = fetched_instr[19:15];\n    assign rs2 = fetched_instr[24:20];\n    assign imm = fetched_instr[31:20];\n\n    assign op1_value = reg_file[rs1];\n    assign op2_value = reg_file[rs2];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            case (opcode)\n                4'b0000: result <= op1 + op2; // Add\n                4'b0010: result <= op1 - op2; // Sub\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b11;\n                end\n                2'b11: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [3:0] counter;\n    wire clk_div_int_4, clk_div_int_3;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int_4)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .clk_div_int_4(clk_div_int_4),\n        .clk_div_int_3(clk_div_int_3)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div_int_3(clk_div_int_3),\n        .clk_div_int_4(clk_div_int_4)\n    );\n\n    assign clk_div = clk_div_int_4 | clk_div_int_3;\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               clk_div_int_4,\n    output reg          clk_div_int_3\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 2'b11) begin\n            counter <= 2'b00;\n            clk_div_int_3 <= ~clk_div_int_3;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div_int_3,\n    input               clk_div_int_4,\n    output reg          clk_div_int_4_neg,\n    output reg          clk_div_int_3_neg\n);\n\n    always @(posedge clk) begin\n        clk_div_int_4_neg <= ~clk_div_int_4;\n        clk_div_int_3_neg <= ~clk_div_int_3;\n    end\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15])\n    );\n\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    full_subtractor fs1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign borrow[0] = A[0] ^ B[0];\n    assign D[0] = A[0] ^ B[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < 4; i = i + 1) begin : sub_loop\n            assign borrow[i] = (A[i] & B[i-1]) | (A[i] & borrow[i-1]) | (B[i] & borrow[i-1]);\n            assign D[i] = A[i] ^ B[i] ^ borrow[i-1];\n        end\n    endgenerate\n\n    assign B_out = borrow[3];\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b11;\n                end\n                2'b11: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State machine logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Waveform generation logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    // Output assignment\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire clk_4, clk_3;\n    reg [3:0] counter;\n    wire clk_avg, clk_adj;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_3)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div(clk_3),\n        .clk_adj(clk_adj)\n    );\n\n    assign clk_4 = counter == 4;\n    assign clk_3 = counter == 3;\n    assign clk_div = clk_4 | clk_adj;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else\n            clk_div <= clk_div + 1;\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            counter <= 0;\n        else if (counter == 2)\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n\n    assign clk_div = counter == 1;\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div,\n    output              clk_adj\n);\n\n    assign clk_adj = clk_div ^ clk;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .pc(pc),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[31:28])\n                4'b0000: begin // ADD\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[31:28];\n                    result <= op1 + op2;\n                end\n                4'b0001: begin // SUB\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[31:28];\n                    result <= op1 - op2;\n                end\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] pc,\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file[pc] <= result;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] B_out_wire;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_wire[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_wire[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_wire[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_wire[15])\n    );\n\n    assign B_out = B_out_wire[15];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] B_out_wire;\n\n    full_subtractor sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out_wire[1])\n    );\n\n    full_subtractor sub2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(B_out_wire[3])\n    );\n\n    assign B_out = B_out_wire[3];\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_wire;\n\n    assign D = A - B;\n    assign B_out = (A[1] && B[1]) || (A[1] && !B[1]) || (!A[1] && B[1]);\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State machine for waveform generation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b00001) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output the waveform\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b0) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b31) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Change this to define the fractional division factor\n\n    reg [3:0] counter;\n    wire clk_div_int1, clk_div_int2;\n    wire clk_div_avg;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_in(counter[3:0]),\n        .clk_out(clk_div_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_in(clk_div_avg),\n        .clk_out(clk_div_int1)\n    );\n\n    clk_adjustment u_clk_adjustment_2(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_in(clk_div_avg),\n        .clk_out(clk_div_int2)\n    );\n\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [3:0]        clk_in,\n    output reg         clk_out\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0000;\n            clk_out <= 1'b0;\n        end else begin\n            if (counter == MUL2_DIV_CLK) begin\n                counter <= 4'b0000;\n                clk_out <= ~clk_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_in,\n    output reg          clk_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_out <= 1'b0;\n        else\n            clk_out <= clk_in;\n    end\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] borrow;\n\n    sub_4bit sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow[3])\n    );\n\n    sub_4bit sub2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow[7])\n    );\n\n    sub_4bit sub3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(borrow[11])\n    );\n\n    sub_4bit sub4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    full_subtractor fsub1(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(borrow[0])\n    );\n\n    full_subtractor fsub2(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(borrow[1])\n    );\n\n    full_subtractor fsub3(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(borrow[2])\n    );\n\n    full_subtractor fsub4(\n        .A(A),\n        .B(B),\n        .D(D),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    assign D = A - B - borrow;\n    assign B_out = borrow[3];\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && (carry == 0);\n    assign A_equal = (diff == 0) && (carry == 0);\n    assign A_less = (diff == 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output carry    // Carry out\n);\n\n    assign diff = A - B;\n    assign carry = (A[31] == B[31]) ? 0 : 1;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .fetched_instr(fetched_instr),\n        .pc(pc)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .instr(fetched_instr),\n        .reg_file(reg_file),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr,\n    output [4:0] pc\n);\n    reg [31:0] current_pc;\n    reg [31:0] next_pc;\n    reg [31:0] instr;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_pc <= 0;\n            instr <= 0;\n        end else begin\n            current_pc <= next_pc;\n            instr <= instr_mem[current_pc];\n        end\n    end\n\n    always @(*) begin\n        next_pc = current_pc + 1;\n    end\n\n    assign fetched_instr = instr;\n    assign pc = current_pc;\n\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    wire [4:0] rs1, rs2;\n    wire [31:0] op1, op2;\n    wire [5:0] funct;\n\n    assign rs1 = instr[25:21];\n    assign rs2 = instr[20:16];\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n    assign funct = instr[5:0];\n\n    always @(*) begin\n        case (funct)\n            6'b000000: result = op1 + op2;\n            6'b000001: result = op1 - op2;\n            default: result = 0;\n        endcase\n    end\n\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] next_reg_file [0:31];\n\n    always @(*) begin\n        next_reg_file[0] = result;\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= next_reg_file;\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && (carry == 0);\n    assign A_equal = (diff == 0) && (carry == 0);\n    assign A_less = (diff == 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output carry\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= d2;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire [MUL2_DIV_CLK:0] clk_div_int;\n    wire [MUL2_DIV_CLK:0] clk_div_int_avg;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int_avg)\n    );\n\n    assign clk_div = |clk_div_int;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK:0] clk_div\n);\n\n    parameter MUL2_CLK = 1; // Multiplier for the clock signal\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + MUL2_CLK;\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK:0] clk_div\n);\n\n    parameter MUL2_CLK = 1; // Multiplier for the clock signal\n    parameter DUTY_CYCLE = 2; // Duty cycle in clock cycles\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (clk_div == DUTY_CYCLE - 1) begin\n                clk_div <= 0;\n            end else begin\n                clk_div <= clk_div + MUL2_CLK;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [MUL2_DIV_CLK:0] clk_div\n);\n\n    parameter MUL2_CLK = 1; // Multiplier for the clock signal\n    parameter DUTY_CYCLE = 2; // Duty cycle in clock cycles\n\n    reg [MUL2_DIV_CLK:0] clk_div_phase;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_phase <= 0;\n        end else begin\n            if (clk_div_phase == DUTY_CYCLE - 1) begin\n                clk_div_phase <= 0;\n            end else begin\n                clk_div_phase <= clk_div_phase + MUL2_CLK;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_phase;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = (diff == 0) && !carry;\n    assign A_less = (diff == 0) && carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output carry\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff > 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff < 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff, \n    output borrow\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [3:0] counter;\n    wire clk_div_int1, clk_div_int2;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1)\n    );\n\n    clk_average_submodule u_clk_average(\n        .clk(clk),\n        .clk_div(clk_div_int1),\n        .clk_div_int2(clk_div_int2)\n    );\n\n    clk_adjustment_submodule u_clk_adjustment(\n        .clk(clk),\n        .clk_div_int2(clk_div_int2),\n        .clk_div(clk_div_int1)\n    );\n\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter_submodule(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average_submodule(\n    input               clk,\n    input               clk_div,\n    output reg          clk_div_int2\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 2'b11) begin\n            counter <= 2'b00;\n            clk_div_int2 <= clk_div;\n        end else begin\n            counter <= counter + 1;\n            clk_div_int2 <= 0;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment_submodule(\n    input               clk,\n    input               clk_div_int2,\n    output reg         clk_div\n);\n\n    always @(posedge clk) begin\n        clk_div <= clk_div_int2;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = (diff == 0) && !carry;\n    assign A_less = (diff == 0) && carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output carry\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n\n    // Fetch stage\n    fetch fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .fetched_instr(fetched_instr));\n\n    // Execute stage\n    execute execute(.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .op1(op1), .op2(op2), .result(result));\n\n    // Writeback stage\n    writeback writeback(.clk(clk), .rst(rst), .result(result), .reg_file(reg_file), .out_reg_file(out_reg_file));\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr\n);\n    reg [31:0] pc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n        end\n    end\n\n    assign fetched_instr = instr_mem[pc];\n\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end else begin\n            case (fetched_instr[6:0])\n                6'b000000: begin // Addition\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 + op2;\n                end\n                6'b000100: begin // Subtraction\n                    op1 <= fetched_instr[31:20];\n                    op2 <= fetched_instr[19:10];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 0;\n                    op2 <= 0;\n                    result <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= reg_file[result[5:0]];\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff > 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff < 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output borrow\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(d0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(d0),\n        .q(d1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(d1),\n        .q(d2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire clk_div_int1, clk_div_int2;\n    wire clk_div_avg;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int1)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div(clk_div_int1),\n        .clk_avg(clk_div_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_avg(clk_div_avg),\n        .clk_div(clk_div_int2)\n    );\n\n    assign clk_div_int1 = (MUL2_DIV_CLK == 1) ? clk : (clk_div_int1 & ~clk);\n    assign clk_div_int2 = (MUL2_DIV_CLK == 1) ? clk : (clk_div_int2 & ~clk);\n    assign clk_div_avg = (MUL2_DIV_CLK == 1) ? clk : (clk_div_avg & ~clk);\n\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else\n            clk_div <= clk_div + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input clk_div,\n    output reg clk_avg\n);\n    always @(posedge clk) begin\n        clk_avg <= clk_div;\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_avg,\n    output reg clk_div\n);\n    always @(posedge clk) begin\n        clk_div <= clk_avg;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output borrow\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q[0];\n            2'b10: q = q[1];\n            2'b11: q = q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = (diff == 0) && !carry;\n    assign A_less = (diff == 0) && carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output carry      // Carry out\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    // Fetch stage\n    fetch fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .pc(pc), .fetched_instr(fetched_instr));\n\n    // Execute stage\n    execute execute(.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .op1(op1), .op2(op2), .result(result));\n\n    // Writeback stage\n    writeback writeback(.clk(clk), .rst(rst), .result(result), .reg_file(reg_file), .out_reg_file(out_reg_file));\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n    wire [4:0] opcode;\n    wire [4:0] rs1, rs2;\n    wire [31:0] imm;\n\n    assign opcode = fetched_instr[31:28];\n    assign rs1 = fetched_instr[27:22];\n    assign rs2 = fetched_instr[21:16];\n    assign imm = fetched_instr[15:0];\n\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            case (opcode)\n                4'b0000: result <= op1 + op2; // Add\n                4'b0010: result <= op1 - op2; // Sub\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    wire [4:0] rd;\n\n    assign rd = result[31:28];\n    assign out_reg_file = (rst) ? reg_file : (reg_file[rd] + result);\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && (carry == 0);\n    assign A_equal = (diff == 0) && (carry == 0);\n    assign A_less = (diff != 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output carry\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    reg [1:0] counter;\n    wire clk_4, clk_3;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter)\n    );\n\n    assign clk_4 = counter[1];\n    assign clk_3 = counter[0];\n\n    wire clk_avg;\n    wire clk_adj;\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_avg(clk_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_avg(clk_avg),\n        .clk_adj(clk_adj)\n    );\n\n    assign clk_div = clk_adj | clk_avg;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [1:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 2'b0;\n        else\n            count <= count + 2'b1;\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_4,\n    input               clk_3,\n    output reg          clk_avg\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            counter <= 2'b0;\n        else if (counter == 2'b11)\n            counter <= 2'b0;\n        else\n            counter <= counter + 2'b1;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_avg <= 1'b0;\n        else if (counter == 2'b00)\n            clk_avg <= clk_4;\n        else if (counter == 2'b01)\n            clk_avg <= clk_3;\n        else\n            clk_avg <= 1'b0;\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_avg,\n    output reg          clk_adj\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk or negedge clk_avg) begin\n        if (!clk_avg)\n            counter <= 2'b0;\n        else if (counter == 2'b11)\n            counter <= 2'b0;\n        else\n            counter <= counter + 2'b1;\n    end\n\n    always @(posedge clk or negedge clk_avg) begin\n        if (!clk_avg)\n            clk_adj <= 1'b0;\n        else if (counter == 2'b00)\n            clk_adj <= 1'b1;\n        else\n            clk_adj <= 1'b0;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry(carry)\n    );\n\n    assign A_greater = (sub_result != 0) && (carry == 0);\n    assign A_equal = (sub_result == 0);\n    assign A_less = (sub_result == 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Output of subtraction\n    output carry      // Carry output\n);\n\n    assign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(d0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(d0),\n        .q(d1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(d1),\n        .q(d2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= d2;\n            2'b10: q <= d1;\n            2'b11: q <= d0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = (diff == 0) && !carry;\n    assign A_less = (diff == 0) && carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output carry      // Carry out\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    parameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n    wire [3:0] clk_div_int;\n    wire clk_div_int_0, clk_div_int_1;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_int(clk_div_int)\n    );\n\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div_int(clk_div_int),\n        .clk_div(clk_div_int_0)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk_div_int(clk_div_int),\n        .clk_div(clk_div_int_1)\n    );\n\n    assign clk_div_int = {clk_div_int_1, clk_div_int_0};\n    assign clk_div = |clk_div_int;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   clk_div_int\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_int <= 4'b0000;\n        else\n            clk_div_int <= clk_div_int + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input [3:0]        clk_div_int,\n    output reg         clk_div\n);\n    always @(posedge clk) begin\n        clk_div <= clk_div_int[3];\n    end\nendmodule\n\nmodule clk_adjustment(\n    input [3:0]        clk_div_int,\n    output reg         clk_div\n);\n    always @(posedge clk) begin\n        clk_div <= clk_div_int[2];\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = (diff == 0) && !carry;\n    assign A_less = (diff == 0) && carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output carry      // Carry out\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .reg_file(reg_file),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    wire [4:0] rs1, rs2;\n    wire [5:0] opcode;\n    wire [31:0] op1, op2;\n    wire [31:0] sum, diff;\n\n    assign rs1 = fetched_instr[25:20];\n    assign rs2 = fetched_instr[15:10];\n    assign opcode = fetched_instr[31:26];\n\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            case (opcode)\n                6'b000000: result <= op1 + op2; // Add\n                6'b001000: result <= op1 - op2; // Subtract\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] out_reg_file_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out_reg_file_reg <= 0;\n        end else begin\n            out_reg_file_reg <= result;\n        end\n    end\n\n    assign out_reg_file = out_reg_file_reg;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] dff_out0, dff_out1, dff_out2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out0),\n        .q(dff_out1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out1),\n        .q(dff_out2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= dff_out0;\n            2'b10: q <= dff_out1;\n            2'b11: q <= dff_out2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 0) && carry;\n    assign A_equal = (diff == 0) && carry;\n    assign A_less = (diff == 0) && !carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output carry      // Carry output\n);\n\n    assign {carry, diff} = A - B;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5; // Change this to the desired odd divisor\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [NUM_V-1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [NUM_DIV-1:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q[0];\n            2'b10: q = q[1];\n            2'b11: q = q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff > 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff < 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow\n);\n\n    assign diff = A - B;\n    assign borrow = (A[31] == 0 && diff[31] == 1);\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q[0];\n            2'b10: q <= q[1];\n            2'b11: q <= q[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire carry;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .carry(carry)\n    );\n\n    assign A_greater = (diff != 0) && !carry;\n    assign A_equal = diff == 0;\n    assign A_less = carry;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output carry\n);\n\n    assign diff = A - B;\n    assign carry = (A[31] == B[31]) ? 0 : (A[31] ^ B[31]);\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(32'd0),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 32'd0;\n            op2 <= 32'd0;\n            result <= 32'd0;\n        end else begin\n            case (fetched_instr[31:28])\n                4'b0000: begin // ADD\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[31:28];\n                    result <= op1 + op2;\n                end\n                4'b0001: begin // SUB\n                    op1 <= fetched_instr[27:0];\n                    op2 <= fetched_instr[31:28];\n                    result <= op1 - op2;\n                end\n                default: begin\n                    op1 <= 32'd0;\n                    op2 <= 32'd0;\n                    result <= 32'd0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 32'd0;\n        else\n            out_reg_file <= reg_file[result[5:0]];\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n\n    carry_lookahead_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    genvar i;\n\n    assign C[1] = Cin;\n\n    always @(*) begin\n        for (i = 1; i < 16; i = i + 1) begin\n            if (A[i] ^ B[i])\n                C[i+1] = C[i] ^ 1;\n            else\n                C[i+1] = C[i];\n        end\n    end\n\n    assign S = A ^ B ^ C;\n    assign Cout = C[16];\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q1, q2, q3;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [32:1] C1;\n\n    carry_lookahead_16bit CLA1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Cin(1'b0),\n        .S(S[15:0]),\n        .Cout(C1[0])\n    );\n\n    carry_lookahead_16bit CLA2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Cin(C1[0]),\n        .S(S[31:16]),\n        .Cout(C1[1])\n    );\n\n    assign C32 = C1[1];\n\nendmodule\n\nmodule carry_lookahead_16bit(A,B,Cin,S,Cout);\n    input [15:0] A;\n    input [15:0] B;\n    input Cin;\n    output [15:0] S;\n    output Cout;\n\n    wire [15:0] C;\n    wire [15:0] G;\n    wire [15:0] P;\n\n    assign C[0] = Cin;\n\n    genvar i;\n    for (i = 0; i < 16; i = i + 1) begin : carry_loop\n        assign G[i] = A[i] & B[i];\n        assign P[i] = A[i] ^ B[i];\n        assign C[i+1] = G[i] | (P[i] & C[i]);\n    end\n\n    assign S = P ^ C[15:0];\n    assign Cout = C[15];\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .fetched_instr(fetched_instr),\n        .pc(pc)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] fetched_instr,\n    output [4:0] pc\n);\n    reg [31:0] current_pc;\n    reg [31:0] next_pc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_pc <= 0;\n        end else begin\n            current_pc <= next_pc;\n        end\n    end\n\n    always @(*) begin\n        next_pc = current_pc + 1;\n        fetched_instr = instr_mem[current_pc];\n    end\n\n    assign pc = current_pc;\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n    wire [4:0] opcode;\n    wire [4:0] rs1, rs2;\n    wire [31:0] imm;\n\n    assign opcode = fetched_instr[31:28];\n    assign rs1 = fetched_instr[27:22];\n    assign rs2 = fetched_instr[21:16];\n    assign imm = fetched_instr[15:0];\n\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(*) begin\n        case (opcode)\n            4'b000: result = op1 + op2; // Add\n            4'b001: result = op1 - op2; // Subtract\n            default: result = 0;\n        endcase\n    end\n\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] next_reg_file [0:31];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            next_reg_file <= 0;\n        end else begin\n            next_reg_file <= reg_file;\n            next_reg_file[0] <= result;\n        end\n    end\n\n    assign out_reg_file = next_reg_file;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end\n        else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end\n        else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end\n        else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end\n        else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] pc;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n    wire [5:0] opcode;\n\n    assign opcode = fetched_instr[31:26];\n    assign op1 = fetched_instr[25:0];\n    assign op2 = fetched_instr[5:0];\n\n    add_sub add_sub (\n        .opcode(opcode),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\nendmodule\n\nmodule add_sub(\n    input [5:0] opcode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    wire [31:0] add_result;\n\n    assign result = (opcode == 6'b000000) ? op1 + op2 : op1 - op2;\n\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] reg_file_next [0:31];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            reg_file_next <= reg_file;\n            out_reg_file <= result;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C1[1]));\n    carry_lookahead_16bit CLA2(.A(A[32:17]), .B(B[32:17]), .Cin(C1[1]), .S(S[32:17]), .Cout(C2[1]));\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n    wire [16:1] G;\n\n    genvar_16bit GEN_AND(A, B, C, G);\n    genvar_16bit GEN_OR(A, B, C, G);\n\n    assign S = A ^ B ^ C;\n    assign Cout = G[16];\n\nendmodule\n\nmodule genvar_16bit(A, B, C, G);\n    input [16:1] A;\n    input [16:1] B;\n    input [16:1] C;\n    output [16:1] G;\n\n    assign G[1] = A[1] & B[1] & C[1];\n    assign G[2] = A[2] & B[2] & C[2];\n    assign G[3] = A[3] & B[3] & C[3];\n    assign G[4] = A[4] & B[4] & C[4];\n    assign G[5] = A[5] & B[5] & C[5];\n    assign G[6] = A[6] & B[6] & C[6];\n    assign G[7] = A[7] & B[7] & C[7];\n    assign G[8] = A[8] & B[8] & C[8];\n    assign G[9] = A[9] & B[9] & C[9];\n    assign G[10] = A[10] & B[10] & C[10];\n    assign G[11] = A[11] & B[11] & C[11];\n    assign G[12] = A[12] & B[12] & C[12];\n    assign G[13] = A[13] & B[13] & C[13];\n    assign G[14] = A[14] & B[14] & C[14];\n    assign G[15] = A[15] & B[15] & C[15];\n    assign G[16] = A[16] & B[16] & C[16];\n\nendmodule\n\nmodule genvar_16bit_or(A, B, C, G);\n    input [16:1] A;\n    input [16:1] B;\n    input [16:1] C;\n    output [16:1] G;\n\n    assign G[1] = A[1] | B[1] | C[1];\n    assign G[2] = A[2] | B[2] | C[2];\n    assign G[3] = A[3] | B[3] | C[3];\n    assign G[4] = A[4] | B[4] | C[4];\n    assign G[5] = A[5] | B[5] | C[5];\n    assign G[6] = A"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV-1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV-1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n\n    carry_lookahead_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    genvar i;\n    assign C[1] = Cin;\n    for (i = 1; i < 16; i = i + 1) begin : carry_chain\n        assign C[i+1] = A[i] & B[i] | A[i] & C[i] | B[i] & C[i];\n        assign S[i] = A[i] ^ B[i] ^ C[i];\n    end\n\n    assign Cout = C[16];\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire [9:0] next_accumulator;\n    wire [3:0] next_count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator),\n        .next_accumulator(next_accumulator)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator,\n    output reg  [9:0]   next_accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accumulator <= 0;\n            next_accumulator <= 0;\n        end\n        else if (count == 4) begin\n            accumulator <= accumulator + data_in;\n            next_accumulator <= accumulator;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= data_out;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C1;\n    wire [15:1] C2;\n\n    // Instantiate the 16-bit CLA blocks\n    CLA_16bit CLA1(\n        .A(A[15:1]),\n        .B(B[15:1]),\n        .Cin(1'b0),\n        .S(S[15:1]),\n        .Cout(C1[1])\n    );\n\n    CLA_16bit CLA2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Cin(C1[1]),\n        .S(S[31:16]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[15];\n\nendmodule\n\nmodule CLA_16bit(A,B,Cin,S,Cout);\n    input [15:1] A;\n    input [15:1] B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n\n    wire [15:1] C;\n\n    // Full adder implementation\n    assign {Cout, S} = A + B + Cin;\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV-1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_div <= 1;\n            end else begin\n                counter <= counter + 1;\n                clk_div <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV-1:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_div <= 1;\n            end else begin\n                counter <= counter + 1;\n                clk_div <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count_out;\n    wire [9:0] accumulated_data;\n    wire count_reset;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count_out(count_out)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count_in(count_out),\n        .accumulated_data(accumulated_data)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .accumulated_data(accumulated_data),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (valid_in)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count_in,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (count_in == 4)\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [9:0]   accumulated_data,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (valid_in)\n            valid_out <= 1;\n        else if (accumulated_data != 0)\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(.A(A[16:1]), .B(B[16:1]), .C1(C1), .C2(C2), .S(S[16:1]));\n    carry_lookahead_16bit CLA2(.A(A[32:17]), .B(B[32:17]), .C1(C1), .C2(C2), .S(S[32:17]));\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, C1, C2, S);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] S;\n    output [15:0] C1;\n    output [15:0] C2;\n\n    wire [15:0] C1_int;\n    wire [15:0] C2_int;\n\n    wire [15:0] C1_out;\n    wire [15:0] C2_out;\n\n    full_adder FA1(.A(A), .B(B), .Cin(1'b0), .S(S), .Cout(C1_out), .C(C1_int));\n    full_adder FA2(.A(A), .B(B), .Cin(C1_out), .S(S), .Cout(C2_out), .C(C2_int));\n\n    assign C1 = C1_int;\n    assign C2 = C2_int;\n\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout, C);\n    input A, B, Cin;\n    output S, Cout;\n    output C;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n    assign C = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C1;\n    wire [15:1] C2;\n\n    // Instantiate the CLA blocks\n    carry_lookahead_16bit CLA1(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .S(S[15:0]), .Cout(C1));\n    carry_lookahead_16bit CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(C1[15]), .S(S[31:16]), .Cout(C2));\n\n    // Carry-out logic\n    assign C32 = C2[15];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [15:1] A;\n    input [15:1] B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n\n    wire [15:1] C;\n\n    // Full adder\n    assign {Cout, S} = A + B + Cin;\n\n    // Carry-out logic\n    assign C = {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout} + {1'b0, Cout};\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] shifted;\n\n    // Stage 1\n    mux2X1 mux1_1 (\n        .sel({1'b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count_out;\n    wire [9:0] accumulator_out;\n    wire ready_for_output;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count_out(count_out)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count_in(count_out),\n        .accumulator_out(accumulator_out)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ready_for_output(ready_for_output),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else if (valid_in)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count_in,\n    output reg  [9:0]   accumulator_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator_out <= 10'b0;\n        else if (count_in == 4)\n            accumulator_out <= accumulator_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               ready_for_output,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= 10'b0;\n        end\n        else if (ready_for_output) begin\n            valid_out <= 1'b1;\n            data_out <= accumulator_out;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted;\n\n    // Stage 1\n    mux2X1 mux1 (in, ctrl[2], shifted, shifted);\n    // Stage 2\n    mux2X1 mux2 (shifted, ctrl[1], shifted, shifted);\n    // Stage 3\n    mux2X1 mux3 (shifted, ctrl[0], shifted, out);\n\nendmodule\n\n// Multiplexer module\nmodule mux2X1 (\n    input [1:0] sel,\n    input [1:0] in1,\n    output [1:0] out\n);\n    assign out = sel ? in1 : 0;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(.A(A[16:1]), .B(B[16:1]), .C1(C1), .C2(C2), .S(S[16:1]));\n    carry_lookahead_16bit CLA2(.A(A[32:17]), .B(B[32:17]), .C1(C2), .C2(C32), .S(S[32:17]));\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A,B,C1,C2,S);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] S;\n    output [16:1] C1;\n    output C2;\n\n    wire [16:1] G, P, C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C[1] = C1[1] | (P[1] & G[1]);\n\n    genvar i;\n    generate\n        for (i = 2; i <= 16; i = i + 1) begin :cla_loop\n            assign C[i] = C[i-1] | (P[i] & G[i]);\n            assign S[i] = P[i] ^ C[i];\n        end\n    endgenerate\n\n    assign C2 = C[16];\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    mux2X1 mux1 (in, ctrl[2], stage1);\n    barrel_shifter_stage1 stage1_shifter (stage1, stage2);\n\n    // Stage 2\n    mux2X1 mux21 (stage1, ctrl[1], stage2);\n    barrel_shifter_stage2 stage2_shifter (stage2, stage3);\n\n    // Stage 3\n    mux2X1 mux31 (stage2, ctrl[0], stage3);\n    barrel_shifter_stage3 stage3_shifter (stage3, out);\n\nendmodule\n\n// Stage 1\nmodule barrel_shifter_stage1 (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = in >> 4;\nendmodule\n\n// Stage 2\nmodule barrel_shifter_stage2 (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = in >> 2;\nendmodule\n\n// Stage 3\nmodule barrel_shifter_stage3 (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = in >> 1;\nendmodule\n\n// 2-to-1 multiplexer\nmodule mux2X1 (\n    input [1:0] sel,\n    output [1:0] out\n);\n    assign out = sel[0] ? 1'b0 : 1'b1;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count_out;\n    wire [9:0] accumulator_out;\n    wire valid_out_internal;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count_out(count_out)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count_in(count_out),\n        .accumulator_out(accumulator_out)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out_internal),\n        .data_out(data_out)\n    );\n\n    assign valid_out = valid_out_internal;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (valid_in)\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count_in,\n    output reg  [9:0]   accumulator_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator_out <= 0;\n        else if (count_in == 4)\n            accumulator_out <= accumulator_out + data_in;\n    end\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_in) begin\n            valid_out <= 1;\n            data_out <= 0;\n        end\n        else if (valid_out) begin\n            valid_out <= 0;\n            data_out <= accumulator_out;\n        end\n    end\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    CLA1 CLA1_inst (\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n\n    CLA1 CLA2_inst (\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    assign C[1] = Cin;\n\n    genvar i;\n    genvar j;\n    generate\n        for (i = 1; i < 16; i = i + 1) begin : loop\n            assign C[i+1] = A[i] & B[i] | A[i] & C[i] | B[i] & C[i];\n            assign S[i] = A[i] ^ B[i] ^ C[i];\n        end\n    endgenerate\n\n    assign Cout = C[16];\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input wire [7:0] in;\n    input wire [2:0] ctrl;\n    output wire [7:0] out;\n\n    wire [7:0] shifted_1, shifted_2, shifted_4;\n\n    mux2X1 mux (in, ctrl, shifted_1, shifted_2, shifted_4);\n\n    shift4X1 shift4 (shifted_1, shifted_2, shifted_4);\n\n    assign shifted_4 = (ctrl[2] ? shifted_2 : (ctrl[1] ? shifted_1 : in);\n\n    shift2X1 shift2 (shifted_1, shifted_2);\n\n    shift1X1 shift1 (shifted_2, shifted_1);\n\n    assign out = (ctrl[2] ? shifted_4 : (ctrl[1] ? shifted_2 : shifted_1));\n\nendmodule\n\n// MUX2X1 implementation\nmodule mux2X1 (\n    input wire [7:0] in1, in2, out;\n    input wire [2:0] sel;\n    output wire [7:0] out1, out2;\n\n    assign out1 = (sel[2] ? in2 : in1);\n    assign out2 = (sel[1] ? out1 : in1);\n\nendmodule\n\n// SHIFT4X1 implementation\nmodule shift4X1 (\n    input wire [7:0] in1, in2, in4;\n    output wire [7:0] out;\n\n    assign out = (in4 ? in2 : in1);\n\nendmodule\n\n// SHIFT2X1 implementation\nmodule shift2X1 (\n    input wire [7:0] in1, in2;\n    output wire [7:0] out;\n\n    assign out = (in2 ? in1 : in1);\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV-1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV-1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV-1:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV-1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n\n    carry_lookahead_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    genvar i;\n    assign C[1] = Cin;\n    for (i = 1; i < 16; i = i + 1) begin : carry_chain\n        assign C[i+1] = A[i] & B[i] | A[i] & C[i] | B[i] & C[i];\n        assign S[i] = A[i] ^ B[i] ^ C[i];\n    end\n\n    assign Cout = C[16];\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] shifted;\n\n    // Stage 1\n    mux2X1 mux1_0 (\n        .sel(ctrl[0]),\n        .in0(in),\n        .in1(shifted),\n        .out(shifted)\n    );\n\n    // Stage 2\n    mux2X1 mux1_1 (\n        .sel(ctrl[1]),\n        .in0(shifted),\n        .in1(in),\n        .out(shifted)\n    );\n\n    // Stage 3\n    mux2X1 mux1_2 (\n        .sel(ctrl[2]),\n        .in0(shifted),\n        .in1(in),\n        .out(out)\n    );\nendmodule\n\n// Multiplexer module\nmodule mux2X1 (\n    input sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    output [7:0] out\n);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulated_data;\n    wire valid_out_internal;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulated_data(accumulated_data)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out_internal),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (count == 4)\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_in) begin\n            valid_out <= 1;\n            data_out <= accumulated_data;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    mux2X1 mux2X1_ctrl0 (in, stage1, ctrl[0], stage1);\n    mux2X1 mux2X1_ctrl1 (stage1, stage2, ctrl[1], stage2);\n    mux2X1 mux2X1_ctrl2 (stage2, stage3, ctrl[2], stage3);\n\n    assign out = stage3;\n\nendmodule\n\n// MUX2X1 implementation\nmodule mux2X1 (\n    input [7:0] a, b, sel,\n    output [7:0] y\n);\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == DIV) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter DIV = NUM_DIV - 1;\n\n    reg [DIV - 1:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == DIV) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    // Instantiate the two CLA blocks\n    carry_lookahead_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n    carry_lookahead_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    // Calculate the carry out\n    assign C32 = C1[1] | C2[1];\n\nendmodule\n\nmodule carry_lookahead_16bit(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    // Full adder\n    full_adder FA(\n        .A(A),\n        .B(B),\n        .Cin(Cin),\n        .S(S),\n        .Cout(C[1])\n    );\n\n    // Carry chain\n    assign Cout = C[16] | C[15] | C[14] | C[13] | C[12] | C[11] | C[10] | C[9] | C[8] | C[7] | C[6] | C[5] | C[4] | C[3] | C[2] | C[1];\n\nendmodule\n\nmodule full_adder(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] P;\n    wire [16:1] G;\n\n    assign P = A ^ B;\n    assign G = A & B;\n    assign S = P ^ Cin;\n    assign Cout = G | (P & Cin);\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire [9:0] next_accumulator;\n    wire [3:0] next_count;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator),\n        .next_accumulator(next_accumulator)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .accumulator(accumulator),\n        .next_accumulator(next_accumulator),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator,\n    output reg  [9:0]   next_accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accumulator <= 10'b0;\n            next_accumulator <= 10'b0;\n        end else begin\n            accumulator <= next_accumulator;\n            next_accumulator <= accumulator + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    input       [9:0]   accumulator,\n    input       [9:0]   next_accumulator,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= 10'b0;\n        end else if (valid_in) begin\n            valid_out <= (count == 4) ? 1'b1 : 1'b0;\n            data_out <= accumulator;\n        end else begin\n            valid_out <= valid_out;\n            data_out <= data_out;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    wire [7:0] shifted;\n    wire [2:0] sel;\n    assign sel[2] = ctrl[2];\n    assign sel[1] = ctrl[1];\n    assign sel[0] = ctrl[0];\n    \n    mux2X1 mux2X1_0 (\n        .in0(in),\n        .in1(shifted),\n        .sel(sel),\n        .out(shifted)\n    );\n    \n    barrel_shifter_stage stage1 (\n        .in(shifted),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    barrel_shifter_stage stage2 (\n        .in(shifted),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    barrel_shifter_stage stage3 (\n        .in(shifted),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    assign out = shifted;\n    \nendmodule\n\nmodule mux2X1 (\n    input [7:0] in0,\n    input [2:0] in1,\n    output [7:0] out,\n    input [2:0] sel\n);\n    assign out = sel[2] ? in1 : in0;\n    assign out = sel[1] ? out : out;\n    assign out = sel[0] ? out : in0;\nendmodule\n\nmodule barrel_shifter_stage (\n    input [7:0] in,\n    output [7:0] out,\n    input [2:0] ctrl\n);\n    wire [7:0] shifted;\n    \n    barrel_shifter_stage_1 stage1 (\n        .in(in),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    barrel_shifter_stage_2 stage2 (\n        .in(shifted),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    barrel_shifter_stage_3 stage3 (\n        .in(shifted),\n        .out(shifted),\n        .ctrl(ctrl)\n    );\n    \n    assign out = shifted;\n    \nendmodule\n\nmodule barrel_shifter_stage_1 (\n    input [7:0] in,\n    output [7:0] out,\n    input [2:0] ctrl\n);\n    wire [7:0] shifted;\n    \n    assign shifted = ctrl[2] ? in : in;\n    assign out = ctrl[1] ? shifted : in;\n    assign out = ctrl[0] ? shifted : in;\nendmodule\n\nmodule barrel_shifter_stage_2 (\n    input [7:0] in,\n    output [7:0] out,\n    input [2:0] ctrl\n);\n    wire [7:0] shifted;\n    \n    assign shifted = ctrl[2] ? in : shifted;\n    assign out = ctrl[1] ? shifted : in;\n    assign out = ctrl[0] ? shifted : in;\nendmodule\n\nmodule barrel_shifter_stage_3 (\n    input [7:0] in,\n    output [7:0] out,\n    input [2:0] ctrl\n);\n    wire [7:0] shifted;\n    \n    assign shifted = ctrl[2] ? in : shifted;\n    assign out = ctrl[1] ? shifted : in;\n    assign out = ctrl[0] ? shifted : in;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    mux2X1 mux2X1_1 (in, stage1, ctrl[2], stage1);\n    mux2X1 mux2X1_2 (stage1, stage2, ctrl[1], stage2);\n    mux2X1 mux2X1_3 (stage2, stage3, ctrl[0], stage3);\n\n    assign stage1 = in << 4;\n    assign stage2 = stage1 << 2;\n    assign stage3 = stage2 << 1;\n\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (\n    input [0:0] a,\n    input [0:0] b,\n    input sel,\n    output [0:0] y\n);\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    // Instantiate the CLA blocks\n    carry_lookahead_16bit CLA1(.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C1[1]));\n    carry_lookahead_16bit CLA2(.A(A[32:17]), .B(B[32:17]), .Cin(C1[1]), .S(S[32:17]), .Cout(C2[1]));\n\n    // Output the carry out\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    full_adder FA1(.A(A), .B(B), .Cin(Cin), .S(S), .Cout(C[1]));\n\n    genvar i;\n    for (i = 2; i <= 16; i = i + 1) begin : carry_loop\n        half_adder HA(.A(A[i]), .B(B[i]), .Cin(C[i - 1]), .S(S[i]), .Cout(C[i]));\n    end\n\n    assign Cout = C[16];\n\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A;\n    input B;\n    input Cin;\n    output S;\n    output Cout;\n\n    wire C1;\n\n    xor XOR1(.A(A), .B(B), .Cout(C1));\n    and AND1(.A(A), .B(B), .Cout(Cout));\n    or OR1(.A(C1), .B(Cin), .Cout(S));\n\nendmodule\n\nmodule half_adder(A, B, Cin, S, Cout);\n    input A;\n    input B;\n    input Cin;\n    output S;\n    output Cout;\n\n    wire C1;\n\n    xor XOR1(.A(A), .B(B), .Cout(C1));\n    and AND1(.A(A), .B(B), .Cout(Cout));\n    or OR1(.A(C1), .B(Cin), .Cout(S));\n\nendmodule\n\nmodule or(A, B, Cout);\n    input A;\n    input B;\n    output Cout;\n\n    assign Cout = A | B;\n\nendmodule\n\nmodule and(A, B, Cout);\n    input A;\n    input B;\n    output Cout;\n\n    assign Cout = A & B;\n\nendmodule\n\nmodule xor(A, B, Cout);\n    input A;\n    input B;\n    output Cout;\n\n    assign Cout = A ^ B;\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= accumulator;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] shifted_1, shifted_2, shifted_3;\n\n    mux2X1 mux2X1_1 (\n        .sel(ctrl[2]),\n        .in0(in),\n        .in1(shifted_1),\n        .out(shifted_2)\n    );\n    mux2X1 mux2X1_2 (\n        .sel(ctrl[1]),\n        .in0(shifted_2),\n        .in1(shifted_3),\n        .out(shifted_1)\n    );\n    mux2X1 mux2X1_3 (\n        .sel(ctrl[0]),\n        .in0(shifted_3),\n        .in1(in),\n        .out(out)\n    );\nendmodule\n\n// Multiplexer implementation\nmodule mux2X1 (\n    input sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    output [7:0] out\n);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C1[1])\n    );\n\n    carry_lookahead_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C1[1]),\n        .S(S[32:17]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[16];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] C;\n\n    genvar i;\n    assign C[1] = Cin;\n\n    always @(*) begin\n        for (i = 1; i < 16; i = i + 1) begin\n            C[i] = A[i] & B[i] | A[i] & C[i-1] | B[i] & C[i-1];\n        end\n    end\n\n    assign S = A ^ B ^ C;\n    assign Cout = C[16];\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4;\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_mod counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_mod(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_FACTOR = 2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == DIV_FACTOR - 1) begin\n                counter <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_FACTOR = 2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= ~clk_div;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] stage1, stage2, stage3;\n    \n    mux2X1 mux2X1_1 (in, stage1, ctrl[2], stage2);\n    mux2X1 mux2X1_2 (stage1, stage2, ctrl[1], stage3);\n    mux2X1 mux2X1_3 (stage2, stage3, ctrl[0], out);\n    \n    assign stage1 = in << 2;\n    assign stage2 = stage1 << 2;\n    assign stage3 = stage2 << 1;\nendmodule\n\nmodule mux2X1 (input [0:0] a, input [0:0] b, input sel, output [0:0] y);\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire valid_out_internal;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out_internal(valid_out_internal),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input               valid_out_internal,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_out_internal) begin\n            valid_out <= 1;\n            data_out <= accumulator;\n        end\n        else if (valid_in)\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_mod counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_divider clk_divider_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_int(clk_div_int)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_mod(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge(clk))\n    begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (counter == (NUM_DIV / 2 - 1))\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div_int\n);\n    always @(posedge(clk))\n    begin\n        if (!rst_n)\n            clk_div_int <= 0;\n        else if (counter == (NUM_DIV / 2 - 1))\n            clk_div_int <= ~clk_div_int;\n    end\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C1;\n    wire [15:1] C2;\n\n    // Instantiate the CLA blocks\n    carry_lookahead_16bit CLA1(.A(A[15:1]), .B(B[15:1]), .Cin(1'b0), .S(S[15:1]), .Cout(C1[1]));\n    carry_lookahead_16bit CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(C1[1]), .S(S[31:16]), .Cout(C2[1]));\n\n    // Combine the carry outs from the CLA blocks\n    assign C32 = C2[15] | C2[14] | C2[13] | C2[12] | C2[11] | C2[10] | C2[9] | C2[8] | C2[7] | C2[6] | C2[5] | C2[4] | C2[3] | C2[2] | C2[1] | C2[0];\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, Cin, S, Cout);\n    input [15:1] A;\n    input [15:1] B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n\n    wire [15:1] G, P;\n    wire C1, C2;\n\n    assign G = A & B;\n    assign P = A ^ B;\n\n    assign S[1] = P[1] ^ Cin;\n    assign C1 = P[1] & Cin;\n\n    genvar i;\n    generate\n        for (i = 2; i <= 15; i = i + 1) begin : carry_loop\n            assign S[i] = P[i] ^ C1;\n            assign C1 = P[i] & C1;\n        end\n    endgenerate\n\n    assign Cout = C1;\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted;\n    wire [3:0] sel;\n\n    assign sel[2] = ctrl[2];\n    assign sel[1] = ctrl[1];\n    assign sel[0] = ctrl[0];\n\n    // Stage 1: Shift by 4\n    mux2X1 mux2X1_4(.sel(sel), .in(in), .out(shifted));\n    assign shifted = sel[2] ? mux2X1_4.out : in;\n\n    // Stage 2: Shift by 2\n    mux2X1 mux2X1_2(.sel(sel), .in(shifted), .out(shifted));\n    assign shifted = sel[1] ? mux2X1_2.out : shifted;\n\n    // Stage 3: Shift by 1\n    mux2X1 mux2X1_1(.sel(sel), .in(shifted), .out(out));\n\nendmodule\n\n// Multiplexer implementation\nmodule mux2X1(input [3:0] sel, input [7:0] in, output [7:0] out);\n    reg [7:0] shifted;\n    always @* shifted = sel[0] ? in : shifted;\n    always @* shifted = sel[1] ? shifted : shifted;\n    always @* shifted = sel[2] ? shifted : shifted;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 8; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_even u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clock_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_divider),\n        .counter_out(counter)\n    );\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out < NUM_DIV/2 - 1) begin\n                count_out <= count_out + 1;\n            end else begin\n                count_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div,\n    input [3:0] counter_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == NUM_DIV/2 - 1) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_1, shifted_2, shifted_3;\n\n    mux2X1 mux2X1_1 (\n        .in0(in[0]),\n        .in1(in[1]),\n        .sel(ctrl[0]),\n        .out(shifted_1)\n    );\n    mux2X1 mux2X1_2 (\n        .in0(shifted_1),\n        .in1(shifted_2),\n        .sel(ctrl[1]),\n        .out(shifted_2)\n    );\n    mux2X1 mux2X1_3 (\n        .in0(shifted_2),\n        .in1(shifted_3),\n        .sel(ctrl[2]),\n        .out(shifted_3)\n    );\n    assign out = shifted_3;\n\nendmodule\n\n// MUX2X1 module implementation\nmodule mux2X1 (\n    input in0,\n    input in1,\n    input sel,\n    output out\n);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] valid_count;\n    wire [9:0] accumulated_data;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_count(valid_count)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .accumulated_data(accumulated_data)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   valid_count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_count <= 0;\n        else if (valid_in)\n            valid_count <= valid_count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (valid_in)\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   valid_count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_count == 4) begin\n            valid_out <= 1;\n            data_out <= accumulated_data;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    mux2X1 mux2X1_1 (ctrl[2], in, stage1);\n    mux2X1 mux2X1_2 (ctrl[1], stage1, stage2);\n    mux2X1 mux2X1_3 (ctrl[0], stage2, stage3);\n\n    assign stage1 = in << 4;\n    assign stage2 = stage1 << 2;\n    assign stage3 = stage2 << 1;\n\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (input [2:0] sel, input [7:0] a, b, output [7:0] y);\n    assign y = sel ? a : b;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the frequency division factor\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_even u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clock_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_out(clk_div_int)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == NUM_DIV / 2 - 1) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div_out\n);\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            clk_div_out <= 0;\n        end else begin\n            clk_div_out <= ~clk_div_out;\n        end\n    end\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C1;\n    wire [16:1] C2;\n\n    carry_lookahead_16bit CLA1(.A(A[16:1]), .B(B[16:1]), .C1(C1), .C2(C2));\n    carry_lookahead_16bit CLA2(.A(A[32:17]), .B(B[32:17]), .C1(C2), .C2(C32));\n\n    assign S = {C2, C1, A[16:1], B[16:1]};\n\nendmodule\n\nmodule carry_lookahead_16bit(A, B, C1, C2);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] C1;\n    output C2;\n\n    wire [16:1] G, P;\n    wire [16:1] C1_int, C2_int;\n\n    assign G = A & B;\n    assign P = A ^ B;\n\n    genvar_16bit(G, P, C1_int);\n    genvar_16bit(G, P, C2_int);\n\n    assign C1 = C1_int;\n    assign C2 = C2_int;\n\nendmodule\n\nmodule genvar_16bit(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage_1(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage_1(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage_2(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage_2(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage_3(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage_3(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage_4(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage_4(G, P, C);\n    input [16:1] G;\n    input [16:1] P;\n    output [16:1] C;\n\n    wire [16:1] C1;\n\n    genvar_16bit_stage_5(G, P, C1);\n\n    assign C = C1;\n\nendmodule\n\nmodule genvar_16bit_stage_5(G, P, C);\n    input [16:1] G;\n    input [16:"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_module u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_divider_module u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider(clk_divider)\n    );\n\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider_module(\n    input clk,\n    input rst_n,\n    output reg clk_divider\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_divider <= 0;\n        end else begin\n            if (counter == NUM_DIV / 2 - 1) begin\n                clk_divider <= ~clk_divider;\n            end\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulated_data;\n    wire [3:0] valid_count;\n\n    // Counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .accumulated_data(accumulated_data),\n        .valid_count(valid_count)\n    );\n\n    // Valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [9:0]   accumulated_data,\n    output reg  [3:0]   valid_count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accumulated_data <= 0;\n            valid_count <= 0;\n        end\n        else if (valid_in) begin\n            accumulated_data <= accumulated_data + data_in;\n            valid_count <= valid_count + 1;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   valid_count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_count == 4) begin\n            valid_out <= 1;\n            data_out <= accumulated_data;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    // Counter submodule\n    counter_divider u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider(clk_divider)\n    );\n\n    // Clock divider submodule\n    clock_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider(clk_divider)\n    );\n\n    // Output divider\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_divider(\n    input clk,\n    input rst_n,\n    output reg clk_divider\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_divider <= 0;\n        end else if (counter == NUM_DIV / 2 - 1) begin\n            counter <= 0;\n            clk_divider <= ~clk_divider;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_divider\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_divider <= 0;\n        end else if (clk_divider) begin\n            clk_divider <= 0;\n        end else begin\n            clk_divider <= 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire valid_out_int;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out_int),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 10'b0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= 10'b0;\n        end\n        else if (valid_in) begin\n            valid_out <= 1'b1;\n            data_out <= 10'b0;\n        end\n        else if (valid_out) begin\n            valid_out <= 1'b0;\n            data_out <= accumulator;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3, c4;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c1[0])\n    );\n\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1[0]),\n        .sum(sum[7:4]),\n        .cout(c1[1])\n    );\n\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c1[1]),\n        .sum(sum[11:8]),\n        .cout(c1[2])\n    );\n\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c1[2]),\n        .sum(sum[15:12]),\n        .cout(c1[3])\n    );\n\n    carry_select_adder_4bit csa_slice1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(c1[0]),\n        .sum(sum[3:0]),\n        .cout(c2[0])\n    );\n\n    carry_select_adder_4bit csa_slice2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c2[0]),\n        .sum(sum[7:4]),\n        .cout(c2[1])\n    );\n\n    carry_select_adder_4bit csa_slice3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c2[1]),\n        .sum(sum[11:8]),\n        .cout(c2[2])\n    );\n\n    carry_select_adder_4bit csa_slice4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c2[2]),\n        .sum(sum[15:12]),\n        .cout(c2[3])\n    );\n\n    assign cout = c2[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(sum[1]),\n        .cout(c[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(sum[2]),\n        .cout(c[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(sum[3]),\n        .cout(c[3])\n    );\n\n    assign cout ="}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] shifted;\n\n    // Stage 1\n    assign shifted = (ctrl[2] ? mux2X1(in, 4'b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the frequency division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_even u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_divider_even u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider(clk_divider)\n    );\n\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider_even(\n    input clk,\n    input rst_n,\n    output reg clk_divider\n);\n    reg [3:0] counter;\n\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_divider <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_divider <= ~clk_divider;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] shifted;\n\n    // Stage 1\n    mux2X1 mux1_1 (\n        .sel(ctrl[2]),\n        .in0(in),\n        .in1(shifted),\n        .out(shifted)\n    );\n\n    // Stage 2\n    mux2X1 mux1_2 (\n        .sel(ctrl[1]),\n        .in0(shifted),\n        .in1(shifted),\n        .out(shifted)\n    );\n\n    // Stage 3\n    mux2X1 mux1_3 (\n        .sel(ctrl[0]),\n        .in0(shifted),\n        .in1(shifted),\n        .out(out)\n    );\n\nendmodule\n\n// Multiplexer module\nmodule mux2X1 (\n    input sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    output [7:0] out\n);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire [3:0] next_count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= accumulator;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_mod counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_divider_mod clk_divider_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider(clk_divider)\n    );\n\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_mod(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider_mod(\n    input clk,\n    input rst_n,\n    output reg clk_divider\n);\n    reg [3:0] counter;\n\n    always @(posedge(clk)) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_divider <= 0;\n        end else begin\n            if (counter == NUM_DIV / 2 - 1) begin\n                counter <= 0;\n                clk_divider <= ~clk_divider;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    // Counter module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    // Clock divider module\n    assign clk_divider = (counter == NUM_DIV / 2 - 1);\n\n    // Output the divided clock signal\n    assign clk_div = clk_divider;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_slice_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_slice_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_slice_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(cout)\n    );\nendmodule\n\nmodule mux4(\n    input sel,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4;\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_even u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    clock_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV / 2 - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n\n    // Counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data Accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    // Valid Output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= accumulator;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 2; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_4bit u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clk_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_out(clk_div_int)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge(clk) or negedge(rst_n)) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div_out\n);\n    reg [3:0] counter;\n\n    always @(posedge(clk) or negedge(rst_n)) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_out <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_div_out <= ~clk_div_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] accumulator;\n    wire valid_out_internal;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .accumulator(accumulator)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out_internal),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   accumulator\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator <= 0;\n        else if (count == 4)\n            accumulator <= accumulator + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (valid_in) begin\n            valid_out <= 1;\n            data_out <= data_out;\n        end\n        else if (valid_out) begin\n            valid_out <= 0;\n            data_out <= data_out;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_slice_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_slice_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_slice_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum["}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 8; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_even u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clock_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_divider_out(clk_divider)\n    );\n\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out < NUM_DIV / 2 - 1) begin\n            count_out <= count_out + 1;\n        end else begin\n            count_out <= 0;\n        end\n    end\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_divider_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_divider_out <= 0;\n        end else if (clk_divider_out) begin\n            clk_divider_out <= 0;\n        end else begin\n            clk_divider_out <= 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n    wire [9:0] sum;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .sum(sum)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   sum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            sum <= 0;\n        else if (count == 4)\n            sum <= sum + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n        else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= sum;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_div_int;\n\n    counter_module u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_int)\n    );\n\n    clock_divider_module u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div)\n    );\n\n    assign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count == NUM_DIV - 1) begin\n                count <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clock_divider_module(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= ~clk_div;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\n\n    assign cout = carry[3];"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Even number specifying the division factor\n\n    reg [3:0] counter;\n    wire clk_divider;\n\n    counter_4bit u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter)\n    );\n\n    clock_divider u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_divider),\n        .divisor(NUM_DIV)\n    );\n\n    assign clk_div = clk_divider;\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div,\n    input divisor\n);\n    reg [31:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == divisor - 1) begin\n                counter <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift_reg;\n    wire div_complete;\n\n    // Calculate absolute value of dividend\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    // Calculate negated absolute value of divisor\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control div_control_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .abs_dividend(abs_dividend),\n        .neg_divisor(neg_divisor),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .div_complete(div_complete)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .div_complete(div_complete),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [3:0] shift_reg,\n    output reg div_complete\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            div_complete <= 0;\n        end\n        else if (opn_valid) begin\n            counter <= 4;\n            shift_reg <= 0;\n            div_complete <= 0;\n        end\n        else if (counter > 0) begin\n            counter <= counter - 1;\n            shift_reg <= shift_reg + 1;\n            if (shift_reg == 4) begin\n                if (sign)\n                    result <= abs_dividend - neg_divisor;\n                else\n                    result <= abs_dividend + neg_"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit_slice cs1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit_slice cs2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit_slice cs3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1 (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    assign cout = carry[0];\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n\n    abs_value abs_dividend_mod (\n        .dividend(dividend),\n        .sign(sign),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .divisor(divisor),\n        .sign(sign),\n        .result(neg_divisor)\n    );\n\n    divider_control div_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .sign(sign),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg)\n    );\n\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .res_ready(res_ready),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -dividend;\n        else\n            result = dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -divisor;\n        else\n            result = divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire sign,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n        end else if (opn_valid) begin\n            counter <= 4'd1;\n            shift_reg <= dividend;\n        end else if (counter > 0) begin\n            counter <= counter + 4'd1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] counter,\n    input wire res_ready,\n    input wire [7:0] shift_reg,\n    input wire [7:0] quotient,\n    input wire [7:0] reminder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end else if (res_ready) begin\n            res_valid <= 1;\n            result <= {reminder, quotient};\n        end else if (counter > 0) begin\n            result <= {shift_reg, quotient};\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit_slice cs1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit_slice cs2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit_slice cs3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(cout)\n    );\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n\n    // Calculate absolute values\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .divisor(divisor),\n        .shift_reg(shift_reg),\n        .counter(counter),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end\n        else begin\n            if (opn_valid) begin\n                if (counter == 0) begin\n                    shift_reg <= dividend;\n                    counter <= 8;\n                end\n                else begin\n                    shift_reg <= {shift_reg[6:0], 1'b0};\n                    counter <= counter - 1;\n                end\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [7:0] shift_reg,\n    input wire [3:0] counter,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    always @(posedge clk or"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3, c4;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c1[0])\n    );\n\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1[0]),\n        .sum(sum[7:4]),\n        .cout(c1[1])\n    );\n\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c1[1]),\n        .sum(sum[11:8]),\n        .cout(c1[2])\n    );\n\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c1[2]),\n        .sum(sum[15:12]),\n        .cout(c1[3])\n    );\n\n    carry_select_adder_slice_4bit csa_slice1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c2[0])\n    );\n\n    carry_select_adder_slice_4bit csa_slice2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1[0]),\n        .sum(sum[7:4]),\n        .cout(c2[1])\n    );\n\n    carry_select_adder_slice_4bit csa_slice3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c1[1]),\n        .sum(sum[11:8]),\n        .cout(c2[2])\n    );\n\n    carry_select_adder_slice_4bit csa_slice4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c1[2]),\n        .sum(sum[15:12]),\n        .cout(c2[3])\n    );\n\n    assign cout = c2[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [1:0] c;\n\n    full"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [15:0] quotient;\n\n    // Calculate absolute values\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division\n    divider_control div_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    // Manage result\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n        end else begin\n            if (counter < 8) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[6:0], dividend[7]};\n            end else begin\n                shift_reg <= {shift_reg[6:0], dividend[7]};\n                if (shift_reg[7:0] >= divisor) begin\n                    shift_reg <= shift_reg - divisor;\n                    counter <= counter + 1;\n                end else begin\n                    counter <= 0;\n                end\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire res_ready,\n    input wire ["}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit_slice cs1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit_slice cs2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit_slice cs3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\n\n    assign cout = carry[3];"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [2:0] counter;\n\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .res_valid(res_valid),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg,\n    output reg [2:0] counter\n);\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n\n    assign abs_dividend = (sign) ? -dividend : dividend;\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end else begin\n            if (counter < 8) begin\n                shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n                counter <= counter + 1;\n            end else begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire res_valid,\n    input wire res_ready,\n    input wire [2:0] counter,\n    input wire [7:0] shift_reg,\n    output"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3, c4;\n\n    ripple_carry_adder_4bit rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c1[0]));\n    ripple_carry_adder_4bit rca2(.a(a[7:4]), .b(b[7:4]), .cin(c1[0]), .sum(sum[7:4]), .cout(c1[1]));\n    ripple_carry_adder_4bit rca3(.a(a[11:8]), .b(b[11:8]), .cin(c1[1]), .sum(sum[11:8]), .cout(c1[2]));\n    ripple_carry_adder_4bit rca4(.a(a[15:12]), .b(b[15:12]), .cin(c1[2]), .sum(sum[15:12]), .cout(c1[3]));\n\n    carry_select_adder_slice_4bit csa_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c2[0]));\n    carry_select_adder_slice_4bit csa_slice2(.a(a[7:4]), .b(b[7:4]), .cin(c1[0]), .sum(sum[7:4]), .cout(c2[1]));\n    carry_select_adder_slice_4bit csa_slice3(.a(a[11:8]), .b(b[11:8]), .cin(c1[1]), .sum(sum[11:8]), .cout(c2[2]));\n    carry_select_adder_slice_4bit csa_slice4(.a(a[15:12]), .b(b[15:12]), .cin(c1[2]), .sum(sum[15:12]), .cout(c2[3]));\n\n    assign cout = c2[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [1:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c["}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift_reg;\n    wire [3:0] shift_reg_next;\n    wire [3:0] counter_next;\n    wire [15:0] result_next;\n    wire [15:0] remainder_next;\n    wire [15:0] quotient_next;\n    wire [7:0] abs_dividend_next;\n    wire [7:0] neg_divisor_next;\n\n    // Calculate absolute value of dividend\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    // Calculate negative divisor\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control divider_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .counter_next(counter_next),\n        .shift_reg_next(shift_reg_next),\n        .quotient(quotient),\n        .remainder(remainder),\n        .quotient_next(quotient_next),\n        .remainder_next(remainder_next)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .res_valid(res_valid),\n        .res_ready(res_ready),\n        .counter(counter),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result),\n        .result_next(result_next),\n        .remainder_next(remainder_next)\n    );\n\nendmodule\n\n// Calculate absolute value of dividend\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\n// Calculate negative divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\n// Control division process\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [3:0] counter,\n    input wire [3:0] shift_reg,\n    output reg"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_slice_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_slice_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_slice_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[1]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux3(\n        .sel(carry[2]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux4(\n        .sel(carry[3]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\nendmodule\n\nmodule mux4(\n    input sel"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift_reg;\n    wire [3:0] shift_next;\n    wire [3:0] shift_done;\n    wire [3:0] shift_ready;\n\n    // Calculate absolute value of dividend\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    // Calculate negated absolute value of divisor\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control divider_mod (\n        .clk(clk),\n        .rst(rst),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .sign(sign),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .shift_next(shift_next),\n        .shift_done(shift_done),\n        .shift_ready(shift_ready)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .shift_done(shift_done),\n        .shift_ready(shift_ready),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= sign ? -dividend : dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= sign ? divisor : -divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire sign,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [3:0] shift_reg,\n    output reg [3:0] shift_next,\n    output reg [3:0] shift_done,\n    output reg [3:0] shift_ready\n);\n    wire [3:0] next_counter;\n    wire [3:0] next_shift_reg;\n    wire [3:0] next_shift_next;\n    wire [3:0] next_shift_done;\n    wire [3:0] next_shift_ready;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            shift_next <="}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3, c4;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c1[0])\n    );\n\n    carry_select_adder_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1[0]),\n        .sum(sum[7:4]),\n        .cout(c1[1])\n    );\n\n    carry_select_adder_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c1[1]),\n        .sum(sum[11:8]),\n        .cout(c1[2])\n    );\n\n    carry_select_adder_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c1[2]),\n        .sum(sum[15:12]),\n        .cout(c1[3])\n    );\n\n    assign cout = c1[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [1:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n\n    assign cout = c[1];\n\n    assign sum[2] = (a[2] & ~b[2]) | (b[2] & ~a[2]) | (a[2] & b[2] & cin);\n    assign sum[3] = (a[3] & ~b[3]) | (b[3] & ~a[3]) | (a[3] & b[3] & cin);\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [2:0] counter;\n\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .abs_dividend(abs_dividend),\n        .neg_divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .counter(counter),\n        .res_valid(res_valid),\n        .res_ready(res_ready),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [7:0] shift_reg,\n    output reg [2:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end\n        else begin\n            if (opn_valid) begin\n                shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n                counter <= counter + 1;\n            end\n            else if (counter > 0) begin\n                shift_reg <= shift_reg << 1;\n                counter <= counter - 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [2:0] counter,\n    input wire res_valid,\n    input wire res_ready,\n    output wire [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end\n        else if (res_ready) begin\n            res_valid <= 0;\n        end\n        else if (res_valid"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_slice_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_slice_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_slice_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux3(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    assign cout = carry[0];\n\nendmodule\n\nmodule mux4(\n    input sel,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift_reg;\n    wire [3:0] shift_reg_next;\n    wire [3:0] counter_next;\n    wire [15:0] result_next;\n\n    // Absolute value calculation\n    abs_value abs_dividend_mod (\n        .dividend(dividend),\n        .sign(sign),\n        .result(abs_dividend)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor_mod (\n        .divisor(divisor),\n        .sign(sign),\n        .result(neg_divisor)\n    );\n\n    // Division control logic\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .counter_next(counter_next),\n        .shift_reg_next(shift_reg_next),\n        .result_next(result_next)\n    );\n\n    // Result management\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result_next(result_next),\n        .res_valid(res_valid)\n    );\n\n    assign result = result_next;\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -dividend;\n        else\n            result = dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -divisor;\n        else\n            result = divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [3:0] counter,\n    input wire [3:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [3:0] counter_next,\n    output reg [3:0] shift_reg_next,\n    output reg [15:0] result_next\n);\n    wire [3:0] counter_inc;\n    wire [3:0] shift_reg_inc;\n    wire [15:0] quotient_inc;\n    wire [15:0] remainder_inc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_next <= 0;\n            shift_reg_next <= 0;\n            quotient_next <= 0;\n            remainder_next <= 0;"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(car"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [2:0] counter;\n\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .abs_dividend(abs_dividend),\n        .neg_divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter),\n        .res_valid(res_valid)\n    );\n\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .res_valid(res_valid),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [7:0] shift_reg,\n    output reg [2:0] counter,\n    output reg res_valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n            res_valid <= 0;\n        end\n        else if (opn_valid) begin\n            shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n            counter <= counter + 1;\n            if (counter == 3) begin\n                res_valid <= 1;\n                counter <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire res_valid,\n    input wire res_ready,\n    input wire [2:0] counter,\n    input wire [7:0] shift_reg,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_slice_4bit cs1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_slice_4bit cs2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_slice_4bit cs3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[1]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux3(\n        .sel(carry[2]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux4(\n        .sel(carry[3]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend, abs_divisor;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [3:0] counter;\n\n// Calculate absolute values\nabs_value abs_dividend_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\nabs_value abs_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(divisor),\n    .result(abs_divisor)\n);\n\n// Calculate negative divisor\nneg_value neg_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(divisor),\n    .result(neg_divisor)\n);\n\n// Control division process\ndivider_control div_ctrl_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(abs_divisor),\n    .neg_divisor(neg_divisor),\n    .shift_reg(shift_reg),\n    .counter(counter)\n);\n\n// Manage result validity\nresult_management res_mgmt_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .divisor(divisor),\n    .shift_reg(shift_reg),\n    .counter(counter),\n    .res_valid(res_valid),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [7:0] neg_divisor,\n    input wire [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n        end else begin\n            if (opn_valid) begin\n                if (counter == 0)\n                    counter <= 8;\n                else\n                    counter <= counter - 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [7:0] shift_reg,\n    input wire ["}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_select_adder_4bit cs1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit cs2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit cs3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    mux4 mux1(\n        .sel(carry[0]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux2(\n        .sel(carry[1]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux3(\n        .sel(carry[2]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\n\n    mux4 mux4(\n        .sel(carry[3]),\n        .a(a),\n        .b(b),\n        .out(sum)\n    );\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Calculate absolute value of dividend\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    // Calculate negated absolute value of divisor\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder),\n        .res_valid(res_valid)\n    );\n\n    // Output result\n    assign result = {remainder, quotient};\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= ~divisor + 1;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end else begin\n            if (counter < 8) begin\n                shift_reg <= {shift_reg[6:0], dividend[7]};\n                counter <= counter + 1;\n            end else begin\n                shift_reg <= {shift_reg[6:0], dividend[7]};\n                if (shift_reg[7])\n                    counter <= counter + 1;\n                else\n                    counter <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire ["}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // Instantiate 8-bit adders\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // Output the final sum and carry\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    add8_inst1 add8_inst3 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    add8_inst2 add8_inst4 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    add8_inst1 add8_inst5 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Co3),\n        .y(y4),\n        .Co(Co4)\n    );\n\n    add8_inst2 add8_inst6 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co4),\n        .y(y5),\n        .Co(Co5)\n    );\n\n    add8_inst1 add8_inst7 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Co5),\n        .y(y6),\n        .Co(Co6)\n    );\n\n    add8_inst2 add8_inst8 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co6),\n        .y(y7),\n        .Co(Co7)\n    );\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n\n    // Calculate absolute values\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control div_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    // Manage result\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .result(result),\n        .res_valid(res_valid)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end\n        else begin\n            if (opn_valid) begin\n                shift_reg <= {shift_reg[6:0], dividend[7]};\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire [15:0] result,\n    output reg res_valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n        end\n        else if (res_ready) begin\n            res_valid <= 1;\n        end\n        else if (counter == 0) begin\n            if (sign)\n                result <= {result[1"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [15:0] carry;\n\n    // Instantiate 8-bit adder for each 8-bit block\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n\n    wire [8:0] carry;\n\n    full_adder fa (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .y(y),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n\n    wire [8:0] carry;\n\n    full_adder fa (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .y(y),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    assign y = {y3, y2, y1, y0};\n    assign Co = Co3;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [15:8] a,\n    input wire [15:8] b,\n    input wire Cin,\n    output wire [15:8] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [15:0] quotient;\n\n    // Calculate absolute values\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control div_ctrl_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .abs_dividend(abs_dividend),\n        .neg_divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter),\n        .quotient(quotient)\n    );\n\n    // Manage result validity\n    result_management res_mgmt_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .quotient(quotient),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -divisor;\n        else\n            result <= divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter,\n    output reg [15:0] quotient\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n            quotient <= 0;\n        end else begin\n            if (counter < 8) begin\n                shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n                counter <= counter + 1;\n            end else begin\n                quotient <= {quotient[14:0], shift_reg[7]};\n                shift_reg <= {shift_reg[6:0], neg_divisor[7]};\n                counter <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [15:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend, abs_divisor;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [15:0] quotient;\n\n    // Calculate absolute values\n    abs_value abs_dividend_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    abs_value abs_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(divisor),\n        .result(abs_divisor)\n    );\n\n    // Calculate negated divisor\n    neg_divisor_mod neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(divisor),\n        .result(neg_divisor)\n    );\n\n    // Control division process\n    divider_control divider_control_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(abs_divisor),\n        .neg_divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .counter(counter)\n    );\n\n    // Manage result validity\n    result_management result_management_mod (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .counter(counter),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_divisor_mod(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire [7:0] neg_divisor,\n    output reg [7:0] shift_reg,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end\n        else begin\n            if (counter == 0) begin\n                shift_reg <= dividend;\n                counter <= 8;\n            end\n            else begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                counter <= counter - 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {A[31:16], 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] c1, c2, c3, c4, c5, c6, c7, c8;\n\n    // Instantiate 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(c1)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c1),\n        .y(y[15:8]),\n        .Co(c2)\n    );\n\n    assign Co = c2;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n\n    always @* begin\n        dividend = {A[31:16], 16'b00000000000000000};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    integer i;\n    reg [31:0] shifted_dividend;\n\n    always @* begin\n        shifted_dividend = dividend;\n        result = 0;\n        odd = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= divisor) begin\n                shifted_dividend = shifted_dividend - divisor;\n                result = result << 1;\n                result = result | 1;\n            end else begin\n                result = result << 1;\n            end\n\n            shifted_dividend = shifted_dividend << 1;\n        end\n\n        odd = dividend - (divisor * result);\n    end\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [15:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {A[31:16], 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n\n    always @(*) begin\n        dividend = {A[31:16], 16'h0000};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] counter;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        counter = 0;\n        odd = 0;\n        result = 0;\n    end\n\n    always @(posedge shifted_divisor[0]) begin\n        if (shifted_divisor == 0) begin\n            result = 0;\n            odd = shifted_dividend;\n        end else begin\n            if (shifted_dividend[0] == 1) begin\n                result = 1;\n                odd = shifted_dividend - shifted_divisor;\n            end else begin\n                result = 0;\n                odd = shifted_dividend;\n            end\n        end\n        shifted_dividend = shifted_dividend >> 1;\n        shifted_divisor = shifted_divisor >> 1;\n        counter = counter + 1;\n    end\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {A[31:16], 16'h0000};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [7:0] carry;\n\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[7] & b[7]) | (a[7] & Cin) | (b[7] & Cin);\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {16'h0000, A};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    wire [31:0] shifted_dividend;\n    wire [31:0] shifted_divisor;\n\n    assign shifted_dividend = dividend << 16;\n    assign shifted_divisor = {16'h0000, divisor};\n\n    assign result = shifted_dividend / shifted_divisor;\n    assign odd = shifted_dividend % shifted_divisor;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // Instantiate the 8-bit adder for each 8-bit chunk\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    assign y = {y3, y2, y1, y0};\n    assign Co = Co3;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n\n    prep_dividend prep_div(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n\n    always @(*) begin\n        dividend = {A[31:16], 16'h0000};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    always @(*) begin\n        result = 0;\n        odd = 0;\n        for (integer i = 0; i < 32; i = i + 1) begin\n            if (dividend[i] == 1) begin\n                result = result + (1 << (31 - i));\n                if (result >= divisor) begin\n                    result = result - divisor;\n                    odd = odd + (1 << (31 - i));\n                end\n            end\n            dividend = dividend << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] c;\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7];\n\nendmodule\n\nmodule FA0(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA1(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA2(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA3(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA4(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA5(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA6(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA7(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_div(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [31:0] divisor\n);\n\n    assign dividend = {A[31:16], 16'h0000};\n    assign divisor = {B, 16'h0000};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @* begin\n        quotient = 32'h00000000;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] prep_A;\n    wire [31:0] prep_B;\n\n    prep_dividend prep_div(\n        .A(A),\n        .B(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n\n    div_operation div_op(\n        .prep_A(prep_A),\n        .prep_B(prep_B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Submodule for preparing the dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n\n    assign prep_A = {A[31:16], 16'h0000};\n    assign prep_B = {B, 16'h0000};\n\nendmodule\n\n// Submodule for the division operation\nmodule div_operation(\n    input wire [31:0] prep_A,\n    input wire [31:0] prep_B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = prep_A;\n        while (remainder >= prep_B) begin\n            quotient = quotient + 1;\n            remainder = remainder - prep_B;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] c;\n\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7];\nendmodule\n\nmodule FA0(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA7(\n    input a, b, \n    input cin, \n    output sum, \n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_div(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [31:0] divisor\n);\n\n    assign dividend = {A[31:16], 16'h0000};\n    assign divisor = {B, 16'h0000};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @* begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {A[31:16], 16'h0000};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 32'b0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule FA0(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin,\n    output sum, cout);\n\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {16'h0000, A};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 32'b0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [31:0] divisor\n);\n\n    assign dividend = {A[31:16], 16'h0000};\n    assign divisor = {B, 16'h0000};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    wire [31:0] shifted_dividend;\n    wire [31:0] shifted_divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    assign shifted_dividend = dividend << 16;\n    assign shifted_divisor = divisor << 16;\n\n    assign quotient = shifted_dividend / shifted_divisor;\n    assign remainder = shifted_dividend % shifted_divisor;\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n\n    prep_dividend prep_div(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    integer i;\n\n    always @(*) begin\n        result = 0;\n        odd = 0;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (dividend[i] == 1) begin\n                result = result + (1 << (31 - i));\n                odd = odd + (1 << (31 - i));\n            end\n            if (odd >= divisor) begin\n                odd = odd - divisor;\n                result = result + 1;\n            end\n            dividend = dividend << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n    wire [7:0] sum_temp;\n\n    FA0 FA0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum_temp[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum_temp[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum_temp[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum_temp[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum_temp[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum_temp[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum_temp[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum_temp[7]),\n        .cout(carry[7])\n    );\n\n    assign sum = sum_temp;\n    assign cout = carry[7];\n\nendmodule\n\nmodule FA0(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] dividend\n);\n\n    assign dividend = {A[31:16], 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] q, r;\n    reg [15:0] shifted_dividend;\n    reg [3:0] counter;\n\n    always @(*) begin\n        q = 0;\n        r = A;\n        shifted_dividend = A;\n        counter = 0;\n    end\n\n    always @(posedge B) begin\n        if (B > 0) begin\n            while (r >= B) begin\n                shifted_dividend = {shifted_dividend[14:0], 1'b0};\n                r = r - B;\n                q = q << 1;\n                q = q + 1;\n                counter = counter + 1;\n            end\n            remainder = r;\n        end\n    end\n\n    assign quotient = q;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] c;\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA0(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA7(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    div_control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] quotient_reg, remainder_reg;\n    reg [15:0] dividend_reg;\n    reg [3:0] shift_reg;\n    reg [7:0] divisor_reg;\n    reg [15:0] temp_reg;\n    reg [1:0] counter;\n    reg [15:0] quotient_temp;\n    reg [15:0] remainder_temp;\n\n    always @(posedge B) begin\n        dividend_reg <= A;\n        divisor_reg <= B;\n        shift_reg <= 0;\n        counter <= 0;\n        quotient_reg <= 0;\n        remainder_reg <= 0;\n    end\n\n    always @(posedge B) begin\n        if (counter < 16) begin\n            shift_reg <= shift_reg + 1;\n            temp_reg <= {dividend_reg[15], dividend_reg[15:1]};\n            dividend_reg <= temp_reg;\n            if (shift_reg == 0) begin\n                quotient_temp <= quotient_reg;\n                remainder_temp <= remainder_reg;\n                quotient_reg <= quotient_temp;\n                remainder_reg <= remainder_temp;\n                quotient_temp <= 0;\n                remainder_temp <= 0;\n            end\n            if (dividend_reg[15:8] >= divisor_reg) begin\n                quotient_temp <= quotient_temp + {1'b0, 1'b1};\n                remainder_temp <= remainder_temp + {1'b0, 1'b1};\n            end\n            counter <= counter + 1;\n        end\n    end\n\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule FA0(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin,\n    output sum, cout);\n\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control unit\n    div_control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [3:0] counter;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        counter = 0;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    always @(posedge dividend[0]) begin\n        if (dividend[0] == 1'b0) begin\n            temp_quotient = quotient;\n            temp_remainder = remainder;\n            quotient = temp_quotient << 1;\n            remainder = temp_remainder << 1;\n        end else begin\n            temp_quotient = quotient;\n            temp_remainder = remainder;\n            quotient = temp_quotient + 1;\n            remainder = temp_remainder + divisor;\n        end\n        dividend = dividend >> 1;\n        divisor = divisor >> 1;\n        counter = counter + 1;\n    end\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] c;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c[0]));\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(sum[1]),\n        .cout(c[1]));\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(sum[2]),\n        .cout(c[2]));\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(sum[3]),\n        .cout(c[3]));\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c[3]),\n        .sum(sum[4]),\n        .cout(c[4]));\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c[4]),\n        .sum(sum[5]),\n        .cout(c[5]));\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c[5]),\n        .sum(sum[6]),\n        .cout(c[6]));\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c[6]),\n        .sum(sum[7]),\n        .cout(cout));\nendmodule\n\nmodule FA0(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA1(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA2(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA3(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA4(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA5(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA6(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule FA7(\n    input a, b, cin,\n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the results to the output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] quotient_reg;\n    reg [15:0] remainder_reg;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_dividend;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        quotient_reg = 0;\n        remainder_reg = 0;\n        shifted_dividend = dividend;\n        shifted_remainder = remainder_reg;\n        temp_quotient = 0;\n        temp_remainder = 0;\n        temp_dividend = shifted_dividend;\n        temp_remainder = shifted_remainder;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp_remainder = remainder_reg;\n        temp_quotient = quotient_reg;\n        temp"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule FA0(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [3:0] counter;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        counter = 0;\n        remainder = 0;\n        quotient = 0;\n    end\n\n    always @(posedge dividend[15]) begin\n        if (dividend[15] == 1) begin\n            quotient[15] = 1;\n            remainder = dividend - divisor;\n        end\n    end\n\n    always @(posedge dividend[14]) begin\n        if (dividend[14] == 1) begin\n            quotient[14] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[13]) begin\n        if (dividend[13] == 1) begin\n            quotient[13] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[12]) begin\n        if (dividend[12] == 1) begin\n            quotient[12] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[11]) begin\n        if (dividend[11] == 1) begin\n            quotient[11] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[10]) begin\n        if (dividend[10] == 1) begin\n            quotient[10] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[9]) begin\n        if (dividend[9] == 1) begin\n            quotient[9] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[8]) begin\n        if (dividend[8] == 1) begin\n            quotient[8] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[7]) begin\n        if (dividend[7] == 1) begin\n            quotient[7] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[6]) begin\n        if (dividend[6] == 1) begin\n            quotient[6] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[5]) begin\n        if (dividend[5] == 1) begin\n            quotient[5] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[4]) begin\n        if (dividend[4] == 1) begin\n            quotient[4] = 1;\n            remainder = remainder - divisor;\n        end\n    end\n\n    always @(posedge dividend[3]) begin\n        if (dividend"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] c;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c[0])\n    );\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(sum[1]),\n        .cout(c[1])\n    );\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(sum[2]),\n        .cout(c[2])\n    );\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(sum[3]),\n        .cout(c[3])\n    );\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c[3]),\n        .sum(sum[4]),\n        .cout(c[4])\n    );\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c[4]),\n        .sum(sum[5]),\n        .cout(c[5])\n    );\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c[5]),\n        .sum(sum[6]),\n        .cout(c[6])\n    );\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule FA0(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA7(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] q, r;\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_dividend_copy;\n    reg [15:0] shifted_dividend_copy_copy;\n    reg [15:0] shifted_dividend_copy_copy_copy;\n    reg [15:0] shifted_dividend_copy_copy_copy_copy;\n    reg [15:0] shifted_dividend_copy_copy_copy_copy_copy;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        q = 0;\n        r = 0;\n        shifted_dividend = 0;\n        shifted_dividend_copy = 0;\n        shifted_dividend_copy_copy = 0;\n        shifted_dividend_copy_copy_copy = 0;\n        shifted_dividend_copy_copy_copy_copy = 0;\n        shifted_dividend_copy_copy_copy_copy_copy = 0;\n    end\n\n    always @(posedge divisor) begin\n        if (divisor == 0) begin\n            quotient <= dividend;\n            remainder <= 0;\n        end else begin\n            shifted_dividend = {dividend[14:0], 1'b0};\n            shifted_dividend_copy = {dividend[14:0], 1'b0};\n            shifted_dividend_copy_copy = {dividend[14:0], 1'b0};\n            shifted_dividend_copy_copy_copy = {dividend[14:0], 1'b0};\n            shifted_dividend_copy_copy_copy_copy = {dividend[14:0], 1'b0};\n            shifted_dividend_copy_copy_copy_copy_copy = {dividend[14:0], 1'b0};\n            shifted_dividend_copy_copy_copy_copy_copy_copy = {dividend[14:0], 1'b0};\n            while (shifted_dividend > divisor) begin\n                shifted_dividend = shifted_dividend - divisor;\n                shifted_dividend_copy = shifted_dividend_copy - divisor;\n                shifted_dividend_copy_copy = shifted_dividend_copy_copy - divisor;\n                shifted_dividend_copy_copy_copy = shifted_dividend_copy_copy_copy - divisor;\n                shifted_dividend_copy_copy_copy_copy = shifted_dividend_copy_copy_copy_copy - divisor;\n                shifted_dividend_copy_copy_copy_copy_copy = shifted_dividend_copy_copy_copy_copy_copy -"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n    wire [7:0] sum_temp;\n\n    FA0 FA0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum_temp[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum_temp[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum_temp[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum_temp[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum_temp[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum_temp[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum_temp[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum_temp[7]),\n        .cout(cout)\n    );\n\n    assign sum = sum_temp;\n\nendmodule\n\nmodule FA0(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\n\nendmodule\n\nmodule FA6(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7("}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] quotient_reg;\n    reg [15:0] remainder_reg;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_dividend;\n    reg [15:0] temp_divisor;\n    reg [15:0] temp_quotient_reg;\n    reg [15:0] temp_remainder_reg;\n    reg [15:0] temp_shifted_dividend;\n    reg [15:0] temp_shifted_remainder;\n    reg [15:0] temp_quotient_reg_2;\n    reg [15:0] temp_remainder_reg_2;\n\n    always @* begin\n        dividend = A;\n        divisor = B;\n        quotient_reg = 0;\n        remainder_reg = 0;\n        shifted_dividend = 0;\n        shifted_remainder = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n        temp_dividend = 0;\n        temp_divisor = 0;\n        temp_quotient_reg = 0;\n        temp_remainder_reg = 0;\n        temp_shifted_dividend = 0;\n        temp_shifted_remainder = 0;\n        temp_quotient_reg_2 = 0;\n        temp_remainder_reg_2 = 0;\n    end\n\n    always @* begin\n        if (dividend > divisor) begin\n            shifted_dividend = {1'b0, dividend[15:1]};\n            shifted_remainder = dividend;\n            temp_quotient = 0;\n            temp_remainder = 0;\n            temp_dividend = shifted_dividend;\n            temp_divisor = divisor;\n            temp_quotient_reg = 0;\n            temp_remainder_reg = 0;\n            temp_shifted_dividend = shifted_dividend;\n            temp_shifted_remainder = shifted_remainder;\n            temp_quotient_reg_2 = 0;\n            temp_remainder_reg_2 = 0;\n        end else begin\n            shifted_dividend = dividend;\n            shifted_remainder = 0;\n            temp_quotient = 1;\n            temp_remainder = 0;\n            temp_dividend = dividend;\n            temp_divisor = divisor;\n            temp_quotient_reg = 1;\n            temp_remainder_reg = 0;\n            temp_shifted_dividend = dividend;\n            temp_shifted_remainder = 0;\n            temp_quotient_reg_2 = 1;\n            temp_remainder_reg_2 ="}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule FA0(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control unit\n    div_control_unit ctrl (\n        .dividend(A),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_control_unit (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] shifted_dividend;\n    reg [3:0] shift_count;\n    reg [7:0] divisor_shifted;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend >> shift_count;\n        divisor_shifted = divisor << shift_count;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    always @(posedge shifted_dividend[15]) begin\n        if (shifted_dividend[15]) begin\n            temp_quotient = temp_quotient << 1;\n            temp_quotient[0] = 1;\n            temp_remainder = temp_remainder << 1;\n            temp_remainder[0] = shifted_dividend[0];\n        end\n        else begin\n            temp_quotient = temp_quotient << 1;\n            temp_remainder = temp_remainder << 1;\n        end\n    end\n\n    always @(posedge divisor_shifted[7]) begin\n        if (divisor_shifted[7]) begin\n            quotient = temp_quotient;\n            remainder = temp_remainder;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule FA0(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA7(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b)"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] quotient_reg, remainder_reg;\n    reg [15:0] dividend_reg;\n    reg [7:0] divisor_reg;\n    reg [3:0] counter;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_dividend;\n    reg [15:0] temp_remainder;\n\n    always @(*) begin\n        dividend_reg = A;\n        divisor_reg = B;\n        shifted_dividend = {1'b0, A};\n        shifted_remainder = {1'b0, A};\n        quotient_reg = 16'b0;\n        remainder_reg = 16'b0;\n        counter = 4'b0;\n    end\n\n    always @(posedge dividend_reg[15]) begin\n        if (counter == 4'b0) begin\n            temp_quotient = 16'b0;\n            temp_remainder = 16'b0;\n            temp_dividend = dividend_reg;\n            temp_remainder = shifted_remainder;\n            shifted_remainder = {1'b0, shifted_remainder};\n        end else begin\n            temp_quotient = quotient_reg;\n            temp_remainder = remainder_reg;\n            temp_dividend = shifted_dividend;\n            shifted_dividend = {1'b0, shifted_dividend};\n        end\n\n        if (temp_dividend[15:8] >= divisor_reg) begin\n            temp_quotient = temp_quotient + 16'b1;\n            temp_remainder = temp_remainder - divisor_reg;\n        end\n\n        quotient_reg = temp_quotient;\n        remainder_reg = temp_remainder;\n        counter = counter + 1;\n    end\n\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] q, r;\n    reg [15:0] shifted_dividend;\n    reg [2:0] counter;\n\n    always @(*) begin\n        counter = 0;\n        shifted_dividend = A;\n        q = 0;\n        r = 0;\n    end\n\n    always @(posedge B) begin\n        if (counter < 16) begin\n            shifted_dividend = {shifted_dividend[14:0], 1'b0};\n            if (shifted_dividend >= B) begin\n                shifted_dividend = shifted_dividend - B;\n                q = {q[14:0], 1'b1};\n            end\n            counter = counter + 1;\n        end\n    end\n\n    assign quotient = q;\n    assign remainder = r;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] q, r;\n    reg [3:0] i;\n\n    always @(*) begin\n        q = 16'b0;\n        r = A;\n        i = 0;\n\n        while (i < 16) begin\n            if (r >= B) begin\n                r = r - B;\n                q[i] = 1;\n            end\n            r = r << 1;\n            i = i + 1;\n        end\n    end\n\n    assign quotient = q;\n    assign remainder = r;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0]));\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1]));\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2]));\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3]));\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4]));\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5]));\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6]));\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout));\n\nendmodule\n\nmodule FA0(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA1(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA2(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA3(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA4(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA5(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA6(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule FA7(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend, divisor;\n    reg [3:0] counter;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        counter = 0;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    always @(*) begin\n        if (dividend[15] == 1) begin\n            quotient[15] = 1;\n            remainder = dividend;\n            dividend = dividend << 1;\n        end\n        else begin\n            quotient[15] = 0;\n            remainder = dividend;\n            dividend = dividend << 1;\n        end\n    end\n\n    always @(*) begin\n        if (counter == 15) begin\n            quotient = quotient << 1;\n            remainder = remainder << 1;\n            counter = 0;\n        end\n        else begin\n            counter = counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA1 FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA2 FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA3 FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA4 FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA5 FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA6 FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA7 FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule FA0(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .dividend(A),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] dividend_shifted;\n    reg [7:0] divisor_shifted;\n    reg [3:0] counter;\n\n    always @(posedge dividend or posedge divisor) begin\n        dividend_shifted = dividend;\n        divisor_shifted = divisor;\n        counter = 0;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    always @(posedge dividend_shifted or posedge divisor_shifted) begin\n        if (dividend_shifted[0] == 1'b0) begin\n            quotient = quotient << 1;\n            quotient[0] = 1'b0;\n            dividend_shifted = dividend_shifted >> 1;\n        end else begin\n            quotient = quotient << 1;\n            quotient[0] = 1'b1;\n            dividend_shifted = dividend_shifted >> 1;\n        end\n\n        if (counter == 0) begin\n            divisor_shifted = divisor_shifted >> 1;\n            counter = 8;\n        end else begin\n            counter = counter - 1;\n        end\n\n        if (dividend_shifted == divisor_shifted) begin\n            remainder = dividend_shifted - divisor_shifted;\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    div_control_unit ctrl_unit (\n        .dividend(A),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_control_unit (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output wire [15:0] quotient,\n    output wire [15:0] reminder\n);\n\n    reg [15:0] quotient_reg, remainder_reg;\n    reg [3:0] shift_reg;\n\n    always @(*) begin\n        quotient_reg = 0;\n        remainder_reg = dividend;\n        shift_reg = 0;\n    end\n\n    genvar i;\n    generate\n        for (i = 0; i < 16; i = i + 1) begin : loop\n            if (remainder_reg[15:8] >= divisor) begin\n                remainder_reg = remainder_reg - divisor;\n                quotient_reg[i] = 1;\n            end\n            remainder_reg = {remainder_reg[14:0], 1'b0};\n            shift_reg = shift_reg + 1;\n        end\n    endgenerate\n\n    assign quotient = quotient_reg;\n    assign reminder = remainder_reg;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] carry;\n\n    FA0 FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    FA1 FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    FA2 FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    FA3 FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    FA4 FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    FA5 FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    FA6 FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    FA7 FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule FA0(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA1(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA2(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA3(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA4(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA5(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA6(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule FA7(\n    input a, b, cin,\n    output sum, cout);\n\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient, remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] quotient, // 16-bit quotient\n    output wire [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_quotient, temp_remainder;\n    reg [15:0] shifted_dividend;\n    reg [7:0] shifted_divisor;\n    reg [3:0] count;\n\n    always @(*) begin\n        shifted_dividend = A;\n        shifted_divisor = B;\n        count = 0;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    always @(posedge count[3]) begin\n        if (count < 16) begin\n            temp_quotient = quotient;\n            temp_remainder = remainder;\n            quotient = temp_quotient << 1;\n            remainder = temp_remainder << 1;\n            if (shifted_dividend[15:8] >= shifted_divisor) begin\n                quotient = quotient + 1;\n                remainder = remainder + shifted_divisor;\n            end\n            shifted_dividend = shifted_dividend << 1;\n            shifted_divisor = shifted_divisor << 1;\n            count = count + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [3:0] shift_count;\n    wire [31:0] product;\n\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .done(done)\n    );\n\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 4'b0000;\n            done <= 0;\n        end\n        else if (start) begin\n            shift_count <= 4'b0001;\n            done <= 0;\n        end\n        else if (shift_count == 4'b1111) begin\n            shift_count <= 4'b0000;\n            done <= 1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else if (shift_count == 4'b0000) begin\n            product <= {ain, 16'b0};\n        end\n        else if (shift_count == 4'b0001) begin\n            product <= {bin, 16'b0};\n        end\n        else if (shift_count == 4'b0010) begin\n            product <= {product[31:16], bin};\n        end\n        else if (shift_count == 4'b0011) begin\n            product <= {product[31:16], bin};\n        end\n        else if (shift_count == 4'b0100) begin\n            product <= {product[31:16], product[15:0]};\n        end\n        else if (shift_count == 4'b0101) begin\n            product <= {product[31:16], product[15:0]};\n        end\n        else if (shift_count == 4'b0110) begin\n            product <= {product[31:16], product[15:0]};\n        end\n        else if (shift_count == 4'b0111) begin\n            product <= {product[31:16], product[15:0]};\n        end\n        else if (shift_count == 4'b1000) begin\n            product <= {product[31:16], product[15:0]};\n        end\n        else if (shift_count == 4'b1001) begin\n            product"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] shift;\n    wire [31:0] y;\n    wire done_int;\n\n    // Control unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .done(done_int)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .shift(shift),\n        .p(p)\n    );\n\n    // Output assignment\n    assign yout = p;\n    assign done = done_int;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            shift <= 16;\n            done <= 0;\n        end\n        else if (shift > 0) begin\n            shift <= shift - 1;\n            done <= 0;\n        end\n        else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [15:0] a,\n    input [15:0] b\n);\n\n    reg [15:0] a_reg, b_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end\n        else begin\n            a_reg <= a;\n            b_reg <= b;\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] shift,\n    output reg [31:0] p\n);\n\n    reg [31:0] temp;\n\n    always @(posedge clk) begin\n        if (shift > 0) begin\n            temp <= temp + (b << (shift - 1));\n            p <= temp;\n        end\n        else begin\n            p <= a * b;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [3:0] shift_count;\n    wire [31:0] product;\n\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .done(done)\n    );\n\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 4'b0000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            shift_count <= 4'b0000;\n            done <= 1'b0;\n        end\n        else begin\n            if (shift_count == 4'b1111) begin\n                shift_count <= 4'b0000;\n                done <= 1'b1;\n            end\n            else begin\n                shift_count <= shift_count + 1;\n                done <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [3:0] shift_count,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else if (start) begin\n            product <= {16'b0, ain};\n        end\n        else begin\n            if (shift_count == 4'b0000) begin\n                product[15:0] <= product[15:0] + bin;\n            end\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [31:0] product\n);\n\n    wire [31:0] shifted_bin;\n\n    assign shifted_bin = {product[31], product[31:16]};\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else begin\n            if (shift_count == 4'b1111) begin\n                product <= {16'b0, shifted_bin};\n            end\n            else begin\n                product <= {product[30:0], shifted_bin[31]};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [3:0] shift_count;\n    wire [31:0] product;\n\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .done(done)\n    );\n\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 4'b0000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            shift_count <= 4'b0001;\n            done <= 1'b0;\n        end\n        else if (shift_count == 4'b1111) begin\n            shift_count <= 4'b0000;\n            done <= 1'b1;\n        end\n        else begin\n            shift_count <= shift_count + 1;\n            done <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else if (shift_count == 4'b0001) begin\n            product <= {ain, 16'b0};\n        end\n        else if (shift_count[3]) begin\n            product <= {bin, 16'b0};\n        end\n        else if (shift_count[2]) begin\n            product <= product + {16'b0, bin};\n        end\n        else if (shift_count[1]) begin\n            product <= product + {16'b0, ain};\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [31:0] product\n);\n\n    reg [31:0] shifted_bin;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_bin <= 32'b0;\n        end\n        else if (shift_count == 4'b0001) begin\n            shifted_bin <= {product[31:16], 16'b0};\n        end\n        else if (shift_count[3]) begin\n            shifted_bin <= {product[31:16], 16'b0};\n        end\n        else if (shift_count["}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] shift;\n    wire [31:0] shifted_b;\n    wire [31:0] product;\n    wire [31:0] sum;\n    wire [31:0] carry;\n    wire [31:0] temp;\n\n    // Control unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .shift(shift),\n        .product(product),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output assignment\n    assign yout = product;\n    assign done = (shift == 16) ? 1 : 0;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n        end\n        else if (start) begin\n            shift <= 1;\n        end\n        else if (shift < 16) begin\n            shift <= shift + 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [15:0] a,\n    input [15:0] b\n);\n\n    reg [15:0] a_reg, b_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end\n        else begin\n            a_reg <= a;\n            b_reg <= b;\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] shift,\n    output reg [31:0] product,\n    output reg [31:0] sum,\n    output reg [31:0] carry\n);\n\n    always @(posedge clk) begin\n        if (shift == 0) begin\n            sum <= 0;\n            carry <= 0;\n        end\n        else begin\n            product <= product + (b << (shift - 1));\n            sum <= sum + (b << (shift - 1)) + carry;\n            carry <= product[31] ? 1 : 0;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] y;\n    wire [31:0] y_next;\n    wire [31:0] p_next;\n    wire [4:0] sc_next;\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .p(p),\n        .sc(sc),\n        .y(y)\n    );\n\n    // Output assignment\n    assign yout = y;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            sc <= 0;\n            done <= 0;\n        end\n        else if (sc < 16) begin\n            sc <= sc + 1;\n            done <= 0;\n        end\n        else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [15:0] a,\n    input [15:0] b\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 0;\n            b <= 0;\n        end\n        else begin\n            a <= a;\n            b <= b;\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p,\n    output reg [31:0] y\n);\n\n    always @(posedge clk) begin\n        if (sc < 16) begin\n            p <= p + (b << sc);\n            y <= y + (a[sc] ? b : 0);\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] y;\n    wire [31:0] y_next;\n    wire [31:0] p_next;\n    wire [4:0] sc_next;\n    wire done_next;\n\n    // Control unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done_next)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .sc(sc),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p),\n        .y(y)\n    );\n\n    assign yout = y;\n    assign done = done_next;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 5'b00000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            sc <= 5'b00000;\n            done <= 1'b0;\n        end\n        else if (sc == 5'b11111) begin\n            done <= 1'b1;\n        end\n        else begin\n            sc <= sc + 1;\n            done <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [4:0] sc,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n        else if (sc == 5'b00000) begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n        else if (sc == 5'b00001) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p,\n    output reg [31:0] y\n);\n\n    always @(posedge clk) begin\n        if (sc == 5'b00000) begin\n            p <= 32'b0;\n            y <= 32'b0;\n        end\n        else if (sc == 5'b00001) begin\n            p <= b;\n            y <= 32'b0;\n        end\n        else if (sc == 5'b00010) begin\n            p <= p + (b"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] y;\n    wire done_int;\n\n    // Control Unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done_int)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .sc(sc),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p)\n    );\n\n    // Output Assignment\n    assign yout = p;\n    assign done = done_int;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 5'b00000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            sc <= 5'b00001;\n            done <= 1'b0;\n        end\n        else if (sc == 5'b11111) begin\n            sc <= 5'b00000;\n            done <= 1'b1;\n        end\n        else begin\n            sc <= sc + 1;\n            done <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [4:0] sc,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n        else if (sc == 5'b00000) begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n        else if (sc == 5'b00001) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p\n);\n\n    reg [15:0] a_reg, b_reg;\n    reg [31:0] p_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 16'b0;\n            b_reg <= 16'b0;\n            p_reg <= 32'b0;\n        end\n        else if (sc == 5'b00000) begin\n            a_reg <= a;\n            b_reg <= b;\n            p_reg <= 32'b0;\n        end\n        else"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] y;\n    wire done_int;\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done_int)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .sc(sc),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p)\n    );\n\n    // Output assignment\n    assign yout = p;\n    assign done = done_int;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 5'b00000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            sc <= 5'b000000;\n            done <= 1'b0;\n        end\n        else if (sc < 5'b111111) begin\n            sc <= sc + 1;\n            done <= 1'b0;\n        end\n        else begin\n            done <= 1'b1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [4:0] sc,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n        else if (sc == 5'b00000) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p\n);\n\n    always @(posedge clk) begin\n        if (sc == 5'b00000) begin\n            p <= 32'b0;\n        end\n        else if (sc < 5'b111111) begin\n            p <= p + (b << sc);\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [3:0] shift_count;\n    wire [31:0] product;\n\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .done(done)\n    );\n\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            shift_count <= 4'd0;\n            done <= 0;\n        end\n        else if (shift_count < 4'd15) begin\n            shift_count <= shift_count + 1;\n            done <= 0;\n        end\n        else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [3:0] shift_count,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end\n        else if (start) begin\n            product <= {16'h0, ain};\n        end\n        else if (shift_count < 4'd15) begin\n            product <= product + {16'h0, bin};\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [3:0] shift_count,\n    input [31:0] product\n);\n\n    wire [31:0] shifted_bin;\n    wire [31:0] shifted_product;\n\n    assign shifted_bin = {product[31:16], bin};\n    assign shifted_product = {product[31:16], 16'h0};\n\n    always @(posedge clk) begin\n        if (shift_count < 4'd15) begin\n            product <= shifted_product + shifted_bin << shift_count;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] shift;\n    wire [31:0] product;\n    wire [31:0] accumulator;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .done(done)\n    );\n\n    // Instantiate the register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .b(b)\n    );\n\n    // Instantiate the multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .shift(shift),\n        .product(product)\n    );\n\n    // Assign the inputs\n    assign a = ain;\n    assign b = bin;\n\n    // Assign the outputs\n    assign yout = product;\n    assign done = (shift == 16);\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            shift <= 0;\n            done <= 0;\n        end\n        else begin\n            if (shift < 16) begin\n                shift <= shift + 1;\n            end\n            else begin\n                done <= 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 0;\n            b <= 0;\n        end\n        else if (start) begin\n            a <= 0;\n            b <= 0;\n        end\n        else begin\n            a <= a;\n            b <= b;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] shift,\n    output reg [31:0] product\n);\n\n    reg [31:0] accumulator;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n            accumulator <= 0;\n        end\n        else begin\n            if (shift < 16) begin\n                accumulator <= accumulator + (b << shift);\n                product <= product;\n            end\n            else begin\n                accumulator <= accumulator + (b << (shift - 16));\n                product <= accumulator + (a << (shift - 16));\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] p_next;\n    wire [31:0] p_reg;\n    wire [4:0] sc_reg;\n    wire [31:0] yout_reg;\n    wire done_reg;\n\n    // Control Unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done_reg)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p_reg)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p_reg),\n        .p_next(p_next)\n    );\n\n    // Output Assignment\n    assign yout = p_next;\n    assign done = done_reg;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output reg done\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            sc <= 5'd16;\n            done <= 0;\n        end\n        else if (sc == 0) begin\n            done <= 1;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            p <= 0;\n        end\n        else if (sc > 0) begin\n            p <= p + (b << (sc - 1));\n        end\n        else begin\n            p <= a;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    input [31:0] p,\n    output reg [31:0] p_next\n);\n    always @(posedge clk) begin\n        if (sc > 0) begin\n            p_next <= p + (b << (sc - 1));\n        end\n        else begin\n            p_next <= a;\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [3:0] shift_count;\n    wire [31:0] product;\n\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .done(done)\n    );\n\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 4'b0000;\n            done <= 1'b0;\n        end\n        else if (start) begin\n            shift_count <= 4'b0000;\n            done <= 1'b0;\n        end\n        else if (shift_count < 4'b1111) begin\n            shift_count <= shift_count + 1;\n            done <= 1'b0;\n        end\n        else begin\n            done <= 1'b1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [3:0] shift_count,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else if (start) begin\n            product <= {16'b0, ain};\n        end\n        else if (shift_count == 4'b0000) begin\n            product[15:0] <= bin;\n        end\n        else if (shift_count < 4'b1111) begin\n            product <= product << 1;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [31:0] product\n);\n\n    reg [31:0] shifted_multiplier;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_multiplier <= 32'b0;\n        end\n        else if (shift_count == 4'b0000) begin\n            shifted_multiplier <= {16'b0, product};\n        end\n        else if (shift_count < 4'b1111) begin\n            shifted_multiplier <= shifted_multiplier << 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end\n        else if ("}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] shift;\n    wire [31:0] product;\n    wire done_int;\n\n    // Control Unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .done(done_int)\n    );\n\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .shift(shift),\n        .product(product)\n    );\n\n    assign yout = product;\n    assign done = done_int;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            shift <= 16;\n            done <= 0;\n        end\n        else if (shift > 0) begin\n            shift <= shift - 1;\n            done <= 0;\n        end\n        else begin\n            shift <= shift;\n            done <= 1;\n        end\n    end\n\nendmodule\n\nmodule reg_unit (\n    input clk,\n    input rst_n,\n    input [15:0] a,\n    input [15:0] b\n);\n\n    reg [15:0] a_reg, b_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end\n        else begin\n            a_reg <= a;\n            b_reg <= b;\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] shift,\n    output reg [31:0] product\n);\n\n    reg [31:0] p;\n\n    always @(posedge clk) begin\n        if (shift > 0) begin\n            p <= p + (b << (shift - 1));\n        end\n        else begin\n            p <= p + (b << 15);\n        end\n    end\n\n    always @(posedge clk) begin\n        if (shift > 0) begin\n            product <= p;\n        end\n        else begin\n            product <= p + (b << 15);\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] sc;\n    wire [31:0] y;\n\n    // Control unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .sc(sc),\n        .done(done)\n    );\n\n    // Register unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .sc(sc),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .sc(sc),\n        .p(p)\n    );\n\n    // Output assignment\n    assign yout = p;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] sc,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sc <= 0;\n            done <= 0;\n        end\n        else if (start) begin\n            sc <= 0;\n            done <= 0;\n        end\n        else if (sc < 16) begin\n            sc <= sc + 1;\n            done <= 0;\n        end\n        else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule reg_unit (\n    input clk,\n    input rst_n,\n    input [4:0] sc,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] a_reg,\n    output reg [15:0] b_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end\n        else if (sc == 0) begin\n            a_reg <= a;\n            b_reg <= b;\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] sc,\n    output reg [31:0] p\n);\n\n    reg [15:0] a_reg;\n    reg [15:0] b_reg;\n\n    always @(posedge clk) begin\n        if (sc > 0) begin\n            a_reg <= a;\n            b_reg <= b;\n        end\n        else begin\n            p <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (sc > 0) begin\n            if (a_reg[0] == 1) begin\n                p <= p + b_reg;\n            end\n            a_reg <= a_reg >> 1;\n            b_reg <= b_reg >> 1;\n        end\n    end\n\nendmodule"}
