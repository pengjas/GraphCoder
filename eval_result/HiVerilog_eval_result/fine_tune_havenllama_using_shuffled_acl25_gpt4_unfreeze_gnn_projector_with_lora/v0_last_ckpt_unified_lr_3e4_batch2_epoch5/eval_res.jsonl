{"task_id": "sub_8bit", "response": "input [7:0] A, B; \noutput [7:0] D; \noutput B_out; \nwire [7:0] B_comp; \nwire [7:0] sum; \nwire [7:0] carry; \nwire [7:0] B_out_temp; \nwire [7:0] D_temp; \nwire [7:0] carry_temp; \nwire [7:0] carry_temp2; \nwire [7:0] carry_temp3; \nwire [7:0] carry_temp4; \nwire [7:0] carry_temp5; \nwire [7:0] carry_temp6; \nwire [7:0] carry_temp7; \nwire [7:0] carry_temp8; \nwire [7:0] carry_temp9; \nwire [7:0] carry_temp10; \nwire [7:0] carry_temp11; \nwire [7:0] carry_temp12; \nwire [7:0] carry_temp13; \nwire [7:0] carry_temp14; \nwire [7:0] carry_temp15; \nwire [7:0] carry_temp16; \nwire [7:0] carry_temp17; \nwire [7:0] carry_temp18; \nwire [7:0] carry_temp19; \nwire [7:0] carry_temp20; \nwire [7:0] carry_temp21; \nwire [7:0] carry_temp22; \nwire [7:0] carry_temp23; \nwire [7:0] carry_temp24; \nwire [7:0] carry_temp25; \nwire [7:0] carry_temp26; \nwire [7:0] carry_temp27; \nwire [7:0] carry_temp28; \nwire [7:0] carry_temp29; \nwire [7:0] carry_temp30; \nwire [7:0] carry_temp31; \nwire [7:0] carry_temp32; \nwire [7:0] carry_temp33; \nwire [7:0] carry_temp34; \nwire [7:0] carry_temp35; \nwire [7:0] carry_temp36; \nwire [7:0] carry_temp37; \nwire [7:0] carry_temp38; \nwire [7:0] carry_temp39; \nwire [7:0] carry_temp40; \nwire [7:0] carry_temp41; \nwire [7:0] carry_temp42; \nwire [7:0] carry_temp43; \nwire [7:0] carry_temp44; \nwire [7:0] carry_temp45; \nwire [7:0] carry_temp46; \nwire [7:0] carry_temp47; \nwire [7:0] carry_temp48; \nwire [7:0] carry_temp49; \nwire [7:0] carry_temp50; \nwire [7:0] carry_temp51; \nwire [7:0] carry_temp52; \nwire [7:0] carry_temp53; \nwire [7:0] carry_temp54; \nwire [7:0] carry_temp55; \nwire [7:0] carry_temp56; \nwire [7:0] carry_temp57; \nwire [7:0] carry_temp58; \nwire [7:0] carry_temp59; \nwire [7:0] carry_temp60; \nwire [7:0] carry_temp61; \nwire [7:0] carry_temp62; \nwire [7:0] carry_temp63; \nwire [7:0] carry_temp64; \nwire [7:0] carry_temp65; \nwire [7:0] carry_temp66; \nwire [7:0] carry_temp67; \nwire [7:0] carry"}
{"task_id": "sub_8bit", "response": "input [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\n\nfull_adder fa0 (.A(A[0]), .B(B_comp[0]), .Cin(1'b0), .Sum(D[0]), .Cout(B_out_temp[0]));\nfull_adder fa1 (.A(A[1]), .B(B_comp[1]), .Cin(B_out_temp[0]), .Sum(D[1]), .Cout(B_out_temp[1]));\nfull_adder fa2 (.A(A[2]), .B(B_comp[2]), .Cin(B_out_temp[1]), .Sum(D[2]), .Cout(B_out_temp[2]));\nfull_adder fa3 (.A(A[3]), .B(B_comp[3]), .Cin(B_out_temp[2]), .Sum(D[3]), .Cout(B_out_temp[3]));\nfull_adder fa4 (.A(A[4]), .B(B_comp[4]), .Cin(B_out_temp[3]), .Sum(D[4]), .Cout(B_out_temp[4]));\nfull_adder fa5 (.A(A[5]), .B(B_comp[5]), .Cin(B_out_temp[4]), .Sum(D[5]), .Cout(B_out_temp[5]));\nfull_adder fa6 (.A(A[6]), .B(B_comp[6]), .Cin(B_out_temp[5]), .Sum(D[6]), .Cout(B_out_temp[6]));\nfull_adder fa7 (.A(A[7]), .B(B_comp[7]), .Cin(B_out_temp[6]), .Sum(D[7]), .Cout(B_out_temp[7]));\n\nassign B_out = B_out_temp[7];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout); ASSISTANT:\ninput A, B, Cin;\noutput Sum, Cout;\n\nwire C1, C2;\n\nxor x1(Sum, A, B);\nand a1(C1, A, B);\nand a2(C2, A, B);\nand a3(Cout, C1, Cin);\n\nendmodule"}
{"task_id": "sub_32bit", "response": "input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n    wire [15:0] A1, B1, Diff1, B_out1;\n    wire [31:0] Diff2, B_out2;\n    sub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff2), .B_out(B_out2));\n    assign Diff = {Diff2, Diff1};\n    assign B_out = {B_out2, B_out1};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out); ASSISTANT:\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n    wire [7:0] A1, B1, Diff1, B_out1;\n    wire [15:0] Diff2, B_out2;\n    sub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff2), .B_out(B_out2));\n    assign Diff = {Diff2, Diff1};\n    assign B_out = {B_out2, B_out1};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out); ASSISTANT:\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n    wire [3:0] A1, B1, Diff1, B_out1;\n    wire [7:0] Diff2, B_out2;\n    sub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff2), .B_out(B_out2));\n    assign Diff = {Diff2, Diff1};\n    assign B_out = {B_out2, B_out1};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out); ASSISTANT:\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n    wire [1:0] A1, B1, Diff1, B_out1;\n    wire [3:0] Diff2, B_out2;\n    sub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff2), .B_out(B_out2));\n    assign Diff = {Diff2, Diff1};\n    assign B_out = {B_out2, B_out1};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out); ASSISTANT:\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n    wire [0:0] A1, B1, Diff1, B_out1;\n    wire [1:0] Diff2, B_out2;\n    sub_1bit sub1_0(.A(A[0:0]), .B(B[0:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_1bit sub1_1(.A(A[1:1]), .B("}
{"task_id": "sub_32bit", "response": "input [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] A1, B1, Diff1, B_out1;\n\nsub_16bit sub16bit1(A[15:0], B[15:0], Diff1, B_out1);\nsub_16bit sub16bit2(A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] A1, B1, Diff1, B_out1;\n\nsub_8bit sub8bit1(A[7:0], B[7:0], Diff1, B_out1);\nsub_8bit sub8bit2(A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] A1, B1, Diff1, B_out1;\n\nsub_4bit sub4bit1(A[3:0], B[3:0], Diff1, B_out1);\nsub_4bit sub4bit2(A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] A1, B1, Diff1, B_out1;\n\nsub_2bit sub2bit1(A[1:0], B[1:0], Diff1, B_out1);\nsub_2bit sub2bit2(A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] A1, B1, Diff1, B_out1;\n\nsub_1bit sub1bit1(A[0], B[0], Diff1, B_out1);\nsub_1bit sub1bit2(A[1], B[1], Diff[1], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "wire [15:0] next_count;\n    wire [15:0] count_reg;\n\n    submodule counter_logic (\n        input wire clk,\n        input wire reset,\n        input wire up_down,\n        input wire [15:0] count,\n        output wire [15:0] next_count\n    );\n        assign next_count = (up_down == 1) ? count + 1 : count - 1;\n    endsubmodule\n\n    submodule counter_register (\n        input wire clk,\n        input wire reset,\n        input wire [15:0] next_count,\n        output reg [15:0] count_reg\n    );\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                count_reg <= 0;\n            end else begin\n                count_reg <= next_count;\n            end\n        end\n    endsubmodule\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count_reg(count_reg)\n    );\n\n    assign count = count_reg;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "reg [31:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule"}
{"task_id": "systolic1x2", "response": "reg [31:0] b1;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  assign c0 = a0 * b0;\n  assign c1 = a1 * b1;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "submodule counter_logic (\n        input wire clk,\n        input wire reset,\n        input wire up_down,\n        output wire [15:0] count\n    );\n        reg [15:0] count_reg;\n\n        always @(posedge clk) begin\n            if (reset) begin\n                count_reg <= 16'h0000;\n            end else begin\n                if (up_down) begin\n                    count_reg <= count_reg + 16'h0001;\n                end else begin\n                    count_reg <= count_reg - 16'h0001;\n                end\n            end\n        end\n\n        assign count = count_reg;\n    endsubmodule\n\n    submodule counter_register (\n        input wire clk,\n        input wire reset,\n        input wire [15:0] count,\n        output wire [15:0] count\n    );\n        reg [15:0] count_reg;\n\n        always @(posedge clk) begin\n            if (reset) begin\n                count_reg <= 16'h0000;\n            end else begin\n                count_reg <= count;\n            end\n        end\n\n        assign count = count_reg;\n    endsubmodule\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count),\n        .count(count)\n    );\nendmodule"}
{"task_id": "ring_counter", "response": "wire [7:0] init;\n    wire [7:0] transition;\n\n    // State Initialization\n    assign init = 8'b0000_0001;\n\n    // State Transition\n    assign transition = {out[6:0], out[7]};\n\n    // Output\n    assign out = reset ? init : transition;\n\nendmodule"}
{"task_id": "ring_counter", "response": "wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // State Initialization\n    submodule #(\n        .id(0),\n        .content('reset'),\n        .type('input port')\n    ) state_init_submodule (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // State Transition\n    submodule #(\n        .id(1),\n        .content('transition'),\n        .type('input port')\n    ) state_transition_submodule (\n        .clk(clk),\n        .reset(reset),\n        .out(transition_out)\n    );\n\n    // Connectivity\n    assign out = init_out | transition_out;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "wire [31:0] instr;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  wire [31:0] alu_out;\n  wire [31:0] res_reg_file_out;\n\n  stagepipe5_fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr),\n    .next_pc(next_pc)\n  );\n\n  stagepipe5_decode_stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  stagepipe5_execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .alu_out(alu_out),\n    .op(op)\n  );\n\n  stagepipe5_memory_stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res_reg_file_out(res_reg_file_out)\n  );\n\n  stagepipe5_writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .next_pc(next_pc),\n    .rd(rd),\n    .res_reg_file_out(res_reg_file_out),\n    .reg_file(reg_file)\n  );\n\n  assign res_reg_file[rd] = res_reg_file_out;\n\n  assign pc = pc + 1;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "input [63:0] A, B; \noutput [63:0] D; \noutput B_out; \n\nwire [15:0] A0, A1, B0, B1; \nwire [7:0] A00, A01, A10, A11, B00, B01, B10, B11; \nwire [15:0] D0, D1; \nwire [7:0] D00, D01, D10, D11; \nwire [15:0] D000, D001, D010, D011, D100, D101, D110, D111; \nwire [15:0] D0000, D0001, D0010, D0011, D0100, D0101, D0110, D0111; \nwire [15:0] D1000, D1001, D1010, D1011, D1100, D1101, D1110, D1111; \nwire [15:0] D00000, D000001, D000010, D000011, D000100, D000101, D000110, D000111; \nwire [15:0] D001000, D001001, D001010, D001011, D001100, D001101, D001110, D001111; \nwire [15:0] D010000, D010001, D010010, D010011, D010100, D010101, D010110, D010111; \nwire [15:0] D011000, D011001, D011010, D011011, D011100, D011101, D011110, D011111; \nwire [15:0] D100000, D100001, D100010, D100011, D100100, D100101, D100110, D100111; \nwire [15:0] D101000, D101001, D101010, D101011, D101100, D101101, D101110, D101111; \nwire [15:0] D110000, D110001, D110010, D110011, D110100, D110101, D110110, D110111; \nwire [15:0] D111000, D111001, D111010, D111011, D111100, D111101, D111110, D111111; \n\nassign A0 = A[63:32]; \nassign A1 = A[31:0]; \nassign B0 = B[63:32]; \nassign B1 = B[31:0]; \n\nassign A00 = A0[7:0]; \nassign A01 = A0[15:8]; \nassign A10 = A1[7:0]; \nassign A11 = A1[15:8]; \nassign B00 = B0[7:0]; \nassign B01 = B0[15:8]; \nassign"}
{"task_id": "alu", "response": "wire [31:0] p;\n    wire [31:0] q;\n    wire [31:0] m;\n    wire [31:0] n;\n    wire [31:0] g;\n    wire [31:0] h;\n    wire [31:0] l;\n    wire [31:0] o;\n    wire [31:0] s;\n    wire [31:0] t;\n    wire [31:0] u;\n    wire [31:0] v;\n    wire [31:0] y;\n    wire [31:0] z;\n    wire [31:0] w;\n    wire [31:0] x;\n    wire [31:0] c;\n    wire [31:0] d;\n    wire [31:0] f;\n    wire [31:0] g;\n    wire [31:0] h;\n    wire [31:0] l;\n    wire [31:0] o;\n    wire [31:0] s;\n    wire [31:0] t;\n    wire [31:0] u;\n    wire [31:0] v;\n    wire [31:0] y;\n    wire [31:0] z;\n    wire [31:0] w;\n    wire [31:0] x;\n    wire [31:0] c;\n    wire [31:0] d;\n    wire [31:0] f;\n\n    assign p = a + b;\n    assign q = a - b;\n    assign m = a * b;\n    assign n = ~a + ~b;\n    assign g = a & b;\n    assign h = a | b;\n    assign l = a << 1;\n    assign o = a >> 1;\n    assign s = a << 2;\n    assign t = a >> 2;\n    assign u = a << 3;\n    assign v = a >> 3;\n    assign y = a << 4;\n    assign z = a >> 4;\n    assign w = a << 5;\n    assign x = a >> 5;\n    assign c = a << 6;\n    assign d = a >> 6;\n    assign f = a << 7;\n\n    assign r = aluc[5'b000000, 6'b100001, 7'b10010, 8'b10101, 9'b10111, 10'b00000, 11'b00010, 12'b00110, 13'b00111, 14'b10000, 15'b10011, 16'b10101, 17'b10111, 18'b10111, 19'b10111, 20'b10111, 21'b10111, 3'b10111, 4'b10111, 5'b10111, 6'b10111, 7'b10111, 8'b10111, 9'b10111, 10'b10111, 11'b10111, 12'b10111, 13'b10111, 14'b10111, 15'b10111, 16'b10111, 17'b10111, 18'b10111, 19'b10111, 20'b10111, 21'b10111, 3'b10111, 4'b10111, 5'b10111, 6'b101111, 7'b101111, 8'b101111, 9'b10"}
{"task_id": "counter_12", "response": "Logic;\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        count <= count + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n); ASSISTANT: Logic;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        count <= count + 1;\n    else\n        count <= 4'b0000;\nend\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n); ASSISTANT: Logic;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= count;\nend\n\nendmodule"}
{"task_id": "stagepipe5", "response": "wire [31:0] instr;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  wire [31:0] alu_out;\n  wire [31:0] res_reg_file_out;\n\n  stagepipe5_fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr),\n    .next_pc(next_pc)\n  );\n\n  stagepipe5_decode_stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  stagepipe5_execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  stagepipe5_memory_stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res_reg_file_out(res_reg_file_out)\n  );\n\n  stagepipe5_writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .next_pc(next_pc),\n    .res_reg_file_out(res_reg_file_out),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign pc = 5'd0;\n  assign next_pc = pc + 5'd1;\n\nendmodule"}
{"task_id": "counter_12", "response": "reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= count + 1;\n    end\n\n    assign out = count;\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n); ASSISTANT:\n    reg [3:0] count_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_r <= 4'b0000;\n        else if (valid_count)\n            count_r <= count_r + 1;\n    end\n\n    assign count = count_r;\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "reg [15:0] a0_reg;\n  reg [15:0] a1_reg;\n  reg [15:0] a2_reg;\n  reg [15:0] a3_reg;\n  reg [15:0] b0_reg;\n  reg [31:0] c0_reg;\n  reg [31:0] c1_reg;\n  reg [31:0] c2_reg;\n  reg [31:0] c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      a0_reg <= 16'h0;\n      a1_reg <= 16'h0;\n      a2_reg <= 16'h0;\n      a3_reg <= 16'h0;\n      b0_reg <= 16'h0;\n      c0_reg <= 32'h0;\n      c1_reg <= 32'h0;\n      c2_reg <= 32'h0;\n      c3_reg <= 32'h0;\n    end else begin\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n      b0_reg <= b0;\n      c0_reg <= {a0_reg * b0_reg};\n      c1_reg <= {a1_reg * b0_reg, c0_reg};\n      c2_reg <= {a2_reg * b0_reg, c1_reg};\n      c3_reg <= {a3_reg * b0_reg, c2_reg};\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "JC_counter", "response": "wire [63:0] Q_tmp;\n    wire [63:0] Q_reg;\n    wire [63:0] Q_logic;\n\n    // Register\n    reg [63:0] Q_reg_tmp;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_reg_tmp <= 64'b0;\n        end else begin\n            Q_reg_tmp <= Q_logic;\n        end\n    end\n\n    // Logic\n    assign Q_logic = {Q_reg_tmp[62:0], Q_reg_tmp[63]};\n\n    // Output\n    assign Q = Q_logic;\n\nendmodule\n\nmodule for the Johnson Counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n); ASSISTANT: \n    reg [63:0] Q_tmp;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_tmp <= 64'b0;\n        end else begin\n            Q_tmp <= Q;\n        end\n    end\n\n    assign Q = Q_tmp;\n\nendmodule\n\nmodule for the Johnson Counter\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output [63:0]       Q_tmp\n); ASSISTANT: \n    reg [63:0] Q_tmp_tmp;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_tmp_tmp <= 64'b0;\n        end else begin\n            Q_tmp_tmp <= {Q[62:0], Q[63]};\n        end\n    end\n\n    assign Q_tmp = Q_tmp_tmp;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "input [63:0] A, B; \noutput [63:0] D; \noutput B_out; \n\nwire [31:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \nsubmodule sub2(A1, B1, D1, B1_out); \nsubmodule sub3(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_16bit(A, B, D, B_out); \ninput [15:0] A, B; \noutput [15:0] D; \noutput B_out; \n\nwire [7:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_8bit(A, B, D, B_out); \ninput [7:0] A, B; \noutput [7:0] D; \noutput B_out; \n\nwire [3:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_4bit(A, B, D, B_out); \ninput [3:0] A, B; \noutput [3:0] D; \noutput B_out; \n\nwire [1:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_2bit(A, B, D, B_out); \ninput [1:0] A, B; \noutput [1:0] D; \noutput B_out; \n\nwire [0:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_1bit(A, B, D, B_out); \ninput A, B; \noutput D; \noutput B_out; \n\nwire A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_2bit_2bit(A, B, D, B_out); \ninput [1:0] A, B; \noutput [1:0] D; \noutput B_out; \n\nwire [0:0] A1, B1, D1; \nwire B1_out; \n\nsubmodule sub0(A1, B1, D1, B1_out); \nsubmodule sub1(A1, B1, D1, B1_out); \n\nassign D = D1; \nassign B_out = B1_out; \n\nendmodule \n\nmodule sub_"}
{"task_id": "alu", "response": "wire [31:0] a_add_b;\n    wire [31:0] b_add_a;\n    wire [31:0] a_sub_b;\n    wire [31:0] b_sub_a;\n    wire [31:0] a_and_b;\n    wire [31:0] b_or_a;\n    wire [31:0] a_or_b;\n    wire [31:0] b_or_b;\n    wire [31:0] a_xor_b;\n    wire [31:0] b_xor_a;\n    wire [31:0] a_sll_b;\n    wire [31:0] b_srl_a;\n    wire [31:0] a_sra_b;\n    wire [31:0] b_sra_a;\n    wire [31:0] a_slt_b;\n    wire [31:0] b_slt_a;\n    wire [31:0] a_sltu_b;\n    wire [31:0] b_sltu_a;\n    wire [31:0] a_sllv_b;\n    wire [31:0] b_srlv_a;\n    wire [31:0] a_sra_b;\n    wire [31:0] b_srav_a;\n    wire [31:0] a_srlv_b;\n    wire [31:0] b_srlv_a;\n    wire [31:0] a_slu_b;\n    wire [31:0] b_srlu_a;\n    wire [31:0] a_slt_b;\n    wire [31:0] b_slt_a;\n    wire [31:0] a_sltu_b;\n    wire [31:0] b_sltu_a;\n    wire [31:0] a_sll_b;\n    wire [31:0] b_srl_a;\n    wire [31:0] a_sra_b;\n    wire [31:0] b_sra_a;\n    wire [31:0] a_srlv_b;\n    wire [31:0] b_srlv_a;\n    wire [31:0] a_slu_b;\n    wire [31:0] b_srlu_a;\n    wire [31:0] a_slt_b;\n    wire [31:0] b_slt_a;\n    wire [31:0] a_sltu_b;\n    wire [31:0] b_sltu_a;\n    wire [31:0] a_sllv_b;\n    wire [31:0] b_srlv_a;\n    wire [31:0] b_sra_b;\n    wire [31:0] b_srav_a;\n    wire [31:0] b_srlv_a;\n    wire [31:0] b_slt_b;\n    wire [31:0] b_slt_a;\n    wire [31:0] b_sltu_b;\n    wire [31:0] b_sltu_a;\n    wire [31:0] b_sll_b;\n    wire [31:0] b_srl_a;\n    wire [31:0] b_sra_b;\n    wire [31:0] b_srl_a;\n    wire [31:0] b_srlv_a;\n    wire [31:0] b_slu_b;\n    wire [31:0] b_srlu_a;\n    wire [31:0] b_slt_b;\n    wire [31:0] b_slt_a;\n    wire [31:0] b_sltu_b;\n    wire [31:0] b_sltu_a;\n    wire [31:0] b_sll_b;"}
{"task_id": "systolic1x4", "response": "reg [15:0] a0_reg;\n  reg [15:0] a1_reg;\n  reg [15:0] a2_reg;\n  reg [15:0] a3_reg;\n  reg [15:0] b0_reg;\n  reg [31:0] c0_reg;\n  reg [31:0] c1_reg;\n  reg [31:0] c2_reg;\n  reg [31:0] c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      a0_reg <= 16'h0;\n      a1_reg <= 16'h0;\n      a2_reg <= 16'h0;\n      a3_reg <= 16'h0;\n      b0_reg <= 16'h0;\n      c0_reg <= 32'h0;\n      c1_reg <= 32'h0;\n      c2_reg <= 32'h0;\n      c3_reg <= 32'h0;\n    end else begin\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n      b0_reg <= b0;\n      c0_reg <= {a0_reg, b0_reg};\n      c1_reg <= {a1_reg, b0_reg};\n      c2_reg <= {a2_reg, b0_reg};\n      c3_reg <= {a3_reg, b0_reg};\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "JC_counter", "response": "wire [63:0]         next_Q;\n    wire [63:0]         reg_inst;\n    wire [63:0]         logic_inst;\n\n    // Submodule: JC_register\n    reg [63:0]          reg_inst_Q;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            reg_inst_Q <= 64'h0;\n        end else begin\n            reg_inst_Q <= next_Q;\n        end\n    end\n\n    // Submodule: JC_logic\n    assign logic_inst = {reg_inst_Q[62:0], reg_inst_Q[63]};\n    assign next_Q = {logic_inst[62:0], logic_inst[63]};\n\n    // Output: Q\n    assign Q = reg_inst_Q;\n\nendmodule\n\nmodule for the Johnson Counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n); ASSISTANT:\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'h0;\n        end\n    end\nendmodule\n\nmodule for the Johnson Counter\nmodule JC_logic(\n    input [63:0]         reg_inst,\n    output [63:0]        next_Q\n); ASSISTANT:\n    assign next_Q = {reg_inst[62:0], reg_inst[63]};\nendmodule"}
{"task_id": "pe", "response": "wire [63:0] mult_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    wire [63:0] mult_result;\n    assign mult_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\n\n    // Output\n    assign c = current_value;\n\nendmodule"}
{"task_id": "pe", "response": "wire [63:0] mult_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    wire [63:0] mult_result_wire;\n    assign mult_result_wire = a * b;\n    assign mult_result = mult_result_wire;\n\n    // Accumulator Submodule\n    reg [31:0] current_value_reg;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value_reg <= 0;\n        end else begin\n            current_value_reg <= current_value_reg + mult_result[31:0];\n        end\n    end\n    assign current_value = current_value_reg;\n\n    // Output\n    assign c = current_value;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "input [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [16:1] A_out, B_out_out;\n\n// 4-bit full subtractor block\nsubmodule (sub_16bit) (A, B, A_out, B_out_out);\n    input [3:1] A, B;\n    output [3:1] A_out, B_out_out;\n    wire B_out;\n\n    // 4-bit full subtractor block\n    submodule (sub_16bit) (A_out, B_out_out);\n        input [1:1] A_out, B_out_out;\n        output B_out;\n        wire B_out;\n\n        // 4-bit full subtractor block\n        submodule (sub_16bit) (B_out_out);\n            input [1:1] B_out_out;\n            output B_out;\n            wire B_out;\n\n            // 4-bit full subtractor block\n            submodule (sub_16bit) (B_out);\n                input B_out;\n                output B_out;\n                wire B_out;\n\n                // 4-bit full subtractor block\n                submodule (sub_16bit) (B_out);\n                    input B_out;\n                    output B_out;\n                    wire B_out;\n\n                    // 4-bit full subtractor block\n                    submodule (sub_16bit) (B_out);\n                        input B_out;\n                        output B_out;\n                        wire B_out;\n\n                        // 4-bit full subtractor block\n                        submodule (sub_16bit) (B_out);\n                            input B_out;\n                            output B_out;\n                            wire B_out;\n\n                            // 4-bit full subtractor block\n                            submodule (sub_16bit) (B_out);\n                                input B_out;\n                                output B_out;\n                                wire B_out;\n\n                                // 4-bit full subtractor block\n                                submodule (sub_16bit) (B_out);\n                                    input B_out;\n                                    output B_out;\n                                    wire B_out;\n\n                                    // 4-bit full subtractor block\n                                    submodule (sub_16bit) (B_out);\n                                        input B_out;\n                                        output B_out;\n                                        wire B_out;\n\n                                        // 4-bit full subtractor block\n                                        submodule (sub_16bit) (B_out);\n                                            input B_out;\n                                            output B_out;\n                                            wire B_out;\n\n                                            // 4-bit full subtractor block\n                                            submodule (sub_16bit) (B_out);\n                                                input B_out;\n                                                output B_out;\n                                                wire B_out;\n\n                                                // 4-bit full subtractor block\n                                                submodule (sub_16bit) (B_out);\n                                                    input B_out;\n                                                    output B_out;\n                                                    wire B_out;\n\n                                                    // 4-bit full subtractor block\n                                                    submodule (sub_16bit) (B_out);\n                                                        input B_out;\n                                                        output B_out;\n                                                        wire B_out;\n\n                                                        // 4-bit full subtractor block\n                                                        submodule (sub_16bit) (B_out);\n                                                            input B_out;\n                                                            output B_out;\n                                                            wire B_out;\n\n                                                            // 4-bit full subtractor block\n                                                            submodule (sub_16bit) (B_out);\n                                                                input B_out;\n                                                                output B_out;\n                                                                wire B_out;\n\n                                                                // 4-bit full subtractor block\n                                                                submodule (sub_16bit)"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\nreg [1:0] counter_50;\nreg [1:0] counter_10;\nreg [1:0] counter_1;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        counter_50 <= 2'b0;\n        counter_10 <= 2'b0;\n        counter_1 <= 2'b0;\n    end else begin\n        if (counter_50 == 2'b11) begin\n            counter_50 <= 2'b0;\n        end else begin\n            counter_50 <= counter_50 + 1;\n        end\n        if (counter_10 == 2'b11) begin\n            counter_10 <= 2'b0;\n        end else begin\n            counter_10 <= counter_10 + 1;\n        end\n        if (counter_1 == 2'b11) begin\n            counter_1 <= 2'b0;\n        end else begin\n            counter_1 <= counter_1 + 1;\n        end\n    end\nend\n\nassign CLK_50 = (counter_50 == 2'b11);\nassign CLK_10 = (counter_10 == 2'b11);\nassign CLK_1 = (counter_1 == 2'b11);\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        counter <= 2'b0;\n    end else begin\n        if (counter == 2'b11) begin\n            counter <= 2'b0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 2'b11);\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        counter <= 2'b0;\n    end else begin\n        if (counter == 2'b11) begin\n            counter <= 2'b0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 2'b11);\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        counter <= 2'b0;\n    end else begin\n        if (counter == 2'b11) begin\n            counter <= 2'b0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 2'b11);\n\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "stagepipe3", "response": "stagepipe3_fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(fetch_stage.pc),\n    .out_instr(fetch_stage.out_instr)\n);\n\nstagepipe3_execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_stage.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute_stage.out_reg_file)\n);\n\nstagepipe3_writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_stage.out_instr),\n    .reg_file(execute_stage.out_reg_file),\n    .out_reg_file(writeback_stage.out_reg_file)\n);\n\nendmodule"}
{"task_id": "instr_reg", "response": "// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register\n// Outputs: ins, ad1\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins, ad2\n\n// Submodule for fetching instructions from the register"}
{"task_id": "accu", "response": "reg [9:0] data_out_r;\n    reg [2:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            data_out_r <= 10'h0;\n            counter <= 3'h0;\n        end else begin\n            if (valid_in) begin\n                case (counter)\n                    3'h0: data_out_r <= data_in;\n                    3'h1: data_out_r <= data_out_r + data_in;\n                    3'h2: data_out_r <= data_out_r + data_in;\n                    3'h3: data_out_r <= data_out_r + data_in;\n                    default: data_out_r <= data_out_r;\n                endcase\n                counter <= counter + 3'h1;\n            end\n        end\n    end\n\n    assign data_out = data_out_r;\n    assign valid_out = (counter == 3'h3);\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\nreg [2:0] counter_50;\nreg [2:0] counter_10;\nreg [2:0] counter_1;\n\nalways @(posedge CLK_in)\nbegin\n    if (RST) begin\n        counter_50 <= 0;\n        counter_10 <= 0;\n        counter_1 <= 0;\n    end else begin\n        if (counter_50 == 2) begin\n            counter_50 <= 0;\n            counter_10 <= counter_10 + 1;\n        end else begin\n            counter_50 <= counter_50 + 1;\n        end\n        if (counter_10 == 4) begin\n            counter_10 <= 0;\n            counter_1 <= counter_1 + 1;\n        end else begin\n            counter_10 <= counter_10 + 1;\n        end\n    end\nend\n\nassign CLK_50 = counter_50[2];\nassign CLK_10 = counter_10[2];\nassign CLK_1 = counter_1[2];\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [2:0] counter;\n\nalways @(posedge CLK_in)\nbegin\n    if (RST) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign CLK_out = counter[2];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [2:0] counter;\n\nalways @(posedge CLK_in)\nbegin\n    if (RST) begin\n        counter <= 0;\n    end else begin\n        if (counter == 4) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign CLK_out = counter[2];\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [2:0] counter;\n\nalways @(posedge CLK_in)\nbegin\n    if (RST) begin\n        counter <= 0;\n    end else begin\n        if (counter == 49) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign CLK_out = counter[2];\n\nendmodule"}
{"task_id": "accu", "response": "reg [9:0] data_accumulator;\n    reg [3:0] counter;\n    reg valid_out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator <= 10'h0;\n            counter <= 4'h0;\n            valid_out_reg <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                if (counter == 4'h0) begin\n                    data_accumulator <= data_in + data_accumulator;\n                    counter <= counter + 1;\n                end else begin\n                    counter <= counter + 1;\n                end\n            end else begin\n                counter <= 4'h0;\n            end\n            valid_out_reg <= (counter == 4'h4) ? 1'b1 : 1'b0;\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_out_reg;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "input [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [16:1] A_out, B_out_out, D_out;\n\nsub_4bit sub1(A[16:1], B[16:1], A_out, B_out_out, D_out);\nsub_4bit sub2(A_out, B_out_out, A_out, B_out_out, D_out);\nsub_4bit sub3(A_out, B_out_out, A_out, B_out_out, D_out);\nsub_4bit sub4(A_out, B_out_out, A_out, B_out_out, D_out);\n\nassign D = D_out;\nassign B_out = B_out_out;\n\nendmodule\n\nmodule sub_4bit(A, B, A_out, B_out, D);\ninput [4:1] A, B;\noutput [4:1] A_out, B_out, D;\n\nwire [4:1] B_out_out, D_out;\n\nwire [4:1] A_out_out, B_out_out_out;\n\nsub_4bit sub1(A[4:1], B[4:1], A_out_out, B_out_out_out, D_out);\nsub_4bit sub2(A_out_out, B_out_out_out, A_out, B_out, D);\n\nassign A_out = A_out_out;\nassign B_out = B_out_out_out;\nassign D = D_out;\n\nendmodule\n\nmodule sub_4bit(A, B, A_out, B_out, D);\ninput [2:1] A, B;\noutput [2:1] A_out, B_out, D;\n\nwire [2:1] B_out_out, D_out;\n\nwire [2:1] A_out_out, B_out_out_out;\n\nsub_4bit sub1(A[2:1], B[2:1], A_out_out, B_out_out_out, D_out);\nsub_4bit sub2(A_out_out, B_out_out_out, A_out, B_out, D);\n\nassign A_out = A_out_out;\nassign B_out = B_out_out_out;\nassign D = D_out;\n\nendmodule\n\nmodule sub_4bit(A, B, A_out, B_out, D);\ninput [1:1] A, B;\noutput [1:1] A_out, B_out, D;\n\nwire [1:1] B_out_out, D_out;\n\nwire [1:1] A_out_out, B_out_out_out;\n\nsub_4bit sub1(A[1:1], B[1:1], A_out_out, B_out_out_out, D_out);\nsub_4bit sub2(A_out_out, B_out_out_out, A_out, B_out, D);\n\nassign A_out = A_out_out;\nassign B_out = B_out_out_out;\nassign D = D_out;\n\nendmodule\n\nmodule sub_4bit(A, B, A_out, B_out, D);\ninput [1:1] A, B;\noutput [1:1] A_out, B_out, D;\n\nwire [1:1] B_out_out, D_out;\n\nwire [1:1] A_out_out, B_out_out_out;\n\nsub_4bit sub1(A[1:1], B[1:1], A_out_out, B_out_out_out, D_out);\nsub_4bit sub2(A_out_out, B_out_out_out, A_out, B_out, D);\n\nassign A_out = A_out_out;\nassign B_out = B_out_out_out;\nassign D = D_out;\n\nendmodule"}
{"task_id": "instr_reg", "response": "// Submodule for fetching instructions from the register\n// Outputs: ins_p1, ad1_p1\n// Inputs: data\n// Registers: ins_p1, ad1_p1\nreg [2:0] ins_p1;\nreg [4:0] ad1_p1;\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        ins_p1 <= 3'b0;\n        ad1_p1 <= 5'b0;\n    end else if (fetch == 2'b01) begin\n        ins_p1 <= data[7:5];\n        ad1_p1 <= data[4:0];\n    end\nend\n\n// Submodule for fetching instructions from the RAM/ROM\n// Outputs: ins_p2, ad2_p2\n// Inputs: data\n// Registers: ins_p2, ad2_p2\nreg [2:0] ins_p2;\nreg [7:0] ad2_p2;\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        ins_p2 <= 3'b0;\n        ad2_p2 <= 8'b0;\n    end else if (fetch == 2'b10) begin\n        ins_p2 <= data[7:5];\n        ad2_p2 <= data[4:0];\n    end\nend\n\n// Outputs\nassign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\nassign ad1 = (fetch == 2'b01) ? ad1_p1 : ad2_p2[7:3];\nassign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\n// Registers\nreg [7:0] ad2_p1;\nreg [4:0] ad1_p1;\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        ad2_p1 <= 8'b0;\n        ad1_p1 <= 5'b0;\n    end else if (fetch == 2'b01) begin\n        ad2_p1 <= data;\n        ad1_p1 <= data[4:0];\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "wire [31:0] subtraction_result;\n    wire borrow;\n\n    // Subtraction operation\n    assign {borrow, subtraction_result} = A - B;\n\n    // Carry generation\n    assign A_greater = (~borrow) & (subtraction_result != 0);\n    assign A_equal = (~borrow) & (subtraction_result == 0);\n    assign A_less = borrow;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "wire [31:0] sub_inst;\n\n// Subtraction operation\nassign sub_inst = A - B;\n\n// Carry generation\nassign A_greater = (sub_inst[31] == 1);\nassign A_equal = (sub_inst == 0);\nassign A_less = (sub_inst[31] == 0 && sub_inst != 0);\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "parameter MUL2_DIV_CLK = 7;"}
{"task_id": "radix2_div", "response": "// Submodules\n\n// Absolute Value Calculation\n\n// Calculate the absolute value of the dividend\nmodule abs_value(\n    input wire [7:0] dividend,\n    output wire [7:0] abs_dividend\n);\n\nassign abs_dividend = dividend[7] ? -dividend : dividend;\n\nendmodule\n\n// Negative Divisor Calculation\n\n// Calculate the negated absolute value of the divisor\nmodule neg_value(\n    input wire [7:0] divisor,\n    output wire [7:0] neg_divisor_mod\n);\n\nassign neg_divisor_mod = divisor[7] ? -divisor : divisor;\n\nendmodule\n\n// Division Control Logic\n\n// Manage the division process\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg res_valid\n);\n\nreg [3:0] counter_reg;\nreg [7:0] shift_reg_reg;\nreg res_valid_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        counter_reg <= 0;\n        shift_reg_reg <= 0;\n        res_valid_reg <= 0;\n    end else begin\n        if (counter_reg == 0) begin\n            counter_reg <= 1;\n            shift_reg_reg <= dividend;\n        end else if (counter_reg == 1) begin\n            counter_reg <= 2;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 2) begin\n            counter_reg <= 3;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 3) begin\n            counter_reg <= 4;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 4) begin\n            counter_reg <= 5;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 5) begin\n            counter_reg <= 6;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 6) begin\n            counter_reg <= 7;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 7) begin\n            counter_reg <= 8;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 8) begin\n            counter_reg <= 9;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 9) begin\n            counter_reg <= 10;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 10) begin\n            counter_reg <= 11;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 11) begin\n            counter_reg <= 12;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 12) begin\n            counter_reg <= 13;\n            shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n        end else if (counter_reg == 13) begin\n            counter_reg <= 14;\n            shift_reg_reg <= {shift_reg_"}
{"task_id": "square_wave", "response": "wire [7:0] count;\n    wire enable;\n    wire [7:0] freq_count;\n    wire [7:0] freq_out;\n    wire [7:0] freq_reset;\n    wire [7:0] freq_set;\n    wire [7:0] freq_toggle;\n    wire [7:0] freq_toggle_count;\n    wire [7:0] freq_toggle_reset;\n    wire [7:0] freq_toggle_set;\n    wire [7:0] freq_toggle_toggle;\n    wire [7:0] freq_toggle_toggle_count;\n    wire [7:0] freq_toggle_toggle_reset;\n    wire [7:0] freq_toggle_toggle_set;\n    wire [7:0] freq_toggle_toggle_toggle;\n\n    // Counter Module\n    wire [7:0] count;\n    wire enable;\n    wire [7:0] freq_count;\n    wire [7:0] freq_out;\n    wire [7:0] freq_reset;\n    wire [7:0] freq_set;\n    wire [7:0] freq_toggle;\n    wire [7:0] freq_toggle_count;\n    wire [7:0] freq_toggle_reset;\n    wire [7:0] freq_toggle_set;\n    wire [7:0] freq_toggle_toggle;\n    wire [7:0] freq_toggle_toggle_count;\n    wire [7:0] freq_toggle_toggle_reset;\n    wire [7:0] freq_toggle_toggle_set;\n    wire [7:0] freq_toggle_toggle_toggle;\n\n    assign enable = 1;\n    assign freq_count = 8'd1;\n    assign freq_out = 8'd1;\n    assign freq_reset = 8'd0;\n    assign freq_set = freq;\n    assign freq_toggle = freq_out;\n    assign freq_toggle_count = freq_toggle;\n    assign freq_toggle_reset = freq_toggle_count;\n    assign freq_toggle_set = freq_toggle_reset;\n    assign freq_toggle_toggle = freq_toggle_set;\n    assign freq_toggle_toggle_count = freq_toggle_toggle;\n    assign freq_toggle_toggle_reset = freq_toggle_toggle_count;\n    assign freq_toggle_toggle_set = freq_toggle_toggle_reset;\n    assign freq_toggle_toggle_toggle = freq_toggle_toggle_set;\n\n    // Wave Generator Module\n    wire [7:0] count;\n    wire enable;\n    wire [7:0] freq_count;\n    wire [7:0] freq_out;\n    wire [7:0] freq_reset;\n    wire [7:0] freq_set;\n    wire [7:0] freq_toggle;\n    wire [7:0] freq_toggle_count;\n    wire [7:0] freq_toggle_reset;\n    wire [7:0] freq_toggle_set;\n    wire [7:0] freq_toggle_toggle;\n    wire [7:0] freq_toggle_toggle_count;\n    wire [7:0] freq_toggle_toggle_reset;\n    wire [7:0] freq_toggle_toggle_set;\n    wire [7:0] freq_toggle_toggle_toggle;\n\n    assign enable = 1;\n    assign freq_count = 8'd1;\n    assign freq_out = 8'd1;\n    assign freq_reset = 8'd0;\n    assign freq_set = freq;\n    assign freq_toggle = freq_out;\n    assign freq_toggle_count = freq_toggle;\n    assign freq_toggle_reset = freq_toggle_count;\n    assign freq_toggle_set = freq_toggle_reset;\n    assign freq_toggle_toggle = freq_toggle_set;\n    assign freq_toggle_toggle_count = freq_toggle_toggle;"}
{"task_id": "adder_32bit", "response": "input [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [16:1] S1,S2,S3,S4,S5,S6,S7,S8;\nwire C1,C2,C3,C4,C5,C6,C7,C8;"}
{"task_id": "freq_divbyfrac", "response": "parameter MUL2_DIV_CLK = 7;"}
{"task_id": "radix2_div", "response": "wire [7:0] abs_dividend;\nwire [7:0] abs_divisor;\nwire [7:0] neg_divisor;\nwire [7:0] res_dividend;\nwire [7:0] res_divisor;\nwire [7:0] res_quotient;\nwire [7:0] res_remainder;\n\nwire [3:0] counter;\nwire [3:0] next_counter;\nwire [3:0] next_counter_ready;\nwire [3:0] next_counter_valid;\n\nwire [7:0] shift_reg;\nwire [7:0] next_shift_reg;\nwire [7:0] next_shift_reg_valid;"}
{"task_id": "square_wave", "response": "wire [7:0] count;\n    wire enable;\n    wire [7:0] freq_count;\n    wire [7:0] freq_out;\n    wire [7:0] freq_out_count;\n    wire [7:0] freq_out_count_next;\n    wire [7:0] freq_out_next;\n    wire [7:0] freq_out_next_next;\n    wire [7:0] freq_out_next_next_next;\n    wire [7:0] freq_out_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [7:0] freq_out_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_"}
{"task_id": "freq_divbyodd", "response": "parameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg [3:0] pos_cnt_div;\nreg [3:0] neg_cnt_div;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_cnt <= 4'd0;\n        neg_cnt <= 4'd0;\n        pos_cnt_div <= 4'd0;\n        neg_cnt_div <= 4'd0;\n        clk_div1 <= 1'b0;\n        clk_div2 <= 1'b0;\n    end else begin\n        if (pos_cnt == NUM_DIV - 1) begin\n            pos_cnt <= 4'd0;\n            pos_cnt_div <= pos_cnt_div + 1;\n        end else begin\n            pos_cnt <= pos_cnt + 1;\n        end\n        if (neg_cnt == NUM_DIV - 1) begin\n            neg_cnt <= 4'd0;\n            neg_cnt_div <= neg_cnt_div + 1;\n        end else begin\n            neg_cnt <= neg_cnt + 1;\n        end\n        clk_div1 <= (pos_cnt_div == NUM_DIV - 1);\n        clk_div2 <= (neg_cnt_div == NUM_DIV - 1);\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "input [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [16:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15,S16;\nwire [16:1] C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;"}
{"task_id": "signal_generator", "response": "reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'h0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'h1F) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'h00) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "parameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_cnt <= 4'b0;\n        neg_cnt <= 4'b0;\n        clk_div1 <= 1'b0;\n        clk_div2 <= 1'b0;\n    end else begin\n        if (pos_cnt < NUM_DIV - 1) begin\n            pos_cnt <= pos_cnt + 1;\n        end else begin\n            pos_cnt <= 4'b0;\n        end\n        if (neg_cnt < NUM_DIV - 1) begin\n            neg_cnt <= neg_cnt + 1;\n        end else begin\n            neg_cnt <= 4'b0;\n        end\n        if (pos_cnt == NUM_DIV - 1) begin\n            clk_div1 <= 1'b1;\n        end else begin\n            clk_div1 <= 1'b0;\n        end\n        if (neg_cnt == NUM_DIV - 1) begin\n            clk_div2 <= 1'b1;\n        end else begin\n            clk_div2 <= 1'b0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "div_32bit", "response": "// Prepare the dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare the dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform the division operation\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the results\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor   // 16-bit divisor\n); ASSISTANT:\n\n    // Prepare the dividend and divisor\n    assign dividend = { {16{1'b0}}, A };\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor, // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n); ASSISTANT:\n\n    // Perform the division operation\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n\n    always @(*) begin\n        quotient_reg = 32'b0;\n        remainder_reg = dividend;\n\n        // Shift the dividend and compare it with the divisor\n        for (integer i = 0; i < 32; i = i + 1) begin\n            quotient_reg = { quotient_reg[30:0], remainder_reg[31] };\n            remainder_reg = { remainder_reg[30:0], 1'b0 };\n\n            if (remainder_reg >= divisor) begin\n                remainder_reg = remainder_reg - divisor;\n                quotient_reg = quotient_reg + 1;\n            end\n        end\n\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule"}
{"task_id": "shift8", "response": "my_dff8 dff0 (\n    .clk(clk),\n    .d(d[0]),\n    .q(q[0])\n);\n\nmy_dff8 dff1 (\n    .clk(clk),\n    .d(q[0]),\n    .q(q[1])\n);\n\nmy_dff8 dff2 (\n    .clk(clk),\n    .d(q[1]),\n    .q(q[2])\n);\n\nmy_dff8 dff3 (\n    .clk(clk),\n    .d(q[2]),\n    .q(q[3])\n);\n\nmy_dff8 dff4 (\n    .clk(clk),\n    .d(q[3]),\n    .q(q[4])\n);\n\nmy_dff8 dff5 (\n    .clk(clk),\n    .d(q[4]),\n    .q(q[5])\n);\n\nmy_dff8 dff6 (\n    .clk(clk),\n    .d(q[5]),\n    .q(q[6])\n);\n\nmy_dff8 dff7 (\n    .clk(clk),\n    .d(q[6]),\n    .q(q[7])\n);\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "parameter NUM_DIV = 8;\n\nreg [3:0] cnt_reg;\nreg [3:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 4'b0;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        4'b0000: cnt_next = NUM_DIV / 2 - 1;\n        4'b0001: cnt_next = NUM_DIV / 2 - 1;\n        4'b0010: cnt_next = NUM_DIV / 2 - 1;\n        4'b0011: cnt_next = NUM_DIV / 2 - 1;\n        4'b0100: cnt_next = NUM_DIV / 2 - 1;\n        4'b0101: cnt_next = NUM_DIV / 2 - 1;\n        4'b0110: cnt_next = NUM_DIV / 2 - 1;\n        4'b0111: cnt_next = NUM_DIV / 2 - 1;\n        4'b1000: cnt_next = 0;\n        4'b1001: cnt_next = 0;\n        4'b1010: cnt_next = 0;\n        4'b1011: cnt_next = 0;\n        4'b1100: cnt_next = 0;\n        4'b1101: cnt_next = 0;\n        4'b1110: cnt_next = 0;\n        4'b1111: cnt_next = 0;\n        default: cnt_next = 0;\n    endcase\nend\n\nassign clk_div = clk & (~cnt_reg[3]);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "input [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice1_cout, csa_slice2_sum, csa_slice2_cout, csa_slice3_sum, csa_slice3_cout;\nwire [3:0] rca1_sum, rca1_cout, rca2_sum, rca2_cout;\nwire [3:0] csa_slice1_carry, csa_slice2_carry, csa_slice3_carry;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_carry, rca2_carry;\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\nassign rca2_sum = a[7:4] + b[7:4] + rca1_cout;\nassign rca2_cout = (a[7] & b[7]) | (a[7] & rca1_cout) | (b[7] & rca1_cout);\nassign rca1_carry = rca1_cout;\nassign rca2_carry = rca2_cout;\n\n// 4-bit carry select adder slice 1\nassign csa_slice1_sum = {rca1_sum[3], rca2_sum[3:2]};\nassign csa_slice1_cout = {rca1_cout, rca2_cout[1]};\nassign csa_slice1_carry = {rca1_carry, rca2_carry[1]};\n\n// 4-bit carry select adder slice 2\nassign csa_slice2_sum = {rca1_sum[7], rca2_sum[7:6]};\nassign csa_slice2_cout = {rca1_cout, rca2_cout[2]};\nassign csa_slice2_carry = {rca1_carry, rca2_carry[2]};\n\n// 4-bit carry select adder slice 3\nassign csa_slice3_sum = {rca2_sum[7], rca2_sum[7]};\nassign csa_slice3_cout = {rca2_cout, rca2_cout[2]};\nassign csa_slice3_carry = {rca2_carry, rca2_carry[2]};\n\n// 4-bit carry select adder\nassign sum = {csa_slice1_sum, csa_slice2_sum, csa_slice3_sum};\nassign cout = {csa_slice1_cout, csa_slice2_cout, csa_slice3_cout};\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "parameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nassign clk_div = counter == NUM_DIV / 2 - 1;\n\nendmodule"}
{"task_id": "shift8", "response": "0;\n\nwire [7:0] dff_out;\n\nmy_dff8 dff0 (.clk(clk), .d(d), .q(dff_out[0]));\nmy_dff8 dff1 (.clk(clk), .d(dff_out[0]), .q(dff_out[1]));\nmy_dff8 dff2 (.clk(clk), .d(dff_out[1]), .q(dff_out[2]));\n\nalways @(posedge clk) begin\n    case (sel)\n        2'b00: q <= d;\n        2'b01: q <= dff_out[0];\n        2'b02: q <= dff_out[1];\n        2'b03: q <= dff_out[2];\n        default: q <= 8'h00;\n    endcase\nend\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n); ASSISTANT: 0;\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule"}
{"task_id": "div_32bit", "response": "// Prepare the dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\n    // Perform the division operation\n    div_operation div_operation_inst (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Prepare the dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n); ASSISTANT:\n\n    // Prepare the dividend\n    wire [31:0] dividend;\n    assign dividend = {A[31:16], 16'b0};\n\n    // Prepare the divisor\n    wire [15:0] divisor;\n    assign divisor = {B[15:0], 16'b0};\n\n    // Perform the division operation\n    div_operation div_operation_inst (\n        .A(dividend),\n        .B(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Perform the division operation\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n); ASSISTANT:\n\n    // Initialize the quotient and remainder\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n    assign result = quotient;\n    assign odd = remainder;\n\n    // Initialize the dividend and divisor\n    reg [31:0] dividend;\n    reg [15:0] divisor;\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n    end\n\n    // Perform the division operation\n    integer i;\n    always @(*) begin\n        quotient = 0;\n        remainder = 0;\n        for (i = 0; i < 32; i = i + 1) begin\n            remainder = remainder << 1;\n            remainder[0] = dividend[0];\n            dividend = dividend >> 1;\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient[i] = 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "wire q0, q1, q2;\n\n    // Instantiate D flip-flop module\n    my_dff dff0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output q\n);\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\nendmodule"}
{"task_id": "div_16bit", "response": "wire [15:0] temp;\n    wire [7:0] temp_odd;\n\n    // Control unit\n    wire [15:0] dividend;\n    wire [7:0] divisor;\n    wire [3:0] i;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Connect inputs to control unit\n    assign dividend = A;\n    assign divisor = B;\n\n    // Initialize variables\n    assign temp = dividend;\n    assign temp_odd = 0;\n    assign quotient = 0;\n    assign remainder = 0;\n\n    // Perform division algorithm\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp >= divisor) begin\n                temp = temp - divisor;\n                temp_odd = temp_odd + 1;\n            end\n            temp = temp << 1;\n        end\n        quotient = temp_odd;\n        remainder = temp;\n    end\n\n    // Connect outputs to control unit\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "shift_reg", "response": "wire q0, q1, q2;\n\n    // Instantiate the D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output q\n);\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "input [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] rca1_cout, rca2_cout, rca3_cout;\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [15:0] rca1_sum_out, rca2_sum_out, rca3_sum_out;\nwire [15:0] csa_slice1_sum_out, csa_slice2_sum_out, csa_slice3_sum_out;\n\n// 4-bit ripple carry adder\nwire [3:0] csa_slice1_cout_out, csa_slice2_cout_out, csa_slice3_cout_out;\nwire [3:0] csa_slice1_sum_out_out, csa_slice2_sum_out_out, csa_slice3_sum_out_out;\n\n// 4-bit carry select adder slices\nwire [3:0] csa_slice1_cout_out_out, csa_slice2_cout_out_out, csa_slice3_cout_out_out;\nwire [3:0] csa_slice1_sum_out_out_out, csa_slice2_sum_out_out_out, csa_slice3_sum_out_out_out;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_out, rca2_cout_out, rca3_cout_out;\nwire [3:0] rca1_sum_out_out, rca2_sum_out_out, rca3_sum_out_out;\n\n// 4-bit carry select adder slices\nwire [3:0] csa_slice1_cout_out_out_out, csa_slice2_cout_out_out_out, csa_slice3_cout_out_out_out;\nwire [3:0] csa_slice1_sum_out_out_out_out, csa_slice2_sum_out_out_out_out, csa_slice3_sum_out_out_out_out;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_out_out, rca2_cout_out_out, rca3_cout_out_out;\nwire [3:0] rca1_sum_out_out_out, rca2_sum_out_out_out, rca3_sum_out_out_out;\n\n// 4-bit carry select adder slices\nwire [3:0] csa_slice1_cout_out_out_out_out, csa_slice2_cout_out_out_out_out, csa_slice3_cout_out_out_out_out;\nwire [3:0] csa_slice1_sum_out_out_out_out_out, csa_slice2_sum_out_out_out_out_out, csa_slice3_sum_out_out_out_out_out;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_out_out_out, rca2_cout_out_out_out, rca3_cout_out_out_out;\nwire [3:0] rca1_sum_out_out_out_out, rca2_sum_out_out_out_out, rca3_sum_out_out_out_out;\n\n// 4-bit carry select adder slices\nwire [3:0] csa_slice1_cout_out_out_out_out_out, csa_slice2_cout_out_out_out_out_out, csa_slice3_cout_out_out_out_out_out;\nwire [3:0] csa_slice1_sum"}
{"task_id": "div_16bit", "response": "// Control unit\nmodule div_control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nreg [15:0] temp_result;\nreg [15:0] temp_odd;\nreg [15:0] temp_dividend;\nreg [7:0] temp_divisor;\n\nalways @(*) begin\n    temp_result = 16'b0;\n    temp_odd = 16'b0;\n    temp_dividend = A;\n    temp_divisor = B;\n\n    // Perform division algorithm\n    for (int i = 0; i < 16; i = i + 1) begin\n        if (temp_dividend[15:8] >= temp_divisor) begin\n            temp_result[15:8] = temp_result[15:8] + 1;\n            temp_dividend = temp_dividend - temp_divisor;\n        end\n        temp_dividend = {temp_dividend[7:0], 1'b0};\n    end\n\n    // Calculate remainder\n    temp_odd = temp_dividend;\nend\n\nassign result = temp_result;\nassign odd = temp_odd;\n\nendmodule\n\n// Main module\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n// Connect input and output ports\nassign result = div_control_unit.result;\nassign odd = div_control_unit.odd;\n\n// Instantiate control unit\ndiv_control_unit div_control_unit (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule"}
{"task_id": "adder_16bit", "response": "wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] c0, c1, c2, c3, c4, c5, c6, c7;\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire [7:0] c00, c11, c22, c33, c44, c55, c66, c77;\n\n    assign a0 = a[0];\n    assign a1 = a[1];\n    assign a2 = a[2];\n    assign a3 = a[3];\n    assign a4 = a[4];\n    assign a5 = a[5];\n    assign a6 = a[6];\n    assign a7 = a[7];\n\n    assign b0 = b[0];\n    assign b1 = b[1];\n    assign b2 = b[2];\n    assign b3 = b[3];\n    assign b4 = b[4];\n    assign b5 = b[5];\n    assign b6 = b[6];\n    assign b7 = b[7];\n\n    assign c0 = Cin;\n    assign c1 = a0 ^ b0;\n    assign c2 = a1 ^ b1;\n    assign c3 = a2 ^ b2;\n    assign c4 = a3 ^ b3;\n    assign c5 = a4 ^ b4;\n    assign c6 = a5 ^ b5;\n    assign c7 = a6 ^ b6;\n\n    assign y0 = c0 ^ c1;\n    assign y1 = c2 ^ c3;\n    assign y2 = c4 ^ c5;\n    assign y3 = c6 ^ c7;\n    assign y4 = c0 ^ c2;\n    assign y5 = c4 ^ c6;\n    assign y6 = c1 ^ c3;\n    assign y7 = c5 ^ c7;\n\n    assign Co = c7;\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[2]) | (in[i] & ~ctrl[2]) | (~in[i] & ctrl[2]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[1]) | (in[i] & ~ctrl[1]) | (~in[i] & ctrl[1]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[0]) | (in[i] & ~ctrl[0]) | (~in[i] & ctrl[0]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[2]) | (in[i] & ~ctrl[2]) | (~in[i] & ctrl[2]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[1]) | (in[i] & ~ctrl[1]) | (~in[i] & ctrl[1]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n    integer i;\n\n    for (i = 0; i < 7; i = i + 1) begin\n        mux2X1[i] = (in[i] & ctrl[0]) | (in[i] & ~ctrl[0]) | (~in[i] & ctrl[0]);\n    end\n\n    out = mux2X1;\n\nendmodule\n\nmodule barrel_shifter (in, ctrl, out); ASSISTANT:\n    input ["}
{"task_id": "adder_16bit", "response": "adder_16bit\n\n    wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire [7:0] c0, c1, c2, c3, c4, c5, c6, c7;\n\n    assign a0 = a[7:0];\n    assign a1 = a[15:8];\n    assign a2 = a[7:0];\n    assign a3 = a[15:8];\n    assign a4 = a[7:0];\n    assign a5 = a[15:8];\n    assign a6 = a[7:0];\n    assign a7 = a[15:8];\n\n    assign b0 = b[7:0];\n    assign b1 = b[15:8];\n    assign b2 = b[7:0];\n    assign b3 = b[15:8];\n    assign b4 = b[7:0];\n    assign b5 = b[15:8];\n    assign b6 = b[7:0];\n    assign b7 = b[15:8];\n\n    assign c0 = Cin;\n    assign c1 = c0 ^ a0 ^ b0;\n    assign c2 = c1 ^ a1 ^ b1;\n    assign c3 = c2 ^ a2 ^ b2;\n    assign c4 = c3 ^ a3 ^ b3;\n    assign c5 = c4 ^ a4 ^ b4;\n    assign c6 = c5 ^ a5 ^ b5;\n    assign c7 = c6 ^ a6 ^ b6;\n\n    assign y0 = a0 ^ b0;\n    assign y1 = a1 ^ b1;\n    assign y2 = a2 ^ b2;\n    assign y3 = a3 ^ b3;\n    assign y4 = a4 ^ b4;\n    assign y5 = a5 ^ b5;\n    assign y6 = a6 ^ b6;\n    assign y7 = a7 ^ b7;\n\n    assign Co = c7;\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n\nendmodule"}
{"task_id": "adder_8bit", "response": "adder_8bit\n\nwire [7:0] a_xor_b;\nwire [7:0] a_and_b;\nwire [7:0] a_and_b_xor_cin;\nwire [7:0] sum_temp;\n\nassign a_xor_b = a ^ b;\nassign a_and_b = a & b;\nassign a_and_b_xor_cin = a_and_b ^ cin;\n\nassign {cout, sum_temp} = a_xor_b + a_and_b_xor_cin;\nassign sum = sum_temp;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "adder_8bit\n\nwire [7:0] a_xor_b;\nwire [7:0] a_and_b;\nwire [7:0] a_and_b_xor_cin;\nwire [7:0] sum_temp;\nwire [7:0] cout_temp;\n\nassign a_xor_b = a ^ b;\nassign a_and_b = a & b;\nassign a_and_b_xor_cin = a_and_b ^ cin;\n\nassign {sum_temp, cout_temp} = adder_8bit(a_xor_b, a_and_b_xor_cin, 1'b0);\n\nassign sum = a_and_b ^ sum_temp;\nassign cout = cout_temp;\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    reg [7:0] mux2X1;\n    reg [3:0] sel;\n\n    always @(\n        sel = ctrl;\n        mux2X1 = sel;\n        out = mux2X1;\n    )\nendmodule"}
{"task_id": "multi_16bit", "response": "// Control Unit.\nreg [31:0] product;\nreg [3:0] shift_count;\nreg done_flag;\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\n// Multiplier Unit.\nreg [31:0] product_reg;\n\n// Output Assignment.\nassign yout = product_reg;\nassign done = done_flag;\n\n// Control Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 0;\n        done_flag <= 0;\n    end else begin\n        if (start) begin\n            shift_count <= 0;\n            done_flag <= 0;\n        end else begin\n            if (shift_count == 15) begin\n                shift_count <= 0;\n                done_flag <= 1;\n            end else begin\n                shift_count <= shift_count + 1;\n                done_flag <= 0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product_reg <= 0;\n    end else begin\n        if (start) begin\n            product_reg <= 0;\n        end else begin\n            if (shift_count == 0) begin\n                product_reg <= product_reg + (b_reg << 16);\n            end else begin\n                product_reg <= product_reg + (b_reg << (16 - shift_count));\n            end\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product_reg;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "// Control Unit.\nreg [1:0] shift_count;\nreg [31:0] product;\nreg [31:0] multiplicand;\nreg [31:0] multiplier;\nreg [31:0] shifted_multiplier;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 2'b00;\n        product <= 32'b00000000000000000000000000000000;\n        multiplicand <= 32'b00000000000000000000000000000000;\n        multiplier <= 32'b00000000000000000000000000000000;\n        shifted_multiplier <= 32'b00000000000000000000000000000000;\n    end else begin\n        if (start) begin\n            shift_count <= 2'b00;\n            product <= 32'b0000000000000000000000000000000;\n            multiplicand <= ain;\n            multiplier <= bin;\n            shifted_multiplier <= 32'b00000000000000000000000000000000;\n        end else begin\n            if (shift_count == 2'b11) begin\n                shift_count <= 2'b00;\n            end else begin\n                shift_count <= shift_count + 1;\n            end\n            product <= product + (shifted_multiplier & {16{multiplicand[shift_count]}});\n            shifted_multiplier <= {shifted_multiplier[31:16], multiplier[shift_count]};\n        end\n    end\nend\n\nassign yout = product;\nassign done = (shift_count == 2'b11);\n\nendmodule"}
