{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] sum;\n    wire carry;\n\n    assign {carry, sum} = A + B;\n    assign D = sum;\n    assign B_out = carry;\nendmodule\n\nmodule full_adder(A, B, C, D, carry);\n    input A, B, C;\n    output D, carry;\n\n    assign {carry, D} = A + B + C;\nendmodule\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire C1, C2;\n\n    sub_16bit S1_inst (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_16bit S2_inst (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = C1 & C2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, C_out); ASSISTANT: module sub_16bit(A, B, Diff, C_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output C_out;\n\n    wire [7:0] S1, S2;\n    wire C1, C2;\n\n    sub_8bit S1_inst (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_8bit S2_inst (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[7:0] = S1;\n    assign Diff[15:8] = S2;\n    assign C_out = C1 & C2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, C_out); ASSISTANT: module sub_8bit(A, B, Diff, C_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output C_out;\n\n    wire [3:0] S1, S2;\n    wire C1, C2;\n\n    sub_4bit S1_inst (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_4bit S2_inst (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[3:0] = S1;\n    assign Diff[7:4] = S2;\n    assign C_out = C1 & C2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, C_out); ASSISTANT: module sub_4bit(A, B, Diff, C_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output C_out;\n\n    wire [1:0] S1, S2;\n    wire C1, C2;\n\n    sub_2bit S1_inst (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_2bit S2_inst (\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[1:0] = S1;\n    assign Diff[3:2] = S2;\n    assign C_out = C1 & C2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, C_out); ASSISTANT: module sub"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire B0, B1;\n\n    submodule sub0(A[31:0], B[31:0], D0, B0);\n    submodule sub1(A[31:0], B[31:0], D1, B1);\n\n    assign D[31:0] = D0;\n    assign D[63:32] = D1;\n    assign B_out = B0 | B1;\n\n    submodule sub2(A[7:0], B[7:0], D0, B0);\n    submodule sub3(A[7:0], B[7:0], D1, B1);\n\n    submodule sub4(A[7:0], B[7:0], D0, B0);\n    submodule sub5(A[7:0], B[7:0], D1, B1);\n\n    submodule sub6(A[7:0], B[7:0], D0, B0);\n    submodule sub7(A[7:0], B[7:0], D1, B1);\n\n    submodule sub8(A[7:0], B[7:0], D0, B0);\n    submodule sub9(A[7:0], B[7:0], D1, B1);\n\n    submodule sub10(A[7:0], B[7:0], D0, B0);\n    submodule sub11(A[7:0], B[7:0], D1, B1);\n\n    submodule sub12(A[7:0], B[7:0], D0, B0);\n    submodule sub13(A[7:0], B[7:0], D1, B1);\n\n    submodule sub14(A[7:0], B[7:0], D0, B0);\n    submodule sub15(A[7:0], B[7:0], D1, B1);\n\n    submodule sub16(A[7:0], B[7:0], D0, B0);\n    submodule sub17(A[7:0], B[7:0], D1, B1);\n\n    submodule sub18(A[7:0], B[7:0], D0, B0);\n    submodule sub19(A[7:0], B[7:0], D1, B1);\n\n    submodule sub20(A[7:0], B[7:0], D0, B0);\n    submodule sub21(A[7:0], B[7:0], D1, B1);\n\n    submodule sub22(A[7:0], B[7:0], D0, B0);\n    submodule sub23(A[7:0], B[7:0], D1, B1);\n\n    submodule sub24(A[7:0], B[7:0], D0, B0);\n    submodule sub25(A[7:0], B[7:0], D1, B1);\n\n    submodule sub26(A[7:0], B[7:0], D0, B0);\n    submodule sub27(A[7:0], B[7:0], D1, B1);\n\n    submodule sub28(A[7:0], B[7:0], D0, B0);\n    submodule sub29(A[7:0], B[7:0], D1, B1);\n\n    submodule sub30(A[7:0], B[7:0], D0, B0);\n    submodule sub31(A[7:0], B[7:0], D1, B1);\n\n    submodule sub32(A[7:0], B[7:0], D0, B0);\n    submodule sub33(A[7:0], B[7:0], D1, B1);\n\n    submodule sub34(A[7:"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    submodule sub1(A[16:1], B[16:1], D_out, A_out, B_out);\n    submodule sub2(A_out, B[16:4], D_out, A_out, B_out);\n    submodule sub3(A_out, B[12:4], D_out, A_out, B_out);\n    submodule sub4(A_out, B[8:4], D_out, A_out, B_out);\n\n    assign D = D_out;\n    assign B_out = B_out;\nendmodule\n\nmodule submodule(A, B, D, A_out, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    full_subtractor full_subtractor_inst1(A, B, D_out, A_out, B_out);\n\n    assign D = D_out;\n    assign B_out = B_out;\nendmodule\n\nmodule full_subtractor(A, B, D, A_out, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    wire [3:0] A_carry, B_carry, D_carry;\n\n    assign A_out = A;\n    assign B_out = B;\n\n    assign D_carry = A_out + B_out;\n    assign D_out = D_carry[3:0];\n    assign B_carry = D_carry[3];\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire carry;\n\n    // Subtraction module\n    submodule (subtractor_32bit) sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0) && (carry == 0);\n    assign A_less = (sub_result == 0) && (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result, \n    output carry     \n);\n\n    assign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C16;\n    wire C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n\n    CLA1 CLA1(.A(A[1:1]),.B(B[1:1]),.S(S[1:1]),.C1(C1),.C2(C2));\n    CLA2 CLA2(.A(A[2:2]),.B(B[2:2]),.S(S[2:2]),.C1(C3),.C2(C4));\n    CLA2 CLA3(.A(A[3:3]),.B(B[3:3]),.S(S[3:3]),.C1(C5),.C2(C6));\n    CLA2 CLA4(.A(A[4:4]),.B(B[4:4]),.S(S[4:4]),.C1(C7),.C2(C8));\n    CLA2 CLA5(.A(A[5:5]),.B(B[5:5]),.S(S[5:5]),.C1(C9),.C2(C10));\n    CLA2 CLA6(.A(A[6:6]),.B(B[6:6]),.S(S[6:6]),.C1(C11),.C2(C12));\n    CLA2 CLA7(.A(A[7:7]),.B(B[7:7]),.S(S[7:7]),.C1(C13),.C2(C14));\n    CLA2 CLA8(.A(A[8:8]),.B(B[8:8]),.S(S[8:8]),.C1(C15),.C2(C16));\n    CLA2 CLA9(.A(A[9:9]),.B(B[9:9]),.S(S[9:9]),.C1(C17),.C2(C18));\n    CLA2 CLA10(.A(A[10:10]),.B(B[10:10]),.S(S[10:10]),.C1(C19),.C2(C20));\n    CLA2 CLA11(.A(A[11:11]),.B(B[11:11]),.S(S[11:11]),.C1(C21),.C2(C22));\n    CLA2 CLA12(.A(A[12:12]),.B(B[12:12]),.S(S[12:12]),.C1(C23),.C2(C24));\n    CLA2 CLA13(.A(A[13:13]),.B(B[13:13]),.S(S[13:13]),.C1(C25),.C2(C26));\n    CLA2 CLA14(.A(A[14:14]),.B(B[14:14]),.S(S[14:14]),.C1(C27),.C2(C28));\n    CLA2 CLA15(.A(A[15:15]),.B(B[15:15]),.S(S[15:15]),.C1(C29),.C2(C30));\n    CLA2 CLA16(.A(A[16:16]),.B(B[16:16]),.S(S[16:16]),.C1(C31),.C2(C32));\n    CLA2 CLA17(.A(A[17:17]),.B(B[17:17]),.S(S[17:17]),.C1("}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry_out;\n    wire [3:0] carry_in;\n\n    // Ripple carry adder for the first 4 bits\n    wire [3:0] sum_0;\n    wire [3:0] carry_0;\n    assign {carry_0, sum_0} = a[3:0] + b[3:0] + cin;\n\n    // Ripple carry adder for the second 4 bits\n    wire [3:0] sum_1;\n    wire [3:0] carry_1;\n    assign {carry_1, sum_1} = a[7:4] + b[7:4] + carry_0[0];\n\n    // Ripple carry adder for the third 4 bits\n    wire [3:0] sum_2;\n    wire [3:0] carry_2;\n    assign {carry_2, sum_2} = a[11:8] + b[11:8] + carry_1[0];\n\n    // Ripple carry adder for the fourth 4 bits\n    wire [3:0] sum_3;\n    wire [3:0] carry_3;\n    assign {carry_3, sum_3} = a[15:12] + b[15:12] + carry_2[0];\n\n    // Carry select adder for the first 4 bits\n    wire [3:0] sum_4;\n    wire [3:0] carry_4;\n    assign {carry_4, sum_4} = (carry_0[1] & carry_1[1]) ? 4'b1000 :\n                              (carry_0[1] & carry_1[0]) ? 4'b1001 :\n                              (carry_0[0] & carry_1[1]) ? 4'b1010 :\n                              (carry_0[0] & carry_1[0]) ? 4'b1011 :\n                              (carry_0[1] & carry_2[1]) ? 4'b1100 :\n                              (carry_0[1] & carry_2[0]) ? 4'b1101 :\n                              (carry_0[0] & carry_2[1]) ? 4'b1110 :\n                              (carry_0[0] & carry_2[0]) ? 4'b1111 :\n                              (carry_1[1] & carry_2[1]) ? 4'b0100 :\n                              (carry_1[1] & carry_2[0]) ? 4'b0101 :\n                              (carry_1[0] & carry_2[1]) ? 4'b0110 :\n                              (carry_1[0] & carry_2[0]) ? 4'b0111 :\n                              (carry_2[1] & carry_3[1]) ? 4'b0010 :\n                              (carry_2[1] & carry_3[0]) ? 4'b0011 :\n                              (carry_2[0] & carry_3[1]) ? 4'b0100 :\n                              (carry_2[0] & carry_3[0]) ? 4'b0101 : 4'b0000;\n\n    // Carry select adder for the second 4 bits\n    wire [3:0] sum_5;\n    wire [3:0] carry_5;\n    assign {carry_5, sum_5} = (carry_1[2] & carry_2[2]) ? 4'b1000 :\n                              (carry_1[2] & carry_2[1]) ? 4'b1001 :\n                              (carry_1[1] & carry_2[2]) ? 4'b1010 :\n                              (car"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    // Counter logic\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'h0000;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    // Counter register\n    reg [15:0] count_next;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_next <= 16'h0000;\n        end else begin\n            count_next <= count_reg;\n        end\n    end\n\n    assign count = count_next;\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] count_next\n);\n    assign count_next = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire [15:0] count_next,\n    input wire clk,\n    input wire reset,\n    output reg [15:0] count_reg\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'h0000;\n        end else begin\n            count_reg <= count_next;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    // State initialization submodule\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State transition submodule\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    // Addition submodule\n    module add_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output zero,\n        output carry\n    );\n        assign {r, carry} = a + b;\n        assign zero = (r == 32'b0);\n    endmodule\n\n    // Subtraction submodule\n    module sub_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output zero,\n        output carry\n    );\n        assign {r, carry} = a - b;\n        assign zero = (r == 32'b0);\n    endmodule\n\n    // AND submodule\n    module and_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r\n    );\n        assign r = a & b;\n    endmodule\n\n    // OR submodule\n    module or_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r\n    );\n        assign r = a | b;\n    endmodule\n\n    // XOR submodule\n    module xor_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r\n    );\n        assign r = a ^ b;\n    endmodule\n\n    // NOR submodule\n    module nor_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r\n    );\n        assign r = ~(a | b);\n    endmodule\n\n    // SLT submodule\n    module slt_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output zero,\n        output carry,\n        output negative,\n        output overflow\n    );\n        assign {r, carry} = a < b;\n        assign zero = (r == 32'b0);\n        assign negative = (r[31] == 1);\n        assign overflow = (a[31] == 1 && b[31] == 0 && r[31] == 0);\n    endmodule\n\n    // SLTU submodule\n    module sltu_submodule(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output zero,\n        output carry,\n        output negative,\n        output overflow\n    );\n        assign {r, carry} = a < b;\n        assign zero = (r == 32'b0);\n        assign negative = (r[31] == 1);\n        assign overflow = (a[31] == 0 && b[31] == 1 && r[31] == 1);\n    endmodule\n\n    // SLL submodule\n    module sll_submodule(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] r\n    );\n        assign r = a << b;\n    endmodule\n\n    // SRL submodule\n    module srl_submodule(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] r\n    );\n        assign r = a >> b;\n    endmodule\n\n    // SRA submodule\n    module sra_submodule(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] r\n    );\n        assign r = $signed(a) >>> b;\n    endmodule\n\n    //"}
{"task_id": "counter_12", "response": "module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end else if (valid_count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nassign out = count;\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'b0;\n    end else begin\n        Q_reg <= Q;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]      Q_next\n);\n\nassign Q_next = {Q[62:0], ~Q[63]};\n\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    // Multiplier submodule\n    reg [63:0] product;\n    always @(posedge clk) begin\n        if (rst) begin\n            product <= 0;\n        end else begin\n            product <= a * b;\n        end\n    end\n\n    // Accumulator submodule\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\n    // Output\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            product <= 0;\n        end else begin\n            product <= a * b;\n        end\n    end\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    reg [1:0] clk_div_2;\n    reg [3:0] clk_div_10;\n    reg [4:0] clk_div_100;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_2 <= 2'b00;\n            clk_div_10 <= 4'b0000;\n            clk_div_100 <= 5'b00000;\n        end else begin\n            if (clk_div_2 == 2'b11) begin\n                clk_div_2 <= 2'b00;\n            end else begin\n                clk_div_2 <= clk_div_2 + 1;\n            end\n\n            if (clk_div_10 == 4'b1001) begin\n                clk_div_10 <= 4'b0000;\n            end else begin\n                clk_div_10 <= clk_div_10 + 1;\n            end\n\n            if (clk_div_100 == 5'b10011) begin\n                clk_div_100 <= 5'b00000;\n            end else begin\n                clk_div_100 <= clk_div_100 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = clk_div_2[1];\n    assign CLK_10 = clk_div_10[3];\n    assign CLK_1 = clk_div_100[4];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [7:0] ins_p1;\nreg [7:0] ins_p2;\n\nalways @(posedge clk) begin\n    if (rst == 1'b0) begin\n        ins_p1 <= 8'b0;\n        ins_p2 <= 8'b0;\n    end else begin\n        if (fetch == 2'b01) begin\n            ins_p1 <= data;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data;\n        end\n    end\nend\n\nassign ins = {ins_p2[7:5], ins_p1[7:5]};\nassign ad1 = {ins_p2[4:0], ins_p1[4:0]};\nassign ad2 = ins_p2;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n    wire enable;\n\n    // Counter Module\n    reg [7:0] counter_reg;\n    always @(posedge clk) begin\n        if (enable) begin\n            if (counter_reg == (freq - 1)) begin\n                counter_reg <= 0;\n            end else begin\n                counter_reg <= counter_reg + 1;\n            end\n        end\n    end\n    assign count = counter_reg;\n    assign enable = (freq > 0);\n\n    // Wave Generator Module\n    reg wave_out_reg;\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                wave_out_reg <= ~wave_out_reg;\n            end\n        end\n    end\n    assign wave_out = wave_out_reg;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\n    reg [7:0] counter_reg;\n    always @(posedge clk) begin\n        if (enable) begin\n            if (counter_reg == (freq - 1)) begin\n                counter_reg <= 0;\n            end else begin\n                counter_reg <= counter_reg + 1;\n            end\n        end\n    end\n    assign count = counter_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg wave_out_reg;\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n    assign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK-1:0] counter;\nreg [MUL2_DIV_CLK-1:0] clk_average;\nreg [MUL2_DIV_CLK-1:0] clk_adjustment;\n\nassign clk_div = clk_average[0] | clk_adjustment[0];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        clk_average <= 0;\n        clk_adjustment <= 0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == MUL2_DIV_CLK-1) begin\n            counter <= 0;\n            clk_average <= clk_average + 1;\n        end\n        clk_adjustment <= clk_average - 1;\n    end\nend\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK-1:0] counter\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        if (counter == MUL2_DIV_CLK-1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [MUL2_DIV_CLK-1:0] counter,\n    output reg [MUL2_DIV_CLK-1:0] clk_average\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        if (counter == MUL2_DIV_CLK-1) begin\n            clk_average <= clk_average + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [MUL2_DIV_CLK-1:0] counter,\n    input [MUL2_DIV_CLK-1:0] clk_average,\n    output reg [MUL2_DIV_CLK-1:0] clk_adjustment\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        if (counter == MUL2_DIV_CLK-1) begin\n            clk_adjustment <= clk_average - 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "signal_generator", "response": "reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry[7];\nendmodule\n\nmodule adder_8bit(A, B, C, D, C_out);\n    input [7:0] A, B, C;\n    output [7:0] D;\n    output C_out;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign {carry, sum} = A + B + C;\n    assign D = sum;\n    assign C_out = carry[7];\nendmodule\n\nmodule full_adder(A, B, C, D, C_out);\n    input A, B, C;\n    output D, C_out;\n\n    assign D = A ^ B ^ C;\n    assign C_out = (A & B) | (C & (A ^ B));\nendmodule\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n  reg [31:0] c0_reg, c1_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      c0_reg <= 32'b0;\n      c1_reg <= 32'b0;\n    end else begin\n      b1 <= b0;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] c_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      c_reg <= 32'b0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n\n  assign c = c_reg;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    // Instantiate D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    // Instantiate 4-to-1 multiplexer\n    reg [3:0] mux_out;\n    always @(*) begin\n        case (sel)\n            2'b00: mux_out = {d[0], d[0], d[0], d[0]};\n            2'b01: mux_out = {d[1], d[1], d[1], d[1]};\n            2'b10: mux_out = {d[2], d[2], d[2], d[2]};\n            2'b11: mux_out = {d[3], d[3], d[3], d[3]};\n            default: mux_out = 4'b0;\n        endcase\n    end\n\n    // Connect multiplexer output to shift register output\n    always @(posedge clk) begin\n        q <= mux_out;\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [$clog2(NUM_DIV) - 1:0] pos_counter;\nreg [$clog2(NUM_DIV) - 1:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        neg_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (pos_counter == NUM_DIV - 1) begin\n            pos_counter <= 0;\n            clk_div1 <= 1;\n        end else begin\n            pos_counter <= pos_counter + 1;\n            clk_div1 <= 0;\n        end\n        if (neg_counter == NUM_DIV - 1) begin\n            neg_counter <= 0;\n            clk_div2 <= 1;\n        end else begin\n            neg_counter <= neg_counter + 1;\n            clk_div2 <= 0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\nparameter NUM_DIV = 5;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\nparameter NUM_DIV = 5;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    // Instantiate D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire C1, C2;\n\n    sub_16bit S1_inst (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_16bit S2_inst (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = C1 | C2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, C_out); ASSISTANT: module sub_16bit(A, B, Diff, C_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output C_out;\n\n    wire [7:0] S1, S2;\n    wire C1, C2;\n\n    sub_8bit S1_inst (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_8bit S2_inst (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[7:0] = S1;\n    assign Diff[15:8] = S2;\n    assign C_out = C1 | C2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, C_out); ASSISTANT: module sub_8bit(A, B, Diff, C_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output C_out;\n\n    wire [3:0] S1, S2;\n    wire C1, C2;\n\n    sub_4bit S1_inst (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_4bit S2_inst (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[3:0] = S1;\n    assign Diff[7:4] = S2;\n    assign C_out = C1 | C2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, C_out); ASSISTANT: module sub_4bit(A, B, Diff, C_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output C_out;\n\n    wire [1:0] S1, S2;\n    wire C1, C2;\n\n    sub_2bit S1_inst (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1),\n        .C_out(C1)\n    );\n\n    sub_2bit S2_inst (\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2),\n        .C_out(C2)\n    );\n\n    assign Diff[1:0] = S1;\n    assign Diff[3:2] = S2;\n    assign C_out = C1 | C2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, C_out); ASSISTANT: module sub"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n  reg [31:0] rd_val;\n  reg [31:0] op;\n  reg [31:0] alu_out;\n\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_out;\n\n  wire [31:0] res_reg_file [0:31];\n\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .fetch_out(fetch_out)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .rd_val(rd_val),\n    .op(op)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .op(op),\n    .execute_out(execute_out)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .memory_out(memory_out)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .rd_val(rd_val),\n    .writeback_out(writeback_out)\n  );\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 32'h00000000;\n      instr <= 32'h00000000;\n      rs1_val <= 32'h00000000;\n      rs2_val <= 32'h00000000;\n      rd_val <= 32'h00000000;\n      op <= 32'h00000000;\n      alu_out <= 32'h00000000;\n    end else begin\n      pc <= pc + 1;\n      instr <= instr_mem[pc];\n      rs1_val <= reg_file[instr[20:16]];\n      rs2_val <= reg_file[instr[15:11]];\n      rd_val <= instr[15:11];\n      op <= instr[31:26];\n      alu_out <= execute_out;\n    end\n  end\n\n  assign res_reg_file[0] = fetch_out;\n  assign res_reg_file[1] = decode_out;\n  assign res_reg_file[2] = execute_out;\n  assign res_reg_file[3] = memory_out;\n  assign res_reg_file[4] = writeback_out;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  output [31:0] fetch_out\n);\n\n  reg [31:0] instr;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter == 0) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] ctrl,\n    output [7:0] out\n);\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    wire [7:0] stage1_mux_out;\n    wire [7:0] stage1_shift_out;\n\n    // Stage 2\n    wire [7:0] stage2_mux_out;\n    wire [7:0] stage2_shift_out;\n\n    // Stage 3\n    wire [7:0] stage3_mux_out;\n    wire [7:0] stage3_shift_out;\n\n    // Stage 1\n    assign stage1_mux_out = (ctrl[2] == 1'b1) ? in : stage1_shift_out;\n    assign stage1_shift_out = (ctrl[2] == 1'b0) ? stage1_mux_out : in;\n\n    // Stage 2\n    assign stage2_mux_out = (ctrl[1] == 1'b1) ? stage1_shift_out : stage2_shift_out;\n    assign stage2_shift_out = (ctrl[1] == 1'b0) ? stage2_mux_out : stage1_shift_out;\n\n    // Stage 3\n    assign stage3_mux_out = (ctrl[0] == 1'b1) ? stage2_shift_out : stage3_shift_out;\n    assign stage3_shift_out = (ctrl[0] == 1'b0) ? stage3_mux_out : stage2_shift_out;\n\n    // Output\n    assign out = stage3_shift_out;\n\nendmodule\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//     .in(in),\n//     .ctrl(ctrl),\n//     .out(out)\n// );\n\n// Input:\n//     in = 8'b10101010;\n//     ctrl = 3'b000;\n// Output:\n//     out = 8'b10101010;\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//     .in(in),\n//     .ctrl(ctrl),\n//     .out(out)\n// );\n\n// Input:\n//     in = 8'b10101010;\n//     ctrl = 3'b001;\n// Output:\n//     out = 8'b10101010;\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//     .in(in),\n//     .ctrl(ctrl),\n//     .out(out)\n// );\n\n// Input:\n//     in = 8'b10101010;\n//     ctrl = 3'b010;\n// Output:\n//     out = 8'b10101010;\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//     .in(in),\n//     .ctrl(ctrl),\n//     .out(out)\n// );\n\n// Input:\n//     in = 8'b10101010;\n//     ctrl = 3'b100;\n// Output:\n//     out = 8'b10101010;\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//     .in(in),\n//     .ctrl(ctrl),\n//     .out(out)\n// );\n\n// Input:\n//     in = 8'b10101010;\n//     ctrl = 3'b101;\n// Output:\n//     out = 8'b10101010;\n\n// Example usage:\n// barrel_shifter barrel_shifter_inst (\n//"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:32], B[63:32], D[63:32], B_out);\n    submodule sub1(A[31:0], B[31:0], D[31:0], B_out);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:0], B[15:0], D[15:0], B_out);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:0], B[15:0], D[15:0], B_out);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:0], B[15:0], D[15:0], B_out);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:48], B[63:48], D[63:48], B_out);\n    submodule sub1(A[47:32], B[47:32], D[47:32], B_out);\n    submodule sub2(A[31:16], B[31:16], D[31:16], B_out);\n    submodule sub3(A[15:0], B[15:0], D[15:0], B_out);\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0(A[63:48], B"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      c1_reg <= 32'b0;\n      c2_reg <= 32'b0;\n      c3_reg <= 32'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c1_reg <= c0;\n      c2_reg <= c1_reg;\n      c3_reg <= c2_reg;\n    end\n  end\n\n  assign c1 = a1 * b1;\n  assign c2 = a2 * b2;\n  assign c3 = a3 * b3;\n\nendmodule\n\nmodule top_module(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  systolic1x4 pe0(\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .a1(a1),\n    .a2(a2),\n    .a3(a3),\n    .b0(b0),\n    .c0(c0),\n    .c1(c1),\n    .c2(c2),\n    .c3(c3)\n  );\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] C_out;\n\n    submodule sub1(A[16:1], B[16:1], D[16:1], B_out);\n    submodule sub2(A[16:4], B[16:4], D[16:4], B_out);\n    submodule sub3(A[16:8], B[16:8], D[16:8], B_out);\n    submodule sub4(A[16:12], B[16:12], D[16:12], B_out);\n\n    assign D[16:1] = {A_out, C_out};\n    assign B_out = C_out[3];\n\n    submodule sub1(A[16:1], B[16:1], D[16:1], B_out);\n    submodule sub2(A[16:4], B[16:4], D[16:4], B_out);\n    submodule sub3(A[16:8], B[16:8], D[16:8], B_out);\n    submodule sub4(A[16:12], B[16:12], D[16:12], B_out);\n\n    assign A_out = A[16] ^ B[16] ^ C_out[3];\n    assign C_out[0] = A[16] & B[16];\n    assign C_out[1] = A[15] ^ B[15] ^ C_out[0];\n    assign C_out[2] = A[14] ^ B[14] ^ C_out[1];\n    assign C_out[3] = A[13] ^ B[13] ^ C_out[2];\n\n    assign D[16:1] = {A_out, C_out};\n    assign B_out = C_out[3];\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] C_out;\n\n    assign A_out = A[16] ^ B[16] ^ C_out[3];\n    assign C_out[0] = A[16] & B[16];\n    assign C_out[1] = A[15] ^ B[15] ^ C_out[0];\n    assign C_out[2] = A[14] ^ B[14] ^ C_out[1];\n    assign C_out[3] = A[13] ^ B[13] ^ C_out[2];\n\n    assign D[16:1] = {A_out, C_out};\n    assign B_out = C_out[3];\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nreg [31:0] pc;\nreg [31:0] instr;\nreg [31:0] op1;\nreg [31:0] op2;\nreg [31:0] result;\nreg [31:0] reg_file_out [0:31];\n\nwire [31:0] instr_mem_out;\nwire [31:0] reg_file_in [0:31];\n\nassign instr_mem_out = instr_mem[pc];\nassign reg_file_in = reg_file;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pc <= 0;\n        instr <= 0;\n        op1 <= 0;\n        op2 <= 0;\n        result <= 0;\n        reg_file_out <= 0;\n    end else begin\n        pc <= pc + 1;\n        instr <= instr_mem_out;\n        op1 <= reg_file_in[instr[25:21]];\n        op2 <= reg_file_in[instr[20:16]];\n        case (instr[5:0])\n            6'b000000: result <= op1 + op2;\n            6'b000010: result <= op1 - op2;\n            default: result <= 0;\n        endcase\n        reg_file_out[instr[15:11]] <= result;\n    end\nend\n\nassign out_reg_file = reg_file_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] instr\n);\n\nreg [31:0] pc;\nreg [31:0] instr_mem_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pc <= 0;\n        instr_mem_out <= 0;\n    end else begin\n        pc <= pc + 1;\n        instr_mem_out <= instr_mem[pc];\n    end\nend\n\nassign instr = instr_mem_out;\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n\nreg [31:0] op1_out;\nreg [31:0] op2_out;\nreg [31:0] result_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        op1_out <= 0;\n        op2_out <= 0;\n        result_out <= 0;\n    end else begin\n        case (instr[5:0])\n            6'b000000: begin\n                op1_out <= reg_file[instr[25:21]];\n                op2_out <= reg_file[instr[20:16]];\n                result_out <= op1_out + op2_out;\n            end\n            6'b000010: begin\n                op1_out <= reg_file[instr[25:21]];\n                op2_out <= reg_file[instr[20:16]];\n                result_out <= op1_out - op2_out;\n            end\n            default: begin\n                op1_out <= 0;\n                op2_out <= 0;\n                result_out <= 0;\n            end\n        endcase\n    end\nend\n\nassign op1 = op1_out;"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    // Subtractor module\n    module subtractor_32bit(\n        input [31:0] A,\n        input [31:0] B,\n        output [31:0] result,\n        output carry\n    );\n        assign {carry, result} = A - B;\n    endmodule\n\n    // Instantiate submodule\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(result),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (result != 0) && (carry == 0);\n    assign A_equal = (result == 0) && (carry == 0);\n    assign A_less = (result == 0) && (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C16;\n    wire [15:1] A1,B1,S1;\n    wire C1;\n\n    wire [7:1] C8;\n    wire [7:1] A2,B2,S2;\n    wire C2;\n\n    wire [3:1] C4;\n    wire [3:1] A4,B4,S4;\n    wire C4_1;\n\n    wire [1:1] C2_1;\n    wire [1:1] A2_1,B2_1,S2_1;\n    wire C2_2;\n\n    wire [1:1] C1_1;\n    wire [1:1] A1_1,B1_1,S1_1;\n    wire C1_2;\n\n    wire C32;\n\n    CLA1 CLA1(.A(A1),.B(B1),.S(S1),.C(C1));\n    CLA2 CLA2(.A(A2),.B(B2),.S(S2),.C(C2));\n    CLA2 CLA2_1(.A(A2_1),.B(B2_1),.S(S2_1),.C(C2_1));\n    CLA2 CLA2_2(.A(A2_1),.B(B2_1),.S(S2_1),.C(C2_2));\n    CLA1 CLA1_1(.A(A1_1),.B(B1_1),.S(S1_1),.C(C1_1));\n    CLA1 CLA1_2(.A(A1_1),.B(B1_1),.S(S1_1),.C(C1_2));\n\n    assign C16 = C1 + C2 + C2_1 + C2_2 + C1_1 + C1_2;\n    assign C32 = C16[15];\n    assign A1 = A[1:1];\n    assign B1 = B[1:1];\n    assign A2 = A[16:15];\n    assign B2 = B[16:15];\n    assign A4 = A[32:17];\n    assign B4 = B[32:17];\n    assign A2_1 = A[33:16];\n    assign B2_1 = B[33:16];\n    assign A1_1 = A[34:15];\n    assign B1_1 = B[34:15];\n    assign A2_1 = A[35:16];\n    assign B2_1 = B[35:16];\n    assign A1_1 = A[36:15];\n    assign B1_1 = B[36:15];\n    assign S1 = A1 + B1;\n    assign S2 = A2 + B2;\n    assign S4 = A4 + B4;\n    assign S2_1 = A2_1 + B2_1;\n    assign S2_1 = A2_1 + B2_1;\n    assign S1_1 = A1_1 + B1_1;\n    assign S1_1 = A1_1 + B1_1;\n    assign S2_1 = A2_1 + B2_1;\n    assign S2_1 = A2_1 + B2_1;\n    assign S1_1 = A1_1 + B1_1;\n    assign S1_1 = A1_1 + B1_1;\n\nendmodule\n\nmodule CLA1(A,B,S,C);\n    input [15:1] A,B;\n    output [15:1] S;\n    output C;\n\n    wire [7:1] C8;\n    wire [7:1] A1,B1,S1;\n    wire C1;\n\n    wire [3:1] C4;\n    wire"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0] counter;\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            data_accumulator <= 0;\n            valid_output <= 0;\n        end else begin\n            if (valid_in) begin\n                counter <= counter + 1;\n                data_accumulator <= data_accumulator + data_in;\n            end\n            if (counter == 4) begin\n                valid_output <= 1;\n                counter <= 0;\n            end else begin\n                valid_output <= 0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 0;\n            valid_output <= 0;\n        end else begin\n            if (valid_in) begin\n                counter_reg <= counter_reg + 1;\n                if (counter_reg == 4) begin\n                    valid_output <= 1;\n                end else begin\n                    valid_output <= 0;\n                end\n            end else begin\n                valid_output <= 0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator <= 0;\n            valid_output <= 0;\n        end else begin\n            if (valid_in) begin\n                data_accumulator <= data_accumulator + data_in;\n                valid_output <= 1;\n            end else begin\n                valid_output <= 0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   counter,\n\n    output              valid_out\n);\n\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_output <= 0;\n        end else begin\n            if (counter == 4) begin\n                valid_output <= 1;\n            end else begin\n                valid_output <= 0;\n            end\n        end\n    end\n\n    assign valid_out = valid_output;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] rca1_sum;\n    wire rca1_cout;\n    wire [3:0] rca2_sum;\n    wire rca2_cout;\n    wire [3:0] rca3_sum;\n    wire rca3_cout;\n    wire [3:0] rca4_sum;\n    wire rca4_cout;\n    wire [3:0] csa_sum;\n    wire csa_cout;\n\n    // Ripple Carry Adder 1\n    ripple_carry_adder rca1(a, b, cin, rca1_sum, rca1_cout);\n\n    // Ripple Carry Adder 2\n    ripple_carry_adder rca2(rca1_sum, 4'b0000, rca2_sum, rca2_cout);\n\n    // Ripple Carry Adder 3\n    ripple_carry_adder rca3(rca2_sum, 4'b0000, rca3_sum, rca3_cout);\n\n    // Ripple Carry Adder 4\n    ripple_carry_adder rca4(rca3_sum, 4'b0000, rca4_sum, rca4_cout);\n\n    // Carry Select Adder Slice\n    carry_select_adder_slice csa_slice1(rca1_sum, rca2_sum, rca3_sum, rca4_sum, cin, csa_sum, csa_cout);\n\n    // Carry Select Adder Slice\n    carry_select_adder_slice csa_slice2(csa_sum, 4'b0000, csa_sum, csa_cout);\n\n    // Carry Select Adder Slice\n    carry_select_adder_slice csa_slice3(csa_sum, 4'b0000, csa_sum, csa_cout);\n\n    // Carry Select Adder Slice\n    carry_select_adder_slice csa_slice4(csa_sum, 4'b0000, csa_sum, csa_cout);\n\n    // Output\n    assign sum = csa_sum;\n    assign cout = csa_cout;\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign sum = a ^ b ^ cin;\n    assign carry = (a & b) | (a & cin) | (b & cin);\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, c, d, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input [3:0] c;\n    input [3:0] d;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] rca1_sum;\n    wire rca1_cout;\n    wire [3:0] rca2_sum;\n    wire rca2_cout;\n\n    // Ripple Carry Adder 1\n    ripple_carry_adder rca1(a, b, cin, rca1_sum, rca1_cout);\n\n    // Ripple Carry Adder 2\n    ripple_carry_adder rca2(rca1_sum, c, rca2_sum, rca2_cout);\n\n    // Carry Select Adder\n    assign sum = rca2_sum ^ d;\n    assign cout = rca2_cout;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor_mod;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n\n    // Absolute Value Calculation\n    abs_value abs_dividend(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative Divisor Calculation\n    neg_value neg_divisor_mod(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor_mod)\n    );\n\n    // Division Control Logic\n    divider_control ctrl(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result Management\n    result_management res_mgmt(\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\n// Absolute Value Calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'b0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Negative Divisor Calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'b0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Division Control Logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor_mod;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'b0;\n            shift_reg <= 8'b0;\n            quotient <= 8'b0;\n            remainder <= 8'b0;\n            abs_dividend <= 8'b0;\n            neg_divisor_mod <= 8'b0;\n        end else begin\n            if (opn_valid) begin\n                counter <= 4'b0;\n                shift_reg <= 8'b0;\n                quotient <= 8'b0;\n                remainder <= 8'b"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] add8_Co;\n\n    // 8-bit adder\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(add8_Co[0])\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(add8_Co[0]),\n        .y(y[15:8]),\n        .Co(add8_Co[1])\n    );\n\n    assign Co = add8_Co[1];\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [3:0] add4_Co;\n\n    // 4-bit adder\n    adder_4bit add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(add4_Co[0])\n    );\n\n    adder_4bit add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(add4_Co[0]),\n        .y(y[7:4]),\n        .Co(add4_Co[1])\n    );\n\n    assign Co = add4_Co[1];\n\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    wire [1:0] add2_Co;\n\n    // 2-bit adder\n    adder_2bit add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(add2_Co[0])\n    );\n\n    adder_2bit add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(add2_Co[0]),\n        .y(y[3:2]),\n        .Co(add2_Co[1])\n    );\n\n    assign Co = add2_Co[1];\n\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 2-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Prepare dividend and divisor for division\nprep_dividend prep_dividend_inst (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\n// Perform division\ndiv_operation div_operation_inst (\n    .A(result),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\n// Prepare dividend and divisor for division\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Prepare dividend for division\nassign result = {A[31:16], 16'b0};\nassign odd = {A[15:0], 16'b0};\n\nendmodule\n\n// Perform division\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Perform division\nassign result = A >> 16;\nassign odd = A & 16'hFFFF;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n\n    full_adder FA0(a[0], b[0], cin, sum[0], FA0_cout);\n    full_adder FA1(a[1], b[1], FA0_cout, sum[1], FA1_cout);\n    full_adder FA2(a[2], b[2], FA1_cout, sum[2], FA2_cout);\n    full_adder FA3(a[3], b[3], FA2_cout, sum[3], FA3_cout);\n    full_adder FA4(a[4], b[4], FA3_cout, sum[4], FA4_cout);\n    full_adder FA5(a[5], b[5], FA4_cout, sum[5], FA5_cout);\n    full_adder FA6(a[6], b[6], FA5_cout, sum[6], FA6_cout);\n    full_adder FA7(a[7], b[7], FA6_cout, sum[7], cout);\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout); ASSISTANT: module full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // Control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [3:0] count;\n\n    // Division algorithm\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        count = 0;\n        quotient = 0;\n        remainder = 0;\n\n        while (count < 16) begin\n            if (dividend >= divisor) begin\n                dividend = dividend - divisor;\n                quotient = quotient + (1 << count);\n            end\n\n            count = count + 1;\n            divisor = divisor << 1;\n        end\n\n        remainder = dividend;\n    end\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n// Control Unit\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_reg <= 1'b0;\n    end else if (start) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_reg <= 1'b0;\n    end else if (shift_count == 4'b1111) begin\n        shift_count <= 4'b0000;\n        done_reg <= 1'b1;\n    end else begin\n        shift_count <= shift_count + 1;\n        done_reg <= 1'b0;\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'b0;\n        reg_b <= 16'b0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Multiplier Unit\nreg [15:0] shifted_b;\nreg [31:0] accumulator;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shifted_b <= 16'b0;\n        accumulator <= 32'b0;\n    end else if (shift_count == 4'b0000) begin\n        shifted_b <= {16'b0, reg_b};\n        accumulator <= 32'b0;\n    end else begin\n        shifted_b <= {shifted_b[14:0], 1'b0};\n        accumulator <= accumulator + (shifted_b & {16'b0, reg_a});\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_reg;\n\nendmodule"}
