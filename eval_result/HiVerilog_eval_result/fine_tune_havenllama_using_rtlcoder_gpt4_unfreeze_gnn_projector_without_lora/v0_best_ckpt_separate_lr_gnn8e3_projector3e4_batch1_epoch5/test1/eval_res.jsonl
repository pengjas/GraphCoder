{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(A, B, carry_out);\n    input [7:0] A, B;\n    output [7:0] carry_out;\n\n    wire [7:0] sum;\n    wire carry;\n\n    assign {carry, sum} = A + B;\n    assign carry_out = carry;\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\n    input A, B, carry_in;\n    output sum, carry_out;\n\n    assign {carry_out, sum} = A + B + carry_in;\nendmodule\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] Diff_16;\n    wire B_out_16;\n\n    sub_16bit S1(A[15:0], B[15:0], Diff_16, B_out_16);\n    sub_16bit S2(A[31:16], B[31:16], Diff[31:16], B_out);\n\n    assign Diff[15:0] = Diff_16;\n    assign B_out = B_out_16;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out); ASSISTANT: module sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] Diff_8;\n    wire B_out_8;\n\n    sub_8bit S1(A[7:0], B[7:0], Diff_8, B_out_8);\n    sub_8bit S2(A[15:8], B[15:8], Diff[15:8], B_out);\n\n    assign Diff[7:0] = Diff_8;\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out); ASSISTANT: module sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] Diff_4;\n    wire B_out_4;\n\n    sub_4bit S1(A[3:0], B[3:0], Diff_4, B_out_4);\n    sub_4bit S2(A[7:4], B[7:4], Diff[7:4], B_out);\n\n    assign Diff[3:0] = Diff_4;\n    assign B_out = B_out_4;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out); ASSISTANT: module sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] Diff_2;\n    wire B_out_2;\n\n    sub_2bit S1(A[1:0], B[1:0], Diff_2, B_out_2);\n    sub_2bit S2(A[3:2], B[3:2], Diff[3:2], B_out);\n\n    assign Diff[1:0] = Diff_2;\n    assign B_out = B_out_2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out); ASSISTANT: module sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0:0] Diff_1;\n    wire B_out_1;\n\n    sub_1bit S1(A[0:0], B[0:0], Diff_1, B_out_1);\n    sub_1bit S2(A[1:1], B[1:1], Diff[1:1], B_out);\n\n    assign Diff[0:0] = Diff_1;\n    assign B_out = B_out_1;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] A_16, B_16, D_16;\n    wire [7:0] A_8, B_8, D_8;\n\n    submodule sub0(A_16, B_16, D_16, A_8, B_8, D_8);\n        input [15:0] A_16, B_16;\n        output [15:0] D_16;\n        output [7:0] A_8, B_8, D_8;\n\n        wire [7:0] A_7, B_7, D_7;\n\n        submodule sub0_0(A_7, B_7, D_7);\n            input [7:0] A_7, B_7;\n            output [7:0] D_7;\n\n            wire [3:0] A_3, B_3, D_3;\n            wire [1:0] A_1, B_1, D_1;\n\n            submodule sub0_0_0(A_3, B_3, D_3);\n                input [3:0] A_3, B_3;\n                output [3:0] D_3;\n\n                wire [1:0] A_1, B_1, D_1;\n\n                submodule sub0_0_0_0(A_1, B_1, D_1);\n                    input [1:0] A_1, B_1;\n                    output [1:0] D_1;\n\n                    wire [0:0] A_0, B_0, D_0;\n\n                    submodule sub0_0_0_0_0(A_0, B_0, D_0);\n                        input [0:0] A_0, B_0;\n                        output [0:0] D_0;\n\n                        wire [0:0] A_0_out, B_0_out, D_0_out;\n\n                        assign A_0_out = A_0;\n                        assign B_0_out = B_0;\n                        assign D_0_out = A_0_out ^ B_0_out;\n                    endmodule\n\n                    sub0_0_0_0 sub0_0_0_0_inst(A_1, B_1, D_1);\n                endmodule\n\n                sub0_0 sub0_0_inst(A_3, B_3, D_3);\n            endmodule\n\n            sub0_0 sub0_1_inst(A_7, B_7, D_7);\n        endmodule\n\n        sub0 sub0_inst(A_16, B_16, D_16);\n    endmodule\n\n    submodule sub1(A_16, B_16, D_16, A_8, B_8, D_8);\n        input [15:0] A_16, B_16;\n        output [15:0] D_16;\n        output [7:0] A_8, B_8, D_8;\n\n        wire [7:0] A_7, B_7, D_7;\n\n        submodule sub1_0(A_7, B_7, D_7);\n            input [7:0] A_7, B_7;\n            output [7:0] D_7;\n\n            wire [3:0] A_3, B_3, D_3;\n            wire [1:0] A_1, B_1, D_1;\n\n            submodule sub1_0_0(A_3, B_3, D_3);\n                input [3:0] A_3, B_3;\n                output [3:0] D_3;\n\n                wire [1:0] A_1, B_1, D_1;\n\n                submodule sub1_0_0_0(A_1, B_1, D_1);\n                    input [1:0] A"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out[15:0];\n    wire [3:0] B_out[15:0];\n    wire [3:0] D_out[15:0];\n    wire [3:0] borrow[15:0];\n\n    submodule sub1(A[16:1], B[16:1], D_out[15:0], borrow[15:0]);\n    submodule sub2(A[16:2], B[16:2], D_out[14:0], borrow[14:0]);\n    submodule sub3(A[16:3], B[16:3], D_out[13:0], borrow[13:0]);\n    submodule sub4(A[16:4], B[16:4], D_out[12:0], borrow[12:0]);\n\n    assign D[16:1] = D_out[15:0];\n    assign B_out = borrow[15];\nendmodule\n\nsubmodule sub1(A[16:1], B[16:1], D_out[15:0], borrow[15:0]);\n    input [16:1] A;\n    input [16:1] B;\n    output [15:0] D_out;\n    output borrow;\n\n    wire [3:0] A_out[15:0];\n    wire [3:0] B_out[15:0];\n    wire [3:0] D_out[15:0];\n    wire [3:0] borrow[15:0];\n\n    full_subtractor_4bit full_subtractor_1(A[1:1], B[1:1], A_out[0], B_out[0], D_out[0], borrow[0]);\n    full_subtractor_4bit full_subtractor_2(A[2:2], B[2:2], A_out[1], B_out[1], D_out[1], borrow[1]);\n    full_subtractor_4bit full_subtractor_3(A[3:3], B[3:3], A_out[2], B_out[2], D_out[2], borrow[2]);\n    full_subtractor_4bit full_subtractor_4(A[4:4], B[4:4], A_out[3], B_out[3], D_out[3], borrow[3]);\n    full_subtractor_4bit full_subtractor_5(A[5:5], B[5:5], A_out[4], B_out[4], D_out[4], borrow[4]);\n    full_subtractor_4bit full_subtractor_6(A[6:6], B[6:6], A_out[5], B_out[5], D_out[5], borrow[5]);\n    full_subtractor_4bit full_subtractor_7(A[7:7], B[7:7], A_out[6], B_out[6], D_out[6], borrow[6]);\n    full_subtractor_4bit full_subtractor_8(A[8:8], B[8:8], A_out[7], B_out[7], D_out[7], borrow[7]);\n    full_subtractor_4bit full_subtractor_9(A[9:9], B[9:9], A_out[8], B_out[8], D_out[8], borrow[8]);\n    full_subtractor_4bit full_subtractor_10(A[10:10], B[10:10], A_out[9], B_out[9], D_out[9], borrow[9]);\n    full_subtractor_4bit full_subtractor_11(A[11:11], B[11:11], A_out[10], B_out"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    // Subtractor module\n    module subtractor_32bit(\n        input [31:0] A,\n        input [31:0] B,\n        output [31:0] result,\n        output carry\n    );\n        assign {carry, result} = A - B;\n    endmodule\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(result),\n        .carry(carry)\n    );\n\n    // Comparison logic\n    assign A_greater = (result != 0) && (carry == 0);\n    assign A_equal = (result == 0) && (carry == 0);\n    assign A_less = (result == 0) && (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [32:1] C16;\n    wire [16:1] C8;\n    wire [8:1] C4;\n    wire [4:1] C2;\n    wire [2:1] C1;\n\n    wire [32:1] S16;\n    wire [16:1] S8;\n    wire [8:1] S4;\n    wire [4:1] S2;\n    wire [2:1] S1;\n\n    wire [32:1] C16_1;\n    wire [16:1] C8_1;\n    wire [8:1] C4_1;\n    wire [4:1] C2_1;\n    wire [2:1] C1_1;\n\n    wire [32:1] S16_1;\n    wire [16:1] S8_1;\n    wire [8:1] S4_1;\n    wire [4:1] S2_1;\n    wire [2:1] S1_1;\n\n    wire [32:1] C16_2;\n    wire [16:1] C8_2;\n    wire [8:1] C4_2;\n    wire [4:1] C2_2;\n    wire [2:1] C1_2;\n\n    wire [32:1] S16_2;\n    wire [16:1] S8_2;\n    wire [8:1] S4_2;\n    wire [4:1] S2_2;\n    wire [2:1] S1_2;\n\n    wire [32:1] C16_3;\n    wire [16:1] C8_3;\n    wire [8:1] C4_3;\n    wire [4:1] C2_3;\n    wire [2:1] C1_3;\n\n    wire [32:1] S16_3;\n    wire [16:1] S8_3;\n    wire [8:1] S4_3;\n    wire [4:1] S2_3;\n    wire [2:1] S1_3;\n\n    wire [32:1] C16_4;\n    wire [16:1] C8_4;\n    wire [8:1] C4_4;\n    wire [4:1] C2_4;\n    wire [2:1] C1_4;\n\n    wire [32:1] S16_4;\n    wire [16:1] S8_4;\n    wire [8:1] S4_4;\n    wire [4:1] S2_4;\n    wire [2:1] S1_4;\n\n    wire [32:1] C16_5;\n    wire [16:1] C8_5;\n    wire [8:1] C4_5;\n    wire [4:1] C2_5;\n    wire [2:1] C1_5;\n\n    wire [32:1] S16_5;\n    wire [16:1] S8_5;\n    wire [8:1] S4_5;\n    wire [4:1] S2_5;\n    wire [2:1] S1_5;\n\n    wire [32:1] C16_6;\n    wire [16:1] C8_6;\n    wire [8:1] C4_6;\n    wire [4:1] C2_6;\n    wire [2:1] C1_6;\n\n    wire [32:1] S16_6;\n    wire [16:1] S8_6;\n    wire [8:1] S4_6;\n    wire [4:1] S2_6;\n    wire [2:1] S1_6;\n\n    wire [32:1] C16_7;\n    wire [16:1] C8_7"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry_out;\n    wire [3:0] sum_slice;\n\n    // Ripple carry adder for the first 4 bits\n    wire [3:0] carry_in;\n    assign carry_in[0] = cin;\n    assign carry_out[0] = (a[0] & b[0]) | (a[0] & carry_in[0]) | (b[0] & carry_in[0]);\n    assign sum_slice[0] = a[0] ^ b[0] ^ carry_in[0];\n\n    // Ripple carry adder for the second 4 bits\n    assign carry_in[1] = carry_out[0];\n    assign carry_out[1] = (a[1] & b[1]) | (a[1] & carry_in[1]) | (b[1] & carry_in[1]);\n    assign sum_slice[1] = a[1] ^ b[1] ^ carry_in[1];\n\n    // Ripple carry adder for the third 4 bits\n    assign carry_in[2] = carry_out[1];\n    assign carry_out[2] = (a[2] & b[2]) | (a[2] & carry_in[2]) | (b[2] & carry_in[2]);\n    assign sum_slice[2] = a[2] ^ b[2] ^ carry_in[2];\n\n    // Ripple carry adder for the fourth 4 bits\n    assign carry_in[3] = carry_out[2];\n    assign carry_out[3] = (a[3] & b[3]) | (a[3] & carry_in[3]) | (b[3] & carry_in[3]);\n    assign sum_slice[3] = a[3] ^ b[3] ^ carry_in[3];\n\n    // Carry select adder for the first 4 bits\n    wire [1:0] carry_select;\n    assign carry_select[0] = carry_out[0];\n    assign carry_select[1] = carry_out[1];\n    assign sum[0] = sum_slice[0];\n    assign sum[1] = sum_slice[1];\n    assign sum[2] = sum_slice[2];\n    assign sum[3] = sum_slice[3];\n    assign cout = carry_out[3];\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry_out;\n    wire [3:0] sum_slice;\n\n    // Ripple carry adder for the first 4 bits\n    wire [3:0] carry_in;\n    assign carry_in[0] = cin;\n    assign carry_out[0] = (a[0] & b[0]) | (a[0] & carry_in[0]) | (b[0] & carry_in[0]);\n    assign sum_slice[0] = a[0] ^ b[0] ^ carry_in[0];\n\n    // Carry select adder for the second 4 bits\n    assign carry_in[1] = carry_out[0];\n    assign carry_out[1] = (a[1] & b[1]) | (a[1] & carry_in[1]) | (b[1] & carry_in[1]);\n    assign sum_slice[1] = a[1] ^ b[1] ^ carry_in[1];\n\n    // Carry select adder for the third 4 bits\n    assign carry_in[2] = carry_out[1];\n    assign carry_out[2] = (a[2] & b[2]) | (a[2] & carry_in[2]) | (b[2] & carry_in["}
{"task_id": "up_down_counter", "response": "// Counter logic\n    reg [15:0] count_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    // Counter register\n    reg [15:0] count_reg_next;\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg_next <= 16'b0;\n        end else begin\n            count_reg_next <= count_reg;\n        end\n    end\n\n    assign count = count_reg;\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count_next\n); ASSISTANT:\n    // Counter logic\n    reg [15:0] count_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count_next = count_reg;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count_next,\n    output reg [15:0] count\n); ASSISTANT:\n    // Counter register\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 16'b0;\n        end else begin\n            count <= count_next;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    // State initialization submodule\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State transition submodule\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\n// counter logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end else if (valid_count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\n// output register\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= in;\n    end\nend\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_r;\n    wire [31:0] add_zero;\n    wire [31:0] add_carry;\n    wire [31:0] add_negative;\n    wire [31:0] add_overflow;\n    wire [31:0] add_flag;\n\n    wire [31:0] sub_r;\n    wire [31:0] sub_zero;\n    wire [31:0] sub_carry;\n    wire [31:0] sub_negative;\n    wire [31:0] sub_overflow;\n    wire [31:0] sub_flag;\n\n    wire [31:0] and_r;\n    wire [31:0] and_zero;\n    wire [31:0] and_carry;\n    wire [31:0] and_negative;\n    wire [31:0] and_overflow;\n    wire [31:0] and_flag;\n\n    wire [31:0] or_r;\n    wire [31:0] or_zero;\n    wire [31:0] or_carry;\n    wire [31:0] or_negative;\n    wire [31:0] or_overflow;\n    wire [31:0] or_flag;\n\n    wire [31:0] xor_r;\n    wire [31:0] xor_zero;\n    wire [31:0] xor_carry;\n    wire [31:0] xor_negative;\n    wire [31:0] xor_overflow;\n    wire [31:0] xor_flag;\n\n    wire [31:0] nor_r;\n    wire [31:0] nor_zero;\n    wire [31:0] nor_carry;\n    wire [31:0] nor_negative;\n    wire [31:0] nor_overflow;\n    wire [31:0] nor_flag;\n\n    wire [31:0] slt_r;\n    wire [31:0] slt_zero;\n    wire [31:0] slt_carry;\n    wire [31:0] slt_negative;\n    wire [31:0] slt_overflow;\n    wire [31:0] slt_flag;\n\n    wire [31:0] sltu_r;\n    wire [31:0] sltu_zero;\n    wire [31:0] sltu_carry;\n    wire [31:0] sltu_negative;\n    wire [31:0] sltu_overflow;\n    wire [31:0] sltu_flag;\n\n    wire [31:0] sll_r;\n    wire [31:0] sll_zero;\n    wire [31:0] sll_carry;\n    wire [31:0] sll_negative;\n    wire [31:0] sll_overflow;\n    wire [31:0] sll_flag;\n\n    wire [31:0] srl_r;\n    wire [31:0] srl_zero;\n    wire [31:0] srl_carry;\n    wire [31:0] srl_negative;\n    wire [31:0] srl_overflow;\n    wire [31:0] srl_flag;\n\n    wire [31:0] sra_r;\n    wire [31:0] sra_zero;\n    wire [31:0] sra_carry;\n    wire [31:0] sra_negative;\n    wire [31:0] sra_overflow;\n    wire [31:0] sra_flag;\n\n    wire [31:0] sllv_r;\n    wire [31:0] sllv"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'h0000000000000000;\n    end else begin\n        Q_reg <= {Q_reg[62:0], Q_reg[63]};\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'h0000000000000000;\n    end else begin\n        Q_reg <= Q;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]      Q_next\n);\n\nassign Q_next = {Q[62:0], Q[63]};\n\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    // Multiplier submodule\n    reg [63:0] product;\n    always @(posedge clk) begin\n        if (rst) begin\n            product <= 0;\n        end else begin\n            product <= a * b;\n        end\n    end\n\n    // Accumulator submodule\n    reg [31:0] current_value;\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\n    // Output\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    // Multiplier logic\n    reg [63:0] product_reg;\n    always @(posedge clk) begin\n        if (rst) begin\n            product_reg <= 0;\n        end else begin\n            product_reg <= a * b;\n        end\n    end\n\n    assign product = product_reg;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n\n    // Accumulator logic\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + product[31:0];\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [2:0] ins_p1;\n    reg [4:0] ad1_p1;\n    reg [7:0] ad2_p1;\n\n    reg [2:0] ins_p2;\n    reg [4:0] ad1_p2;\n    reg [7:0] ad2_p2;\n\n    always @(posedge clk) begin\n        if (rst == 1'b0) begin\n            ins_p1 <= 3'b0;\n            ad1_p1 <= 5'b0;\n            ad2_p1 <= 8'b0;\n\n            ins_p2 <= 3'b0;\n            ad1_p2 <= 5'b0;\n            ad2_p2 <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1 <= data[7:5];\n                ad1_p1 <= data[4:0];\n                ad2_p1 <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2 <= data[7:5];\n                ad1_p2 <= data[4:0];\n                ad2_p2 <= data;\n            end\n        end\n    end\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    reg [1:0] count_50;\n    reg [3:0] count_10;\n    reg [5:0] count_1;\n    reg clk_50, clk_10, clk_1;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count_50 <= 0;\n            count_10 <= 0;\n            count_1 <= 0;\n            clk_50 <= 0;\n            clk_10 <= 0;\n            clk_1 <= 0;\n        end else begin\n            if (count_50 == 1) begin\n                clk_50 <= ~clk_50;\n                count_50 <= 0;\n            end else begin\n                count_50 <= count_50 + 1;\n            end\n\n            if (count_10 == 4) begin\n                clk_10 <= ~clk_10;\n                count_10 <= 0;\n            end else begin\n                count_10 <= count_10 + 1;\n            end\n\n            if (count_1 == 49) begin\n                clk_1 <= ~clk_1;\n                count_1 <= 0;\n            end else begin\n                count_1 <= count_1 + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [1:0] count;\n    reg clk_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count == 1) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [3:0] count;\n    reg clk_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count == 4) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [5:0] count;\n    reg clk_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count == 49) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg [7:0] count;\n    reg wave_out;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n            wave_out <= ~wave_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n); ASSISTANT: module wave_generator(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    reg [7:0] count;\n    reg wave_out;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n            wave_out <= ~wave_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 5'b00000;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_avg;\nwire clk_adj;\nwire clk_div_int;\n\nreg [MUL2_DIV_CLK-1:0] counter;\n\nassign clk_avg = counter[MUL2_DIV_CLK-1];\nassign clk_adj = counter[MUL2_DIV_CLK-2];\n\nassign clk_div_int = clk_avg | clk_adj;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div = clk_div_int;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          counter\n);\n\nparameter LIMIT = 10;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == LIMIT) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_avg,\n    input               clk_adj,\n    output reg          clk_div\n);\n\nparameter LIMIT = 10;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (clk_div == LIMIT) begin\n        clk_div <= 0;\n    end else begin\n        clk_div <= clk_div + 1;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (clk_div == LIMIT) begin\n        clk_div <= 0;\n    end else begin\n        clk_div <= clk_div + 1;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_avg,\n    input               clk_adj,\n    output reg          clk_div\n);\n\nparameter LIMIT = 10;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (clk_div == LIMIT) begin\n        clk_div <= 0;\n    end else begin\n        clk_div <= clk_div + 1;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (clk_div == LIMIT) begin\n        clk_div <= 0;\n    end else begin\n        clk_div <= clk_div + 1;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = A + B_comp;\n    assign D = sum;\n    assign B_out = carry[7];\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] carry;\n\n    full_adder fa0 (.A(A[0]), .B(B[0]), .Cin(carry[0]), .D(D[0]), .Cout(carry[1]));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .Cin(carry[1]), .D(D[1]), .Cout(carry[2]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .Cin(carry[2]), .D(D[2]), .Cout(carry[3]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .Cin(carry[3]), .D(D[3]), .Cout(carry[4]));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .Cin(carry[4]), .D(D[4]), .Cout(carry[5]));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .Cin(carry[5]), .D(D[5]), .Cout(carry[6]));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .Cin(carry[6]), .D(D[6]), .Cout(carry[7]));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .Cin(carry[7]), .D(D[7]), .Cout(B_out));\nendmodule\n\nmodule full_adder(A, B, Cin, D, Cout);\n    input A, B, Cin;\n    output D, Cout;\n\n    assign {Cout, D} = A + B + Cin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  // Processing Element 0\n  wire [31:0] pe0_out;\n  assign pe0_out = {a0, 16'b0} * {b0, 16'b0};\n\n  // Processing Element 1\n  wire [31:0] pe1_out;\n  assign pe1_out = {a1, 16'b0} * {b1, 16'b0};\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\n  // Pipeline b0 to b1\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'b0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    // Instantiate 3 D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    // 4-to-1 multiplexer\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= {q[6:0], q[7]};\n            2'b10: q <= {q[5:0], q[7], q[7]};\n            2'b11: q <= {q[4:0], q[7], q[7], q[7]};\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    // Instantiate D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    // Instantiate D flip-flop module\n    my_dff u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [$clog2(NUM_DIV) - 1:0] pos_counter;\n    reg [$clog2(NUM_DIV) - 1:0] neg_counter;\n    reg clk_div1, clk_div2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            pos_counter <= 0;\n            neg_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else begin\n            if (pos_counter == NUM_DIV - 1) begin\n                pos_counter <= 0;\n                clk_div1 <= 1;\n            end else begin\n                pos_counter <= pos_counter + 1;\n                clk_div1 <= 0;\n            end\n\n            if (neg_counter == NUM_DIV - 1) begin\n                neg_counter <= 0;\n                clk_div2 <= 1;\n            end else begin\n                neg_counter <= neg_counter + 1;\n                clk_div2 <= 0;\n            end\n        end\n    end\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV) - 1:0] counter\n);\n\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out;\n    wire [15:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_16bit S1 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_16bit S2 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1_out;\n    wire [7:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_8bit S1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_8bit S2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1_out;\n    wire [3:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_4bit S1 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_4bit S2 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1_out;\n    wire [1:0] S2_out;\n    wire B1;\n    wire B2;\n\n    sub_2bit S1 (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(B1)\n    );\n\n    sub_2bit S2 (\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2_out),\n        .B_out(B2)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n  reg [31:0] rd_val;\n  reg [31:0] op;\n  reg [31:0] alu_out;\n  reg [31:0] mem_out;\n  reg [31:0] writeback_out;\n\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_out;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(fetch_out)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .rd_val(rd_val),\n    .op(op)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .mem_out(memory_out)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .mem_out(mem_out),\n    .writeback_out(writeback_out)\n  );\n\n  assign res_reg_file = writeback_out;\n\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n\n  reg [31:0] instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr_reg <= 32'b0;\n    end else begin\n      instr_reg <= instr_mem[pc];\n    end\n  end\n\n  assign instr = instr_reg;\n\nendmodule\n\nmodule stage2(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] rs1_val,\n  output [31:0] rs2_val,\n  output [31:0] rd_val,\n  output [5:0] op_val\n);\n\n  reg [31:0] rs1_val_reg;\n  reg [31:0] rs2_val_reg;\n  reg [31:0] rd_val_reg;\n  reg [5:0] op_val_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      rs1_val_reg <= 32'b0;\n      rs2_val_reg <= 32'b0;\n      rd_val_reg <= 32'b0;\n      op_val_reg <= 6'b0;\n    end else begin\n      rs1_val"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] shifted_in;\n    wire [7:0] shifted_out;\n    wire [7:0] intermediate_out;\n    wire [3:0] sel;\n    \n    // Shift input based on control signal\n    assign shifted_in[7:4] = (ctrl[2] == 1) ? in[7:4] : in[3:0];\n    assign shifted_in[3:0] = (ctrl[2] == 1) ? in[3:0] : in[7:4];\n    \n    // Shift intermediate output based on control signal\n    assign shifted_out[7:4] = (ctrl[2] == 1) ? intermediate_out[7:4] : intermediate_out[3:0];\n    assign shifted_out[3:0] = (ctrl[2] == 1) ? intermediate_out[3:0] : intermediate_out[7:4];\n    \n    // Select between shifted input and intermediate output based on control signal\n    assign sel[3:0] = (ctrl[2] == 1) ? 4'b0000 : ctrl[1:0];\n    assign intermediate_out[7:0] = (sel[3] == 1) ? shifted_out[7:4] : shifted_in[7:4];\n    assign intermediate_out[3:0] = (sel[3] == 1) ? shifted_out[3:0] : shifted_in[3:0];\n    \n    // Output shifted input\n    assign out[7:0] = shifted_in[7:0];\n    \nendmodule\n\n// Example instantiation of barrel_shifter\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst (\n    .in(8'b11111111),\n    .ctrl(3'b000),\n    .out(8'b00000000)\n);\n\n// Example instantiation of barrel_shifter with control signal set to 3'b100\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst2 (\n    .in(8'b11111111),\n    .ctrl(3'b100),\n    .out(8'b00000000)\n);\n\n// Example instantiation of barrel_shifter with control signal set to 3'b111\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst3 (\n    .in(8'b1111111),\n    .ctrl(3'b111),\n    .out(8'b0000000)\n);\n\n// Example instantiation of barrel_shifter with control signal set to 3'b000\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst4 (\n    .in(8'b1111111),\n    .ctrl(3'b000),\n    .out(8'b1111111)\n);\n\n// Example instantiation of barrel_shifter with control signal set to 3'b100\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst5 (\n    .in(8'b1111111),\n    .ctrl(3'b100),\n    .out(8'b0000000)\n);\n\n// Example instantiation of barrel_shifter with control signal set to 3'b111\n// This instantiation is used for testing purposes only\nbarrel_shifter barrel_shifter_inst6 (\n    .in(8'b1111111),\n    .ctrl(3'b111),\n    .out(8'b0000000)"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_out;\n\n    submodule sub0 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out)\n    );\n\n    submodule sub1 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule submodule (\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] D,\n    output B_out\n);\n    wire [31:0] B_out;\n\n    submodule sub0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out)\n    );\n\n    submodule sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule submodule (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n    wire [7:0] B_out;\n\n    submodule sub0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out)\n    );\n\n    submodule sub1 (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out)\n    );\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'd0;\n      b2 <= 16'd0;\n      b3 <= 16'd0;\n      c0_reg <= 32'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= c0;\n      c1_reg <= c1;\n      c2_reg <= c2;\n      c3_reg <= c3;\n    end\n  end\n\n  assign c0 = a0 * b0;\n  assign c1 = a1 * b1;\n  assign c2 = a2 * b2;\n  assign c3 = a3 * b3;\n\nendmodule\n\nmodule top_module(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n\n  systolic1x4 pe0(\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .a1(a1),\n    .a2(a2),\n    .a3(a3),\n    .b0(b0),\n    .c0(c0),\n    .c1(c1),\n    .c2(c2),\n    .c3(c3)\n  );\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] A_out, B_out;\n    wire [3:0] D_out;\n\n    submodule sub1(A[16:1], B[16:1], D_out, A_out, B_out);\n    submodule sub2(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub3(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub4(A_out, B[16:1], D_out, A_out, B_out);\n\n    assign D = D_out;\n    assign B_out = B_out;\n\n    submodule sub1(A[16:1], B[16:1], D_out, A_out, B_out);\n    submodule sub2(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub3(A_out, B[16:1], D_out, A_out, B_out);\n    submodule sub4(A_out, B[16:1], D_out, A_out, B_out);\n\n    assign D_out[3:0] = A[3:0] - B[3:0];\n    assign A_out[3:0] = A[3:0] - B[3:0];\n    assign B_out[3:0] = A[3:0] - B[3:0];\n\n    assign D_out[7:4] = A[7:4] - B[7:4];\n    assign A_out[7:4] = A[7:4] - B[7:4];\n    assign B_out[7:4] = A[7:4] - B[7:4];\n\n    assign D_out[11:8] = A[11:8] - B[11:8];\n    assign A_out[11:8] = A[11:8] - B[11:8];\n    assign B_out[11:8] = A[11:8] - B[11:8];\n\n    assign D_out[15:12] = A[15:12] - B[15:12];\n    assign A_out[15:12] = A[15:12] - B[15:12];\n    assign B_out[15:12] = A[15:12] - B[15:12];\nendmodule\n\nmodule submodule(A, B, D_out, A_out, B_out);\n    input [16:1] A, B;\n    output [16:1] D_out;\n    output [3:0] A_out, B_out;\n\n    wire [3:0] D_out_1, D_out_2, D_out_3, D_out_4;\n    wire [3:0] A_out_1, A_out_2, A_out_3, A_out_4;\n    wire [3:0] B_out_1, B_out_2, B_out_3, B_out_4;\n\n    full_subtractor_4bit sub1(A[3:0], B[3:0], D_out_1, A_out_1, B_out_1);\n    full_subtractor_4bit sub2(A[7:4], B[7:4], D_out_2, A_out_2, B_out_2);\n    full_subtractor_4bit sub3(A[11:8], B[11:8], D_out_3, A_out_3, B_out_3);\n    full_subtractor_4bit sub4(A[15:12], B[15:12], D_out_4, A_out_4, B_out_4);\n\n    assign"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    // Subtractor module\n    module subtractor_32bit(\n        input [31:0] A,   // First 32-bit input operand\n        input [31:0] B,   // Second 32-bit input operand\n        output [31:0] sub_result,  // Subtraction result\n        output carry_out  // Carry out signal\n    );\n        assign {carry_out, sub_result} = A - B;\n    endmodule\n\n    // Instantiate subtractor module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .carry_out(carry_out)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0) && (carry_out == 0);\n    assign A_less = (sub_result == 0) && (carry_out == 1);\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    reg [31:0] pc;\n    reg [31:0] instr;\n    reg [31:0] op1;\n    reg [31:0] op2;\n    reg [31:0] result;\n    reg [31:0] write_reg;\n    reg [31:0] write_data;\n    reg [31:0] read_reg1;\n    reg [31:0] read_reg2;\n    reg [31:0] read_data1;\n    reg [31:0] read_data2;\n    reg [31:0] write_data_reg;\n    reg [31:0] out_reg_file_reg;\n\n    wire [31:0] instr_mem_read_data;\n    wire [31:0] reg_file_read_data1;\n    wire [31:0] reg_file_read_data2;\n\n    assign instr_mem_read_data = instr_mem[pc];\n    assign reg_file_read_data1 = reg_file[read_reg1];\n    assign reg_file_read_data2 = reg_file[read_reg2];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc <= 0;\n            instr <= 0;\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            write_reg <= 0;\n            write_data <= 0;\n            read_reg1 <= 0;\n            read_reg2 <= 0;\n            read_data1 <= 0;\n            read_data2 <= 0;\n            write_data_reg <= 0;\n            out_reg_file_reg <= 0;\n        end else begin\n            pc <= pc + 1;\n            instr <= instr_mem_read_data;\n            op1 <= reg_file_read_data1;\n            op2 <= reg_file_read_data2;\n            result <= op1 + op2;\n            write_reg <= instr[15:11];\n            write_data <= result;\n            read_reg1 <= instr[19:15];\n            read_reg2 <= instr[24:20];\n            read_data1 <= reg_file_read_data1;\n            read_data2 <= reg_file_read_data2;\n            write_data_reg <= write_data;\n            out_reg_file_reg <= reg_file[write_reg];\n        end\n    end\n\n    assign out_reg_file = out_reg_file_reg;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] instr\n);\n\n    reg [31:0] pc;\n    reg [31:0] instr_mem_read_data;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc <= 0;\n            instr <= 0;\n        end else begin\n            pc <= pc + 1;\n            instr <= instr_mem[pc];\n        end\n    end\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n\n    reg [31:0] op1_reg;\n    reg [31:0] op2_reg;\n    reg [31:0] result_reg;\n\n    always @(posedge clk) begin\n        if"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C16;\n    wire C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n\n    CLA1 CLA1_inst(A[15:1],B[15:1],S[15:1],C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15);\n    CLA2 CLA2_inst(A[31:16],B[31:16],S[31:16],C16,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16);\n\n    assign C32 = C16;\nendmodule\n\nmodule CLA1(A,B,S,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15);\n    input [15:1] A,B;\n    output [15:1] S;\n    output C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15;\n\n    wire [15:1] G,P,C;\n\n    assign G = A ^ B;\n    assign P = A & B;\n    assign C[1] = G[1] | (P[1] & C1);\n    assign C[2] = G[2] | (P[2] & C2);\n    assign C[3] = G[3] | (P[3] & C3);\n    assign C[4] = G[4] | (P[4] & C4);\n    assign C[5] = G[5] | (P[5] & C5);\n    assign C[6] = G[6] | (P[6] & C6);\n    assign C[7] = G[7] | (P[7] & C7);\n    assign C[8] = G[8] | (P[8] & C8);\n    assign C[9] = G[9] | (P[9] & C9);\n    assign C[10] = G[10] | (P[10] & C10);\n    assign C[11] = G[11] | (P[11] & C11);\n    assign C[12] = G[12] | (P[12] & C12);\n    assign C[13] = G[13] | (P[13] & C13);\n    assign C[14] = G[14] | (P[14] & C14);\n    assign C[15] = G[15] | (P[15] & C15);\n\n    assign S = A ^ B ^ C;\nendmodule\n\nmodule CLA2(A,B,S,C16,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16);\n    input [31:16] A,B;\n    output [31:16] S;\n    output C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n\n    wire [31:"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0] counter;\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0000;\n            data_accumulator <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter <= counter + 1;\n                data_accumulator <= data_accumulator + data_in;\n                if (counter == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter_reg <= counter_reg + 1;\n                if (counter_reg == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [9:0] data_accumulator;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator <= 10'b0000000000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                data_accumulator <= data_accumulator + data_in;\n                if (counter == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = data_accumulator;\n    assign valid_out = valid_output;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [3:0]   counter\n);\n\n    reg [3:0] counter_reg;\n    reg valid_output;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 4'b0000;\n            valid_output <= 1'b0;\n        end else begin\n            if (valid_in) begin\n                counter_reg <= counter_reg + 1;\n                if (counter_reg == 4) begin\n                    valid_output <= 1'b1;\n                end\n            end else begin\n                valid_output <= 1'b0;\n            end\n        end\n    end\n\n    assign counter = counter_reg;"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] csa1_sum, csa2_sum, csa3_sum;\n    wire [3:0] csa1_cout, csa2_cout, csa3_cout;\n\n    // 4-bit ripple carry adder\n    wire [3:0] rca1_sum, rca2_sum, rca3_sum;\n    wire [3:0] rca1_cout, rca2_cout, rca3_cout;\n\n    // 4-bit carry select adder slice\n    wire [3:0] csa1_sum_slice, csa2_sum_slice, csa3_sum_slice;\n    wire [3:0] csa1_cout_slice, csa2_cout_slice, csa3_cout_slice;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, rca1_sum, rca1_cout);\n    ripple_carry_adder rca2(a[7:4], b[7:4], rca1_cout, rca2_sum, rca2_cout);\n    ripple_carry_adder rca3(a[11:8], b[11:8], rca2_cout, rca3_sum, rca3_cout);\n    ripple_carry_adder rca4(a[15:12], b[15:12], rca3_cout, sum, cout);\n\n    // 4-bit carry select adder slice\n    carry_select_adder_slice csa1(rca1_sum, rca1_cout, csa1_sum_slice, csa1_cout_slice);\n    carry_select_adder_slice csa2(rca2_sum, rca2_cout, csa2_sum_slice, csa2_cout_slice);\n    carry_select_adder_slice csa3(rca3_sum, rca3_cout, csa3_sum_slice, csa3_cout_slice);\n\n    assign csa1_sum = csa1_sum_slice;\n    assign csa2_sum = csa2_sum_slice;\n    assign csa3_sum = csa3_sum_slice;\n\n    assign csa1_cout = csa1_cout_slice;\n    assign csa2_cout = csa2_cout_slice;\n    assign csa3_cout = csa3_cout_slice;\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign carry[0] = cin;\n    assign carry[1] = a[0] & b[0] | a[0] & carry[0] | b[0] & carry[0];\n    assign carry[2] = a[1] & b[1] | a[1] & carry[1] | b[1] & carry[1];\n    assign carry[3] = a[2] & b[2] | a[2] & carry[2] | b[2] & carry[2];\n\n    assign sum = a + b + cin;\n    assign cout = carry[3];\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign carry[0] = cin;\n    assign carry[1] = a[0] & b[0] | a[0] & carry[0] | b[0] & carry[0];\n    assign carry[2] = a[1] &"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [15:0] quotient;\n    reg [7:0] remainder;\n    reg [3:0] counter;\n    reg [7:0] shift_reg;\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor_mod;\n    reg [15:0] res_mgmt;\n\n    // Absolute Value Calculation\n    abs_value abs_dividend(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative Divisor Calculation\n    neg_value neg_divisor_mod(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor_mod)\n    );\n\n    // Division Control Logic\n    divider_control ctrl(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result Management\n    result_management res_mgmt(\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\nendmodule\n\n// Absolute Value Calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'h00;\n        end else begin\n            if (sign) begin\n                result <= -dividend;\n            end else begin\n                result <= dividend;\n            end\n        end\n    end\n\nendmodule\n\n// Negative Divisor Calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'h00;\n        end else begin\n            if (sign) begin\n                result <= divisor;\n            end else begin\n                result <= -divisor;\n            end\n        end\n    end\n\nendmodule\n\n// Division Control Logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder\n);\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor_mod;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'h0;\n            shift_reg <= 8'h00;\n            quotient <= 16'h0000;\n            remainder <= 8'h00;\n        end else begin\n            if (opn_valid) begin\n                counter <= 4'h0;\n                shift_"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n\n    // 8-bit adder\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8bit[0])\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit[0]),\n        .y(y[15:8]),\n        .Co(Co_8bit[1])\n    );\n\n    assign Co = Co_8bit[1];\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [3:0] Co_4bit;\n\n    // 4-bit adder\n    adder_4bit add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_4bit[0])\n    );\n\n    adder_4bit add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_4bit[0]),\n        .y(y[7:4]),\n        .Co(Co_4bit[1])\n    );\n\n    assign Co = Co_4bit[1];\n\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    wire [1:0] Co_2bit;\n\n    // 2-bit adder\n    adder_2bit add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_2bit[0])\n    );\n\n    adder_2bit add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_2bit[0]),\n        .y(y[3:2]),\n        .Co(Co_2bit[1])\n    );\n\n    assign Co = Co_2bit[1];\n\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 2-bit adder\n    assign y = a + b + Cin;\n    assign Co = (a[1] & b[1]) | (a[1] & Cin) | (b[1] & Cin);\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Prepare dividend and divisor\nprep_dividend prep_dividend_inst (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\n// Perform division\ndiv_operation div_operation_inst (\n    .A(result),\n    .B(odd),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\n// Prepare dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\nassign result = {A[31:16], 16'h0000};\nassign odd = {A[15:0], 16'h0000};\n\nendmodule\n\n// Perform division\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\nreg [31:0] shifted_dividend;\nreg [15:0] shifted_divisor;\nreg [31:0] quotient;\nreg [31:0] remainder;\n\ninteger i;\n\nalways @(*) begin\n    shifted_dividend = A;\n    shifted_divisor = B;\n    quotient = 32'h00000000;\n    remainder = 32'h00000000;\n\n    for (i = 0; i < 16; i = i + 1) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            quotient = quotient << 1;\n            quotient = quotient | 1'b1;\n            shifted_dividend = shifted_dividend - shifted_divisor;\n        end else begin\n            quotient = quotient << 1;\n            shifted_dividend = shifted_dividend;\n        end\n        shifted_divisor = shifted_divisor << 1;\n    end\n\n    remainder = shifted_dividend;\nend\n\nassign result = quotient;\nassign odd = remainder;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n\n    // First full adder\n    full_adder FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(FA0_sum),\n        .cout(FA0_cout)\n    );\n\n    // Second full adder\n    full_adder FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(FA0_cout),\n        .sum(FA1_sum),\n        .cout(FA1_cout)\n    );\n\n    // Third full adder\n    full_adder FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(FA1_cout),\n        .sum(FA2_sum),\n        .cout(FA2_cout)\n    );\n\n    // Fourth full adder\n    full_adder FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(FA2_cout),\n        .sum(FA3_sum),\n        .cout(FA3_cout)\n    );\n\n    // Fifth full adder\n    full_adder FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(FA3_cout),\n        .sum(FA4_sum),\n        .cout(FA4_cout)\n    );\n\n    // Sixth full adder\n    full_adder FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(FA4_cout),\n        .sum(FA5_sum),\n        .cout(FA5_cout)\n    );\n\n    // Seventh full adder\n    full_adder FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(FA5_cout),\n        .sum(FA6_sum),\n        .cout(FA6_cout)\n    );\n\n    // Eighth full adder\n    full_adder FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(FA6_cout),\n        .sum(FA7_sum),\n        .cout(FA7_cout)\n    );\n\n    // Final full adder\n    full_adder FA8(\n        .a(FA7_sum),\n        .b(FA7_cout),\n        .cin(FA7_cout),\n        .sum(sum),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n// Control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\n// Submodule\nsubmodule ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] quotient;\nreg [15:0] remainder;\nreg [15:0] temp;\nreg [3:0] i;\n\nalways @(*) begin\n    dividend = A;\n    divisor = B;\n    quotient = 0;\n    remainder = 0;\n    temp = 0;\n    i = 0;\n    \n    while (dividend >= divisor) begin\n        temp = dividend;\n        dividend = dividend - divisor;\n        quotient = quotient << 1;\n        quotient[0] = 1;\n        remainder = remainder + temp;\n        i = i + 1;\n    end\n    \n    remainder = remainder << (16 - i);\nend\n\nendmodule\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n// Control Unit\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else if (start) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else if (shift_count == 4'b1111) begin\n        done_flag <= 1'b1;\n    end else begin\n        shift_count <= shift_count + 1;\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'b0;\n        reg_b <= 16'b0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Multiplier Unit\nreg [15:0] shifted_b;\nreg [31:0] accumulator;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shifted_b <= 16'b0;\n        accumulator <= 32'b0;\n    end else if (shift_count == 4'b0000) begin\n        shifted_b <= {16'b0, reg_b};\n        accumulator <= 32'b0;\n    end else if (shift_count[0]) begin\n        shifted_b <= {shifted_b[14:0], 1'b0};\n        accumulator <= accumulator + (shifted_b & reg_a);\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
