{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for registering instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for register 1\n    reg [7:0] ins_reg1;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data; // Fetch instruction from data input\n            end else begin\n                ins_reg1 <= ins_reg1; // Retain previous value\n            end\n        end\n    end\n\n    // Instruction register for register 2\n    reg [7:0] ins_reg2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg2 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_reg2 <= data; // Fetch instruction from data input\n            end else begin\n                ins_reg2 <= ins_reg2; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1; // Output instruction from register 1\n    assign ad1 = ins_reg1[4:0]; // Output high 5 bits of instruction\n    assign ad2 = ins_reg2; // Output full 8-bit instruction\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions in the register\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for fetching instructions\n    reg [7:0] reg_ins;\n\n    // Instruction fetch logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Fetch instruction from data input\n                2'b10: reg_ins <= data; // Fetch instruction from data input\n                default: reg_ins <= reg_ins; // Retain previous value\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins[7:5]; // Output high 3 bits of instruction\n    assign ad1 = reg_ins[4:0]; // Output low 5 bits of instruction\n    assign ad2 = data; // Output full 8-bit data\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for registering instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for fetching from data input\n    reg [7:0] reg_ins;\n\n    // Instruction register for fetching from data input\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b01) begin\n                reg_ins <= data; // Fetch instruction from data input\n            end else if (fetch == 2'b10) begin\n                reg_ins <= data; // Fetch instruction from data input\n            end else begin\n                reg_ins <= reg_ins; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins_p1 = reg_ins; // Assign instruction to first submodule\n    assign ins_p2 = reg_ins; // Assign instruction to second submodule\n\n    // Output selection based on fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ins_p1[4:0] : ins_p2[4:0];\n    assign ad2 = (fetch == 2'b01) ? ins_p1[7:5] : ins_p2[7:5];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for registering instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    instr_reg_sub ins_p1_sub (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad(ad1)\n    );\n\n    instr_reg_sub ins_p2_sub (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad(ad2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : (fetch == 2'b10) ? ins_p2 : 3'b0;\n    assign ad1 = (fetch == 2'b01) ? data[7:0] : 8'd0;\n    assign ad2 = (fetch == 2'b10) ? data[7:0] : 8'd0;\n\nendmodule\n\n// Submodule for registering instructions\nmodule instr_reg_sub (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [7:0] ad\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'd0;\n            ad <= 8'd0;\n        end else begin\n            if (fetch) begin\n                ins <= data;\n                ad <= data;\n            end else begin\n                ins <= ins; // Retain previous value\n                ad <= ad; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for register\n    reg [7:0] reg_ins;\n\n    // Instruction register for RAM/ROM\n    reg [7:0] ram_ins, rom_ins;\n\n    // Instruction register output\n    assign ins = reg_ins;\n    assign ad1 = reg_ins[4:0];\n    assign ad2 = reg_ins[7:0];\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0;\n            ram_ins <= 8'd0;\n            rom_ins <= 8'd0;\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Store instruction in register\n                2'b10: ram_ins <= data; // Store instruction in RAM/ROM\n                default: begin\n                    reg_ins <= reg_ins; // Retain previous value\n                    ram_ins <= ram_ins;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for register\n    reg [7:0] reg_ins;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Fetch from data input\n                2'b10: reg_ins <= data; // Fetch from data input\n                default: reg_ins <= reg_ins; // Retain previous value\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins[7:5]; // High 3 bits of instruction\n    assign ad1 = reg_ins[4:0]; // Low 5 bits of instruction\n    assign ad2 = data; // Full 8-bit data input\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    instr_storage istr1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .fetch(2'b01),\n        .ins_out(ins_p1)\n    );\n\n    instr_storage istr2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .fetch(2'b10),\n        .ins_out(ins_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? data[4:0] : 5'd0;\n    assign ad2 = (fetch == 2'b10) ? data[7:0] : 8'd0;\n\nendmodule\n\n// Submodule for instruction storage\nmodule instr_storage (\n    input clk,\n    input rst,\n    input [7:0] data,\n    input [1:0] fetch,\n    output reg [7:0] ins_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0; // Reset instruction register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_out <= data; // Store instruction from data input\n            end else begin\n                ins_out <= ins_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for register\n    reg [7:0] reg_ins;\n\n    // Instruction register for RAM/ROM\n    reg [7:0] ram_ins;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n            ram_ins <= 8'd0; // Reset RAM/ROM instruction register\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Fetch from data input for register\n                2'b10: ram_ins <= data; // Fetch from data input for RAM/ROM\n                default: begin\n                    reg_ins <= reg_ins; // Retain previous value\n                    ram_ins <= ram_ins; // Retain previous value\n                end\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins;\n    assign ad1 = {5'd0, reg_ins}; // Concatenate with 5 LSBs\n    assign ad2 = {3'd0, ram_ins}; // Concatenate with 3 LSBs\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for fetching from data input\n    reg [7:0] ins_reg;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 8'd0; // Reset instruction register\n            ins_p1 <= 8'd0; // Reset instruction for first submodule\n            ins_p2 <= 8'd0; // Reset instruction for second submodule\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= data; // Store instruction in register\n                ins_p1 <= data; // Store instruction in first submodule\n            end else if (fetch == 2'b10) begin\n                ins_reg <= data; // Store instruction in register\n                ins_p2 <= data; // Store instruction in second submodule\n            end else begin\n                ins_reg <= ins_reg; // Retain previous instruction\n                ins_p1 <= ins_p1; // Retain previous instruction in first submodule\n                ins_p2 <= ins_p2; // Retain previous instruction in second submodule\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg;\n    assign ad1 = ins_p1;\n    assign ad2 = ins_p2;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for register\n    reg [7:0] reg_ins;\n\n    // Instruction register for RAM/ROM\n    reg [7:0] ram_ins;\n\n    // Instruction fetch logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n            ram_ins <= 8'd0; // Reset RAM/ROM instruction register\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Fetch instruction from data input\n                2'b10: ram_ins <= data; // Fetch instruction from data input\n                default: begin\n                    reg_ins <= reg_ins; // Retain previous value\n                    ram_ins <= ram_ins; // Retain previous value\n                end\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins;\n    assign ad1 = {5'd0, reg_ins};\n    assign ad2 = {3'd0, ram_ins};\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction storage for register\n    reg [7:0] reg_ins;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n            ins_p1 <= 8'd0; // Reset instruction for first submodule\n            ins_p2 <= 8'd0; // Reset instruction for second submodule\n        end else begin\n            if (fetch == 2'b01) begin\n                reg_ins <= data; // Store instruction in register\n                ins_p1 <= reg_ins; // Output instruction from register for first submodule\n            end else if (fetch == 2'b10) begin\n                reg_ins <= data; // Store instruction in register\n                ins_p2 <= reg_ins; // Output instruction from register for second submodule\n            end else begin\n                ins_p1 <= ins_p1; // Retain previous instruction for first submodule\n                ins_p2 <= ins_p2; // Retain previous instruction for second submodule\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins; // Output instruction from register\n    assign ad1 = ins_p1; // Output instruction from first submodule\n    assign ad2 = ins_p2; // Output instruction from second submodule\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule to store instructions from data input\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register 1\n    reg [7:0] ins_reg1;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data; // Store instruction from data input\n            end else begin\n                ins_reg1 <= ins_reg1; // Retain previous value\n            end\n        end\n    end\n\n    // Instruction register 2\n    reg [7:0] ins_reg2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg2 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_reg2 <= data; // Store instruction from data input\n            end else begin\n                ins_reg2 <= ins_reg2; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1; // Assign instruction from first submodule\n    assign ad1 = ins_reg1[4:0]; // Assign high 5 bits of first submodule\n    assign ad2 = ins_reg2; // Assign instruction from second submodule\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for fetching\n    reg [7:0] reg_ins;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n        end else begin\n            case (fetch)\n                2'b01: reg_ins <= data; // Fetch from data input\n                2'b10: reg_ins <= data; // Fetch from data input\n                default: reg_ins <= reg_ins; // Retain previous value\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins[7:5]; // High 3 bits of instruction\n    assign ad1 = reg_ins[4:0]; // Low 5 bits of instruction\n    assign ad2 = data; // Full 8-bit data input\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for registering instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register for first source\n    reg [7:0] ins_reg1;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data; // Fetch instruction from first source\n            end else begin\n                ins_reg1 <= ins_reg1; // Retain previous value\n            end\n        end\n    end\n\n    // Instruction register for second source\n    reg [7:0] ins_reg2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg2 <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_reg2 <= data; // Fetch instruction from second source\n            end else begin\n                ins_reg2 <= ins_reg2; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins_p1 = ins_reg1;\n    assign ins_p2 = ins_reg2;\n    assign ins = {ins_p2[7:5], ins_p1[4:0]}; // Concatenate instructions\n    assign ad1 = ins_p1[7:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction storage for register\n    reg [7:0] reg_ins;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_ins <= 8'd0; // Reset instruction register\n            ins_p1 <= 8'd0; // Reset first submodule\n            ins_p2 <= 8'd0; // Reset second submodule\n        end else begin\n            if (fetch == 2'b01) begin\n                reg_ins <= data; // Store instruction in register\n                ins_p1 <= data; // Store instruction in first submodule\n            end else if (fetch == 2'b10) begin\n                reg_ins <= data; // Store instruction in register\n                ins_p2 <= data; // Store instruction in second submodule\n            end else begin\n                // No instruction fetched\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = reg_ins;\n    assign ad1 = ins_p1;\n    assign ad2 = ins_p2;\n\nendmodule"}
