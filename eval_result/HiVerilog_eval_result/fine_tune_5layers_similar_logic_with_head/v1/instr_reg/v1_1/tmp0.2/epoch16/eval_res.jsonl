{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register\n    reg [7:0] ins_reg;\n\n    // Instruction fetch logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 8'd0; // Reset instruction register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= ins_p1; // Store instruction from data input\n            end else if (fetch == 2'b10) begin\n                ins_reg <= ins_p2; // Store instruction from data input\n            end else begin\n                ins_reg <= ins_reg; // Retain previous value\n            end\n        end\n    end\n\n    // Submodule 1: Fetch instruction from data input\n    assign ins_p1 = data;\n\n    // Submodule 2: Fetch instruction from data input\n    assign ins_p2 = data;\n\n    // Output assignments\n    assign ins = ins_reg;\n    assign ad1 = ins_reg[4:0];\n    assign ad2 = ins_reg[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    fetch_instruction fetch_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p1),\n        .ad_out(ad1)\n    );\n\n    // Submodule for storing instructions\n    reg [7:0] ins_reg1, ins_reg2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            ins_reg1 <= ins_p1;\n            ins_reg2 <= ins_p2;\n        end\n    end\n\n    // Outputs\n    assign ins = ins_reg1;\n    assign ad1 = ins_reg2;\n    assign ad2 = data; // Directly output the data input\n\nendmodule\n\n// Submodule for fetching instructions\nmodule fetch_instruction (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] ins_out,\n    output reg [4:0] ad_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0;\n            ad_out <= 5'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch from data input\n                ins_out <= data;\n                ad_out <= 5'd0; // No address needed\n            end else if (fetch == 2'b10) begin // Fetch from data input\n                ins_out <= data;\n                ad_out <= 5'd0; // No address needed\n            end else begin\n                ins_out <= ins_out; // Retain previous value\n                ad_out <= ad_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    instruction_fetch fetch_inst1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .output(ins_p1)\n    );\n\n    instruction_fetch fetch_inst2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .output(ins_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2; // Select instruction from fetch\n    assign ad1 = (fetch == 2'b01) ? data[7:0] : ins_p1[4:0]; // Select data from fetch\n    assign ad2 = (fetch == 2'b10) ? data[7:0] : ins_p2[7:0]; // Select data from fetch\n\nendmodule\n\n// Submodule for instruction fetching\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0; // Reset output\n        end else begin\n            if (fetch == 2'b01) begin\n                output <= data; // Fetch from data input\n            end else if (fetch == 2'b10) begin\n                output <= data; // Fetch from data input\n            end else begin\n                output <= output; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [2:0] ins_reg1, ins_reg2;\n\n    // Instruction fetching logic\n    assign ins_p1 = (fetch == 2'b01) ? data : 8'd0;\n    assign ins_p2 = (fetch == 2'b10) ? data : 8'd0;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 3'd0;\n            ins_reg2 <= 3'd0;\n        end else begin\n            ins_reg1 <= ins_p1;\n            ins_reg2 <= ins_p2;\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1;\n    assign ad1 = ins_reg2;\n    assign ad2 = data;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction register 1\n    wire [7:0] ins_p1;\n    reg [7:0] ins_p1_reg;\n\n    assign ins_p1 = (fetch == 2'b01) ? data : ins_p1_reg;\n\n    // Submodule for instruction register 2\n    wire [7:0] ins_p2;\n    reg [7:0] ins_p2_reg;\n\n    assign ins_p2 = (fetch == 2'b10) ? data : ins_p2_reg;\n\n    // Output assignments\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [7:0] ins_reg1, ins_reg2;\n\n    // Instruction fetch logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n\n    // Instruction register logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) ins_reg1 <= data;\n            if (fetch == 2'b10) ins_reg2 <= data;\n        end\n    end\n\n    // Output assignments\n    assign ad1 = ins_reg1;\n    assign ad2 = ins_reg2;\n    assign ins = ins_reg1; // Output from the last instruction stored\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    fetch_instruction fetch_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .output(ins_p1)\n    );\n\n    // Submodule for storing instructions\n    reg [7:0] ins_reg1, ins_reg2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            ins_reg1 <= ins_p1;\n            ins_reg2 <= ins_p2;\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1;\n    assign ad1 = ins_reg2[4:0];\n    assign ad2 = ins_reg2[7:5];\n\nendmodule\n\n// Submodule for fetching instructions\nmodule fetch_instruction (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin\n                output <= data; // Fetch from data input\n            end else if (fetch == 2'b10) begin\n                output <= data >> 3; // Fetch from data input, shifted\n            end else begin\n                output <= output; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    instruction_fetch fetch_inst1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .fetch_sel(fetch),\n        .ins_out(ins_p1),\n        .ad1_out(ad1)\n    );\n\n    instruction_fetch fetch_inst2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .fetch_sel(fetch),\n        .ins_out(ins_p2),\n        .ad2_out(ad2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1 : 5'd0; // Retain ad1 if fetch is not 2'b01\n    assign ad2 = (fetch == 2'b10) ? ad2 : 5'd0; // Retain ad2 if fetch is not 2'b10\n\nendmodule\n\n// Submodule for instruction fetching\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    input [1:0] fetch_sel,\n    output reg [7:0] ins_out,\n    output reg [4:0] ad_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0;\n            ad_out <= 5'd0;\n        end else begin\n            if (fetch_sel == 2'b01) begin\n                ins_out <= data_in;\n                ad_out <= 5'd0;\n            end else if (fetch_sel == 2'b10) begin\n                ins_out <= 8'd0;\n                ad_out <= data_in[4:0];\n            end else begin\n                ins_out <= ins_out;\n                ad_out <= ad_out;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [7:0] ins_reg1, ins_reg2;\n\n    // Instruction fetch logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n\n    // Instruction register\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) ins_reg1 <= data;\n            else if (fetch == 2'b10) ins_reg2 <= data;\n        end\n    end\n\n    // Output assignments\n    assign ad1 = ins_reg1;\n    assign ad2 = ins_reg2;\n    assign ins = ins_reg1; // Output from the last instruction stored\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [7:0] ins_reg1, ins_reg2;\n\n    // Instruction fetching logic\n    assign ins_p1 = (fetch == 2'b01) ? data : 8'd0;\n    assign ins_p2 = (fetch == 2'b10) ? data : 8'd0;\n\n    // Instruction register\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            ins_reg1 <= ins_p1;\n            ins_reg2 <= ins_p2;\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1;\n    assign ad1 = ins_reg2;\n    assign ad2 = ins_reg2; // Reuse for ad2\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction fetching\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register\n    reg [2:0] ins_reg;\n\n    // Instruction fetching logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'd0; // Reset register\n        end else begin\n            case (fetch)\n                2'b01: ins_reg <= ins_p1; // Fetch from data input\n                2'b10: ins_reg <= ins_p2; // Fetch from data input\n                default: ins_reg <= ins_reg; // Retain previous value\n            endcase\n        end\n    end\n\n    // Submodule for instruction fetching\n    assign ins_p1 = data; // Simple assignment\n    assign ins_p2 = data; // Simple assignment\n\n    // Output assignments\n    assign ins = ins_reg;\n    assign ad1 = ins_reg[4:0];\n    assign ad2 = ins_reg[7:5];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register\n    reg [2:0] ins_reg;\n\n    // Instruction fetch logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'd0; // Reset register\n        end else begin\n            case (fetch)\n                2'b01: ins_reg <= ins_p1; // Fetch from data input\n                2'b10: ins_reg <= ins_p2; // Fetch from data input\n                default: ins_reg <= ins_reg; // Retain previous value\n            endcase\n        end\n    end\n\n    // Submodule for instruction storage\n    assign ins_p1 = data; // Store data input\n    assign ins_p2 = data; // Store data input\n\n    // Output assignments\n    assign ins = ins_reg;\n    assign ad1 = ins_reg[4:0];\n    assign ad2 = ins_reg[7:5];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register\n    reg [7:0] ins_reg;\n\n    // Instruction fetch logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 8'd0; // Reset register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= ins_p1; // Fetch from first submodule\n            end else if (fetch == 2'b10) begin\n                ins_reg <= ins_p2; // Fetch from second submodule\n            end else begin\n                ins_reg <= ins_reg; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg;\n    assign ad1 = ins_reg[4:0];\n    assign ad2 = ins_reg[7:0];\n\n    // Submodules for instruction storage\n    instruction_storage ins_storage_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .output(ins_p1)\n    );\n\n    instruction_storage ins_storage_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .output(ins_p2)\n    );\n\nendmodule\n\n// Submodule for instruction storage\nmodule instruction_storage (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0; // Reset output\n        end else begin\n            output <= data; // Store input data\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction fetching\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [7:0] ins_reg1, ins_reg2;\n\n    // Instruction fetching logic\n    assign ins_p1 = (fetch == 2'b01) ? data : 8'd0;\n    assign ins_p2 = (fetch == 2'b10) ? data : 8'd0;\n\n    // Instruction register\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'd0;\n            ins_reg2 <= 8'd0;\n        end else begin\n            ins_reg1 <= ins_p1;\n            ins_reg2 <= ins_p2;\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_reg1;\n    assign ad1 = ins_reg2[4:0];\n    assign ad2 = ins_reg2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    inst_fetch fetch_inst (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .ins_out(ins_p1),\n        .ins_out(ins_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? data[7:2] : data[7:2]; // Use only the lower 5 bits\n    assign ad2 = (fetch == 2'b10) ? data[7:2] : data[7:2]; // Use only the lower 5 bits\n\nendmodule\n\n// Submodule for fetching instructions\nmodule inst_fetch (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] ins_out1,\n    output reg [7:0] ins_out2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out1 <= 8'd0;\n            ins_out2 <= 8'd0;\n        end else begin\n            ins_out1 <= data_in; // Store full 8-bit data\n            ins_out2 <= data_in; // Store full 8-bit data\n        end\n    end\n\nendmodule"}
