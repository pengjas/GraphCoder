{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Input register submodules\n    wire [5:0] ins1, ins2;\n    wire [7:0] ad1_int, ad2_int;\n\n    // Instruction register connections\n    assign ins = (fetch == 2'b01) ? ins1 : ins2; // Fetched from port 1\n    assign ad1 = (fetch == 2'b01) ? ad1_int : 8'd0; // Fetched from port 1\n    assign ad2 = (fetch == 2'b10) ? ad2_int : 8'd0; // Fetched from port 2\n\n    // Submodules\n    instruction_reg_sub ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(2'b01),\n        .data(data),\n        .out_ins(ins1),\n        .out_ad(ad1_int)\n    );\n\n    instruction_reg_sub ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(2'b10),\n        .data(data),\n        .out_ins(ins2),\n        .out_ad(ad2_int)\n    );\n\nendmodule\n\n// Instruction register submodule\nmodule instruction_reg_sub (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [5:0] out_ins,\n    output reg [7:0] out_ad\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out_ins <= 6'd0; // Reset instruction\n            out_ad  <= 8'd0; // Reset address\n        end else begin\n            if (fetch == 2'b01) begin\n                out_ins <= data[5:0]; // Input instruction\n                out_ad  <= data[7:0]; // Input address\n            end else if (fetch == 2'b10) begin\n                out_ins <= data[7:3]; // Input instruction\n                out_ad  <= data[7:0]; // Input address\n            end else begin\n                out_ins <= out_ins; // Retain previous instruction\n                out_ad  <= out_ad; // Retain previous address\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction storage\n    wire [7:0] p1_out, p2_out; // Intermediate outputs from submodules\n\n    submodule p1 (\n        input clk,\n        input rst,\n        input 8'd0,\n        input [7:0] data,\n        output reg [7:0] p1_out\n    );\n\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                p1_out <= 8'd0; // Reset the register\n            end else begin\n                if (fetch == 2'b01) begin\n                    p1_out <= data; // Store data\n                end else begin\n                    p1_out <= p1_out; // Retain previous value\n                end\n            end\n        end\n\n    submodule p2 (\n        input clk,\n        input rst,\n        input 8'd0,\n        input [7:0] data,\n        output reg [7:0] p2_out\n    );\n\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                p2_out <= 8'd0; // Reset the register\n            end else begin\n                if (fetch == 2'b10) begin\n                    p2_out <= data; // Store data\n                end else begin\n                    p2_out <= p2_out; // Retain previous value\n                end\n            end\n        end\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? p1_out : p2_out; // Select output based on fetch signal\n    assign ad1 = (fetch == 2'b01) ? 5'd0 : 5'd11; // Constant address for first submodule\n    assign ad2 = (fetch == 2'b10) ? 5'd0 : 5'd12; // Constant address for second submodule\n\nendmodule\n\n// Submodule for instruction storage\nsubmodule p1 (\n    input clk,\n    input rst,\n    input 8'd0,\n    input [7:0] data,\n    output reg [7:0] p1_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            p1_out <= 8'd0; // Reset the register\n        end else begin\n            p1_out <= data; // Store data\n        end\n    end\n\nendmodule\n\n// Submodule for instruction storage\nsubmodule p2 (\n    input clk,\n    input rst,\n    input 8'd0,\n    input [7:0] data,\n    output reg [7:0] p2_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            p2_out <= 8'd0; // Reset the register\n        end else begin\n            p2_out <= data; // Store data\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    reg [7:0] ins_p1, ins_p2;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n\n            // Instruction fetch\n            case (fetch)\n                2'b01: begin\n                    ins_p1 <= data; // Store fetched data\n                end\n                2'b10: begin\n                    ins_p2 <= data; // Store fetched data\n                end\n                default: begin\n                    ins_p1 <= ins_p1; // Retain previous value\n                    ins_p2 <= ins_p2; // Retain previous value\n                end\n            endcase\n        end\n    end\n\n    // Outputs\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for instruction storage\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction register\n    reg [2:0] ins_reg1, ins_reg2;\n\n    // Fetch logic\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_reg1 <= 3'd0;\n            ins_reg2 <= 3'd0;\n        end else begin\n            if (fetch == 2'b01) // Fetch from data\n                ins_p1 <= data;\n            else if (fetch == 2'b10) // Fetch from data\n                ins_p2 <= data;\n            else begin\n                ins_p1 <= ins_p1; // Retain previous value\n                ins_p2 <= ins_p2; // Retain previous value\n            end\n        end\n    end\n\n    // Outputs\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules for register storage\n    reg [7:0] ins_p1, ins_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0; // Reset\n            ins_p2 <= 8'd0; // Reset\n        end else begin\n            if (fetch == 2'b01) ins_p1 <= data; // Fetch from data input\n            else if (fetch == 2'b10) ins_p2 <= data; // Fetch from data input\n            else begin\n                ins_p1 <= ins_p1; // Retain previous value\n                ins_p2 <= ins_p2; // Retain previous value\n            end\n        end\n    end\n\n    // Outputs\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for first instruction\n    reg [2:0] ins_p1, ins_p2;\n    reg [4:0] ad1_p1, ad1_p2;\n\n    // Input logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 3'd0; // Initialize to zero\n            ad1_p1 <= 5'd0;\n            ins_p2 <= 3'd0;\n            ad1_p2 <= 5'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch instruction P1\n                ins_p1 <= data[7:4]; // Assign lower 4-bits\n                ad1_p1 <= data[3:0]; // Assign upper 4-bits\n            end else if (fetch == 2'b10) begin // Fetch instruction P2\n                ins_p2 <= data[7:4]; // Assign lower 4-bits\n                ad1_p2 <= data[3:0]; // Assign upper 4-bits\n            end else begin // Retain previous values\n                ins_p1 <= ins_p1;\n                ad1_p1 <= ad1_p1;\n                ins_p2 <= ins_p2;\n                ad1_p2 <= ad1_p2;\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_p1; // Output instruction from submodule P1\n    assign ad1 = ad1_p1; // Output data from submodule P1\n    assign ad2 = ad1_p2; // Output data from submodule P2\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions from RAM/ROM\n    wire [7:0] ins_p1, ins_p2;\n\n    register_stage ram_stage (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .data_out(ins_p1),\n        .active_id(2'b01)\n    );\n\n    register_stage rom_stage (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .data_out(ins_p2),\n        .active_id(2'b10)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2; // Select instruction from RAM/ROM based on fetch signal\n    assign ad1 = (fetch == 2'b01) ? data[7:2] : ins_p1[4:0]; // Assign address and data from RAM/ROM\n    assign ad2 = (fetch == 2'b01) ? data[7:2] : ins_p2[7:0]; // Assign address and data from RAM/ROM\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for register input\n    wire [7:0] ins_p1, ins_p2;\n\n    // Instruction fetch logic\n    reg [7:0] ins_reg;\n    reg [1:0] fetch_reg; // Register to hold the previous fetch value\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 8'd0; // Reset register\n            fetch_reg <= 2'b00; // Reset fetch register\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= ins_p1;\n                fetch_reg <= fetch;\n            end else if (fetch == 2'b10) begin\n                ins_reg <= ins_p2;\n                fetch_reg <= fetch;\n            end else begin\n                ins_reg <= ins_reg;\n                fetch_reg <= fetch_reg;\n            end\n        end\n    end\n\n    // Submodules to store fetched instructions\n    fetch_register ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .out(ins_p1)\n    );\n\n    fetch_register ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .out(ins_p2)\n    );\n\n    // Assign registers to outputs\n    assign ins = ins_reg;\n    assign ad1 = ins_p1;\n    assign ad2 = ins_p2;\n\nendmodule\n\n// Submodule to store fetched instructions\nmodule fetch_register (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 8'd0; // Reset output\n        end else begin\n            out <= data; // Store incoming data\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions from data inputs\n    wire [7:0] ins_p1, ins_p2;\n\n    fetch_instruction fe_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1)\n    );\n\n    fetch_instruction fe_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2)\n    );\n\n    // Output signals based on instruction fetch\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2; // Select instruction based on fetch\n    assign ad1 = (fetch == 2'b01) ? ad1 : ad2;  // Select data from first submodule\n    assign ad2 = (fetch == 2'b10) ? ad1 : ad2;  // Select data from second submodule\n\nendmodule\n\n// Submodule for fetching instructions\nmodule fetch_instruction (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'd0; // Reset output\n        end else if (fetch) begin\n            ins <= data; // Load data input\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for storing instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [7:0] ins_p1_reg, ins_p2_reg;\n\n    // Instruction input\n    wire [7:0] ins_input;\n\n    // Control logic for selecting instruction entry\n    wire [1:0] fetch_sig;\n    assign fetch_sig = fetch;\n\n    // Instruction input\n    assign ins_input = data;\n\n    // Instruction registers\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 8'd0;\n            ins_p2_reg <= 8'd0;\n        end else begin\n            if (fetch_sig == 2'b01) begin\n                ins_p1_reg <= ins_input;\n            end else if (fetch_sig == 2'b10) begin\n                ins_p2_reg <= ins_input;\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_p1_reg;\n    assign ad1 = ins_p2_reg;\n    assign ad2 = ins_p1_reg; // Reusing for ad2\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    instruction_fetch ifetch (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins_p1(ins_p1),\n        .ins_p2(ins_p2)\n    );\n\n    // Output logic\n    reg [2:0] ins_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'd0; // Reset output on reset\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg <= ins_p1; // Assign from first instruction\n            end else if (fetch == 2'b10) begin\n                ins_reg <= ins_p2; // Assign from second instruction\n            end else begin\n                ins_reg <= ins_reg; // Retain previous value\n            end\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ins_p1; // Pass data inputs through, as they are not needed\n    assign ad2 = ins_p2; // Pass data inputs through, as they are not needed\n\nendmodule\n\n// Instruction fetch submodule\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins_p1,\n    output reg [7:0] ins_p2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0; // Reset both register outputs on reset\n            ins_p2 <= 8'd0;\n        end else begin\n            if (data[7:5] == 3'b01) begin\n                ins_p1 <= data; // Assign from first data input\n            end else if (data[7:5] == 3'b10) begin\n                ins_p2 <= data; // Assign from second data input\n            end else begin\n                ins_p1 <= ins_p1; // Retain previous value\n                ins_p2 <= ins_p2; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    wire [7:0] ins_p1, ins_p2;\n\n    reg [31:0] ins_reg1, ins_reg2; // Registers for instructions\n\n    // Instruction fetch control\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n\n    // Submodules for storing instructions\n    fetch_instruction inst_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .inst_out(ins_p1)\n    );\n\n    fetch_instruction inst_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data),\n        .inst_out(ins_p2)\n    );\n\n    // Store fetched instructions in registers\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 0;\n            ins_reg2 <= 0;\n        end else begin\n            ins_reg1 <= {ins_p1, ins_reg1[31:8]};\n            ins_reg2 <= {ins_p2, ins_reg2[31:8]};\n        end\n    end\n\n    // Assign outputs to register values\n    assign ins = ins_reg1[2:0];\n    assign ad1 = ins_reg1[4:0];\n    assign ad2 = ins_reg2[7:0];\n\nendmodule\n\n// Submodule for fetching instructions\nmodule fetch_instruction (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] inst_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) inst_out <= 0; // Reset output\n        else if (data_in[7] && !data_in[6]) inst_out <= data_in; // Valid instruction, forward\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodules to store instructions\n    reg [7:0] ins_p1, ins_p2;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_p1 <= 0; // Reset\n            ins_p2 <= 0; // Reset\n        end else begin\n            if (fetch == 2'b01) begin // Fetch from first port\n                ins_p1 <= data;\n            end else if (fetch == 2'b10) begin // Fetch from second port\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1; // Retain previous value\n                ins_p2 <= ins_p2; // Retain previous value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_p1;\n    assign ad1 = ins_p2;\n    assign ad2 = data; // Direct assignment for RAM/ROM data input\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for fetching instructions\n    reg [7:0] ins_p1, ins_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0; // Reset in first submodule\n            ins_p2 <= 8'd0; // Reset in second submodule\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1 <= data; // Fetch data from register port\n            end else if (fetch == 2'b10) begin\n                ins_p2 <= data; // Fetch data from RAM port\n            end else begin\n                ins_p1 <= ins_p1; // Maintain current value\n                ins_p2 <= ins_p2; // Maintain current value\n            end\n        end\n    end\n\n    // Output assignments\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2[7:0];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for first instruction input\n    wire [7:0] ins_p1;\n    reg [7:0] ins_p1_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 8'd0; // Reset instruction\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data; // Fetch instruction from input\n        end else begin\n            ins_p1_reg <= ins_p1_reg; // Retain instruction\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n\n    // Submodule for second instruction input\n    wire [7:0] ins_p2;\n    reg [7:0] ins_p2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_reg <= 8'd0; // Reset instruction\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data; // Fetch instruction from input\n        end else begin\n            ins_p2_reg <= ins_p2_reg; // Retain instruction\n        end\n    end\n\n    assign ins_p2 = ins_p2_reg;\n\n    // Output assignments\n    assign ins  = ins_p1;\n    assign ad1  = ins_p1[4:0];\n    assign ad2  = ins_p2;\n\nendmodule"}
