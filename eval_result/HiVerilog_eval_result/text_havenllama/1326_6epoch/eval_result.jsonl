{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            next_count <= 0;\n        else if (up_down)\n            next_count <= count + 1;\n        else\n            next_count <= count - 1;\n    end\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] state;\n\n    // Instantiate submodules to handle state initialization and transition\n    ring_counter_init init (\n        .clk(clk),\n        .reset(reset),\n        .state_out(state)\n    );\n\n    ring_counter_transition transition (\n        .clk(clk),\n        .state_in(state),\n        .state_out(state)\n    );\n\n    assign out = state;\n\nendmodule\n\n// Submodule to handle initial state initialization\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] state_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state_out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\n// Submodule to handle state transition\nmodule ring_counter_transition (\n    input wire clk,\n    input wire [7:0] state_in,\n    output reg [7:0] state_out\n);\n\n    always @(posedge clk) begin\n        case(state_in)\n            8'b0000_0001: state_out <= 8'b0000_0010;\n            8'b0000_0010: state_out <= 8'b0000_0100;\n            8'b0000_0100: state_out <= 8'b0000_1000;\n            8'b0000_1000: state_out <= 8'b0001_0000;\n            8'b0001_0000: state_out <= 8'b0010_0000;\n            8'b0010_0000: state_out <= 8'b0100_0000;\n            8'b0100_0000: state_out <= 8'b1000_0000;\n            8'b1000_0000: state_out <= 8'b0000_0001;\n            default: state_out <= 8'b0000_0001;\n        endcase\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instantiate the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (!valid_count) begin\n            out <= out;\n        end else begin\n            out <= count;\n        end\n    end\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\n// Submodule for register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q;\n        end\n    end\nendmodule\n\n// Submodule for logic\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state <= (Q & (Q - 1)) | (Q & (~Q + 1));\n        end\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_50_out, CLK_10_out, CLK_1_out;\n\n    clk_div_2 clk_div_50 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_50_out));\n    clk_div_10 clk_div_10 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_10_out));\n    clk_div_100 clk_div_1 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_1_out));\n\n    assign CLK_50 = CLK_50_out;\n    assign CLK_10 = CLK_10_out;\n    assign CLK_1 = CLK_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 3) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 49) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\n// Internal wires\nwire clk_4_div;\nwire clk_3_div;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_4_div)\n);\n\n// Instantiate the clock divider\nclk_average u_clk_average (\n    .clk_in(clk),\n    .clk_div(clk_4_div),\n    .clk_out(clk_3_div)\n);\n\n// Instantiate the clock adjustment module\nclk_adjustment u_clk_adjustment (\n    .clk_in(clk),\n    .clk_div(clk_3_div),\n    .clk_out(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter MAX_COUNT = MUL2_DIV_CLK;\n\nreg [7:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div <= 0;\n    end else if (cnt == MAX_COUNT) begin\n        cnt <= 0;\n        clk_div <= ~clk_div;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input clk_in,\n    input clk_div,\n    output reg clk_out\n);\n\nparameter N = 2;\nparameter CLK_PERIOD = 10; // 100 MHz\nparameter CYCLES_PER_CLK = CLK_PERIOD / N;\n\nreg [$clog2(N):0] cycles;\nreg [$clog2(N):0] clk_div_cnt;\nreg clk_div_r;\n\nalways @(posedge clk_in) begin\n    cycles <= cycles + 1;\n    clk_div_r <= clk_div;\nend\n\nalways @(posedge clk_in) begin\n    if (cycles == 0) begin\n        clk_div_cnt <= clk_div_cnt + 1;\n        clk_out <= clk_div_r;\n    end else if (clk_div_cnt == N - 1) begin\n        clk_div_cnt <= 0;\n        clk_out <= ~clk_div_r;\n    end else begin\n        clk_div_cnt <= clk_div_cnt + 1;\n        clk_out <= clk_div_r;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input clk_in,\n    input clk_div,\n    output clk_out\n);\n\nparameter N = 2;\nparameter CLK_PERIOD = 10; // 100 MHz\nparameter CYCLES_PER_CLK = CLK_PERIOD / N;\n\nreg [$clog2(N):0] cycles;\nreg clk_div_r;\n\nalways @(posedge clk_in) begin\n    cycles <= cycles + 1;\n    clk_div_r <= clk_div;\nend\n\nassign clk_out = ~clk_div_r;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1;\nwire clk_div2;\n\npos_edge_counter u_pos_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n        cnt <= 0;\n    end else if (cnt < NUM_DIV - 1) begin\n        cnt <= cnt + 1;\n    end else begin\n        clk_div <= 1;\n        cnt <= 0;\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] cnt;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n        cnt <= 0;\n    end else if (cnt < NUM_DIV - 1) begin\n        cnt <= cnt + 1;\n    end else begin\n        clk_div <= 1;\n        cnt <= 0;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n\n    reg [3:0] cnt;\n    wire clk_div_en;\n    wire clk_div_toggle;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt)\n    );\n\n    clk_divider u_clk_divider(\n        .clk(clk),\n        .clk_div_en(clk_div_en),\n        .clk_div_toggle(clk_div_toggle)\n    );\n\n    assign clk_div = clk_div_toggle;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (cnt == NUM_DIV / 2 - 1) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input clk_div_en,\n    output reg clk_div_toggle\n);\n    always @(posedge clk) begin\n        if (clk_div_en) begin\n            clk_div_toggle <= ~clk_div_toggle;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, lui_r;\n    wire add_carry, sub_carry, sllv_carry, srlv_carry, sra_carry;\n    wire add_overflow, sub_overflow, slt_overflow, sltu_overflow;\n    wire add_zero, sub_zero, slt_zero, sltu_zero;\n    wire [31:0] sll_b, srl_b, sra_b;\n\n    assign sll_b = b << aluc[4:0];\n    assign srl_b = b >> aluc[4:0];\n    assign sra_b = $signed(b) >>> aluc[4:0];\n\n    add add(.a(a), .b(b), .r(add_r), .carry(add_carry), .overflow(add_overflow));\n    add addu(.a(a), .b(b), .r(add_r), .carry(add_carry), .overflow(add_overflow));\n    sub sub(.a(a), .b(b), .r(sub_r), .carry(sub_carry), .overflow(sub_overflow));\n    sub subu(.a(a), .b(b), .r(sub_r), .carry(sub_carry), .overflow(sub_overflow));\n    and and1(.a(a), .b(b), .r(and_r));\n    or or1(.a(a), .b(b), .r(or_r));\n    xor xor1(.a(a), .b(b), .r(xor_r));\n    nor nor1(.a(a), .b(b), .r(nor_r));\n    slt slt_inst(.a(a), .b(b), .r(slt_r));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_r));\n    sll sll(.a(a), .b(b), .r(sll_r));\n    srl srl(.a(a), .b(b), .r(srl_r));\n    sra sra(.a(a), .b(b), .r(sra_r));\n    lui lui_inst(.a(a), .b(b), .r(lui_r));\n\n    assign r = aluc[5:0] == 6'b000000 ? sll_r :\n               aluc[5:0] == 6'b000010 ? srl_r :\n               aluc[5:0] == 6'b000011 ? sra_r :\n               aluc[5:0] == 6'b000100 ? add_r :\n               aluc[5:0] == 6'b000101 ? addu_r :\n               aluc[5:0] == 6'b000110 ? or_r :\n               aluc[5:0] == 6'b000111 ? nor_r :\n               aluc[5:0] == 6'b001000 ? xor_r :\n               aluc[5:0] == 6'b001001 ? sllv_r :\n               aluc[5:0] == 6'b001010 ? srlv_r :\n               aluc[5:0] == 6'b001011 ? sra_r :\n               aluc[5:0] == 6'b001111 ? lui_r :\n               aluc[5:0] == 6'b100000 ? sub_r :\n               aluc[5:0] == 6'b100001 ? subu_r :\n               aluc[5:0] == 6'b100010 ? slt_r :\n               aluc[5:0] == 6'b10001"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [31:0] product;\n    wire [31:0] accumulated_value;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(accumulated_value),\n        .new_value(product),\n        .result(c)\n    );\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output [31:0] result\n);\n    reg [31:0] internal_value;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            internal_value <= 0;\n        end else begin\n            internal_value <= internal_value + new_value;\n        end\n    end\n\n    assign result = internal_value;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1, ins2;\n    wire [4:0] ad11, ad12, ad21, ad22;\n\n    ins_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(fetch == 2'b01 ? data : ins1),\n        .ins(ins1)\n    );\n    ins_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(fetch == 2'b10 ? data : ins2),\n        .ins(ins2)\n    );\n\n    assign ins = fetch[0] ? ins1[7:5] : ins2[7:5];\n    assign ad1 = fetch[0] ? ad11 : ad12;\n    assign ad2 = ad21 | ad22;\n\nendmodule\n\nmodule ins_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else\n            ins <= data;\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\nwire [7:0] freq_inv;\n\nassign freq_inv = 8'd256 - freq;\n\n// Counter\ncounter cnt(.clk(clk), .enable(enable), .freq(freq_inv), .count(count));\n\n// Wave Generator\nwave_generator wg(.clk(clk), .count(count), .freq(freq), .wave_out(wave_out));\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] cnt;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (cnt >= (freq - 1)) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nend\n\nassign count = cnt;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    if (count >= (freq - 1)) begin\n        wave_out <= 1'b0;\n    end else begin\n        wave_out <= 1'b1;\n    end\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\nreg [4:0] wave_reg;\nreg [1:0] state_reg;\n\nassign wave = wave_reg;\n\n// State control logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state_reg <= 2'b00;\n    end else begin\n        case (state_reg)\n            2'b00: state_reg <= 2'b01;\n            2'b01: state_reg <= 2'b10;\n            2'b10: state_reg <= 2'b00;\n            default: state_reg <= 2'b00;\n        endcase\n    end\nend\n\n// Waveform generation logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wave_reg <= 5'b0;\n    end else begin\n        case (state_reg)\n            2'b00: wave_reg <= (wave_reg == 5'b11111) ? 5'b00000 : wave_reg + 1;\n            2'b01: wave_reg <= (wave_reg == 5'b00000) ? 5'b11111 : wave_reg - 1;\n            default: wave_reg <= wave_reg;\n        endcase\n    end\nend\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= 2'b00;\n    end else begin\n        state <= 2'b00;\n    end\nend\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wave <= 5'b0;\n    end else begin\n        wave <= 5'b0;\n    end\nend\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q0;\n            2'b01: q <= q1;\n            2'b10: q <= q2;\n            2'b11: q <= d;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage_1, stage_2, stage_3, stage_4;\n    wire [3:0] sel;\n\n    mux2X1 mux0 (stage_1, in, in >> 4, sel[0]);\n    mux2X1 mux1 (stage_2, stage_1, stage_1 >> 2, sel[1]);\n    mux2X1 mux2 (stage_3, stage_2, stage_2 >> 1, sel[2]);\n    mux2X1 mux3 (stage_4, stage_3, stage_3 >> 1, sel[2]);\n\n    assign sel = ctrl;\n\n    assign out = stage_4;\nendmodule\n\nmodule mux2X1 (y, a, b, sel);\n    input a, b, sel;\n    output y;\n\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  assign b1 = b0;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= c_reg + a * b;\n  end\n\n  assign c = c_reg;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc_out;\n  wire [31:0] alu_out;\n  wire [3:0] op;\n  wire [4:0] rs1, rs2, rd;\n  wire [31:0] alu_in1, alu_in2;\n\n  // Stage 1: Fetch\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc_out(pc_out));\n\n  // Stage 2: Decode\n  decode_stage decode(.clk(clk), .rst(rst), .pc_in(pc_out), .instr(instr_mem[pc_out]), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd));\n\n  // Stage 3: Execute\n  execute_stage execute(.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .alu_in1(alu_in1), .alu_in2(alu_in2), .alu_out(alu_out));\n\n  // Stage 4: Memory\n  memory_stage memory(.clk(clk), .rst(rst), .alu_in1(alu_in1), .alu_in2(alu_in2), .alu_out(alu_out));\n\n  // Stage 5: Writeback\n  writeback_stage writeback(.clk(clk), .rst(rst), .alu_out(alu_out), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(input clk, input rst, input [31:0] instr_mem[0:31], output reg [31:0] pc_out);\n  always @(posedge clk or posedge rst) begin\n    if (rst) pc_out <= 0;\n    else pc_out <= pc_out + 1;\n  end\nendmodule\n\nmodule decode_stage(input clk, input rst, input [31:0] pc_in, input [31:0] instr, output reg [3:0] op, output reg [4:0] rs1, output reg [4:0] rs2, output reg [4:0] rd);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n    end else begin\n      op <= instr[6:0];\n      rs1 <= instr[11:7];\n      rs2 <= instr[15:10];\n      rd <= instr[20:15];\n    end\n  end\nendmodule\n\nmodule execute_stage(input clk, input rst, input [3:0] op, input [4:0] rs1, input [4:0] rs2, input [31:0] alu_in1, input [31:0] alu_in2, output reg [31:0] alu_out);\n  always @(posedge clk or posedge rst) begin\n    if (rst) alu_out <= 0;\n    else begin\n      case (op)\n        6'b000000: alu_out <= alu_in1 + alu_in2;\n        6'b000010: alu_out <= alu_in1 - alu_in2;\n        default: alu_out <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(input clk, input rst, input [31:0] alu_in1, input [31:0] alu_in2, output reg [31:0] alu_out);\n  always @(posedge clk or posedge rst) begin\n    if (rst) alu_out <= 0;\n    else alu_out <= alu_in1;\n  end\nendmodule\n\nmodule writeback_stage(input clk, input rst, input [31:0] alu_out"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [31:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  wire [31:0] b0_next, b1_next, b2_next, b3_next;\n  wire [31:0] c0_next, c1_next, c2_next, c3_next;\n  PE pe0(.a(a0), .b(b0), .c(c0_next));\n  PE pe1(.a(a1), .b(b1_next), .c(c1_next));\n  PE pe2(.a(a2), .b(b2_next), .c(c2_next));\n  PE pe3(.a(a3), .b(b3_next), .c(c3_next));\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b0_reg <= b0_next;\n      b1_reg <= b1_next;\n      b2_reg <= b2_next;\n      b3_reg <= b3_next;\n    end\n  end\n  assign b0_next = b0;\n  assign b1_next = b0_reg;\n  assign b2_next = b1_reg;\n  assign b3_next = b2_reg;\n  assign c0_next = b0 * a0;\n  assign c1_next = b1 * a1;\n  assign c2_next = b2 * a2;\n  assign c3_next = b3 * a3;\n  assign c0 = c0_next;\n  assign c1 = c1_next;\n  assign c2 = c2_next;\n  assign c3 = c3_next;\nendmodule\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  input [31:0] c_in,\n  output [31:0] c_out\n);\n  assign c_out = a * b + c_in;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr, fetched_reg;\n    wire [31:0] instr_result;\n\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr), .fetched_reg(fetched_reg));\n    execute_stage execute(.clk(clk), .fetched_instr(fetched_instr), .fetched_reg(fetched_reg), .instr_result(instr_result));\n    writeback_stage writeback(.clk(clk), .instr_result(instr_result), .out_reg_file(out_reg_file));\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetched_instr,\n    output reg [31:0] fetched_reg\n);\n    reg [31:0] pc;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n            fetched_instr <= 0;\n            fetched_reg <= 0;\n        end else begin\n            fetched_instr <= instr_mem[pc];\n            fetched_reg <= reg_file[fetched_instr[15:11]];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] fetched_instr,\n    input [31:0] fetched_reg,\n    output reg [31:0] instr_result\n);\n    always @(posedge clk) begin\n        case (fetched_instr[31:28])\n            4'b0000: instr_result <= fetched_reg + fetched_instr[15:0];\n            4'b0001: instr_result <= fetched_reg - fetched_instr[15:0];\n            default: instr_result <= 0;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] instr_result,\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk) begin\n        out_reg_file <= instr_result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [3:0] cnt;\n    wire add_done;\n    wire [9:0] data_accum;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_done(add_done),\n        .cnt(cnt)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_done(add_done),\n        .data_in(data_in),\n        .data_accum(data_accum)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               add_done,\n    output reg  [3:0]   cnt\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (add_done) begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               add_done,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_accum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accum <= 0;\n        end else if (add_done) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    reg [3:0] cnt;\n    reg [9:0] accum;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            valid_out <= 0;\n            data_out <= 0;\n        end else begin\n            if (valid_in) begin\n                cnt <= cnt + 1;\n                accum <= accum + data_in;\n            end\n            if (cnt == 4) begin\n                valid_out <= 1;\n                data_out <= accum;\n                cnt <= 0;\n            end else begin\n                valid_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend, neg_divisor;\n    wire [3:0] cnt_div;\n    wire [15:0] quotient, remainder;\n    wire done;\n\n    // Submodule Instantiation\n    abs_value abs_dividend_inst (\n        .dividend(dividend),\n        .sign(sign),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_inst (\n        .dividend(divisor),\n        .sign(sign),\n        .result(neg_divisor)\n    );\n\n    div_ctrl ctrl_inst (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .divisor(neg_divisor),\n        .cnt_div(cnt_div),\n        .done(done)\n    );\n\n    div_result res_mgmt_inst (\n        .clk(clk),\n        .rst(rst),\n        .cnt_div(cnt_div),\n        .done(done),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result),\n        .res_valid(res_valid)\n    );\n\nendmodule\n\nmodule abs_value(\n    input [7:0] dividend,\n    input sign,\n    output reg [7:0] result\n);\n\n    always @(dividend or sign) begin\n        if (sign)\n            result = ~dividend + 1;\n        else\n            result = dividend;\n    end\n\nendmodule\n\nmodule neg_value(\n    input [7:0] dividend,\n    input sign,\n    output reg [7:0] result\n);\n\n    always @(dividend or sign) begin\n        if (sign)\n            result = ~dividend + 1;\n        else\n            result = ~dividend;\n    end\n\nendmodule\n\nmodule div_ctrl(\n    input clk,\n    input rst,\n    input opn_valid,\n    input res_ready,\n    input [7:0] divisor,\n    output reg [3:0] cnt_div,\n    output reg done\n);\n\n    reg [3:0] cnt_div_reg;\n    reg done_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cnt_div_reg <= 0;\n            done_reg <= 0;\n        end else if (opn_valid && !done_reg && !res_ready) begin\n            cnt_div_reg <= cnt_div_reg + 1;\n            if (cnt_div_reg == 3)\n                done_reg <= 1;\n        end else begin\n            cnt_div_reg <= 0;\n            done_reg <= 0;\n        end\n    end\n\n    always @(cnt_div_reg or done_reg) begin\n        cnt_div = cnt_div_reg;\n        done = done_reg;\n    end\n\nendmodule\n\nmodule div_result(\n    input clk,\n    input rst,\n    input [3:0] cnt_div,\n    input done,\n    input [15:0] quotient,\n    input [15:0] remainder,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else if (done) begin\n            result <= {remainder, quotient};\n            res_valid <= 1;\n        end else begin\n            result <= 0;\n            res_valid <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Instantiate submodules\nprep_dividend prep(\n    .A(A),\n    .B(B),\n    .prep_A(prep_A),\n    .prep_B(prep_B)\n);\n\ndiv_operation div_op(\n    .A(prep_A),\n    .B(prep_B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n\n    assign prep_A = {16'b0, A};\n    assign prep_B = {16'b0, B};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    integer i;\n\n    always @(*) begin\n        result = 32'b0;\n        odd = 32'b0;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (A[i]) begin\n                result[i] = 1'b1;\n                odd[i] = A[i-1];\n            end else if (odd[i-1]) begin\n                odd[i] = 1'b1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [7:0] shifter;\n    wire [7:0] remainder;\n    wire [7:0] quotient;\n\n    // Control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .result(temp),\n        .remainder(remainder)\n    );\n\n    assign result = temp;\n    assign odd = remainder;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [7:0] remainder  // 8-bit remainder\n);\n    // Initialize temp and remainder\n    reg [15:0] temp = 16'b0;\n\n    // Loop logic\n    always @(*) begin\n        temp = A;\n        remainder = 8'b0;\n        for (int i = 15; i >= 0; i--) begin\n            remainder = (remainder << 1) | temp[15];\n            temp = temp << 1;\n            if (temp >= B) begin\n                temp = temp - B;\n                remainder = remainder + 1;\n            end\n        end\n        result = temp >> 8;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire [7:0] sum;\nwire carry;\n\n// 2's complement of B\nassign B_complement = ~B + 1;\n\n// Instantiation of adder module\nadder_8bit adder_inst(\n    .a(A),\n    .b(B_complement),\n    .sum(sum),\n    .carry(carry)\n);\n\n// Output D and B_out\nassign D = sum;\nassign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(a, b, sum, carry);\ninput [7:0] a, b;\noutput [7:0] sum;\noutput carry;\n\nwire [7:0] c;\n\nassign {carry, sum} = a + b;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_diff, S2_diff;\n    wire S1_borrow, S2_borrow;\n\n    sub_16bit S1(A[15:0], B[15:0], S1_diff, S1_borrow);\n    sub_16bit S2(A[31:16], B[31:16], S2_diff, S2_borrow);\n\n    assign B_out = S1_borrow | S2_borrow;\n    assign Diff = {S2_diff, S1_diff};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output Borrow_out;\n\n    wire [4:0] borrow;\n    wire [15:0] B_neg;\n\n    assign B_neg = ~B + 1;\n\n    full_adder FA0 (.A(A[0]), .B(B_neg[0]), .Cin(1'b0), .Sum(Diff[0]), .Cout(borrow[0]));\n    full_adder FA1 (.A(A[1]), .B(B_neg[1]), .Cin(borrow[0]), .Sum(Diff[1]), .Cout(borrow[1]));\n    full_adder FA2 (.A(A[2]), .B(B_neg[2]), .Cin(borrow[1]), .Sum(Diff[2]), .Cout(borrow[2]));\n    full_adder FA3 (.A(A[3]), .B(B_neg[3]), .Cin(borrow[2]), .Sum(Diff[3]), .Cout(borrow[3]));\n    full_adder FA4 (.A(A[4]), .B(B_neg[4]), .Cin(borrow[3]), .Sum(Diff[4]), .Cout(borrow[4]));\n    full_adder FA5 (.A(A[5]), .B(B_neg[5]), .Cin(borrow[4]), .Sum(Diff[5]), .Cout(borrow[5]));\n    full_adder FA6 (.A(A[6]), .B(B_neg[6]), .Cin(borrow[5]), .Sum(Diff[6]), .Cout(borrow[6]));\n    full_adder FA7 (.A(A[7]), .B(B_neg[7]), .Cin(borrow[6]), .Sum(Diff[7]), .Cout(borrow[7]));\n    full_adder FA8 (.A(A[8]), .B(B_neg[8]), .Cin(borrow[7]), .Sum(Diff[8]), .Cout(borrow[8]));\n    full_adder FA9 (.A(A[9]), .B(B_neg[9]), .Cin(borrow[8]), .Sum(Diff[9]), .Cout(borrow[9]));\n    full_adder FA10(.A(A[10]), .B(B_neg[10]), .Cin(borrow[9]), .Sum(Diff[10]), .Cout(borrow[10]));\n    full_adder FA11(.A(A[11]), .B(B_neg[11]), .Cin(borrow[10]), .Sum(Diff[11]), .Cout(borrow[11]));\n    full_adder FA12(.A(A[12]), .B(B_neg[12]), .Cin(borrow[11]), .Sum(Diff[12]), .Cout(borrow[12]));\n    full_adder FA13(.A(A[13]), .B(B_neg[13]), .Cin(borrow[12]), .Sum(Diff[13]), .Cout(borrow[13]));\n    full_adder FA14(.A(A[14]), .B(B_neg[14]),"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nsub_32bit sub0(A[31:0], B[31:0], D[31:0], B_out);\nsub_32bit sub1(A[63:32], B[63:32], D[63:32], B_out);\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nsub_16bit sub0(A[15:0], B[15:0], D[15:0], B_out);\nsub_16bit sub1(A[31:16], B[31:16], D[31:16], B_out);\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nsub_8bit sub0(A[7:0], B[7:0], D[7:0], B_out);\nsub_8bit sub1(A[15:8], B[15:8], D[15:8], B_out);\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [1:0] borrow;\nassign borrow[0] = (~A[0] & B[0]) | (~A[0] & borrow[1]);\nassign B_out = borrow[1];\n\nassign D = A - B;\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [15:0] B_out_in;\n\n    // Instance of 4-bit BLS subtractor\n    BLS_subtractor_4bit sub1(A[3:0], B[3:0], D[3:0], B_out_in[0]);\n    BLS_subtractor_4bit sub2(A[7:4], B[7:4], D[7:4], B_out_in[1]);\n    BLS_subtractor_4bit sub3(A[11:8], B[11:8], D[11:8], B_out_in[2]);\n    BLS_subtractor_4bit sub4(A[15:12], B[15:12], D[15:12], B_out_in[3]);\n\n    // Generate borrow out\n    assign B_out = B_out_in[3];\nendmodule\n\nmodule BLS_subtractor_4bit(A, B, D, borrow_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output borrow_out;\n\n    wire [3:0] B_out;\n\n    // Instance of full subtractor\n    full_subtractor_4bit full_sub(A, B, D, B_out);\n    assign borrow_out = B_out[3];\nendmodule\n\nmodule full_subtractor_4bit(A, B, D, borrow_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output borrow_out;\n\n    wire [3:0] B_out;\n\n    assign D = A - B;\n    assign B_out = A < B;\n    assign borrow_out = B_out[3];\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff;\n    wire borrow;\n    \n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .D(diff),\n        .B_out(borrow)\n    );\n    \n    assign A_greater = ~borrow & (diff != 0);\n    assign A_equal = ~borrow & (diff == 0);\n    assign A_less = borrow;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] D,  // Difference\n    output B_out      // Borrow output\n);\n    wire [31:0] B_neg;\n    wire borrow_internal;\n\n    // Calculate 2's complement of B\n    assign B_neg = ~B + 1;\n\n    // Perform subtraction\n    full_adder FA0(.A(A[31]), .B(B_neg[31]), .Cin(1'b0), .Sum(D[31]), .Cout(borrow_internal));\n    genvar i;\n    generate\n        for (i = 30; i >= 0; i = i - 1) begin : gen_subtract\n            full_adder FA (.A(A[i]), .B(B_neg[i]), .Cin(borrow_internal), .Sum(D[i]), .Cout(borrow_internal));\n        end\n    endgenerate\n\n    // Assign borrow output\n    assign B_out = borrow_internal;\nendmodule\n\nmodule full_adder(input A, B, Cin, output Sum, Cout);\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:0] C15;\n\nCLA1 CLA1(.A(A[15:0]),.B(B[15:0]),.Cin(1'b0),.S(S[15:0]),.Cout(C15));\n\nCLA2 CLA2(.A(A[31:16]),.B(B[31:16]),.Cin(C15[0]),.S(S[31:16]),.Cout(C32));\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:0] A,B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [14:0] G,P;\nwire [15:0] C;\n\ngenvar i;\ngenerate\n    for(i=0;i<15;i=i+1) begin:gen1\n        assign G[i]=A[i]&B[i];\n        assign P[i]=A[i]^B[i];\n    end\nendgenerate\nassign C[0]=G[0]|(P[0]&Cin);\ngenerate\n    for(i=1;i<15;i=i+1) begin:gen2\n        assign C[i]=G[i]|(P[i]&C[i-1]);\n    end\nendgenerate\n\nassign S=P+C[14];\nassign Cout=C[14];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\ninput [15:0] A,B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [14:0] G,P;\nwire [15:0] C;\n\ngenvar i;\ngenerate\n    for(i=0;i<15;i=i+1) begin:gen1\n        assign G[i]=A[i]&B[i];\n        assign P[i]=A[i]^B[i];\n    end\nendgenerate\nassign C[0]=G[0]|(P[0]&Cin);\ngenerate\n    for(i=1;i<15;i=i+1) begin:gen2\n        assign C[i]=G[i]|(P[i]&C[i-1]);\n    end\nendgenerate\n\nassign S=P+C[14];\nassign Cout=C[14];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Ripple carry adder for 4-bit\nwire [3:0] a_slice, b_slice;\nwire [3:0] c_slice;\n\nassign a_slice = a[3:0];\nassign b_slice = b[3:0];\nassign c_slice = {1'b0, cin, cin, cin};\n\nwire [3:0] p0, p1, p2, p3;\nwire [3:0] g0, g1, g2, g3;\n\nassign p0 = a_slice ^ b_slice ^ c_slice;\nassign p1 = a_slice ^ b_slice;\nassign p2 = a_slice ^ c_slice;\nassign p3 = b_slice ^ c_slice;\n\nassign g0 = a_slice & b_slice;\nassign g1 = a_slice & c_slice;\nassign g2 = p1 & c_slice;\nassign g3 = p2 & c_slice;\n\nassign sum_slice = {p3, p2, p1, p0};\nassign carry[3:0] = {g3, g2, g1, g0};\n\n// Carry select adder for 4-bit\nwire [1:0] csa_out;\nwire [1:0] csa_carry;\n\nassign csa_out[0] = (a_slice[0] & b_slice[0]) | (a_slice[0] & c_slice[0]) | (b_slice[0] & c_slice[0]);\nassign csa_out[1] = (a_slice[1] & b_slice[1]) | (a_slice[1] & c_slice[1]) | (b_slice[1] & c_slice[1]);\nassign csa_carry[0] = (a_slice[1] & b_slice[1]) | (a_slice[1] & c_slice[1]) | (b_slice[1] & c_slice[1]) | (a_slice[0] & b_slice[0]) | (a_slice[0] & c_slice[0]) | (b_slice[0] & c_slice[0]);\nassign csa_carry[1] = csa_carry[0];\n\nassign sum = {sum_slice, csa_out};\nassign cout = csa_carry[1];\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] c;\n\nassign {c[2], c[1], c[0]} = {1'b0, cin, cin, cin};\nassign sum = a ^ b ^ c;\nassign cout = (a & b) | (c & (a ^ b));\n\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] c;\nwire [3:0] s;\n\nassign {c[2], c[1], c[0]} = {1'b0, cin, cin, cin};\nassign s[0] = a[0] ^ b[0] ^ c[0];\nassign s[1] = a[1] ^ b[1] ^ c[1];\nassign s[2] = a[2] ^ b[2] ^ c[2];\nassign s[3] = a[3] ^ b[3] ^ c[3];\n\nassign sum = s;\nassign cout = (a & b) | (c & (a ^ b));\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] c;\nwire"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire c1, c2, c3;\n    wire [15:0] sum_tmp;\n\n    // Instantiate 8-bit adder\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .sum(sum_tmp[7:0]),\n        .Co(c1)\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c1),\n        .sum(sum_tmp[15:8]),\n        .Co(c2)\n    );\n\n    assign y = sum_tmp;\n    assign Co = c2;\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] sum,\n    output wire Co\n);\n    wire [7:0] sum_tmp;\n    wire c;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(Cin), .sum(sum_tmp[0]), .Co(c));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(c), .sum(sum_tmp[1]), .Co(c));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(c), .sum(sum_tmp[2]), .Co(c));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(c), .sum(sum_tmp[3]), .Co(c));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(c), .sum(sum_tmp[4]), .Co(c));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(c), .sum(sum_tmp[5]), .Co(c));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(c), .sum(sum_tmp[6]), .Co(c));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(c), .sum(sum_tmp[7]), .Co(Co));\n\n    assign sum = sum_tmp;\n\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire sum,\n    output wire Co\n);\n    assign {Co, sum} = a + b + Cin;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] carry;\n    adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(carry[7]));\n    \n    assign cout = carry[7];\nendmodule\n\nmodule adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nwire [3:0] ctrl_shift;\nwire ctrl_start;\nwire ctrl_done;\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ctrl_shift(ctrl_shift),\n    .ctrl_start(ctrl_start),\n    .ctrl_done(ctrl_done)\n);\n\n// Register Unit\nreg [15:0] a_reg, b_reg;\nreg [31:0] product;\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .ctrl_start(ctrl_start),\n    .ctrl_shift(ctrl_shift),\n    .ain(ain),\n    .bin(bin),\n    .a_reg(a_reg),\n    .b_reg(b_reg),\n    .product(product)\n);\n\n// Multiplier Unit\nwire [15:0] shifted_b;\nwire [31:0] acc;\nwire [31:0] sum;\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .a_reg(a_reg),\n    .b_reg(b_reg),\n    .shifted_b(shifted_b),\n    .acc(acc),\n    .sum(sum)\n);\n\nassign yout = product;\nassign done = ctrl_done;\n\n// Internal wires\nassign shifted_b = b_reg << ctrl_shift;\nassign acc = product + sum;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output [3:0] ctrl_shift, // Shift count register.\n    output ctrl_start,  // Start signal for register and multiplier units.\n    output ctrl_done    // Completion flag.\n);\n\nreg [3:0] ctrl_shift_reg;\nreg ctrl_start_reg;\nreg ctrl_done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl_shift_reg <= 0;\n        ctrl_start_reg <= 0;\n        ctrl_done_reg <= 0;\n    end else begin\n        if (ctrl_done_reg == 1) begin\n            ctrl_shift_reg <= 0;\n        end else if (start) begin\n            ctrl_shift_reg <= ctrl_shift_reg + 1;\n        end\n        ctrl_start_reg <= start;\n        ctrl_done_reg <= (ctrl_shift_reg == 15);\n    end\nend\n\nassign ctrl_shift = ctrl_shift_reg;\nassign ctrl_start = ctrl_start_reg;\nassign ctrl_done = ctrl_done_reg;\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input ctrl_start,   // Start signal for register and multiplier units.\n    input [3:0] ctrl_shift, // Shift count register.\n    input [15:0] ain,    // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,    // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_reg,\n    output reg [15:0] b_reg,\n    output reg [31:0] product\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n        product <= 0;\n    end else if (ctrl_start) begin\n        a_reg <= ain;\n        b_reg <= bin;\n        product <= 0;\n    end else if (ctrl_shift != 0) begin\n        product <= product; // Keep the same value\n   "}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            if (up_down) begin\n                next_count <= current_count + 1;\n            end else begin\n                next_count <= current_count - 1;\n            end\n        end\n    end\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] current_state;\n\n    initial_state init (\n        .reset(reset),\n        .out(current_state)\n    );\n\n    transition transition (\n        .clk(clk),\n        .current_state(current_state),\n        .next_state(out)\n    );\n\nendmodule\n\nmodule initial_state (\n    input reset,\n    output reg [7:0] out\n);\n    initial begin\n        out = 8'b0000_0001;\n    end\nendmodule\n\nmodule transition (\n    input clk,\n    input [7:0] current_state,\n    output reg [7:0] next_state\n);\n    always @(posedge clk) begin\n        next_state <= (current_state == 8'b1111_1111) ? 8'b0000_0001 : current_state + 1;\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count_value;\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instantiate output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_value <= 4'b0000;\n        else if (valid_count) begin\n            if (count_value == 4'd11)\n                count_value <= 4'b0000;\n            else\n                count_value <= count_value + 1;\n        end\n    end\n\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count_value;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_state;\n\n    // Instantiate the register\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\n    // Instantiate the logic\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q,\n    input [63:0]         next_state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= next_state;\n    end\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            next_state <= 64'b0;\n        else\n            next_state <= {~Q[0], Q[63:1]};\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_en, clk_10_en, clk_1_en;\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (cnt == 1) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (cnt == 4) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (cnt == 49) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4, clk_3;\n    wire clk_avg_1, clk_avg_2;\n\n    // Counter submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_4)\n    );\n\n    // Clock average generator submodule\n    clk_average u_clk_average (\n        .clk(clk_4),\n        .clk_avg(clk_avg_1)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk_in(clk_4),\n        .clk_avg(clk_avg_2),\n        .clk_out(clk_3)\n    );\n\n    // Intermediate clock signals\n    assign clk_div = clk_3 | clk_avg_2;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg clk_out\n);\n    reg [1:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_out <= 0;\n        end else if (cnt == 3) begin\n            cnt <= 0;\n            clk_out <= ~clk_out;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk_in,\n    output reg clk_avg\n);\n    reg [1:0] cnt;\n    always @(posedge clk_in) begin\n        cnt <= cnt + 1;\n        clk_avg <= cnt[1];\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk_in,\n    input clk_avg,\n    output clk_out\n);\n    assign clk_out = clk_in ^ clk_avg;\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    localparam NUM_DIV = 5;\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam DIV_VAL = NUM_DIV - 1;\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            clk_div <= 1'b0;\n            counter <= 0;\n        end else begin\n            if(counter < DIV_VAL) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n            end\n            clk_div <= counter == (DIV_VAL - 1);\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam DIV_VAL = NUM_DIV - 1;\n    reg [3:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            clk_div <= 1'b0;\n            counter <= 0;\n        end else begin\n            if(counter < DIV_VAL) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n            end\n            clk_div <= counter == (DIV_VAL - 1);\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    localparam NUM_DIV = 4;\n    reg [3:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == NUM_DIV/2-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n\n    assign clk_div = cnt == 0;\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == NUM_DIV/2-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (cnt == NUM_DIV/2-1)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, sll_out, srl_out, sra_out;\n    wire slt_out, sltu_out;\n    wire [31:0] lui_out;\n\n    add add_inst(.a(a), .b(b), .r(add_out));\n    add addu addu_inst(.a(a), .b(b), .r(sub_out));\n    sub sub_inst(.a(a), .b(b), .r(sub_out));\n    and and_inst(.a(a), .b(b), .r(and_out));\n    or or_inst(.a(a), .b(b), .r(or_out));\n    xor xor_inst(.a(a), .b(b), .r(xor_out));\n    nor nor_inst(.a(a), .b(b), .r(nor_out));\n    sll sll_inst(.a(a), .b(b[4:0]), .r(sll_out));\n    srl srl_inst(.a(a), .b(b[4:0]), .r(srl_out));\n    sra sra_inst(.a(a), .b(b[4:0]), .r(sra_out));\n    slt slt_inst(.a(a), .b(b), .r(slt_out));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_out));\n    lui lui_inst(.a(a), .b(b[31:12]), .r(lui_out));\n\n    assign r = (aluc == 6'b100000) ? add_out :\n               (aluc == 6'b100001) ? add_out :\n               (aluc == 6'b100010) ? sub_out :\n               (aluc == 6'b100011) ? sub_out :\n               (aluc == 6'b100100) ? and_out :\n               (aluc == 6'b100101) ? or_out :\n               (aluc == 6'b100110) ? xor_out :\n               (aluc == 6'b100111) ? nor_out :\n               (aluc == 6'b101010) ? slt_out :\n               (aluc == 6'b101011) ? sltu_out :\n               (aluc == 6'b000000) ? sll_out :\n               (aluc == 6'b000010) ? srl_out :\n               (aluc == 6'b000011) ? sra_out :\n               (aluc == 6'b000100) ? sll_out :\n               (aluc == 6'b000110) ? srl_out :\n               (aluc == 6'b000111) ? sra_out :\n               (aluc == 6'b001111) ? lui_out :\n               32'bz;\n\n    assign zero = (r == 32'b0);\n    assign carry = (add_out[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (aluc == 6'b101010) ? (a[31] & b[31] & ~r[31]) : (aluc == 6'b101011) ? (a[31] ^ b[31] ^ r[31]) : 0;\n    assign flag = (aluc == 6'b101010) ? slt_out : (aluc == 6'b101011) ? sltu_out : 0;\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [63:0] product;\nwire [31:0] current_value;\n\n// Instantiating the multiplier\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .product(product)\n);\n\n// Instantiating the accumulator\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .product(product[31:0]),\n    .current_value(current_value)\n);\n\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] product,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product;\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] opcode;\n    wire [4:0] reg_addr;\n    wire [7:0] data_out;\n\n    // Submodule for register\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .opcode(opcode),\n        .reg_addr(reg_addr)\n    );\n\n    // Submodule for RAM/ROM\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .opcode(opcode),\n        .reg_addr(reg_addr)\n    );\n\n    // Output\n    assign ins = opcode;\n    assign ad1 = reg_addr;\n    assign ad2 = data_out;\n\nendmodule\n\n// Instruction register submodule\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] opcode,\n    output reg [4:0] reg_addr\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            opcode <= 3'b0;\n            reg_addr <= 5'b0;\n        end else if (fetch) begin\n            opcode <= data[7:5];\n            reg_addr <= data[4:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state_reg, state_next;\n    reg [4:0] wave_reg, wave_next;\n\n    // State control logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state_reg <= 2'b00;\n        else\n            state_reg <= state_next;\n    end\n\n    always @(*) begin\n        case (state_reg)\n            2'b00: state_next = 2'b01;\n            2'b01: state_next = 2'b10;\n            2'b10: state_next = 2'b00;\n            default: state_next = 2'b00;\n        endcase\n    end\n\n    // Waveform generation logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_reg <= 5'b00000;\n        else\n            wave_reg <= wave_next;\n    end\n\n    always @(*) begin\n        case (state_reg)\n            2'b00: wave_next = wave_reg + 1;\n            2'b01: wave_next = wave_reg - 1;\n            default: wave_next = wave_reg;\n        endcase\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [4:0] wave_in,\n    output reg [4:0] wave_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_out <= 5'b00000;\n        else\n            wave_out <= wave_in;\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q0;\n            2'b01: q <= q1;\n            2'b10: q <= q2;\n            2'b11: q <= d;\n            default: q <= d;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule four_to_one_mux (\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [1:0] sel,\n    output [7:0] q\n);\n    always @(*) begin\n        case (sel)\n            2'b00: q = d0;\n            2'b01: q = d1;\n            2'b10: q = d2;\n            2'b11: q = d3;\n            default: q = d3;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] s1, s2, s3, s4, s5, s6, s7, s8;\n\n    mux2X1 ins_17 (in, s8, ctrl[2], s7);\n    mux2X1 ins_16 (s7, s8, ctrl[1], s6);\n    mux2X1 ins_15 (s6, s8, ctrl[1], s5);\n    mux2X1 ins_14 (s5, s8, ctrl[1], s4);\n    mux2X1 ins_13 (s4, s8, ctrl[1], s3);\n    mux2X1 ins_12 (s3, s8, ctrl[1], s2);\n    mux2X1 ins_11 (s2, s8, ctrl[1], s1);\n    mux2X1 ins_10 (s1, s8, ctrl[1], out);\n\n    mux2X1 ins_27 (in, s1, ctrl[2], out);\n    mux2X1 ins_26 (s1, s1, ctrl[1], s2);\n    mux2X1 ins_25 (s2, s2, ctrl[1], s3);\n    mux2X1 ins_24 (s3, s2, ctrl[1], s4);\n    mux2X1 ins_23 (s4, s2, ctrl[1], s5);\n    mux2X1 ins_22 (s5, s2, ctrl[1], s6);\n    mux2X1 ins_21 (s6, s2, ctrl[1], s7);\n    mux2X1 ins_20 (s7, s2, ctrl[1], s8);\n\n    mux2X1 ins_07 (in, s8, ctrl[2], s7);\n    mux2X1 ins_06 (s7, s8, ctrl[1], s6);\n    mux2X1 ins_05 (s6, s8, ctrl[1], s5);\n    mux2X1 ins_04 (s5, s8, ctrl[1], s4);\n    mux2X1 ins_03 (s4, s8, ctrl[1], s3);\n    mux2X1 ins_02 (s3, s8, ctrl[1], s2);\n    mux2X1 ins_01 (s2, s8, ctrl[1], s1);\n    mux2X1 ins_00 (s1, s8, ctrl[1], out);\nendmodule\n\nmodule mux2X1 (a, b, sel, m);\n    input a, b, sel;\n    output m;\n    assign m = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  assign b1 = (rst) ? 16'd0 : b0;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) c <= 32'd0;\n    else c <= c + (a * b);\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  wire [31:0] next_pc;\n  \n  stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(next_pc)\n  );\n  \n  stage decode (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage execute (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage memory (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage writeback (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  assign res_reg_file = alu_out;\nendmodule\n\nmodule stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc,\n  output reg [31:0] alu_in\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      pc <= 32'h0000_0000;\n      alu_in <= 32'h0000_0000;\n    end\n    else begin\n      alu_in <= instr_mem[pc];\n      pc <= pc + 4;\n    end\n  end\nendmodule\n\nmodule stagepipe5 (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_out;\n  wire [31:0] next_pc;\n  \n  stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(next_pc)\n  );\n  \n  stage decode (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage execute (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage memory (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  stage writeback (\n    .clk(clk),\n    .instr_mem(instr_mem),\n    .alu_in(alu_out)\n  );\n  \n  assign res_reg_file = alu_out;\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  wire [31:0] p0, p1, p2, p3;\n  wire [31:0] d0, d1, d2, d3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] p0_reg, p1_reg, p2_reg, p3_reg;\n  reg [31:0] d0_reg, d1_reg, d2_reg, d3_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      p0_reg <= 0;\n      p1_reg <= 0;\n      p2_reg <= 0;\n      p3_reg <= 0;\n      d0_reg <= 0;\n      d1_reg <= 0;\n      d2_reg <= 0;\n      d3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      p0_reg <= p0;\n      p1_reg <= p1;\n      p2_reg <= p2;\n      p3_reg <= p3;\n      d0_reg <= d0;\n      d1_reg <= d1;\n      d2_reg <= d2;\n      d3_reg <= d3;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  assign p0 = a0*b0;\n  assign p1 = a1*b1;\n  assign p2 = a2*b2;\n  assign p3 = a3*b3;\n\n  assign d0 = p0;\n  assign d1 = p1 + p0_reg;\n  assign d2 = p2 + p1_reg;\n  assign d3 = p3 + p2_reg;\n\n  assign c0 = d0;\n  assign c1 = d1;\n  assign c2 = d2;\n  assign c3 = d3;\n\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 0;\n    end else begin\n      c_reg <= a*b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    \n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .fetched_instr(fetched_instr)\n    );\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .out_reg_file(out_reg_file)\n    );\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetched_instr\n);\n    reg [31:0] pc = 32'd0;\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            pc <= 0;\n        else begin\n            fetched_instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end\n        else begin\n            op1 <= fetched_instr[7:0] == 1'b0 ? fetched_instr[31:25] : fetched_instr[31:25];\n            op2 <= fetched_instr[7:0] == 1'b0 ? fetched_instr[15:7] : fetched_instr[24:18];\n            result <= op1 + op2;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] count;\n    wire [9:0] accum;\n\n    // Counter\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data Accumulator\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .accum(accum)\n    );\n\n    // Valid Output\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_in(valid_in),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output reg  [9:0]   accum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accum <= 0;\n        end else if (valid_in) begin\n            accum <= accum + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   count,\n    input               valid_in,\n    input               valid_in_d1,\n\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    reg [1:0] count_d1;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_d1 <= 0;\n            valid_out <= 0;\n            data_out <= 0;\n        end else begin\n            count_d1 <= count;\n            valid_out <= (count_d1 == 2 && valid_in_d1) || (count_d1 == 3 && valid_in);\n            data_out <= accum;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [15:0] abs_dividend, abs_divisor, neg_divisor;\n    wire [7:0] quotient, remainder;\n    wire done;\n\n    abs_value abs_dividend_inst(\n        .dividend(dividend),\n        .sign(sign),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_inst(\n        .divisor(divisor),\n        .sign(sign),\n        .result(neg_divisor)\n    );\n\n    divider_control ctrl_inst(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .done(done)\n    );\n\n    result_management res_mgmt_inst(\n        .clk(clk),\n        .rst(rst),\n        .done(done),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\n    assign remainder = abs_dividend % abs_divisor;\n    assign quotient = abs_dividend / abs_divisor;\n    assign result = {remainder, quotient};\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,    \n    input wire sign,       \n    output reg [15:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = -dividend;\n        else\n            result = dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire [7:0] divisor,    \n    input wire sign,       \n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign)\n            result = divisor;\n        else\n            result = -divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,   \n    input wire res_ready,   \n    output reg res_valid,   \n    output reg done\n);\n    reg [3:0] counter;\n    reg [15:0] shift_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            done <= 0;\n            res_valid <= 0;\n        end else begin\n            if (opn_valid && !res_valid && !done) begin\n                shift_reg <= shift_reg >> 1;\n                counter <= counter + 1;\n            end else if (counter == 15 && !res_ready) begin\n                done <= 1;\n                res_valid <= 0;\n            end else if (!res_ready) begin\n                res_valid <= 1;\n                done <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire done,   \n    input wire res_valid,   \n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else if (done) begin\n            result <= 0;\n            res_valid <= 0;\n        end else if (res_valid) begin\n            result <= result;\n        end else begin\n            result <= 0;\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [35:0] D, Q;\n    wire [31:0] rem;\n\n    prep_dividend prep(\n        .in(A),\n        .out(D)\n    );\n\n    div_operation div_op(\n        .dividend(D[35:16]),\n        .divisor(B),\n        .quotient(Q),\n        .remainder(rem)\n    );\n\n    assign result = Q;\n    assign odd = rem;\n\nendmodule\n\n// Submodule: prep_dividend\nmodule prep_dividend(\n    input wire [31:0] in,\n    output reg [35:0] out\n);\n\n    always @(*) begin\n        out = {1'b1, in}; // Prepend a 1 to indicate positive\n    end\n\nendmodule\n\n// Submodule: div_operation\nmodule div_operation(\n    input wire [15:0] dividend,\n    input wire [15:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [15:0] shift;\n    reg [15:0] shifted_dividend;\n\n    always @(*) begin\n        shift = 16'd1 << (dividend[15:0] - divisor[15:0]);\n        shifted_dividend = dividend >> shift;\n        quotient = shifted_dividend - divisor;\n        remainder = dividend & (~(1 << (shift - 1)));\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] dividend;\n    wire [7:0] divisor;\n    wire [4:0] quotient;\n    wire [4:0] remainder;\n\n    // Instantiate control unit\n    div_control ctrl (.A(A), .B(B), .dividend(dividend), .divisor(divisor), .quotient(quotient), .remainder(remainder));\n\n    // Connect ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Control unit submodule\nmodule div_control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] dividend,\n    output reg [7:0] divisor,\n    output reg [4:0] quotient,\n    output reg [4:0] remainder\n);\n\n    // Initialize dividend and divisor\n    initial begin\n        dividend = A;\n        divisor = B;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    // Divide loop\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        while (remainder[7:0] >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum, carry;\n\n    assign B_comp = ~B + 1;\n\n    adder_8bit adder_inst(.A(A), .B(B_comp), .Cin(1'b0), .Sum(sum), .Cout(carry));\n\n    assign D = sum;\n    assign B_out = carry[7];\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\n    input [7:0] A, B;\n    input Cin;\n    output [7:0] Sum;\n    output Cout;\n\n    wire [6:0] carry;\n\n    full_adder FA0 (.A(A[0]), .B(B[0]), .Cin(Cin), .Sum(Sum[0]), .Cout(carry[0]));\n    full_adder FA1 (.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(Sum[1]), .Cout(carry[1]));\n    full_adder FA2 (.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(Sum[2]), .Cout(carry[2]));\n    full_adder FA3 (.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(Sum[3]), .Cout(carry[3]));\n    full_adder FA4 (.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(Sum[4]), .Cout(carry[4]));\n    full_adder FA5 (.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(Sum[5]), .Cout(carry[5]));\n    full_adder FA6 (.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(Sum[6]), .Cout(carry[6]));\n    full_adder FA7 (.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(Sum[7]), .Cout(Cout));\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1, S2;\n\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1),\n    .B_out(B_out)\n);\n\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2),\n    .B_out()\n);\n\nassign Diff[15:0] = S1;\nassign Diff[31:16] = S2;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A;\ninput [15:0] B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [15:0] A_neg, B_neg;\nwire [15:0] D1, D2;\nwire B_neg_out, B_out;\n\nassign A_neg = ~A + 1;\nassign B_neg = ~B + 1;\n\nsub_16bit D1_inst(\n    .A(A_neg),\n    .B(B),\n    .Diff(D1),\n    .B_out(B_neg_out)\n);\n\nsub_16bit D2_inst(\n    .A(A),\n    .B(B_neg),\n    .Diff(D2),\n    .B_out()\n);\n\nassign Diff = D1 + D2 + B_neg_out;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] B_sub, borrow1, borrow2;\nwire [31:0] D0, D1;\nwire B_out_sub0, B_out_sub1;\n\nsub16 sub0(.A(A[31:0]), .B(B[31:0]), .B_sub(B_sub[31:0]), .borrow_in(1'b0), .D(D0), .borrow_out(borrow1));\nsub16 sub1(.A(A[63:32]), .B(B[63:32]), .B_sub(B_sub[63:32]), .borrow_in(borrow1), .D(D1), .borrow_out(B_out_sub1));\nassign D = {D1, D0};\nassign B_out = B_out_sub1;\n\nendmodule\n\nmodule sub16(A, B, B_sub, borrow_in, D, borrow_out);\ninput [15:0] A, B;\ninput [15:0] B_sub;\ninput borrow_in;\noutput [15:0] D;\noutput borrow_out;\n\nwire [15:0] borrow;\nwire [15:0] D_sub;\n\nsub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_sub(B_sub[7:0]), .borrow_in(borrow_in), .D(D_sub[7:0]), .borrow_out(borrow[0]));\nsub8 sub1(.A(A[15:8]), .B(B[15:8]), .B_sub(B_sub[15:8]), .borrow_in(borrow[0]), .D(D_sub[15:8]), .borrow_out(borrow[1]));\nassign D = D_sub;\nassign borrow_out = borrow[1];\n\nendmodule\n\nmodule sub8(A, B, B_sub, borrow_in, D, borrow_out);\ninput [7:0] A, B;\ninput [7:0] B_sub;\ninput borrow_in;\noutput [7:0] D;\noutput borrow_out;\n\nwire [7:0] borrow;\n\nsub4 sub0(.A(A[3:0]), .B(B[3:0]), .B_sub(B_sub[3:0]), .borrow_in(borrow_in), .D(D[3:0]), .borrow_out(borrow[0]));\nsub4 sub1(.A(A[7:4]), .B(B[7:4]), .B_sub(B_sub[7:4]), .borrow_in(borrow[0]), .D(D[7:4]), .borrow_out(borrow[1]));\nassign D = D;\nassign borrow_out = borrow[1];\n\nendmodule\n\nmodule sub4(A, B, B_sub, borrow_in, D, borrow_out);\ninput [3:0] A, B;\ninput [3:0] B_sub;\ninput borrow_in;\noutput [3:0] D;\noutput borrow_out;\n\nwire [3:0] borrow;\n\nsub2 sub0(.A(A[1:0]), .B(B[1:0]), .B_sub(B_sub[1:0]), .borrow_in(borrow_in), .D(D[1:0]), .borrow_out(borrow[0]));\nsub2 sub1(.A(A[3:2]), .B(B[3:2]), .B_sub(B_sub[3:2]), .borrow_in(borrow[0]), .D(D[3:2]), .borrow_out(borrow[1]));\nassign D = D;\nassign borrow_out = borrow[1];\n\nendmodule\n\nmodule sub2(A, B, B_sub, borrow_in, D, borrow_out);\ninput [1:0] A, B;\ninput [1:0] B_sub;\ninput borrow_"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow_out;\n\nsub4 sub1 (\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_out(borrow_out[0]),\n    .D(D[3:0])\n);\n\nsub4 sub2 (\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .B_out(borrow_out[1]),\n    .D(D[7:4])\n);\n\nsub4 sub3 (\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .B_out(borrow_out[2]),\n    .D(D[11:8])\n);\n\nsub4 sub4 (\n    .A(A[15:12]),\n    .B(B[15:12]),\n    .B_out(borrow_out[3]),\n    .D(D[15:12])\n);\n\nassign B_out = borrow_out[3];\n\nendmodule\n\nmodule sub4(A, B, B_out, D);\ninput [3:0] A, B;\noutput B_out, D;\n\nwire [3:0] B_in;\nwire borrow_out;\n\nassign B_in = {B, B_out};\n\nfull_subtractor_4bit fs0 (.A(A), .B(B_in), .B_in(borrow_out), .D(D));\n\nassign B_out = borrow_out;\n\nendmodule\n\nmodule full_subtractor_4bit(A, B, B_in, D);\ninput [3:0] A, B;\ninput B_in;\noutput D, B_out;\n\nwire [3:0] B_in_reg;\nwire borrow_out;\n\nassign B_in_reg = {B_in, 1'b0};\n\nfull_subtractor_1bit fs0 (.A(A[0]), .B(B_in_reg[0]), .B_in(borrow_out), .D(D[0]));\nfull_subtractor_1bit fs1 (.A(A[1]), .B(B_in_reg[1]), .B_in(borrow_out), .D(D[1]));\nfull_subtractor_1bit fs2 (.A(A[2]), .B(B_in_reg[2]), .B_in(borrow_out), .D(D[2]));\nfull_subtractor_1bit fs3 (.A(A[3]), .B(B_in_reg[3]), .B_in(borrow_out), .D(D[3]));\n\nassign B_out = borrow_out;\n\nendmodule\n\nmodule full_subtractor_1bit(A, B, B_in, D);\ninput A, B, B_in;\noutput D, B_out;\n\nassign D = A ^ B ^ B_in;\nassign B_out = (~A & B) | (A & ~B);\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] diff; // Difference between A and B\n    wire borrow;      // Borrow flag for subtraction\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff == 32'b0 && !borrow);\n    assign A_equal = (diff == 32'b0 && borrow);\n    assign A_less = (!A_greater && !A_equal);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n\n    wire [32:0] temp;\n\n    assign {borrow, diff} = A - B; // Subtraction\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\n\nwire [31:0] c16_0, c16_1, c16_2, c16_3;\nwire [31:0] s16_0, s16_1, s16_2, s16_3;\n\ncla CLA1 (.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .S(s16_0), .Cout(c16_0));\ncla CLA2 (.A(A[31:16]), .B(B[31:16]), .Cin(c16_0), .S(s16_1), .Cout(c16_1));\ncla CLA3 (.A(A[31:16]), .B(B[31:16]), .Cin(c16_1), .S(s16_2), .Cout(c16_2));\ncla CLA4 (.A(A[31:16]), .B(B[31:16]), .Cin(c16_2), .S(s16_3), .Cout(c16_3));\n\nassign S = {s16_3[15:0], s16_2[15:0], s16_1[15:0], s16_0[15:0]};\nassign C32 = c16_3;\n\nendmodule\n\nmodule cla(A,B,Cin,S,Cout);\ninput [15:0] A;\ninput [15:0] B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [16:0] c;\nassign c[0] = Cin;\nassign c[1] = A[0]&B[0] | A[0]&c[0] | B[0]&c[0];\nassign c[2] = A[1]&B[1] | A[1]&c[1] | B[1]&c[1];\nassign c[3] = A[2]&B[2] | A[2]&c[2] | B[2]&c[2];\nassign c[4] = A[3]&B[3] | A[3]&c[3] | B[3]&c[3];\nassign c[5] = A[4]&B[4] | A[4]&c[4] | B[4]&c[4];\nassign c[6] = A[5]&B[5] | A[5]&c[5] | B[5]&c[5];\nassign c[7] = A[6]&B[6] | A[6]&c[6] | B[6]&c[6];\nassign c[8] = A[7]&B[7] | A[7]&c[7] | B[7]&c[7];\nassign c[9] = A[8]&B[8] | A[8]&c[8] | B[8]&c[8];\nassign c[10] = A[9]&B[9] | A[9]&c[9] | B[9]&c[9];\nassign c[11] = A[10]&B[10] | A[10]&c[10] | B[10]&c[10];\nassign c[12] = A[11]&B[11] | A[11]&c[11] | B[11]&c[11];\nassign c[13] = A[12]&B[12] | A[12]&c[12] | B[12]&c[12];\nassign c[14] = A[13]&B[13] | A[13]&c[13] | B[13]&c[13];\nassign c[15] = A[14]&B[14] | A[14]"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // 4-bit ripple carry adder for initial 4 bits\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    // 4-bit carry select adder for subsequent 4 bits\n    carry_select_adder_4bit csa_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    carry_select_adder_4bit csa_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    carry_select_adder_4bit csa_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(cout));\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] c;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder_4bit rca2(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(c)\n    );\n\n    // 4-bit carry select adder\n    carry_select_adder_4bit csa_slice4(\n        .a(a),\n        .b(b),\n        .cin(c),\n        .sum(sum),\n        .cout(cout)\n    );\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input [3:0] cin;\n    output [3:0] sum;\n    output [3:0] cout;\n    wire [3:0] s, c;\n\n    assign s[0] = a[0] ^ b[0] ^ cin[0];\n    assign c[0] = (a[0] & b[0]) | (b[0] &"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] C;\n\n    // Instantiate 8-bit adder for each 8 bits.\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(C[0])\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(C[0]),\n        .y(y[15:8]),\n        .Co(C[1])\n    );\n\n    assign Co = C[1];\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] c;\n\n    // 1-bit adder\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(Cin), .y(y[0]), .Co(c[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(c[0]), .y(y[1]), .Co(c[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(c[1]), .y(y[2]), .Co(c[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(c[2]), .y(y[3]), .Co(c[3]));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(c[3]), .y(y[4]), .Co(c[4]));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(c[4]), .y(y[5]), .Co(c[5]));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(c[5]), .y(y[6]), .Co(c[6]));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(c[6]), .y(y[7]), .Co(Co));\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (b & Cin) | (a & Cin);\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [2:0] carry;\n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Wires and registers\nreg [15:0] a, b;\nreg [31:0] p;\nreg [4:0] cnt;\nwire [4:0] next_cnt;\n\n// Control Unit\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .cnt(cnt),\n    .next_cnt(next_cnt)\n);\n\n// Register Unit\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .a(a),\n    .b(b)\n);\n\n// Multiplier Unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .a(a),\n    .b(b),\n    .p(p)\n);\n\n// Output assignment\nassign yout = p;\nassign done = (cnt == 15);\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] cnt,    // Shift count register.\n    output [4:0] next_cnt // Next count output.\n);\n\nreg [4:0] cnt_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 0;\n    else if (start)\n        cnt_reg <= 15;\n    else\n        cnt_reg <= cnt + 1;\nend\n\nassign next_cnt = cnt_reg;\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand).\n    input [15:0] b     // Input b (multiplier).\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset registers\n        a <= 0;\n        b <= 0;\n    end else if (start) begin\n        // Load input values\n        a <= a;\n        b <= b;\n    end\nend\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] a,     // Input a (multiplicand).\n    input [15:0] b,     // Input b (multiplier).\n    output reg [31:0] p // Product output.\n);\n\nreg [31:0] p_reg;\n\nalways @(posedge clk) begin\n    p_reg <= p_reg + (b << cnt);\nend\n\nalways @(posedge clk) begin\n    if (a[0] == 1)\n        p_reg <= p_reg + (b << cnt);\nend\n\nalways @(posedge clk) begin\n    p <= p_reg;\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 16'b0;\n        end else begin\n            next_count <= (up_down) ? (count + 1) : (count - 1);\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // Submodule for initializing state\n    ring_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(next_state)\n    );\n\n    // Submodule for state transition\n    ring_transition transition (\n        .clk(clk),\n        .init_state(next_state),\n        .out(out)\n    );\n\nendmodule\n\nmodule ring_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule ring_transition (\n    input wire clk,\n    input wire [7:0] init_state,\n    output reg [7:0] out\n);\n\n    always @ (posedge clk) begin\n        out <= (init_state == 8'b1111_1110) ? 8'b0000_0001 : init_state << 1;\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .current_value(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] current_value,\n    output reg [3:0] out\n);\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= current_value;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instance of the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\n    // Instance of the logic module\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q,\n    input [63:0]         next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 0;\n        end else begin\n            Q <= next_Q;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] Q,\n    output reg [63:0] next_Q\n);\n\n    always @(*) begin\n        next_Q = (Q & (Q - 1)) + 1;\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_50_out),\n        .RST(RST)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_10_out),\n        .RST(RST)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_1_out),\n        .RST(RST)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    output reg CLK_out,\n    input RST\n);\n    reg [1:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 1)\n            count <= 0;\n        else\n            count <= count + 1;\n        CLK_out <= count == 1;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    output reg CLK_out,\n    input RST\n);\n    reg [3:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 4)\n            count <= 0;\n        else\n            count <= count + 1;\n        CLK_out <= count == 4;\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    output reg CLK_out,\n    input RST\n);\n    reg [5:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 49)\n            count <= 0;\n        else\n            count <= count + 1;\n        CLK_out <= count == 49;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4cycles;\n    wire clk_3cycles;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_4cycles)\n    );\n\n    clk_average u_clk_average (\n        .clk_in(clk_4cycles),\n        .clk_out(clk_3cycles)\n    );\n\n    clk_adjustment u_clk_adjustment (\n        .clk_in(clk),\n        .clk_out(clk_div)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg          clk_out\n);\n\n    localparam COUNT_LIMIT = 4;\n\n    reg [3:0] counter_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_r <= 0;\n            clk_out <= 0;\n        end else if (counter_r < COUNT_LIMIT) begin\n            counter_r <= counter_r + 1;\n        end else begin\n            counter_r <= 0;\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\nmodule clk_average (\n    input               clk_in,\n    output reg          clk_out\n);\n\n    reg [1:0] clk_count;\n\n    always @(posedge clk_in) begin\n        clk_count <= clk_count + 1;\n        if (clk_count == 2) begin\n            clk_out <= ~clk_out;\n            clk_count <= 0;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment (\n    input               clk_in,\n    output reg          clk_out\n);\n\n    reg [1:0] clk_count;\n    reg clk_phase;\n\n    always @(negedge clk_in) begin\n        clk_phase <= ~clk_phase;\n    end\n\n    always @(posedge clk_in) begin\n        if (clk_phase) begin\n            clk_out <= clk_in;\n        end else begin\n            clk_out <= clk_in;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    // Count the number of rising edges\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Count the number of falling edges\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [$clog2(NUM_DIV)-1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end\n        else if (count == NUM_DIV - 1) begin\n            clk_div <= 1'b1;\n            count <= 0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [$clog2(NUM_DIV)-1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end\n        else if (count == NUM_DIV - 1) begin\n            clk_div <= 1'b1;\n            count <= 0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    localparam NUM_DIV = 8;\n\n    reg [3:0] cnt;\n    wire clk_div_en;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt),\n        .cnt_limit(NUM_DIV / 2 - 1)\n    );\n\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_out,\n    input [3:0] cnt_limit\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (cnt_out >= cnt_limit) begin\n            cnt_out <= 0;\n        end else begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div_en,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_en <= 0;\n            clk_div <= 0;\n        end else begin\n            clk_div_en <= 1;\n            clk_div <= ~clk_div;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, addu_out, sub_out, and_out, or_out, xor_out, nor_out, slt_out, sltu_out;\n    wire [31:0] sll_out, srl_out, sra_out;\n    wire [31:0] sllv_out, srlv_out, srav_out;\n    wire [31:0] lui_out;\n\n    add add_inst(.a(a), .b(b), .r(add_out));\n    addu addu_inst(.a(a), .b(b), .r(addu_out));\n    sub sub_inst(.a(a), .b(b), .r(sub_out));\n    and and_inst(.a(a), .b(b), .r(and_out));\n    or or_inst(.a(a), .b(b), .r(or_out));\n    xor xor_inst(.a(a), .b(b), .r(xor_out));\n    nor nor_inst(.a(a), .b(b), .r(nor_out));\n    slt slt_inst(.a(a), .b(b), .r(slt_out));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_out));\n    sll sll_inst(.a(a), .b(b), .r(sll_out));\n    srl srl_inst(.a(a), .b(b), .r(srl_out));\n    sra sra_inst(.a(a), .b(b), .r(sra_out));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_out));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_out));\n    srav srav_inst(.a(a), .b(b), .r(srav_out));\n    lui lui_inst(.a(a), .r(lui_out));\n\n    assign r = aluc[5] ? lui_out : aluc[4] ? srav_out : aluc[3] ? sllv_out : aluc[2] ? srlv_out : aluc[1] ? sll_out : aluc[0] ? srl_out : aluc[4] ? sltu_out : aluc[3] ? sra_out : aluc[2] ? srl_out : aluc[1] ? sll_out : aluc[0] ? slt_out : aluc[4] ? sltu_out : aluc[3] ? nor_out : aluc[2] ? or_out : aluc[1] ? xor_out : aluc[0] ? and_out : aluc[4] ? nor_out : aluc[3] ? or_out : aluc[2] ? xor_out : aluc[1] ? addu_out : aluc[0] ? add_out : addu_out;\n    assign zero = r == 32'b0;\n    assign carry = r[31];\n    assign negative = r[31];\n    assign overflow = aluc[4] ? (r[31] ^ r[30]) : r[31];\n    assign flag = aluc[4] ? 1'b0 : aluc[3] ? 1'b0 : aluc[2] ? 1'b0 : aluc[1] ? 1'b0 : aluc[0] ? 1'b0 : slt_out;\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nend"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [31:0] m;\n    wire [31:0] acc_input;\n\n    // Instantiate the multiplier\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .m(m)\n    );\n\n    // Instantiate the accumulator\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .acc_input(m),\n        .acc_output(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] m\n);\n    assign m = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] acc_input,\n    output reg [31:0] acc_output\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            acc_output <= 0;\n        end else begin\n            acc_output <= acc_output + acc_input;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins(ins1),\n        .ad(ad11)\n    );\n    assign ad1 = ad11;\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins(ins2),\n        .ad(ad22)\n    );\n    assign ad2 = ad22;\n\n    assign ins = fetch == 2'b01 ? ins1 :\n                 fetch == 2'b10 ? ins2 :\n                 ins1;\n\nendmodule\n\n// Instruction register submodule\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else if (fetch == 2'b01)\n            ins <= data[7:5];\n    end\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ad <= 0;\n        else if (fetch == 2'b01)\n            ad <= data[4:0];\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n    wire [7:0] enable = freq;\n\n    // Instantiate counter module\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate wave_generator module\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input [7:0] enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            count <= 0;\n        else\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire [1:0] state;\n\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else\n            state <= state + 1;\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'd0;\n        else begin\n            case(state)\n                2'b00: begin\n                    wave <= (wave == 5'd31) ? 5'd0 : wave + 1;\n                end\n                2'b01: begin\n                    wave <= (wave == 5'd0) ? 5'd31 : wave - 1;\n                end\n                default: wave <= wave;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] d_ff[2:0];\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d_ff[0]));\n    my_dff8 u1 (.clk(clk), .d(d_ff[0]), .q(d_ff[1]));\n    my_dff8 u2 (.clk(clk), .d(d_ff[1]), .q(d_ff[2]));\n\n    // Multiplexer to select the output\n    always @(sel or d_ff) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = d_ff[0];\n            2'b10: q = d_ff[1];\n            2'b11: q = d_ff[2];\n            default: q = 8'bx;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    mux2X1 ins_17 (in[7:4], stage1[3:0], stage1[7:4]);\n    mux2X1 ins_16 (in[7:4], stage1[3:0], stage2[7:4]);\n    mux2X1 ins_15 (in[7:4], stage1[3:0], stage3[7:4]);\n    mux2X1 ins_14 (in[7:4], stage1[3:0], stage3[3:0]);\n    mux2X1 ins_13 (stage2[7:4], stage3[7:4], stage3[7:4]);\n    mux2X1 ins_12 (stage2[7:4], stage3[7:4], stage3[3:0]);\n    mux2X1 ins_11 (stage3[7:4], stage3[7:4], stage3[7:4]);\n    mux2X1 ins_10 (stage3[7:4], stage3[7:4], stage3[3:0]);\n    mux2X1 ins_27 (stage3[7:4], in[3:0], out[7:4]);\n    mux2X1 ins_26 (stage3[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_25 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_24 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_23 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_22 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_21 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_20 (stage3[3:0], in[3:0], out[3:0]);\n    mux2X1 ins_07 (in[7:4], in[3:0], out[7:4]);\n    mux2X1 ins_06 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_05 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_04 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_03 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_02 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_01 (in[7:4], in[3:0], out[3:0]);\n    mux2X1 ins_00 (in[7:4], in[3:0], out[3:0]);\n\n    assign stage1 = in << 4;\n    assign stage2 = stage1 >> 4;\n    assign stage3 = stage2 >> ctrl;\nendmodule\n\nmodule mux2X1 (sel, a, b, y);\n    input sel;\n    input a, b;\n    output y;\n\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(p0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(p1)\n  );\n\n  assign c0 = p0;\n  assign c1 = p1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  wire [31:0] ab;\n\n  assign ab = a * b;\n  assign c = ab + ab;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      ab <= 0;\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] op;\n  wire [4:0] rs1, rs2, rd;\n\n  // Fetch stage\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .res_reg_file(res_reg_file), .pc(pc), .next_pc(next_pc), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd));\n\n  // Decode stage\n  decode_stage decode (.clk(clk), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd));\n\n  // Execute stage\n  execute_stage execute (.clk(clk), .rs1(rs1), .rs2(rs2), .alu_res(alu_res));\n\n  // Memory stage\n  memory_stage memory (.clk(clk), .alu_res(alu_res), .memory_res(alu_res));\n\n  // Writeback stage\n  writeback_stage writeback (.clk(clk), .alu_res(alu_res), .res_reg_file(res_reg_file));\n\n  // Pipeline registers\n  reg [31:0] pipeline_reg [4:0];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg[0] <= pc;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n      pipeline_reg[4] <= 0;\n    end else begin\n      pipeline_reg[0] <= next_pc;\n      pipeline_reg[1] <= decode.alu_res;\n      pipeline_reg[2] <= execute.alu_res;\n      pipeline_reg[3] <= memory.memory_res;\n      pipeline_reg[4] <= writeback.alu_res;\n    end\n  end\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc,\n  output [31:0] op,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd\n);\n  reg [31:0] next_instr;\n  wire [31:0] current_pc;\n\n  assign current_pc = pc;\n  assign next_pc = pc + 1;\n  assign op = current_instr[31:26];\n  assign rs1 = current_instr[25:21];\n  assign rs2 = current_instr[20:16];\n  assign rd = current_instr[15:11];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_instr <= 0;\n    end else begin\n      next_instr <= instr_mem[pc];\n    end\n  end\n\n  assign res_reg_file[0] = next_instr;\n  assign res_reg_file[1] = next_instr;\n  assign res_reg_file[2] = next_instr;\n  assign res_reg_file[3] = next_instr;\n  assign res_reg_file[4] = next_instr;\n  assign pc = current_pc;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] op,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd\n);\n  reg [31:0] alu_res;\n\n  always @(posedge clk) begin\n   "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] d1, d2;\n  assign b1 = d1;\n  assign b2 = d2;\n  assign b3 = d2;\n  assign c0 = a0 * b0;\n  assign c1 = a1 * b1;\n  assign c2 = a2 * b2;\n  assign c3 = a3 * b3;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      d1 <= 0;\n      d2 <= 0;\n    end else begin\n      d1 <= b0;\n      d2 <= d1;\n    end\n  end\nendmodule\nmodule pe_simple(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b_reg;\n  reg [15:0] a_reg;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b_reg <= 0;\n      a_reg <= 0;\n    end else begin\n      b_reg <= b;\n      a_reg <= a;\n    end\n  end\n  assign c = a_reg * b_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr_fetched(fetch_out)\n    );\n    execute_stage execute (\n        .clk(clk),\n        .instr_fetched(fetch_out),\n        .reg_file(reg_file),\n        .instr_execute(execute_out)\n    );\n    writeback_stage writeback (\n        .clk(clk),\n        .instr_execute(execute_out),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\n    reg [4:0] pc = 0;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] instr_fetched\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            instr_fetched <= 0;\n        end else begin\n            instr_fetched <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] instr_fetched,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] instr_execute\n);\n    always @(posedge clk) begin\n        instr_execute <= 0;\n        case (instr_fetched[6:0])\n            7'b000000: instr_execute <= reg_file[instr_fetched[9:5]] + reg_file[instr_fetched[14:10]];\n            7'b000001: instr_execute <= reg_file[instr_fetched[9:5]] - reg_file[instr_fetched[14:10]];\n            default: instr_execute <= 0;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] instr_execute,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk) begin\n        out_reg_file <= instr_execute;\n    end\nendmodule\n\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] count;\n    wire       ready;\n    wire [9:0] acc_data;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .ready(ready),\n        .acc_data(acc_data)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .acc_data(acc_data),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    output reg          ready,\n    output reg  [9:0]   acc_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc_data <= 0;\n            ready <= 0;\n        end else if (ready) begin\n            acc_data <= acc_data + data_in;\n        end else if (valid_in) begin\n            acc_data <= data_in;\n            ready <= 1;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   count,\n    input       [9:0]   acc_data,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end else if (count == 4) begin\n            valid_out <= 1;\n            data_out <= acc_data;\n        end else if (ready) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n// Instance of the absolute value calculator\nabs_value abs_dividend(\n    .dividend(dividend),\n    .sign(sign),\n    .result(abs_dividend_out)\n);\n\n// Instance of the negated divisor calculator\nneg_value neg_divisor_mod(\n    .divisor(divisor),\n    .sign(sign),\n    .result(neg_divisor_mod_out)\n);\n\n// Instance of the division control logic\ndivider_control ctrl(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid)\n);\n\n// Instance of the result management logic\nresult_management res_mgmt(\n    .clk(clk),\n    .rst(rst),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input [7:0] dividend,\n    input sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign) begin\n            result = ~dividend + 1;\n        end else begin\n            result = dividend;\n        end\n    end\nendmodule\n\nmodule neg_value(\n    input [7:0] divisor,\n    input sign,\n    output reg [7:0] result\n);\n    always @(*) begin\n        if (sign) begin\n            result = divisor;\n        end else begin\n            result = ~divisor + 1;\n        end\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid\n);\n    reg [2:0] count;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            res_valid <= 0;\n        end else if (opn_valid && !res_valid) begin\n            count <= 1;\n            res_valid <= 1;\n        end else if (res_ready) begin\n            count <= 0;\n            res_valid <= 0;\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_valid,\n    input wire res_ready,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else if (res_ready) begin\n            result <= 0;\n        end else if (res_valid) begin\n            result <= 16'bx;\n        end\n    end\nendmodule\n"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend, divisor, quotient, remainder;\n\n    prep_dividend prep (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n\n    always @(*) begin\n        dividend = {16'b0, A};\n        divisor = B;\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    reg [31:0] temp;\n    reg [4:0] index;\n    reg [15:0] shifted_divisor;\n\n    always @(*) begin\n        shifted_divisor = divisor;\n        quotient = 32'b0;\n        remainder = dividend;\n\n        for (index = 0; index < 32; index = index + 1) begin\n            if (remainder >= shifted_divisor) begin\n                quotient[index] = 1'b1;\n                remainder = remainder - shifted_divisor;\n            end else begin\n                quotient[index] = 1'b0;\n            end\n            shifted_divisor = {shifted_divisor[14:0], 1'b0};\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] quotient;      // 16-bit quotient\n    wire [7:0] remainder;      // 8-bit remainder\n    wire [15:0] temp_quotient; // Temporary quotient\n    wire [15:0] temp_remainder; // Temporary remainder\n\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [7:0] div_remainder;\n    reg [15:0] div_dividend;\n\n    always @(*) begin\n        div_dividend = A;\n        div_remainder = 0;\n        quotient = 0;\n        remainder = 0;\n\n        for (int i = 0; i < 16; i = i + 1) begin\n            div_dividend = div_dividend << 1;\n            div_remainder = (div_remainder << 1) | div_dividend[15];\n            if (div_remainder >= B) begin\n                div_remainder = div_remainder - B;\n                quotient[i] = 1;\n            end else begin\n                quotient[i] = 0;\n            end\n        end\n        remainder = div_remainder;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire carry;\n\nassign B_comp = ~B + 1;\n\nadder_8bit adder_inst(.A(A), .B(B_comp), .Cin(1'b1), .Sum(sum), .Cout(carry));\nassign D = sum;\nassign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\ninput [7:0] A;\ninput [7:0] B;\ninput Cin;\noutput [7:0] Sum;\noutput Cout;\n\nwire [6:0] carry;\n\nfull_adder FA0(.A(A[0]), .B(B[0]), .Cin(Cin), .Sum(Sum[0]), .Cout(carry[0]));\nfull_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(Sum[1]), .Cout(carry[1]));\nfull_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(Sum[2]), .Cout(carry[2]));\nfull_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(Sum[3]), .Cout(carry[3]));\nfull_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(Sum[4]), .Cout(carry[4]));\nfull_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(Sum[5]), .Cout(carry[5]));\nfull_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(Sum[6]), .Cout(carry[6]));\nfull_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(Sum[7]), .Cout(Cout));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\n\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1_out),\n    .B_out(B_out)\n);\n\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2_out),\n    .B_out(/* B_out from S1 */)\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [15:0] A_s, B_s, diff_s;\nwire borrow_s;\n\nassign A_s = {1'b0, A};\nassign B_s = {1'b0, B};\n\nsub_8bit S1(\n    .A(A_s[7:0]),\n    .B(B_s[7:0]),\n    .Diff(diff_s[7:0]),\n    .B_out(borrow_s)\n);\n\nsub_8bit S2(\n    .A(A_s[15:8]),\n    .B(B_s[15:8]),\n    .Diff(diff_s[15:8]),\n    .B_out(borrow_s)\n);\n\nassign Diff = diff_s;\nassign B_out = borrow_s;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [7:0] A_s, B_s, diff_s;\nwire borrow_s;\n\nassign A_s = {1'b0, A};\nassign B_s = {1'b0, B};\n\nsub_4bit S1(\n    .A(A_s[3:0]),\n    .B(B_s[3:0]),\n    .Diff(diff_s[3:0]),\n    .B_out(borrow_s)\n);\n\nsub_4bit S2(\n    .A(A_s[7:4]),\n    .B(B_s[7:4]),\n    .Diff(diff_s[7:4]),\n    .B_out(borrow_s)\n);\n\nsub_4bit S3(\n    .A(A_s[11:8]),\n    .B(B_s[11:8]),\n    .Diff(diff_s[11:8]),\n    .B_out(borrow_s)\n);\n\nsub_4bit S4(\n    .A(A_s[15:12]),\n    .B(B_s[15:12]),\n    .Diff(diff_s[15:12]),\n    .B_out(/* borrow_s from S3 */)\n);\n\nassign Diff = diff_s;\nassign B_out = borrow_s;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [3:0] A_s, B_s, diff_s;\nwire borrow_s;\n\nassign A_s = {1'b0, A};\nassign B_s = {1'b0, B};\n\nsub_2bit S1(\n    .A(A_s[1:0]),\n    .B(B_s[1:0]),\n    .Diff(diff_s[1:0]),\n    .B_out(borrow_s)\n);\n\nsub_2bit S2(\n    .A(A_s[3:2]),\n    .B(B_"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_complement;\nwire [63:0] B_inverted;\nwire [63:0] borrow;\nwire [63:0] diff;\nwire [63:0] B_inverted_diff;\nwire B_internal;\n\nassign B_complement = ~B;\nassign B_inverted = ~B;\nassign B_internal = borrow[63];\nassign diff = A - B;\nassign B_inverted_diff = B_inverted - diff;\n\nassign D = diff;\nassign B_out = B_internal;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] D;\noutput B_out;\n\nwire [31:0] B_complement;\nwire [31:0] B_inverted;\nwire [31:0] borrow;\nwire [31:0] diff;\nwire [31:0] B_inverted_diff;\nwire B_internal;\n\nassign B_complement = ~B;\nassign B_inverted = ~B;\nassign B_internal = borrow[31];\nassign diff = A - B;\nassign B_inverted_diff = B_inverted - diff;\n\nassign D = diff;\nassign B_out = B_internal;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A;\ninput [15:0] B;\noutput [15:0] D;\noutput B_out;\n\nwire [15:0] B_complement;\nwire [15:0] B_inverted;\nwire [15:0] borrow;\nwire [15:0] diff;\nwire [15:0] B_inverted_diff;\nwire B_internal;\n\nassign B_complement = ~B;\nassign B_inverted = ~B;\nassign B_internal = borrow[15];\nassign diff = A - B;\nassign B_inverted_diff = B_inverted - diff;\n\nassign D = diff;\nassign B_out = B_internal;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire [7:0] B_inverted;\nwire [7:0] borrow;\nwire [7:0] diff;\nwire [7:0] B_inverted_diff;\nwire B_internal;\n\nassign B_complement = ~B;\nassign B_inverted = ~B;\nassign B_internal = borrow[7];\nassign diff = A - B;\nassign B_inverted_diff = B_inverted - diff;\n\nassign D = diff;\nassign B_out = B_internal;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\nwire [16:1] B_out;\n\n// Instance of BLS for A-B\nsubbls sub1(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]));\n// Instance of BLS for A-B\nsubbls sub2(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]));\n// Instance of BLS for A-B\nsubbls sub3(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]));\n// Instance of BLS for A-B\nsubbls sub4(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]));\nendmodule\n\nmodule subbls(A, B, D);\ninput [4:1] A;\ninput [4:1] B;\noutput [4:1] D;\nwire [4:1] borrow;\nwire [4:1] B_out;\n\n// Full subtractor\nfull_subtractor fs0(.A(A[4:1]), .B(B[4:1]), .D(D[4:1]), .B_out(borrow[4:1]));\nfull_subtractor fs1(.A(A[4:1]), .B(B[4:1]), .D(D[4:1]), .B_out(borrow[4:1]));\nfull_subtractor fs2(.A(A[4:1]), .B(B[4:1]), .D(D[4:1]), .B_out(borrow[4:1]));\nfull_subtractor fs3(.A(A[4:1]), .B(B[4:1]), .D(D[4:1]), .B_out(borrow[4:1]));\n\n// Borrow-out\nassign B_out = borrow[4] & borrow[3] & borrow[2] & borrow[1];\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\ninput [3:1] A;\ninput [3:1] B;\noutput [3:1] D;\noutput B_out;\nwire [3:1] B_out;\n\nassign {B_out, D} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] sub_result;\n    wire borrow_flag;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow_flag(borrow_flag)\n    );\n\n    assign A_greater = ~borrow_flag & (sub_result != 0);\n    assign A_equal = ~borrow_flag & (sub_result == 0);\n    assign A_less = borrow_flag;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow_flag\n);\n    wire [31:0] B_complement;\n    wire [31:0] B_inverted;\n    wire [31:0] borrow;\n    wire [31:0] sum;\n\n    assign B_complement = ~B + 1;\n    assign B_inverted = ~B;\n    assign borrow = B_complement < A;\n    assign sum = A + B_inverted + borrow;\n\n    assign sub_result = sum;\n    assign borrow_flag = borrow[31];\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\nwire [15:1] C15;\nwire C16, C17, C18, C19;\n\nCLA1 CLA1(.A(A[15:1]),.B(B[15:1]),.Cin(1'b0),.S(S[15:1]),.Cout(C15[1]));\nCLA2 CLA2(.A(A[16:1]),.B(B[16:1]),.Cin(C15[1]),.S(S[16:1]),.Cout(C16));\nCLA2 CLA3(.A(A[17:1]),.B(B[17:1]),.Cin(C15[2]),.S(S[17:1]),.Cout(C17));\nCLA2 CLA4(.A(A[18:1]),.B(B[18:1]),.Cin(C15[3]),.S(S[18:1]),.Cout(C18));\nCLA2 CLA5(.A(A[19:1]),.B(B[19:1]),.Cin(C15[4]),.S(S[19:1]),.Cout(C19));\n\nassign C32 = C15[15] | C16 | C17 | C18 | C19;\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\n\nwire [15:1] G,P,C;\nwire [16:1] Cp;\n\nassign G = A & B;\nassign P = A ^ B;\nassign Cp[1] = Cin;\nassign Cp[2:16] = Cp[1:15];\n\nassign C[1:15] = P[1:15] | (G[1:15] & Cp[1:15]);\nassign S[1:15] = P[1:15] ^ Cp[1:15];\nassign Cout = Cp[16];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\ninput [16:1] A,B;\ninput Cin;\noutput [16:1] S;\noutput Cout;\n\nwire [16:1] G,P,C;\nwire [17:1] Cp;\n\nassign G = A[16:1] & B[16:1];\nassign P = A[16:1] ^ B[16:1];\nassign Cp[1] = Cin;\nassign Cp[2:17] = Cp[1:16];\n\nassign C[1:16] = P[1:16] | (G[1:16] & Cp[1:16]);\nassign S[1:16] = P[1:16] ^ Cp[1:16];\nassign Cout = Cp[17];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] sum_slice;\nwire [3:0] carry_slice;\n\n// 4-bit ripple carry adder\nripple_carry_adder_4bit rca1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum(sum_slice[0]),\n    .cout(carry_slice[0])\n);\n\n// First 4-bit carry select adder slice\ncarry_select_adder_4bit csa_slice1(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(carry_slice[0]),\n    .sum(sum_slice[1]),\n    .cout(carry_slice[1])\n);\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_4bit csa_slice2(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(carry_slice[1]),\n    .sum(sum_slice[2]),\n    .cout(carry_slice[2])\n);\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_4bit csa_slice3(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(carry_slice[2]),\n    .sum(sum_slice[3]),\n    .cout(cout)\n);\n\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\nfull_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\nfull_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\nfull_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\nfull_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\nassign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] sum0, sum1;\nwire [2:0] carry;\n\nripple_carry_adder_4bit rca0(\n    .a(a),\n    .b(b),\n    .cin(1'b0),\n    .sum(sum0),\n    .cout(carry[0])\n);\n\nripple_carry_adder_4bit rca1(\n    .a(a),\n    .b(b),\n    .cin(1'b1),\n    .sum(sum1),\n    .cout(carry[1])\n);\n\nassign sum = cin ? sum1 : sum0;\nassign cout = cin ? carry[1] : carry[0];\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire c[15:0];\n    \n    // Instantiate 8-bit adder\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(c[0])\n    );\n    \n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c[7]),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum = {1'b0, a} + {1'b0, b} + {8'b0, Cin};\n    assign y = sum[7:0];\n    assign Co = sum[8];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [6:0] carry;\n    fa FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    fa FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    fa FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    fa FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    fa FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    fa FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    fa FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    fa FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule fa(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [15:0] a, b;\n    wire [4:0] cnt;\n    wire [31:0] prod;\n    wire cnt_done;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .cnt_done(cnt_done)\n    );\n\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .prod(prod),\n        .cnt(cnt)\n    );\n\n    assign yout = prod;\n    assign done = cnt_done;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg cnt_done // Chip output flag signal.\n);\n\n    reg [4:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            cnt_done <= 0;\n        end else if (start) begin\n            cnt <= 0;\n            cnt_done <= 0;\n        end else if (cnt == 15) begin\n            cnt_done <= 1;\n        end else begin\n            cnt <= cnt + 1;\n            cnt_done <= 0;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule reg_unit (\n    input clk,            // Chip clock signal.\n    input rst_n,          // Active-low reset signal.\n    output reg [15:0] a, // Input a (multiplicand) with a data width of 16 bits.\n    output reg [15:0] b  // Input b (multiplier) with a data width of 16 bits.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 0;\n            b <= 0;\n        end else begin\n            a <= 16'b0;\n            b <= 16'b0;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= ain;\n            b <= bin;\n        end else if (start) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b,     // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] prod, // Product output with a data width of 32 bits.\n    input [4:0] cnt     // Counter to count the number of bits processed.\n);\n\n    always @(posedge clk) begin\n        if (cnt == 15) begin\n            prod <= 0;\n        end else if (a[cnt]) begin\n            prod <= prod + b;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_count <= 16'b0;\n        else if (up_down)\n            next_count <= current_count + 1;\n        else\n            next_count <= current_count - 1;\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 16'b0;\n        else\n            current_count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the submodule for initial state\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the submodule for cyclic state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .in(init_out),\n        .out(transition_out)\n    );\n\n    assign out = transition_out;\n\nendmodule\n\n// Instantiate the ring counter for initialization\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n    end\nendmodule\n\n// Instantiate the ring counter for state transition\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= in;\n            out <= out << 1 | out[7];\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Output register module\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] Q_next;\n    wire [63:0] Q_reg;\n\n    // Instantiate the register module\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q_reg));\n    // Instantiate the logic module\n    JC_logic logic_inst(.Q_reg(Q_reg), .Q_next(Q_next));\n\n    assign Q = Q_next;\n\nendmodule\n\n// Submodule for the register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    reg [63:0] Q_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_reg <= 64'b0;\n        else\n            Q_reg <= Q_reg + 1;\n    end\n\n    assign Q = Q_reg;\n\nendmodule\n\n// Submodule for the logic\nmodule JC_logic(\n    input [63:0] Q_reg,\n    output [63:0] Q_next\n);\n\n    assign Q_next = Q_reg + (Q_reg & 64'h1);\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 4) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 49) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4, clk_3;\n\n    // Generate intermediate clock signals.\n    clk_div_gen u_clk_average(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_3)\n    );\n    clk_div_gen u_clk_adjustment(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_4)\n    );\n\n    // Generate fractional clock.\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\nmodule clk_div_gen(\n    input               clk,\n    input               rst_n,\n    output reg          clk_out\n);\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_out <= 1'b0;\n            cnt <= 4'd0;\n        end else begin\n            if (cnt == MUL2_DIV_CLK - 1) begin\n                clk_out <= ~clk_out;\n                cnt <= 4'd0;\n            end else begin\n                clk_out <= clk_out;\n                cnt <= cnt + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Instantiation of fractional frequency divider.\nfreq_divbyfrac u_freq_divbyfrac (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div)\n);\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n            cnt <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            clk_div <= ~clk_div;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    reg [3:0] cnt;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n            cnt <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            clk_div <= ~clk_div;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire clk_div_en;\nreg [3:0] counter;\n\ncounter_module u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_en(clk_div_en)\n);\n\nclk_divider_module u_clk_divider (\n    .clk(clk),\n    .clk_div_en(clk_div_en),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg clk_div_en\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        clk_div_en <= 0;\n    end else begin\n        if (counter >= (NUM_DIV >> 1) - 1) begin\n            counter <= 0;\n            clk_div_en <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div_en <= 0;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_divider_module(\n    input clk,\n    input clk_div_en,\n    output reg clk_div\n);\n\nalways @(posedge clk) begin\n    if (clk_div_en)\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, slt_out, sltu_out, sll_out, srl_out, sra_out;\n    wire [31:0] sllv_out, srlv_out, srav_out;\n\n    // Instantiate the submodules\n    adder add(\n        .a(a),\n        .b(b),\n        .r(add_out)\n    );\n    adder_unsigned addu(\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    and_gate and1(\n        .a(a),\n        .b(b),\n        .r(and_out)\n    );\n    or_gate or1(\n        .a(a),\n        .b(b),\n        .r(or_out)\n    );\n    xor_gate xor1(\n        .a(a),\n        .b(b),\n        .r(xor_out)\n    );\n    nor_gate nor1(\n        .a(a),\n        .b(b),\n        .r(nor_out)\n    );\n    slt_comparator slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_out)\n    );\n    sltu_comparator sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_out)\n    );\n    shift_left sll(\n        .a(a),\n        .b(b),\n        .r(sll_out)\n    );\n    shift_right srl(\n        .a(a),\n        .b(b),\n        .r(srl_out)\n    );\n    shift_right_arithmetic sra(\n        .a(a),\n        .b(b),\n        .r(sra_out)\n    );\n    shift_left_variable sllv(\n        .a(a),\n        .b(b),\n        .r(sllv_out)\n    );\n    shift_right_variable srlv(\n        .a(a),\n        .b(b),\n        .r(srlv_out)\n    );\n    shift_right_arithmetic_variable srav(\n        .a(a),\n        .b(b),\n        .r(srav_out)\n    );\n    lui_comparator lui_inst(\n        .a(a),\n        .b(b),\n        .r(r)\n    );\n\n    // Assign the outputs\n    assign r = aluc[5:0] == 6'b100000 ? add_out :\n               aluc[5:0] == 6'b100001 ? addu.r :\n               aluc[5:0] == 6'b100010 ? sub_out :\n               aluc[5:0] == 6'b100011 ? sub_out :\n               aluc[5:0] == 6'b100100 ? and_out :\n               aluc[5:0] == 6'b100101 ? or_out :\n               aluc[5:0] == 6'b100110 ? xor_out :\n               aluc[5:0] == 6'b100111 ? nor_out :\n               aluc[5:0] == 6'b101010 ? slt_out :\n               aluc[5:0] == 6'b101011 ? sltu_out :\n               aluc[5:0] == 6'b000000 ? sll_out :\n               aluc[5:0] == 6'b000010 ? srl_out :\n               aluc[5:0] == 6'b000011 ? sra_out :\n               aluc[5:0] == 6'b000100 ? sllv_out :\n               aluc[5:0]"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] mul_result;\n    wire [31:0] current_value;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(mul_result)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .new_result(mul_result[31:0]),\n        .current_value(current_value),\n        .result(c)\n    );\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_result,\n    input [31:0] current_value,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            result <= 0;\n        else\n            result <= current_value + new_result;\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n    wire [7:0] data1, data2;\n\n    ins_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad(ad11)\n    );\n\n    ins_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad(ad22)\n    );\n\n    assign ad1 = ad11;\n    assign ad2 = ad22;\n    assign ins = (fetch == 2'b01) ? ins1 : (fetch == 2'b10) ? ins2 : ins1;\n\nendmodule\n\nmodule ins_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\n// Counter Module\ncounter cnt(.clk(clk), .enable(1'b1), .freq(freq), .count(count));\n\n// Wave Generator Module\nwave_generator wg(.clk(clk), .count(count), .freq(freq), .wave_out(wave_out));\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable && (count == (freq - 1)))\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count < (freq / 2 - 1)) ? 1'b1 : 1'b0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    wire [1:0] state;\n\n    // State control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state_out(state)\n    );\n\n    // Waveform generation module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state_out <= 2'b00;\n        else\n            state_out <= (state_out == 2'b00) ? 2'b01 : 2'b00;\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk) begin\n        if (state == 2'b00)\n            wave <= (wave == 5'd31) ? 5'd0 : wave + 1;\n        else\n            wave <= (wave == 5'd0) ? 5'd31 : wave - 1;\n    end\n\n    always @(negedge rst_n) begin\n        wave <= 5'd0;\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] shifted_d;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(shifted_d[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(shifted_d[0]),\n        .q(shifted_d[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(shifted_d[1]),\n        .q(shifted_d[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= shifted_d[0];\n            2'b01: q <= shifted_d[1];\n            2'b10: q <= shifted_d[2];\n            2'b11: q <= d;\n            default: q <= 8'bx;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n    always @(*) begin\n        case (sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n            default: out = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] s1, s2, s3, s4;\n\nmux2X1 ins_17 (.in0(in), .in1(s4), .sel(ctrl[2]), .out(s1));\nmux2X1 ins_16 (.in0(s1), .in1(s1), .sel(ctrl[1]), .out(s2));\nmux2X1 ins_15 (.in0(s2), .in1(s2), .sel(ctrl[0]), .out(s3));\nmux2X1 ins_14 (.in0(s3), .in1(s3), .sel(ctrl[1]), .out(s4));\nmux2X1 ins_13 (.in0(s4), .in1(s4), .sel(ctrl[2]), .out(out));\n\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out);\ninput in0, in1, sel;\noutput out;\nassign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(p0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(p1)\n  );\n  assign b1 = rst ? 16'b0 : b0;\n  assign c0 = p0;\n  assign c1 = p1;\nendmodule\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b_reg <= 16'b0;\n    else\n      b_reg <= b;\n  end\n  assign c = a * b_reg;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetched_inst, decoded_inst, exec_result;\n  wire [4:0] pc;\n  wire [4:0] pc_next;\n  wire [4:0] pc_next_next;\n\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .fetched_inst(fetched_inst));\n  decode_stage decode(.clk(clk), .fetched_inst(fetched_inst), .decoded_inst(decoded_inst));\n  execute_stage execute(.clk(clk), .decoded_inst(decoded_inst), .reg_file(reg_file), .exec_result(exec_result));\n  memory_stage memory(.clk(clk), .exec_result(exec_result), .mem_result(exec_result));\n  writeback_stage writeback(.clk(clk), .reg_file(reg_file), .exec_result(exec_result), .res_reg_file(res_reg_file));\n\n  assign pc_next = pc + 1;\n  assign pc_next_next = pc + 2;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else begin\n      if (pc == 31)\n        pc <= 0;\n      else\n        pc <= pc_next;\n    end\n  end\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output [31:0] fetched_inst\n);\n  assign fetched_inst = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] fetched_inst,\n  output [31:0] decoded_inst\n);\n  assign decoded_inst = fetched_inst;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [31:0] decoded_inst,\n  input [31:0] reg_file [0:31],\n  output [31:0] exec_result\n);\n  assign exec_result = decoded_inst;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] exec_result,\n  output [31:0] mem_result\n);\n  assign mem_result = exec_result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] reg_file [0:31],\n  input [31:0] mem_result,\n  output [31:0] res_reg_file [0:31]\n);\n  integer i;\n  always @(posedge clk) begin\n    for (i = 0; i < 32; i = i + 1) begin\n      res_reg_file[i] <= mem_result;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  wire [31:0] c1_internal, c2_internal, c3_internal;\n\n  // Instantiate the first PE\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  // Instantiate the second PE\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_internal)\n  );\n\n  // Instantiate the third PE\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2_internal)\n  );\n\n  // Instantiate the fourth PE\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3_internal)\n  );\n\n  // Delay the inputs for PE2 and PE3\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  assign c1 = c1_internal;\n  assign c2 = c2_internal;\n  assign c3 = c3_internal;\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      c_reg <= 0;\n    end else begin\n      c_reg <= a * b + c_reg;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr;\n    \n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n    \n    wire [31:0] operand1, operand2;\n    wire [31:0] result;\n    \n    execute_stage execute(\n        .clk(clk),\n        .fetched_instr(fetched_instr),\n        .reg_file(reg_file),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(result)\n    );\n    \n    wire [4:0] reg_dst;\n    writeback_stage writeback(\n        .clk(clk),\n        .result(result),\n        .reg_dst(reg_dst),\n        .out_reg_file(out_reg_file)\n    );\n    \n    reg [4:0] pc = 0;\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetched_instr <= 0;\n        else\n            fetched_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] operand1,\n    output reg [31:0] operand2,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        case(fetched_instr[31:26])\n            6'b001000: begin  // Addition\n                operand1 = reg_file[fetched_instr[25:21]];\n                operand2 = reg_file[fetched_instr[20:16]];\n                result = operand1 + operand2;\n            end\n            6'b001010: begin  // Subtraction\n                operand1 = reg_file[fetched_instr[25:21]];\n                operand2 = reg_file[fetched_instr[20:16]];\n                result = operand1 - operand2;\n            end\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] result,\n    input [4:0] reg_dst,\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk) begin\n        out_reg_file[reg_dst] <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_value;\n    wire [9:0] accum_value;\n    wire accu_ready;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .accu_ready(accu_ready),\n        .accum_value(accum_value)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .accu_ready(accu_ready),\n        .valid_out(valid_out)\n    );\n\n    assign data_out = accum_value;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg [1:0]    cnt_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_value <= 0;\n        else if (cnt_value < 3)\n            cnt_value <= cnt_value + 1;\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    output reg          accu_ready,\n    output reg [9:0]    accum_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accum_value <= 0;\n            accu_ready <= 0;\n        end else if (accu_ready) begin\n            accum_value <= accum_value + data_in;\n            accu_ready <= 0;\n        end else if (data_in != 0) begin\n            accu_ready <= 1;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               accu_ready,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (accu_ready)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [3:0] count;\n    wire [3:0] next_count;\n    wire [7:0] shift_reg;\n    wire [7:0] next_shift_reg;\n    wire [15:0] res_q;\n    wire [15:0] next_res_q;\n\n    // Absolute Value Calculation\n    abs_value abs_dividend_inst (\n        .dividend(dividend),\n        .sign(sign),\n        .abs_value(abs_dividend)\n    );\n\n    // Negative Value Calculation\n    neg_divisor_mod neg_divisor_mod_inst (\n        .divisor(divisor),\n        .sign(sign),\n        .neg_divisor(neg_divisor)\n    );\n\n    // Control Logic\n    divider_control ctrl_inst (\n        .clk(clk),\n        .rst(rst),\n        .count(count),\n        .next_count(next_count),\n        .divisor(neg_divisor),\n        .shift_reg(shift_reg),\n        .next_shift_reg(next_shift_reg),\n        .dividend(abs_dividend),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .res_valid(res_valid)\n    );\n\n    // Result Management\n    result_management res_mgmt_inst (\n        .clk(clk),\n        .rst(rst),\n        .count(count),\n        .next_count(next_count),\n        .res_valid(res_valid),\n        .res_ready(res_ready),\n        .res_q(res_q),\n        .next_res_q(next_res_q)\n    );\n\n    // Output\n    assign result = res_q;\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] abs_value\n);\n    always @(*) begin\n        if (sign)\n            abs_value = -dividend;\n        else\n            abs_value = dividend;\n    end\nendmodule\n\nmodule neg_divisor_mod(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] neg_divisor\n);\n    always @(*) begin\n        if (sign)\n            neg_divisor = ~divisor + 1;\n        else\n            neg_divisor = divisor;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] count,\n    output reg [3:0] next_count,\n    input wire [7:0] divisor,\n    input wire [7:0] shift_reg,\n    output reg [7:0] next_shift_reg,\n    input wire [7:0] dividend,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid\n);\n    wire [7:0] q;\n    wire [7:0] r;\n\n    // Next state logic\n    always @(*) begin\n        next_count = count;\n        next_shift_reg = shift_reg;\n        res_valid = 1'b0;\n        if (opn_valid && !res_ready) begin\n            next_count = count + 1;\n            next_shift_reg = {dividend[7:0], 1'b0};\n            res_valid = 1'b1;\n        end\n    end\n\n    // Quotient calculation\n    assign q = shift_reg[7:0] >> 1;\n\n    // Remainder calculation\n    assign r = shift_reg[7:0] - (divisor << (count[2:0] - 1));\n\n    // Output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0;\n            shift_reg <= 8'"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep(\n        .dividend_in(A),\n        .divisor_in(B),\n        .dividend_out(dividend),\n        .divisor_out(divisor)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend_in,\n    input wire [15:0] divisor_in,\n    output reg [31:0] dividend_out,\n    output reg [31:0] divisor_out\n);\n    always @(*) begin\n        dividend_out = {dividend_in[31:0], 16'b0};\n        divisor_out = {divisor_in, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        quotient = dividend / divisor;\n        remainder = dividend % divisor;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result, temp_odd;\n    wire [7:0] shifted_divisor;\n\n    // Control unit\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_result),\n        .remainder(temp_odd)\n    );\n\n    assign result = temp_result;\n    assign odd = temp_odd;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    wire [7:0] shifted_divisor;\n    wire [15:0] shifted_dividend;\n    wire [7:0] bit_result;\n\n    // Control signals\n    reg [2:0] bit_count;\n    reg [1:0] shift_count;\n    reg done;\n\n    // Registers\n    reg [7:0] quotient_reg;\n    reg [15:0] dividend_reg;\n    reg [7:0] remainder_reg;\n\n    // Initialize\n    initial begin\n        bit_count = 0;\n        shift_count = 0;\n        done = 0;\n        quotient_reg = 0;\n        dividend_reg = A;\n        remainder_reg = 0;\n    end\n\n    // Update quotient and remainder\n    always @(posedge done) begin\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\n\n    // Shift divisor\n    always @(posedge done) begin\n        shifted_divisor = {B, 1'b0};\n    end\n\n    // Shift dividend\n    always @(posedge done) begin\n        shifted_dividend = dividend_reg << 1;\n    end\n\n    // Check divisor\n    always @(posedge done) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            bit_result = 1;\n        end else begin\n            bit_result = 0;\n        end\n    end\n\n    // Update quotient and remainder\n    always @(posedge done) begin\n        if (bit_result == 1) begin\n            quotient_reg = quotient_reg + (1 << bit_count);\n            remainder_reg = shifted_dividend - shifted_divisor;\n        end\n        dividend_reg = shifted_dividend;\n    end\n\n    // Next bit\n    always @(posedge done) begin\n        bit_count = bit_count + 1;\n        shift_count = shift_count + 1;\n    end\n\n    // Check done\n    always @(posedge done) begin\n        if (bit_count == 15) begin\n            done = 1;\n        end else begin\n            done = 0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [8:0] carry;\n\nassign B_comp = ~B + 1;\nassign {B_out, D} = A + B_comp;\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D);\ninput [7:0] A, B;\ninput C_in;\noutput [7:0] D;\n\nwire [8:0] sum;\n\nassign sum = {1'b0, A} + {1'b0, B} + {1'b0, C_in};\nassign D = sum[7:0];\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n\n    subtractor_16_module S1_inst(.A(A[15:0]), .B(B[15:0]), .Diff(S1), .B_out(B_out));\n    subtractor_16_module S2_inst(.A(A[31:16]), .B(B[31:16]), .Diff(S2), .B_out(B_out));\n\n    assign Diff = {S2, S1};\n\nendmodule\n\nmodule subtractor_16_module(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] B_not;\n\n    assign B_not = ~B;\n    assign {B_out, Diff} = A + B_not;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n    \n    wire [31:0] D0, D1;\n    wire B0, B1;\n    \n    // Instantiate the two 32-bit subtractor modules\n    sub_32bit sub0(\n        .A(A[31:0]), \n        .B(B[31:0]), \n        .D(D0), \n        .B_out(B0)\n    );\n    sub_32bit sub1(\n        .A(A[63:32]), \n        .B(B[63:32]), \n        .D(D1), \n        .B_out(B1)\n    );\n    \n    // Output\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n    \n    wire [15:0] D0, D1;\n    wire B0, B1;\n    \n    // Instantiate the two 16-bit subtractor modules\n    sub_16bit sub0(\n        .A(A[15:0]), \n        .B(B[15:0]), \n        .D(D0), \n        .B_out(B0)\n    );\n    sub_16bit sub1(\n        .A(A[31:16]), \n        .B(B[31:16]), \n        .D(D1), \n        .B_out(B1)\n    );\n    \n    // Output\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n    \n    wire [7:0] D0, D1;\n    wire B0, B1;\n    \n    // Instantiate the two 8-bit subtractor modules\n    sub_8bit sub0(\n        .A(A[7:0]), \n        .B(B[7:0]), \n        .D(D0), \n        .B_out(B0)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]), \n        .B(B[15:8]), \n        .D(D1), \n        .B_out(B1)\n    );\n    \n    // Output\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n    \n    wire [3:0] D0, D1;\n    wire B0, B1;\n    \n    // Instantiate the two 4-bit subtractor modules\n    sub_4bit sub0(\n        .A(A[3:0]), \n        .B(B[3:0]), \n        .D(D0), \n        .B_out(B0)\n    );\n    sub_4bit sub1(\n        .A(A[7:4]), \n        .B(B[7:4]), \n        .D(D1), \n        .B_out(B1)\n    );\n    \n    // Output\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n    \n    wire B_out;\n    assign B_out = (~A[0] & ~B[0]) | (~A[1] & ~B[1]) | (~A"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow1, borrow2, borrow3;\nwire b1, b2, b3;\n\nsub4 sub1(\n    .A(A[3:0]), .B(B[3:0]), .B_in(1'b0), .D(D[3:0]), .B_out(borrow1)\n);\nsub4 sub2(\n    .A(A[7:4]), .B(B[7:4]), .B_in(borrow1[0]), .D(D[7:4]), .B_out(borrow2)\n);\nsub4 sub3(\n    .A(A[11:8]), .B(B[11:8]), .B_in(borrow2[0]), .D(D[11:8]), .B_out(borrow3)\n);\nsub4 sub4(\n    .A(A[15:12]), .B(B[15:12]), .B_in(borrow3[0]), .D(D[15:12]), .B_out(B_out)\n);\n\nendmodule\n\nmodule sub4(A, B, B_in, D, B_out);\ninput [3:0] A, B;\ninput B_in;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] B_not, B_xor, B_and, B_or;\nwire borrow;\n\nassign B_not = ~B;\nassign B_xor = B_not ^ A;\nassign B_and = B_not & A;\nassign B_or = B_xor | B_and;\nassign D = B_or ^ B_in;\nassign borrow = (~B_or & B_in);\nassign B_out = borrow;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] diff; \n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(diff)\n    );\n\n    assign A_greater = (diff == 32'b0);\n    assign A_equal = (diff == 32'b0);\n    assign A_less = (diff[31] == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A, \n    input [31:0] B, \n    output [31:0] result\n);\n\n    wire [31:0] A_minus_B;\n    wire borrow;\n\n    // Perform subtraction using 32-bit adder\n    adder_32bit add_inst(\n        .A(A),\n        .B(~B),\n        .result(A_minus_B),\n        .borrow(borrow)\n    );\n\n    assign result = (borrow) ? A_minus_B : 32'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A, \n    input [31:0] B, \n    output [31:0] result, \n    output borrow\n);\n\n    wire [31:0] sum; \n    wire [31:0] carry;\n\n    assign carry[0] = 1'b0;\n    assign borrow = carry[31];\n\n    genvar i;\n    generate\n        for (i = 0; i < 32; i = i + 1) begin : bit_addition\n            assign sum[i] = A[i] ^ B[i] ^ carry[i];\n            assign carry[i+1] = (A[i] & B[i]) | (B[i] & carry[i]) | (A[i] & carry[i]);\n        end\n    endgenerate\n\n    assign result = sum;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\nwire [31:0] C16;\n\ncla_16bit CLA1(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .Sum(S[15:0]), .Cout(C16[0]));\ncla_16bit CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(C16[0]), .Sum(S[31:16]), .Cout(C16[1]));\nassign C32 = C16[1];\nendmodule\n\nmodule cla_16bit(A,B,Cin,Sum,Cout);\ninput [15:0] A;\ninput [15:0] B;\ninput Cin;\noutput [15:0] Sum;\noutput Cout;\n\nwire [16:0] p, g, c;\nassign p = A ^ B;\nassign g = A & B;\nassign c[0] = Cin;\nassign c[1] = g[0] | (p[0] & c[0]);\nassign c[2] = g[1] | (p[1] & c[1]);\nassign c[3] = g[2] | (p[2] & c[2]);\nassign c[4] = g[3] | (p[3] & c[3]);\nassign c[5] = g[4] | (p[4] & c[4]);\nassign c[6] = g[5] | (p[5] & c[5]);\nassign c[7] = g[6] | (p[6] & c[6]);\nassign c[8] = g[7] | (p[7] & c[7]);\nassign c[9] = g[8] | (p[8] & c[8]);\nassign c[10] = g[9] | (p[9] & c[9]);\nassign c[11] = g[10] | (p[10] & c[10]);\nassign c[12] = g[11] | (p[11] & c[11]);\nassign c[13] = g[12] | (p[12] & c[12]);\nassign c[14] = g[13] | (p[13] & c[13]);\nassign c[15] = g[14] | (p[14] & c[14]);\nassign c[16] = g[15] | (p[15] & c[15]);\nassign Cout = c[16];\nassign Sum = p ^ c;\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sums[0:3];\nwire [3:0] csa_carries[0:3];\n\n// 4-bit ripple carry adder\nripple_carry_adder_4bit rca1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum(csa_sums[0][0]),\n    .cout(csa_carries[0][0])\n);\nripple_carry_adder_4bit rca2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(csa_carries[0][0]),\n    .sum(csa_sums[0][1]),\n    .cout(csa_carries[0][1])\n);\nripple_carry_adder_4bit rca3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(csa_carries[0][1]),\n    .sum(csa_sums[0][2]),\n    .cout(csa_carries[0][2])\n);\nripple_carry_adder_4bit rca4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(csa_carries[0][2]),\n    .sum(csa_sums[0][3]),\n    .cout(csa_carries[0][3])\n);\n\n// 4-bit carry select adder slices\ncarry_select_adder_4bit csa_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(csa_carries[0][0]),\n    .sum(csa_sums[1][0]),\n    .cout(csa_carries[1][0])\n);\ncarry_select_adder_4bit csa_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(csa_carries[1][0]),\n    .sum(csa_sums[1][1]),\n    .cout(csa_carries[1][1])\n);\ncarry_select_adder_4bit csa_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(csa_carries[1][1]),\n    .sum(csa_sums[1][2]),\n    .cout(csa_carries[1][2])\n);\ncarry_select_adder_4bit csa_slice4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(csa_carries[1][2]),\n    .sum(csa_sums[1][3]),\n    .cout(csa_carries[1][3])\n);\n\n// 4-bit carry select adder slices\ncarry_select_adder_4bit csa_slice5(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(csa_carries[1][0]),\n    .sum(csa_sums[2][0]),\n    .cout(csa_carries[2][0])\n);\ncarry_select_adder_4bit csa_slice6(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(csa_carries[2][0]),\n    .sum(csa_sums[2][1]),\n    .cout(csa_carries[2][1])\n);\ncarry_select_adder_4bit csa_slice7(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(csa_carries[2][1]),"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n    assign carry = {Cin, 1'b0};\n    assign y = a ^ b ^ carry;\n    assign Co = (a & b) | (carry & (a ^ b));\nendmodule\n\nmodule add8_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [7:0] carry;\n    assign carry = {Cin, 1'b0};\n    assign y = a[7:0] ^ b[7:0] ^ carry;\n    assign Co = (a[7:0] & b[7:0]) | (carry & (a[7:0] ^ b[7:0]));\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [6:0] carry;\n\n    FA FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [3:0] count; // Shift count.\n    wire [31:0] product; // Product register.\n    wire add_sub; // Add or subtract flag.\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .count(count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .add_sub(add_sub),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .add_sub(add_sub),\n        .product(product),\n        .count(count)\n    );\n\n    // Output assignment\n    assign yout = product;\n    assign done = start && count == 0;\n\nendmodule\n\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n        end else if (start) begin\n            count <= 4'd1;\n        end else begin\n            count <= count - 1'b1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg add_sub, // Add or subtract flag.\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            add_sub <= 1'b1;\n            product <= 32'd0;\n        end else if (start) begin\n            add_sub <= 1'b1;\n            product <= {16'd0, ain}; // Load multiplicand\n        end else begin\n            add_sub <= ~add_sub;\n            product <= product + ({16'd0, bin} << count);\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input add_sub,      // Add or subtract flag.\n    input [31:0] product, // Product register.\n    input [3:0] count    // Shift count.\n);\n\n    reg [31:0] product_reg; // Internal product register.\n\n    always @(posedge clk) begin\n        if (add_sub) begin\n            product_reg <= product + ({16'd0, product} << count);\n        end else begin\n            product_reg <= product - ({16'd0, product} << count);\n        end\n    end\n\n    assign product = product_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count_in(count),\n        .count_out(next_count)\n    );\n\n    // Instantiate the counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count_in,\n    output reg [15:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 0;\n        end else if (up_down) begin\n            count_out <= count_in + 1;\n        end else begin\n            count_out <= count_in - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 0;\n        end else begin\n            count_out <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // State Initialization Module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State Transition Module\n    state_transition transition (\n        .clk(clk),\n        .out(out),\n        .next_state(next_state)\n    );\n\nendmodule\n\n// State Initialization Submodule\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\n// State Transition Submodule\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] out,\n    output reg [7:0] next_state\n);\n\n    always @(posedge clk) begin\n        case (out)\n            8'b0000_0001: next_state <= 8'b0000_0010;\n            8'b0000_0010: next_state <= 8'b0000_0100;\n            8'b0000_0100: next_state <= 8'b0000_1000;\n            8'b0000_1000: next_state <= 8'b0001_0000;\n            8'b0001_0000: next_state <= 8'b0010_0000;\n            8'b0010_0000: next_state <= 8'b0100_0000;\n            8'b0100_0000: next_state <= 8'b1000_0000;\n            8'b1000_0000: next_state <= 8'b0000_0001;\n            default: next_state <= 8'b0000_0001; // Default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    // Submodule instance\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Submodule instance\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\n// Submodule: counter logic\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= (count == 4'd11) ? 4'b0000 : count + 1;\n    end\n\nendmodule\n\n// Submodule: output register\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register submodule\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic submodule\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output reg [63:0]   next_Q\n);\n    always @(*) begin\n        next_Q = Q ^ (Q >> 1);\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 2'd4) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 6'd49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4, clk_3;\n\n    // Counter submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_4)\n    );\n\n    // Clock average generator submodule\n    clk_average u_clk_average (\n        .clk(clk),\n        .clk_in(clk_4),\n        .clk_out(clk_3)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_in(clk_3),\n        .clk_out(clk_div)\n    );\n\nendmodule\n\n// Counter submodule\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg clk_out\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count == 3) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Clock average generator submodule\nmodule clk_average(\n    input clk,\n    input clk_in,\n    output reg clk_out\n);\n\n    always @(posedge clk) begin\n        clk_out <= clk_in;\n    end\n\nendmodule\n\n// Clock adjustment submodule\nmodule clk_adjustment(\n    input clk,\n    input clk_in,\n    output reg clk_out\n);\n\n    always @(negedge clk) begin\n        clk_out <= clk_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    wire clk_en;\n    reg [3:0] cnt_reg;\n\n    assign clk_en = (cnt_reg == (NUM_DIV / 2 - 1));\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_reg <= 0;\n        end else if (clk_en) begin\n            cnt_reg <= 0;\n        end else begin\n            cnt_reg <= cnt_reg + 1;\n        end\n    end\n\n    assign clk_div = clk_en ? ~clk_div : clk_div;\n\nendmodule\n\nmodule freq_divbyeven_cnt(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\nendmodule\n\nmodule freq_divbyeven_clkdiv(\n    input clk,\n    input rst_n,\n    input clk_en,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (clk_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] result;\n    wire [31:0] c;\n    wire [31:0] b_neg;\n    wire [31:0] b_neg_add;\n    \n    assign b_neg = ~b + 1;\n    assign b_neg_add = b_neg + 1;\n\n    add add_inst(.a(a), .b(b), .c(c));\n    addu addu_inst(.a(a), .b(b), .c(result));\n    sub sub_inst(.a(a), .b(b), .c(result));\n    subu subu_inst(.a(a), .b(b), .c(result));\n    and and1_inst(.a(a), .b(b), .c(result));\n    or or1_inst(.a(a), .b(b), .c(result));\n    xor xor1_inst(.a(a), .b(b), .c(result));\n    nor nor1_inst(.a(a), .b(b), .c(result));\n    slt slt_inst(.a(a), .b(b), .c(result));\n    sltu sltu_inst(.a(a), .b(b), .c(result));\n    sll sll_inst(.a(a), .b(b), .c(result));\n    srl srl_inst(.a(a), .b(b), .c(result));\n    sra sra_inst(.a(a), .b(b), .c(result));\n    sllv sllv_inst(.a(a), .b(b), .c(result));\n    srlv srlv_inst(.a(a), .b(b), .c(result));\n    srav srav_inst(.a(a), .b(b), .c(result));\n    lui lui_inst(.a(a), .b(b), .c(result));\n\n    assign r = result;\n    assign zero = (result == 0);\n    assign carry = c[31];\n    assign negative = result[31];\n    assign overflow = c[31] ^ c[30];\n    assign flag = (aluc == 6'b101010) ? result[31] ^ result[30] : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a - b;\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] c);\n    assign c = {31'b0, a[31]} < {31'b0, b[31]};\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] product;\n    wire [31:0] next_value;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(next_value),\n        .new_value(product[31:0]),\n        .next_value(next_value)\n    );\n\n    assign c = next_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    assign product = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output reg [31:0] next_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            next_value <= 0;\n        end else begin\n            next_value <= current_value + new_value;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instruction fetch from registers\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    // Instruction fetch from RAM/ROM\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    assign ins = fetch[1] ? ins2 : ins1;\n    assign ad1 = fetch[1] ? ad12 : ad11;\n    assign ad2 = fetch[1] ? ad22 : ad21;\n\nendmodule\n\n// Instruction register for registers\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule\n\n// Instruction register for RAM/ROM\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule\n\n```"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n    wire enable;\n\n    // Instance of the counter\n    counter cnt (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % (freq + freq)) < (freq / 2);\n    end\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [4:0] wave_reg;\n    reg [1:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 0;\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b11111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b10;\n                end\n                2'b10: state <= 2'b00;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) state <= 2'b00;\n        else state <= state + 1;\n    end\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) wave <= 5'b00000;\n        else begin\n            if (wave == 5'b11111) wave <= 5'b00000;\n            else if (wave == 5'b00000) wave <= 5'b11111;\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [2:0] internal_d;\n    wire [2:0] internal_q;\n\n    // Instantiate 3 D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d[0]), .q(internal_d[0]));\n    my_dff8 u1 (.clk(clk), .d(internal_d[0]), .q(internal_d[1]));\n    my_dff8 u2 (.clk(clk), .d(internal_d[1]), .q(internal_d[2]));\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= internal_d[0];\n            2'b01: q <= internal_d[1];\n            2'b10: q <= internal_d[2];\n            2'b11: q <= d;\n            default: q <= q; // Prevent latches\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] d,\n    input [1:0] sel,\n    output reg q\n);\n    always @(*) begin\n        case (sel)\n            2'b00: q = d[0];\n            2'b01: q = d[1];\n            2'b10: q = d[2];\n            2'b11: q = d[3];\n            default: q = 1'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n    my_dff u0 (clk, d, q0);\n    my_dff u1 (clk, q0, q1);\n    my_dff u2 (clk, q1, q2);\n    assign q = q2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] s1, s2, s3;\n\n// Stage 1: Shift by 4\nmux2X1 ins_17 (in, s1, ctrl[2], s2);\nmux2X1 ins_16 (s2, in, ctrl[1], s3);\n\n// Stage 2: Shift by 2\nmux2X1 ins_15 (s3, in, ctrl[1], s2);\nmux2X1 ins_14 (s2, in, ctrl[0], out);\n\n// Stage 3: Shift by 1\nmux2X1 ins_13 (in, s2, ctrl[0], out);\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\ninput sel;\ninput in0, in1;\noutput out;\n\nassign out = sel ? in1 : in0;\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  assign b1 = rst ? 16'h0000 : b0;\n\n  PE pe0 (.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1 (.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) c_reg <= 32'h00000000;\n    else c_reg <= c_reg + (a * b);\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_out;\n  wire [31:0] pc;\n\n  stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .pc(pc),\n    .fetch_out(fetch_out)\n  );\n\n  stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .decode_out(decode_out)\n  );\n\n  stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(decode_out),\n    .execute_out(execute_out)\n  );\n\n  stage memory (\n    .clk(clk),\n    .rst(rst),\n    .instr(execute_out),\n    .memory_out(memory_out)\n  );\n\n  stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .instr(memory_out),\n    .writeback_out(writeback_out)\n  );\n\n  assign res_reg_file = writeback_out;\n  assign pc = pc + 1;\nendmodule\n\nmodule stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output reg [31:0] out,\n  input [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 0;\n    else\n      out <= instr_mem[pc];\n  end\nendmodule\n\nmodule fetch (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [31:0] pc,\n  output reg [31:0] out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 0;\n    else\n      out <= instr_mem[pc];\n  end\nendmodule\n\nmodule decode (\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [31:0] out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 0;\n    else begin\n      case (instr[31:26])\n        6'b001001: out <= {instr[31:26], 6'b000000, instr[5:0], instr[11:6], instr[5:0], 5'b00000};\n        6'b011001: out <= {instr[31:26], 6'b000000, instr[5:0], instr[11:6], instr[5:0], 5'b00000};\n        default: out <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule execute (\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [31:0] out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 0;\n    else begin\n      case (instr[31:26])\n        6'b001001: out <= instr[15:0] + instr[20:16];\n        6'b011001: out <= instr[15:0] - instr[20:16];\n        default: out <= 0;\n     "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if(rst) begin\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= c0_reg + (a0 * b0);\n      c1_reg <= c1_reg + (a1 * b1);\n      c2_reg <= c2_reg + (a2 * b2);\n      c3_reg <= c3_reg + (a3 * b3);\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk) begin\n    if(rst)\n      c_reg <= 0;\n    else\n      c_reg <= c_reg + (a * b);\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr;\n    wire [31:0] decoded_instr;\n    wire [31:0] result;\n    wire [4:0] reg_write_addr;\n    wire [31:0] next_reg_file;\n\n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .fetched_instr(fetched_instr)\n    );\n    \n    execute_stage execute(\n        .clk(clk),\n        .rst(rst),\n        .instr(fetched_instr),\n        .reg_file(reg_file),\n        .decoded_instr(decoded_instr),\n        .result(result),\n        .reg_write_addr(reg_write_addr)\n    );\n    \n    writeback_stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .instr(decoded_instr),\n        .reg_file(reg_file),\n        .result(result),\n        .reg_write_addr(reg_write_addr),\n        .next_reg_file(next_reg_file)\n    );\n    \n    assign out_reg_file = next_reg_file;\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetched_instr\n);\n    reg [4:0] pc;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            pc <= 5'd0;\n        else begin\n            fetched_instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] decoded_instr,\n    output reg [31:0] result,\n    output reg [4:0] reg_write_addr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            decoded_instr <= 0;\n            result <= 0;\n            reg_write_addr <= 0;\n        end\n        else begin\n            case (instr[31:26])\n                6'b000000: begin\n                    decoded_instr <= instr;\n                    reg_write_addr <= instr[5:0];\n                    result <= reg_file[instr[10:6]] + reg_file[instr[15:11]];\n                end\n                6'b001010: begin\n                    decoded_instr <= instr;\n                    reg_write_addr <= instr[5:0];\n                    result <= reg_file[instr[10:6]] - reg_file[instr[15:11]];\n                end\n                default: begin\n                    decoded_instr <= 0;\n                    result <= 0;\n                    reg_write_addr <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    input [31:0] result,\n    input [4:0] reg_write_addr,\n    output reg [31:0] next_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            next_reg_file <= 0;\n        else begin\n            next_reg_file <= reg_file;\n            next_reg_file[reg_write_addr] <= result;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [2:0] cnt_out;\n    wire [10:0] acc_data;\n    wire accu_valid;\n\n    // Instance of Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Instance of Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .acc_data(acc_data),\n        .accu_valid(accu_valid)\n    );\n\n    // Instance of Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .accu_valid(accu_valid),\n        .valid_out(valid_out)\n    );\n\n    // Output the accumulated data\n    assign data_out = acc_data;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (valid_in) begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [10:0]  acc_data,\n    output reg          accu_valid\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc_data <= 0;\n            accu_valid <= 0;\n        end else if (valid_in) begin\n            acc_data <= acc_data + data_in;\n            accu_valid <= 1;\n        end else begin\n            accu_valid <= 0;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               accu_valid,\n    output reg          valid_out\n);\n\n    reg [1:0] cnt_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            cnt_out <= 0;\n        end else if (accu_valid) begin\n            valid_out <= 0;\n            cnt_out <= 0;\n        end else if (cnt_out == 3) begin\n            valid_out <= 1;\n            cnt_out <= 0;\n        end else begin\n            valid_out <= 0;\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [15:0] abs_dividend, abs_divisor, neg_divisor_mod;\n    wire [7:0] quotient, remainder;\n    wire [2:0] state;\n\n    // Instantiate submodules\n    abs_value abs_dividend_inst(.a(dividend), .b(sign), .result(abs_dividend));\n    abs_value abs_divisor_inst(.a(divisor), .b(sign), .result(abs_divisor));\n    neg_value neg_divisor_mod_inst(.a(divisor), .b(sign), .result(neg_divisor_mod));\n    divider_control ctrl_inst(.clk(clk), .rst(rst), .sign(sign), .dividend(abs_dividend), .divisor(abs_divisor), .neg_mod(neg_divisor_mod), .state(state), .quotient(quotient), .remainder(remainder));\n    result_management res_mgmt_inst(.clk(clk), .rst(rst), .state(state), .remainder(remainder), .quotient(quotient), .opn_valid(opn_valid), .res_valid(res_valid), .res_ready(res_ready), .result(result));\nendmodule\n\n// Submodule: Absolute Value Calculation\nmodule abs_value(a, b, result);\n    input wire [7:0] a;\n    input wire b;\n    output reg [7:0] result;\n\n    always @(a or b) begin\n        if (b) begin\n            result <= -a;\n        end else begin\n            result <= a;\n        end\n    end\nendmodule\n\n// Submodule: Negative Value Calculation\nmodule neg_value(a, b, result);\n    input wire [7:0] a;\n    input wire b;\n    output reg [7:0] result;\n\n    always @(a or b) begin\n        if (b) begin\n            result <= a;\n        end else begin\n            result <= -a;\n        end\n    end\nendmodule\n\n// Submodule: Division Control Logic\nmodule divider_control(clk, rst, sign, dividend, divisor, neg_mod, state, quotient, remainder);\n    input wire clk, rst, sign;\n    input wire [7:0] dividend, divisor, neg_mod;\n    output reg [7:0] quotient, remainder;\n    output reg [2:0] state;\n\n    reg [2:0] count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            state <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else begin\n            case (state)\n                0: begin\n                    state <= 1;\n                    quotient <= 0;\n                    remainder <= dividend;\n                end\n                1: begin\n                    count <= 1;\n                    state <= 2;\n                end\n                2: begin\n                    if (remainder >= neg_mod) begin\n                        remainder <= remainder - neg_mod;\n                        quotient <= quotient + 1;\n                    end\n                    if (count == 7) begin\n                        state <= 3;\n                        count <= 0;\n                    end else begin\n                        count <= count + 1;\n                    end\n                end\n                3: begin\n                    if (remainder >= neg_mod) begin\n                        remainder <= remainder - neg_mod;\n                        quotient <= quotient + 1;\n                    end\n                    if (count == 7) begin\n                        state <= 0;\n                        count <= 0;\n                    end else begin\n                        count <= count + 1;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n\n// Submodule: Result Management\nmodule result_management(clk, rst, state, remainder, quotient, opn_valid, res_valid, res_ready, result);\n    input wire clk, rst, opn_valid, res_ready;\n    input wire [7:"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep_d (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n\n    always @(*) begin\n        dividend = {A, 16'b0};\n        divisor = B;\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    reg [31:0] shift_dividend;\n    reg [15:0] shift_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shift_dividend = dividend;\n        shift_divisor = divisor;\n        temp_quotient = 32'b0;\n        temp_remainder = 32'b0;\n    end\n\n    always @(*) begin\n        while (shift_dividend[31:16] >= shift_divisor) begin\n            shift_dividend = shift_dividend - shift_divisor;\n            temp_quotient = temp_quotient + 32'b1;\n        end\n        temp_remainder = shift_dividend;\n    end\n\n    assign quotient = temp_quotient;\n    assign remainder = temp_remainder;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    wire [15:0] tmp_q, tmp_r;\n    wire [7:0] shifted_dividend, shifted_divisor;\n    wire [4:0] count;\n    \n    div_ctrl ctrl (\n        .dividend(A),\n        .divisor(B),\n        .result(tmp_q),\n        .remainder(tmp_r)\n    );\n    \n    assign result = tmp_q;\n    assign odd = tmp_r;\n    \nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] result,\n    output reg [15:0] remainder\n);\n    reg [7:0] shifted_divisor;\n    reg [4:0] count;\n    \n    always @(*) begin\n        shifted_divisor = divisor;\n        result = 0;\n        remainder = dividend;\n    end\n    \n    always @(posedge dividend[15]) begin\n        count = 0;\n        shifted_divisor = {divisor, 1'b0};\n    end\n    \n    always @(posedge dividend[15] or posedge count[4]) begin\n        if (count[4]) begin\n            result[15:8] = result[7:0];\n            result[7:0] = result[15:8];\n        end\n        else begin\n            result[15:8] = remainder[15:8];\n            result[7:0] = remainder[7:0];\n        end\n        remainder = remainder - shifted_divisor;\n    end\n    \n    always @(posedge dividend[15]) begin\n        count = count + 1;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_complement;\n    wire carry_in;\n\n    assign B_complement = ~B;\n    assign carry_in = 1'b0;\n\n    adder_8bit adder_inst(.a(A), .b(B_complement), .cin(carry_in), .sum(D), .cout(B_out));\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] carry;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    full_adder fa4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    full_adder fa5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    full_adder fa6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    full_adder fa7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] B_internal, S1_out, S2_out;\n    wire B1_out, B2_out;\n\n    // Instance of 16-bit subtractor\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(S1_out),\n        .B_out(B1_out)\n    );\n\n    // Instance of 16-bit subtractor\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs of sub_16bit instances\n    assign Diff[15:0] = S1_out;\n    assign Diff[31:16] = S2_out;\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [15:0] G, P;\n    wire [14:0] G_internal, P_internal;\n    wire [15:0] P_internal_out;\n    wire borrow_internal;\n\n    assign G_internal = A ^ B;\n    assign P_internal = A - B;\n    assign borrow_internal = ~&G_internal;\n\n    assign P_internal_out = {borrow_internal, P_internal[14:0]};\n\n    assign D = P_internal_out;\n    assign B_out = borrow_internal;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire [15:0] D00, D01;\n    wire [15:0] D10, D11;\n    wire borrow0, borrow1;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .borrow_out(borrow0)\n    );\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D1),\n        .borrow_out(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign B_out = borrow1;\nendmodule\n\nmodule sub_32bit(A, B, D, borrow_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output borrow_out;\n\n    wire [15:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D0),\n        .borrow_out(borrow0)\n    );\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D1),\n        .borrow_out(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign borrow_out = borrow1;\nendmodule\n\nmodule sub_16bit(A, B, D, borrow_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output borrow_out;\n\n    wire [7:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .borrow_out(borrow0)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .borrow_out(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign borrow_out = borrow1;\nendmodule\n\nmodule sub_8bit(A, B, D, borrow_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output borrow_out;\n\n    wire [3:0] borrow;\n    wire [3:0] D_bit;\n\n    assign borrow[0] = B[0] & ~A[0];\n    assign borrow[1] = (B[1] & ~A[1]) | (B[1] & A[1] & borrow[0]);\n    assign borrow[2] = (B[2] & ~A[2]) | (B[2] & A[2] & borrow[1]);\n    assign borrow[3] = (B[3] & ~A[3]) | (B[3] & A[3] & borrow[2]);\n\n    assign D_bit[0] = A[0] ^ B[0];\n    assign D_bit[1] = A[1] ^ B[1];\n    assign D_bit[2] = A[2] ^ B[2];\n    assign D_bit[3] = A[3] ^ B[3];\n\n    assign D = {D_bit, borrow};\n    assign borrow_out = borrow[3];\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [16:1] B_out_w;\n    wire [3:0] borrow_out_w;\n\n    // Instance of four 4-bit full subtractors\n    sub_4bit sub1(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(borrow_out_w[0]));\n    sub_4bit sub2(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(borrow_out_w[1]));\n    sub_4bit sub3(.A(A[11:8]), .B(B[11:8]), .D(D[11:8]), .B_out(borrow_out_w[2]));\n    sub_4bit sub4(.A(A[15:12]), .B(B[15:12]), .D(D[15:12]), .B_out(borrow_out_w[3]));\n\n    // Calculate borrow-out\n    assign B_out = borrow_out_w[3];\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [4:0] B_out_w;\n    wire [1:0] borrow_out_w;\n\n    // Instance of two 2-bit full subtractors\n    sub_2bit sub1(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(borrow_out_w[0]));\n    sub_2bit sub2(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(borrow_out_w[1]));\n\n    // Calculate borrow-out\n    assign B_out = borrow_out_w[1];\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0] A, B;\n    output [1:0] D;\n    output B_out;\n\n    wire [2:0] B_out_w;\n\n    // Instance of 1-bit full subtractor\n    full_subtractor sub1(.A(A[1]), .B(B[1]), .D(D[1]), .B_out(B_out_w[1]));\n\n    // Calculate borrow-out\n    assign B_out = B_out_w[1];\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input A, B;\n    output D, B_out;\n\n    // Calculate D and borrow\n    assign D = A ^ B ^ B_out;\n    assign B_out = ~(A & B) | (B_out & B);\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    assign A_greater = ~borrow & (sub_result != 0);\n    assign A_equal = ~borrow & (sub_result == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result, \n    output borrow\n);\n\n    wire [31:0] B_complement;\n    wire [31:0] B_sum;\n\n    assign B_complement = ~B + 1;\n    assign B_sum = A + B_complement;\n\n    assign sub_result = B_sum;\n    assign borrow = B_sum[31];\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:0] S1,S2,S3;\nwire C1,C2,C3;\n\nCLA1 CLA1(.A(A[31:16]),.B(B[31:16]),.S(S1),.Cin(1'b0),.Cout(C1));\nCLA1 CLA2(.A(A[15:0]),.B(B[15:0]),.S(S2),.Cin(C1),.Cout(C2));\nCLA32 CLA32(.A(A[31:16]),.B(B[31:16]),.S(S3),.Cin(C2),.Cout(C3));\n\nassign S = {S3,S2,S1};\nassign C32 = C3;\n\nendmodule\n\nmodule CLA1(A,B,S,Cin,Cout);\ninput [15:0] A,B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [15:0] G,P,C;\n\nassign G = A & B;\nassign P = A ^ B;\nassign C = {Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin};\n\nassign S = P ^ C;\nassign Cout = P & C;\n\nendmodule\n\nmodule CLA32(A,B,S,Cin,Cout);\ninput [31:0] A,B;\ninput Cin;\noutput [31:0] S;\noutput Cout;\n\nwire [31:0] G,P,C;\n\nassign G = A & B;\nassign P = A ^ B;\nassign C = {Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin,Cin};\n\nassign S = P ^ C;\nassign Cout = P & C;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    // Four 4-bit ripple carry adders\n    rca1 rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n    rca1 rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n    rca1 rca3(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n    rca1 rca4(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    assign cout = carry[3];\nendmodule\n\nmodule rca1(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] sum1, sum2;\n    wire cout1, cout2;\n\n    adder_4bit adder1(.a(a), .b(b), .cin(cin), .sum(sum1), .cout(cout1));\n    adder_4bit adder2(.a(a), .b(b), .cin(1'b1), .sum(sum2), .cout(cout2));\n\n    assign sum = sum1 ^ sum2;\n    assign cout = cout1 ^ cout2;\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    // Full adder for 4-bit adders\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    // Two slices for each 4 bits\n    carry_select_adder_slice csa_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n    carry_select_adder_slice csa_slice2(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n    carry_select_adder_slice csa_slice3(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [15:0] sum;\n    wire carry;\n\n    // Instantiate 8-bit adder\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .sum(sum[7:0]),\n        .Co(carry)\n    );\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .sum(sum[15:8]),\n        .Co(Co)\n    );\n\n    assign y = sum;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] sum,\n    output wire Co\n);\n    wire [7:0] c;\n    genvar i;\n\n    // Generate full adder trees\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : full_adder_tree\n            full_adder fa (.a(a[i]), .b(b[i]), .Cin(Cin), .sum(sum[i]), .Cout(c[i]));\n            if (i == 0)\n                assign Co = c[i];\n            else\n                assign Cin = c[i];\n        end\n    endgenerate\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire sum,\n    output wire Cout\n);\n    assign sum = a ^ b ^ Cin;\n    assign Cout = (a & b) | (Cin & (a ^ b));\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [3:0] carry;\n\n    fa FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    fa FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    fa FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    fa FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    fa FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    fa FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    fa FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    fa FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule fa(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [3:0] count;   // Counter for multiplier unit.\n    wire start_shift;   // Start signal for multiplier unit.\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(start | count[3]),\n        .done(done)\n    );\n\n    // Register unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift(start_shift),\n        .count(count)\n    );\n\n    // Multiplier unit\n    mul_unit mul_unit (\n        .clk(clk),\n        .shift(start_shift),\n        .count(count),\n        .yout(yout)\n    );\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input shift,        // Start signal for multiplier unit.\n    output reg done     // Chip output flag signal.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 0;\n        end else if (shift) begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input shift,        // Start signal for multiplier unit.\n    output reg [3:0] count // Counter for multiplier unit.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (start) begin\n            count <= 0;\n        end else if (shift) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule mul_unit (\n    input clk,          // Chip clock signal.\n    input shift,        // Start signal for multiplier unit.\n    input [3:0] count,  // Counter for multiplier unit.\n    output reg [31:0] yout // Product output with a data width of 32 bits.\n);\n\n    reg [15:0] mul_reg; // Multiplier register.\n\n    always @(posedge clk) begin\n        if (shift) begin\n            mul_reg <= bin << count;\n            yout <= mul_reg;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the logic module to calculate next count\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register module to update the current count\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            if (up_down) begin\n                next_count <= current_count + 1;\n            end else begin\n                next_count <= current_count - 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Instantiate state initialization submodule\n    init state_init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // Instantiate state transition submodule\n    transition state_transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\n// Submodule for state initialization\nmodule init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001; // Initial state\n        end\n    end\nendmodule\n\n// Submodule for state transition\nmodule transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001; // Reset to initial state\n        end else begin\n            out <= (out == 8'b1111_1110) ? 8'b0000_0001 : out << 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    // Counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count)\n    );\n\n    // Output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_in(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end\n        else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end\n            else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end\n        else if (valid_count) begin\n            out <= count_in;\n        end\n    end\n\nendmodule\n```\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instance of the register\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q_next(next_Q)\n    );\n\n    // Instance of the logic\n    JC_logic logic_inst(\n        .Q_current(Q),\n        .Q_next(next_Q)\n    );\n\nendmodule\n\n// Submodule for the register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_next <= 64'b0;\n        end else begin\n            Q_next <= Q_next + 1;\n        end\n    end\n\nendmodule\n\n// Submodule for the logic\nmodule JC_logic(\n    input [63:0]         Q_current,\n    output reg [63:0]    Q_next\n);\n\n    always @(*) begin\n        Q_next = Q_current ^ (Q_current >> 1);\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_in_internal;\n\n    assign CLK_in_internal = CLK_in;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in_internal),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in_internal),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in_internal),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 1) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 4) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 49) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_div_4, clk_div_3;\n\n    // Counter Submodule\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_4)\n    );\n\n    // Clock Average Generator Submodule\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div_4(clk_div_4),\n        .clk_div_3(clk_div_3)\n    );\n\n    // Clock Adjustment Submodule\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div_4(clk_div_4),\n        .clk_div_3(clk_div_3)\n    );\n\n    assign clk_div = clk_div_4 | clk_div_3;\n\nendmodule\n\n// Counter Submodule\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\n    localparam MUL2_DIV_CLK = 7;\n\n    reg [2:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == MUL2_DIV_CLK - 1) begin\n            cnt <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\n// Clock Average Generator Submodule\nmodule clk_average(\n    input               clk,\n    input               clk_div_4,\n    input               clk_div_3,\n    output reg          clk_div\n);\n\n    always @(posedge clk) begin\n        clk_div <= clk_div_3 & clk_div_4;\n    end\n\nendmodule\n\n// Clock Adjustment Submodule\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_4,\n    input               clk_div_3,\n    output reg          clk_div_3_negedge,\n    output reg          clk_div_4_negedge\n);\n\n    always @(negedge clk) begin\n        clk_div_3_negedge <= clk_div_3;\n        clk_div_4_negedge <= clk_div_4;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [2:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end\n        else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n        else begin\n            clk_div <= 1;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [2:0] cnt;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end\n        else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n        else begin\n            clk_div <= 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nlocalparam NUM_DIV = 4;\n\nwire [3:0] count;\nwire toggle;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count),\n    .toggle(toggle)\n);\n\nclk_divider u_clk_divider(\n    .clk(clk),\n    .rst_n(rst_n),\n    .toggle(toggle),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count,\n    output toggle\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n    end else if (count == NUM_DIV/2 - 1) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign toggle = (count == NUM_DIV/2 - 1);\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input toggle,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (toggle) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_res, sub_res, and_res, or_res, xor_res, nor_res;\n    wire [31:0] sll_res, srl_res, sra_res, sllv_res, srlv_res, srav_res;\n    wire [31:0] add_carry, sub_carry;\n    wire [31:0] slt_res, sltu_res;\n\n    // Submodules\n    adder add(\n        .a(a),\n        .b(b),\n        .res(add_res),\n        .carry(add_carry)\n    );\n    adder_u addu(\n        .a(a),\n        .b(b),\n        .res(sub_res),\n        .carry(sub_carry)\n    );\n    sub_module sub(\n        .a(a),\n        .b(b),\n        .res(sub_res),\n        .carry(sub_carry)\n    );\n    and_module and1(\n        .a(a),\n        .b(b),\n        .res(and_res)\n    );\n    or_module or1(\n        .a(a),\n        .b(b),\n        .res(or_res)\n    );\n    xor_module xor1(\n        .a(a),\n        .b(b),\n        .res(xor_res)\n    );\n    nor_module nor1(\n        .a(a),\n        .b(b),\n        .res(nor_res)\n    );\n    slt_module slt_inst(\n        .a(a),\n        .b(b),\n        .res(slt_res)\n    );\n    sltu_module sltu_inst(\n        .a(a),\n        .b(b),\n        .res(sltu_res)\n    );\n    sll_module sll(\n        .a(a),\n        .b(b),\n        .res(sll_res)\n    );\n    srl_module srl(\n        .a(a),\n        .b(b),\n        .res(srl_res)\n    );\n    sra_module sra(\n        .a(a),\n        .b(b),\n        .res(sra_res)\n    );\n    sllv_module sllv(\n        .a(a),\n        .b(b),\n        .res(sllv_res)\n    );\n    srlv_module srlv(\n        .a(a),\n        .b(b),\n        .res(srlv_res)\n    );\n    srav_module srav(\n        .a(a),\n        .b(b),\n        .res(srav_res)\n    );\n    lui_module lui_inst(\n        .b(b),\n        .res(r)\n    );\n\n    assign r = aluc[5:4] == 2'b00 ? add_res :\n               aluc[5:4] == 2'b01 ? addu_res :\n               aluc[5:4] == 2'b10 ? sub_res :\n               aluc[5:4] == 2'b11 ? sub_res :\n               aluc[5:4] == 2'b10 ? sll_res :\n               aluc[5:4] == 2'b11 ? srl_res :\n               aluc[5:4] == 2'b11 ? sra_res :\n               aluc[5:4] == 2'b10 ? sllv_res :\n               aluc[5:4] == 2'b11 ? srlv_res :\n               aluc[5:4] == 2'b11 ? srav_res :\n               aluc[5:4] == 2'b00 ? and_res :\n               aluc[5:4] == 2'b01 ? or_res :\n               aluc[5:4] == 2'b10 ? xor_res :\n               aluc[5:4] == 2'b11 ? nor"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] product;\n\n    // Instantiate the multiplier\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .p(product)\n    );\n\n    // Instantiate the accumulator\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .p(product),\n        .c(c)\n    );\nendmodule\n\n// Module for multiplier\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] p\n);\n    assign p = a * b;\nendmodule\n\n// Module for accumulator\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] p,\n    output reg [31:0] c\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            c <= 32'b0;\n        end else begin\n            c <= c + p[31:0];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\ncounter cnt(.clk(clk), .freq(freq), .count(count));\nwave_generator wg(.clk(clk), .count(count), .freq(freq), .wave_out(wave_out));\n\nendmodule\n\nmodule counter(\n    input clk,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count % (freq / 2) == 0) begin\n            wave_out <= ~wave_out;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    wire inc_dec;\n\n    // State control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .inc_dec(inc_dec)\n    );\n\n    // Waveform generation module\n    waveform_gen wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .inc_dec(inc_dec),\n        .wave(wave)\n    );\n\nendmodule\n\n// State control module\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg inc_dec\n);\n\n    reg [1:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n            inc_dec <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    state <= 2'b01;\n                    inc_dec <= 1;\n                end\n                2'b01: begin\n                    state <= 2'b00;\n                    inc_dec <= 0;\n                end\n                default: begin\n                    state <= 2'b00;\n                    inc_dec <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Waveform generation module\nmodule waveform_gen (\n    input clk,\n    input rst_n,\n    input inc_dec,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 0;\n        end else begin\n            if (inc_dec) begin\n                wave <= wave + 1;\n            end else begin\n                wave <= wave - 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [2:0] q_wire;\n\n    my_dff8 u0 (clk, d, 0, q_wire[0]);\n    my_dff8 u1 (clk, q_wire[0], 1, q_wire[1]);\n    my_dff8 u2 (clk, q_wire[1], 2, q_wire[2]);\n\n    always @ (sel or q_wire) begin\n        case (sel)\n            2'b00: q = q_wire[0];\n            2'b01: q = q_wire[1];\n            2'b10: q = q_wire[2];\n            2'b11: q = d;\n            default: q = 8'bZ;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    input cnt,\n    output reg [7:0] q\n);\n    always @ (posedge clk) begin\n        if (cnt == 0)\n            q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\nwire [7:0] shifted_by_4, shifted_by_2, shifted_by_1;\nwire [7:0] shifted_by_4_muxed, shifted_by_2_muxed, shifted_by_1_muxed;\n\n// Shift by 4\nassign shifted_by_4 = in << 4;\nassign shifted_by_4_muxed = ctrl[2] ? shifted_by_4 : in;\n\n// Shift by 2\nassign shifted_by_2 = shifted_by_4_muxed << 2;\nassign shifted_by_2_muxed = ctrl[1] ? shifted_by_2 : shifted_by_4_muxed;\n\n// Shift by 1\nassign shifted_by_1 = shifted_by_2_muxed << 1;\nassign shifted_by_1_muxed = ctrl[0] ? shifted_by_1 : shifted_by_2_muxed;\n\n// Final output\nassign out = shifted_by_1_muxed;\n\n// Multiplexer\nmodule mux2X1 (sel, a, b, y);\ninput sel;\ninput a, b;\noutput y;\nassign y = sel ? b : a;\nendmodule\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  assign b1 = rst ? 16'd0 : b0;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 0;\n    else\n      c <= c + a * b;\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch_instr;\n  wire [31:0] decode_instr;\n  wire [31:0] execute_res;\n  wire [31:0] memory_res;\n  wire [31:0] writeback_res;\n  wire [31:0] pc;\n\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .fetch_instr(fetch_instr));\n  decode_stage decode(.clk(clk), .instr(fetch_instr), .decode_instr(decode_instr));\n  execute_stage execute(.clk(clk), .instr(decode_instr), .execute_res(execute_res));\n  memory_stage memory(.clk(clk), .instr(decode_instr), .res(execute_res), .memory_res(memory_res));\n  writeback_stage writeback(.clk(clk), .instr(decode_instr), .res(memory_res), .reg_file(reg_file), .res_reg_file(writeback_res));\n\n  assign res_reg_file = writeback_res;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] fetch_instr\n);\n  reg [31:0] fetched_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      fetched_instr <= 0;\n    else\n      fetched_instr <= instr_mem[pc];\n  end\n\n  assign fetch_instr = fetched_instr;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] instr,\n  output [31:0] decode_instr\n);\n  assign decode_instr = instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [31:0] instr,\n  output [31:0] execute_res\n);\n  wire [4:0] rs1, rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  wire [31:0] res;\n\n  assign {op, rs2, rs1, rd} = instr;\n  assign res = (op == 6'b001001) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\n\n  always @(posedge clk) begin\n    execute_res <= res;\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] instr,\n  input [31:0] res,\n  output [31:0] memory_res\n);\n  assign memory_res = res;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] instr,\n  input [31:0] res,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [4:0] rd;\n\n  assign rd = instr[31:27];\n\n  always @(posedge clk) begin\n    reg_file[rd] <= res;\n    res_reg_file[rd] <= reg_file[rd];\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [31:0] b0_d, b1_d, b2_d, b3_d;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      c0_reg <= c0_reg + b0 * a0;\n      c1_reg <= c1_reg + b1 * a1;\n      c2_reg <= c2_reg + b2 * a2;\n      c3_reg <= c3_reg + b3 * a3;\n    end\n  end\n  \n  assign b0_d = b0;\n  assign b1_d = b1;\n  assign b2_d = b2;\n  assign b3_d = b3;\n  \n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b_d,\n  output [31:0] c\n);\n  reg [15:0] b;\n  reg [31:0] c_reg;\n  wire [31:0] p;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b <= 0;\n      c_reg <= 0;\n    end else begin\n      b <= b_d;\n      c_reg <= c_reg + p;\n    end\n  end\n  \n  assign p = a * b;\n  \n  assign c = c_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] rd;\n    wire [4:0] rs1, rs2;\n    wire [4:0] pc;\n    wire [1:0] op;\n    \n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .pc(pc), .instr(instr));\n    execute_stage execute(.clk(clk), .instr(instr), .reg_file(reg_file), .op1(op1), .op2(op2), .rd(rd), .result(result), .rs1(rs1), .rs2(rs2), .op(op));\n    writeback_stage writeback(.clk(clk), .result(result), .rd(rd), .reg_file(reg_file), .out_reg_file(out_reg_file));\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] instr,\n    output [4:0] pc\n);\n    reg [31:0] fetched_instr;\n    reg [4:0] current_pc;\n    always @(posedge clk or posedge rst) begin\n        if (rst) current_pc <= 0;\n        else begin\n            current_pc <= current_pc + 1;\n            fetched_instr <= instr_mem[current_pc];\n        end\n    end\n    assign instr = fetched_instr;\n    assign pc = current_pc;\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [4:0] rd,\n    output [31:0] result,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [1:0] op\n);\n    reg [31:0] op1_reg, op2_reg, result_reg;\n    reg [4:0] rd_reg, rs1_reg, rs2_reg;\n    reg [1:0] op_reg;\n    always @(posedge clk) begin\n        op1_reg <= reg_file[rs1];\n        op2_reg <= reg_file[rs2];\n        op_reg <= instr[6:5];\n        rd_reg <= instr[11:7];\n        rs1_reg <= instr[19:15];\n        rs2_reg <= instr[24:20];\n        result_reg <= 0;\n    end\n    assign op1 = op1_reg;\n    assign op2 = op2_reg;\n    assign rd = rd_reg;\n    assign rs1 = rs1_reg;\n    assign rs2 = rs2_reg;\n    assign op = op_reg;\n    assign result = (op == 2'b00) ? op1_reg + op2_reg : op1_reg - op2_reg;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk) begin\n        reg_file[rd] <= result;\n        out_reg_file <= reg_file[rd];\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_value;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_value(cnt_value)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .cnt_value(cnt_value),\n        .data_out(data_out)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg [1:0]    cnt_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_value <= 2'b00;\n        else if (valid_in)\n            cnt_value <= cnt_value + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [1:0]   cnt_value,\n\n    output reg [9:0]    data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 10'd0;\n        else if (cnt_value == 2'b11) begin\n            data_out <= data_out + data_in;\n            data_out <= data_out;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg          valid_out\n);\n\n    reg [1:0] cnt_value;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            cnt_value <= 2'b00;\n        end else if (valid_in) begin\n            valid_out <= 1'b0;\n            cnt_value <= cnt_value + 1;\n        end else if (cnt_value == 2'b11) begin\n            valid_out <= 1'b1;\n            cnt_value <= 2'b00;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend, neg_divisor;\n    wire [15:0] quotient;\n    wire [3:0] counter;\n\n    assign abs_dividend = (sign) ? -dividend : dividend;\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    div_ctrl ctrl (.clk(clk), .rst(rst), .opn_valid(opn_valid), .res_ready(res_ready), .res_valid(res_valid), .counter(counter));\n    div_mgmt res_mgmt (.clk(clk), .counter(counter), .quotient(quotient), .result(result), .res_valid(res_valid));\n\nendmodule\n\nmodule div_ctrl(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [3:0] counter\n);\n\n    reg [3:0] shift_cnt;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            counter <= 0;\n            res_valid <= 0;\n            shift_cnt <= 0;\n        end\n        else if(opn_valid) begin\n            counter <= 1;\n            shift_cnt <= 0;\n            res_valid <= 0;\n        end\n        else if(~res_ready) begin\n            counter <= counter + 1;\n            shift_cnt <= shift_cnt + 1;\n        end\n        else if(shift_cnt == 4) begin\n            res_valid <= 1;\n            shift_cnt <= 0;\n        end\n        else begin\n            res_valid <= 0;\n        end\n    end\n\nendmodule\n\nmodule div_mgmt(\n    input wire clk,\n    input wire [3:0] counter,\n    input wire [15:0] quotient,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\n    always @(posedge clk) begin\n        if(counter == 0) begin\n            result <= quotient;\n            res_valid <= 1;\n        end\n        else if(counter == 1) begin\n            result <= quotient;\n            res_valid <= 0;\n        end\n        else begin\n            res_valid <= 0;\n        end\n    end\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] in_value,\n    output wire [7:0] out_value\n);\n\n    assign out_value = (in_value[7]) ? -in_value : in_value;\n\nendmodule\n\nmodule neg_value(\n    input wire [7:0] in_value,\n    output wire [7:0] out_value\n);\n\n    assign out_value = -in_value;\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [63:0] D;\n    wire [15:0] Q;\n    wire [31:0] R;\n\n    // Prepare dividend\n    prep_dividend prep(\n        .A(A),\n        .B(B),\n        .D(D),\n        .Q(Q),\n        .R(R)\n    );\n\n    // Perform division\n    div_operation div_op(\n        .D(D),\n        .Q(Q),\n        .R(R)\n    );\n\n    assign result = Q;\n    assign odd = R;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [63:0] D,\n    output reg [15:0] Q,\n    output reg [31:0] R\n);\n\n    // Prepare dividend\n    always @(*) begin\n        D = {{(32-16){A[31]}}, A};\n        Q = 0;\n        R = D;\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [63:0] D,\n    output reg [15:0] Q,\n    output reg [31:0] R\n);\n\n    reg [15:0] shifted;\n\n    always @(*) begin\n        // Shift dividend\n        shifted = D >> 16;\n        // Compare and subtract\n        if (shifted >= D[31:16]) begin\n            Q = Q + 1;\n            R = R - D[31:16];\n        end\n        D = shifted;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result, temp_odd;\n\n    // Instantiate the divider control unit\n    div_ctrl ctrl (\n        .dividend(A),\n        .divisor(B),\n        .quotient(temp_result),\n        .remainder(temp_odd)\n    );\n\n    // Assign output ports\n    assign result = temp_result;\n    assign odd = temp_odd;\n\nendmodule\n\n// Submodule for the divider logic\nmodule div_ctrl (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    // Temporary variables\n    reg [7:0] shifted_divisor, shifted_dividend;\n    reg [15:0] temp_result, temp_remainder;\n    reg [3:0] bit_count;\n\n    always @(*) begin\n        // Shift divisor and dividend\n        shifted_divisor = divisor << bit_count;\n        shifted_dividend = dividend << bit_count;\n\n        // Perform division logic\n        if (shifted_dividend >= shifted_divisor) begin\n            temp_result = quotient;\n            temp_result[bit_count] = 1'b1;\n            quotient = temp_result;\n            temp_remainder = remainder;\n            temp_remainder = temp_remainder - shifted_divisor;\n            remainder = temp_remainder;\n        end\n\n        // Increment bit count\n        bit_count = bit_count + 1;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire borrow;\n\nassign B_comp = ~B + 1;\n\nadder_8bit adder_inst(.A(A), .B(B_comp), .D(D), .B_out(borrow));\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] carry;\n\nfull_adder FA0(.a(A[0]), .b(B[0]), .cin(1'b0), .sum(D[0]), .cout(carry[0]));\nfull_adder FA1(.a(A[1]), .b(B[1]), .cin(carry[0]), .sum(D[1]), .cout(carry[1]));\nfull_adder FA2(.a(A[2]), .b(B[2]), .cin(carry[1]), .sum(D[2]), .cout(carry[2]));\nfull_adder FA3(.a(A[3]), .b(B[3]), .cin(carry[2]), .sum(D[3]), .cout(carry[3]));\nfull_adder FA4(.a(A[4]), .b(B[4]), .cin(carry[3]), .sum(D[4]), .cout(carry[4]));\nfull_adder FA5(.a(A[5]), .b(B[5]), .cin(carry[4]), .sum(D[5]), .cout(carry[5]));\nfull_adder FA6(.a(A[6]), .b(B[6]), .cin(carry[5]), .sum(D[6]), .cout(carry[6]));\nfull_adder FA7(.a(A[7]), .b(B[7]), .cin(carry[6]), .sum(D[7]), .cout(B_out));\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\n\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1_out),\n    .B_out(B_out)\n);\n\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2_out),\n    .B_out(/* dummy output */)\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [14:0] C;\nwire b_out_int;\n\n// Compute carry\nassign C[14:0] = A[14:0] - B[14:0];\nassign b_out_int = (~A[14] & B[14]) | (C[14] & (~A[14] | B[14]));\n\n// Generate difference\nassign Diff = C[14:0];\nassign B_out = b_out_int;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n    \n    wire [63:0] B_compl, B_out_inter;\n    wire borrow_out;\n    \n    // Complement B\n    assign B_compl = ~B + 1'b1;\n    \n    // Subtractor\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B_compl[31:0]),\n        .D(D[31:0]),\n        .B_out(borrow_out)\n    );\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B_compl[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out_inter)\n    );\n    assign B_out = borrow_out | B_out_inter;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n    \n    wire [31:0] B_compl;\n    wire borrow_out;\n    \n    // Complement B\n    assign B_compl = ~B + 1'b1;\n    \n    // Subtractor\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B_compl[15:0]),\n        .D(D[15:0]),\n        .B_out(borrow_out)\n    );\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B_compl[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n    \n    wire [15:0] B_compl;\n    wire borrow_out;\n    \n    // Complement B\n    assign B_compl = ~B + 1'b1;\n    \n    // Subtractor\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B_compl[7:0]),\n        .D(D[7:0]),\n        .B_out(borrow_out)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B_compl[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n    \n    wire [7:0] B_compl;\n    wire borrow_out;\n    \n    // Complement B\n    assign B_compl = ~B + 1'b1;\n    \n    // Subtractor\n    full_subtractor fs0(\n        .A(A[3:0]),\n        .B(B_compl[3:0]),\n        .D(D[3:0]),\n        .B_out(borrow_out)\n    );\n    full_subtractor fs1(\n        .A(A[7:4]),\n        .B(B_compl[7:4]),\n        .D(D[7:4]),\n        .B_out(borrow_out)\n    );\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0]"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow[0:14];\n\nsub_4bit sub1(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_out(borrow[0])\n);\nsub_4bit sub2(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .B_out(borrow[1])\n);\nsub_4bit sub3(\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .B_out(borrow[2])\n);\nsub_4bit sub4(\n    .A(A[15:12]),\n    .B(B[15:12]),\n    .B_out(borrow[3])\n);\n\nassign D = {borrow[3], borrow[2], borrow[1], borrow[0]} - B;\nassign B_out = borrow[0];\nendmodule\n\nmodule sub_4bit(A, B, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] B_out;\n\nwire [4:0] borrow;\n\nassign borrow[0] = B[0] ^ A[0];\nassign B_out[0] = A[0] & B[0];\n\ngenvar i;\ngenerate\n    for(i = 1; i < 4; i = i + 1) begin : gen\n        assign borrow[i] = B[i] ^ A[i] ^ borrow[i-1];\n        assign B_out[i] = A[i] & B[i] | A[i] & borrow[i-1] | borrow[i-1] & B[i];\n    end\nendgenerate\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] difference;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .Difference(difference),\n        .Borrow(borrow)\n    );\n\n    assign A_greater = difference[31];\n    assign A_equal = ~|difference;\n    assign A_less = ~borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Difference,\n    output Borrow\n);\n    wire [31:0] temp_diff;\n    wire [31:0] borrow_chain;\n    wire borrow_internal;\n    wire [31:0] borrow_chain_internal;\n\n    assign borrow_internal = (A[0] & ~B[0]);\n    assign borrow_chain[0] = borrow_internal;\n    assign borrow_chain_internal[0] = borrow_internal;\n\n    genvar i;\n    generate\n        for (i = 1; i < 32; i = i + 1) begin : bit_level_subtractor\n            assign temp_diff[i] = A[i] ^ B[i] ^ borrow_chain[i-1];\n            assign borrow_chain[i] = (~A[i] & B[i]) | (A[i] & borrow_chain[i-1]);\n            assign borrow_chain_internal[i] = borrow_chain[i-1];\n        end\n    endgenerate\n\n    assign Difference = temp_diff;\n    assign Borrow = borrow_chain[31];\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\n\nwire [16:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15;\nwire [16:1] C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15;\n\nCLA CLA1(.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S1), .Cout(C1));\nCLA CLA2(.A(A[32:17]), .B(B[32:17]), .Cin(1'b0), .S(S2), .Cout(C2));\nCLA CLA3(.A(A[16:1]), .B(B[32:17]), .Cin(1'b0), .S(S3), .Cout(C3));\nCLA CLA4(.A(A[17:1]), .B(B[32:18]), .Cin(1'b0), .S(S4), .Cout(C4));\nCLA CLA5(.A(A[32:18]), .B(B[32:19]), .Cin(1'b0), .S(S5), .Cout(C5));\nCLA CLA6(.A(A[17:1]), .B(B[32:19]), .Cin(1'b0), .S(S6), .Cout(C6));\nCLA CLA7(.A(A[18:1]), .B(B[32:20]), .Cin(1'b0), .S(S7), .Cout(C7));\nCLA CLA8(.A(A[32:20]), .B(B[32:21]), .Cin(1'b0), .S(S8), .Cout(C8));\nCLA CLA9(.A(A[18:1]), .B(B[32:21]), .Cin(1'b0), .S(S9), .Cout(C9));\nCLA CLA10(.A(A[19:1]), .B(B[32:22]), .Cin(1'b0), .S(S10), .Cout(C10));\nCLA CLA11(.A(A[32:22]), .B(B[32:23]), .Cin(1'b0), .S(S11), .Cout(C11));\nCLA CLA12(.A(A[19:1]), .B(B[32:23]), .Cin(1'b0), .S(S12), .Cout(C12));\nCLA CLA13(.A(A[20:1]), .B(B[32:24]), .Cin(1'b0), .S(S13), .Cout(C13));\nCLA CLA14(.A(A[32:24]), .B(B[32:25]), .Cin(1'b0), .S(S14), .Cout(C14));\nCLA CLA15(.A(A[20:1]), .B(B[32:25]), .Cin(1'b0), .S(S15), .Cout(C15));\n\nassign S = {S15,S14,S13,S12,S11,S10,S9,S8,S7,S6,S5,S4,S3,S2,S1};\nassign C32 = C15;\n\nendmodule\n\nmodule CLA(A,B,Cin,S,Cout);\ninput [16:1] A;\ninput [16:1] B;\ninput Cin;\noutput [16:1] S;\noutput C"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2;\n\n    adder_4bit rca1(.a(a), .b(b), .cin(cin), .sum(sum), .cout(c1));\n    adder_4bit rca2(.a(a), .b(b), .cin(c1), .sum(sum), .cout(c2));\n    adder_4bit rca3(.a(a), .b(b), .cin(c2), .sum(sum), .cout(cout));\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] p, g;\n    assign p = a ^ b;\n    assign g = a & b;\n\n    assign sum = p ^ cin;\n    assign cout = (p & cin) | (g & cin);\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] s1, s2, s3, s4;\n    wire c1, c2, c3, c4;\n\n    adder_16bit_csa csa_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s1), .cout(c1));\n    adder_16bit_csa csa_slice2(.a(a[7:4]), .b(b[7:4]), .cin(c1), .sum(s2), .cout(c2));\n    adder_16bit_csa csa_slice3(.a(a[11:8]), .b(b[11:8]), .cin(c2), .sum(s3), .cout(c3));\n    adder_16bit_csa csa_slice4(.a(a[15:12]), .b(b[15:12]), .cin(c3), .sum(s4), .cout(c4));\n\n    assign sum = {s4, s3, s2, s1};\n    assign cout = c4;\nendmodule\n\nmodule adder_16bit_csa(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2;\n\n    adder_4bit rca1(.a(a), .b(b), .cin(cin), .sum(sum), .cout(c1));\n    adder_4bit rca2(.a(a), .b(b), .cin(c1), .sum(sum), .cout(c2));\n    adder_4bit rca3(.a(a), .b(b), .cin(c2), .sum(sum), .cout(cout));\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n    wire [15:0] sum;\n\n    // Instantiate 8-bit adders.\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(sum[7:0]),\n        .Co(carry[0])\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(sum[15:8]),\n        .Co(carry[1])\n    );\n\n    assign y = sum;\n    assign Co = carry[1];\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n    wire [7:0] carry;\n\n    // 8-bit full adder implementation.\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [2:0] carry;\n\n    adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    adder FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    adder FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    adder FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    adder FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    adder FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    adder FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    adder FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nreg done_r;\nreg [3:0] shift_cnt;\nreg [31:0] prod_reg;\n\n// Control Unit\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .shift_cnt(shift_cnt)\n);\n\n// Register Unit\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .shift_cnt(shift_cnt),\n    .ain(ain),\n    .bin(bin),\n    .prod_reg(prod_reg)\n);\n\n// Multiplier Unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .prod_reg(prod_reg)\n);\n\n// Output Assignment\nassign yout = prod_reg;\nassign done = done_r;\n\nendmodule\n\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [3:0] shift_cnt // Shift count register.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0;\n    end else if (start) begin\n        shift_cnt <= 4'b0;\n    end else begin\n        shift_cnt <= shift_cnt + 1'b1;\n    end\nend\n\nendmodule\n\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [3:0] shift_cnt, // Shift count register.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] prod_reg // Product register.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        prod_reg <= 32'b0;\n    end else if (start) begin\n        prod_reg <= {16'b0, ain};\n    end else begin\n        prod_reg <= {prod_reg[30:0], prod_reg[31] & bin[shift_cnt]};\n    end\nend\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [31:0] prod_reg // Product register.\n);\n\nalways @(posedge clk) begin\n    // Multiplier operation logic\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n\n    // Instance of the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(current_count),\n        .next_count(next_count)\n    );\n\n    // Instance of the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(current_count)\n    );\n\n    // Output the current count\n    assign count = current_count;\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_count <= 16'b0000000000000000;\n        else if (up_down)\n            next_count <= current_count + 1;\n        else\n            next_count <= current_count - 1;\n    end\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 16'b0000000000000000;\n        else\n            current_count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] state_init, state_next;\n    wire [7:0] state_trans;\n\n    state_init_submodule init (\n        .clk(clk),\n        .reset(reset),\n        .state_init(state_init)\n    );\n\n    state_transition_submodule transition (\n        .clk(clk),\n        .reset(reset),\n        .state_init(state_init),\n        .state_trans(state_trans)\n    );\n\n    assign out = state_trans;\n\nendmodule\n\nmodule state_init_submodule (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] state_init\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state_init <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule state_transition_submodule (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state_init,\n    output reg [7:0] state_trans\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state_trans <= state_init;\n        end else begin\n            state_trans <= (state_trans == 8'b1111_1111) ? state_init : state_trans << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n    wire [3:0] next_count;\n    wire [3:0] next_out;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(next_out)\n    );\n\n    assign out = next_out;\n\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] next_count\n);\n\n    reg [3:0] cnt_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_r <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                cnt_r <= 4'b0000;\n            end else begin\n                cnt_r <= count + 1;\n            end\n        end\n    end\n\n    assign next_count = cnt_r;\n\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n    wire [63:0] cur_Q;\n\n    // Instantiate the register and logic modules\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(cur_Q)\n    );\n\n    JC_logic logic_inst (\n        .cur_Q(cur_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = cur_Q;\n\nendmodule\n\n// Submodule for the register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= Q + 64'b1;\n    end\n\nendmodule\n\n// Submodule for the logic\nmodule JC_logic(\n    input [63:0] cur_Q,\n    output reg [63:0] next_Q\n);\n\n    always @(*) begin\n        next_Q = cur_Q & (cur_Q - 1);\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_in_div_by_2;\n    wire clk_in_div_by_10;\n    wire clk_in_div_by_100;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 1) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_4cycles;\nwire clk_3cycles;\n\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_4cycles(clk_4cycles),\n    .clk_3cycles(clk_3cycles)\n);\n\nclk_average u_clk_average (\n    .clk(clk_4cycles),\n    .clk_3cycles(clk_3cycles),\n    .clk_div(clk_div)\n);\n\nclk_adjustment u_clk_adjustment (\n    .clk(clk),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_4cycles,\n    output reg          clk_3cycles\n);\n    reg [2:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_4cycles <= 0;\n            clk_3cycles <= 0;\n        end else if (cnt == MUL2_DIV_CLK - 1) begin\n            cnt <= 0;\n            clk_4cycles <= 1;\n            clk_3cycles <= 1;\n        end else begin\n            cnt <= cnt + 1;\n            clk_4cycles <= 0;\n            clk_3cycles <= 0;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk_4cycles,\n    input               clk_3cycles,\n    output              clk_div\n);\n    reg clk_high;\n    always @(posedge clk_4cycles or negedge clk_3cycles) begin\n        if (clk_4cycles) begin\n            clk_high <= ~clk_high;\n        end else if (clk_3cycles) begin\n            clk_high <= 1;\n        end\n    end\n    assign clk_div = clk_high;\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div,\n    output              clk_div\n);\n    assign clk_div = clk_div ^ clk;\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            clk_div <= 1'b1;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            clk_div <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [3:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            clk_div <= 1'b1;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            clk_div <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire clk_div_en;\nreg [3:0] cnt;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .cnt_limit(NUM_DIV / 2 - 1),\n    .cnt_out(cnt)\n);\n\nclk_divider u_clk_divider(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_en(clk_div_en),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    input [3:0] cnt_limit,\n    output reg [3:0] cnt\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (cnt == cnt_limit) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (clk_div_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_res, sub_res, and_res, or_res, xor_res, nor_res;\nwire [31:0] slt_res, sltu_res;\nwire [31:0] sll_res, srl_res, sra_res;\nwire [31:0] sllv_res, srlv_res, srav_res;\nwire [31:0] lui_res;\n\n// Addition\nadder add(.a(a), .b(b), .r(add_res));\n\n// Subtraction\nsubtractor sub(.a(a), .b(b), .r(sub_res));\n\n// Logical operations\nand_gate and1(.a(a), .b(b), .r(and_res));\nor_gate or1(.a(a), .b(b), .r(or_res));\nxor_gate xor1(.a(a), .b(b), .r(xor_res));\nnor_gate nor1(.a(a), .b(b), .r(nor_res));\n\n// Shift operations\nshift_left_logic sll(.a(a), .b(b), .r(sll_res));\nshift_right_logic srl(.a(a), .b(b), .r(srl_res));\nshift_right_arithmetic sra(.a(a), .b(b), .r(sra_res));\n\n// Shift operations with variable shift amount\nshift_left_variable sllv(.a(a), .b(b), .r(sllv_res));\nshift_right_variable srlv(.a(a), .b(b), .r(srlv_res));\nshift_right_arithmetic_variable srav(.a(a), .b(b), .r(srav_res));\n\n// Load upper immediate\nload_upper_immediate lui(.a(a), .b(b), .r(lui_res));\n\n// Select operation based on control signal\nassign r = (aluc == 6'b100000) ? add_res :\n           (aluc == 6'b100001) ? add_res :\n           (aluc == 6'b100010) ? sub_res :\n           (aluc == 6'b100011) ? sub_res :\n           (aluc == 6'b100100) ? and_res :\n           (aluc == 6'b100101) ? or_res :\n           (aluc == 6'b100110) ? xor_res :\n           (aluc == 6'b100111) ? nor_res :\n           (aluc == 6'b101010) ? slt_res :\n           (aluc == 6'b101011) ? sltu_res :\n           (aluc == 6'b000000) ? sll_res :\n           (aluc == 6'b000010) ? srl_res :\n           (aluc == 6'b000011) ? sra_res :\n           (aluc == 6'b000100) ? sllv_res :\n           (aluc == 6'b000110) ? srlv_res :\n           (aluc == 6'b000111) ? srav_res :\n           (aluc == 6'b001111) ? lui_res :\n           32'bz;\n\nassign zero = (r == 0);\nassign carry = (r[32] == 1);\nassign negative = r[31];\nassign overflow = 1'b0;\nassign flag = (aluc == 6'b101010 || aluc == 6'b101011) ? 1'b1 : 1'b0;\n\nendmodule\n\n// Addition\nmodule adder(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a +"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [63:0] result;\nwire [31:0] lower_result;\n\n// Instantiating the multiplier submodule\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .result(result)\n);\n\n// Instantiating the accumulator submodule\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .result(result[31:0]),\n    .current_value(lower_result)\n);\n\n// Assigning the result to c\nassign c = lower_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad22;\n    wire [7:0] ad21;\n\n    // Instruction register from register\n    ins_p ins_p1 (.clk(clk), .rst(rst), .data(data), .ins(ins1), .ad1(ad11), .ad2(ad21));\n\n    // Instruction register from RAM/ROM\n    ins_p ins_p2 (.clk(clk), .rst(rst), .data(data), .ins(ins2), .ad1(ad12), .ad2(ad22));\n\n    assign ins = fetch[0] ? ins1 : ins2;\n    assign ad1 = fetch[0] ? ad11 : ad12;\n    assign ad2 = fetch[1] ? ad22 : ad21;\n\nendmodule\n\nmodule ins_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\n// Instantiating counter module\ncounter cnt (\n    .clk(clk),\n    .enable(1'b1),\n    .freq(freq),\n    .count(count)\n);\n\n// Instantiating wave generator module\nwave_generator wg (\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1))\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    wave_out <= (count == 0);\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b0) begin\n                        wave_reg <= 5'b00001;\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b01110) begin\n                        wave_reg <= 5'b00001;\n                        state <= 2'b10;\n                    end else begin\n                        wave_reg <= wave_reg + 1;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b11111) begin\n                        wave_reg <= 5'b00001;\n                        state <= 2'b00;\n                    end else begin\n                        wave_reg <= wave_reg - 1;\n                    end\n                end\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            state <= state;\n        end\n    end\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            wave <= wave;\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] out0, out1, out2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(out0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(out0),\n        .q(out1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(out1),\n        .q(out2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= out0;\n            2'b01: q <= out1;\n            2'b10: q <= out2;\n            2'b11: q <= d;\n            default: q <= 8'bx;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire w1, w2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q),\n        .q(w1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(w1),\n        .q(w2)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Shift stage 1\n    assign stage1 = (ctrl[2]) ? (in << 4) : in;\n    assign stage2 = (ctrl[1]) ? (stage1 >> 2) : stage1;\n    assign stage3 = (ctrl[0]) ? (stage2 >> 1) : stage2;\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out);\n    input in0, in1, sel;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule\n\nmodule barrel_shifter_8to1_ins (in, ctrl, out);\n    input in;\n    input [2:0] ctrl;\n    output out;\n\n    wire [7:0] stage1, stage2, stage3, stage4;\n\n    // Shift stage 1\n    assign stage1 = (ctrl[2]) ? (in << 4) : in;\n    assign stage2 = (ctrl[1]) ? (stage1 >> 2) : stage1;\n    assign stage3 = (ctrl[0]) ? (stage2 >> 1) : stage2;\n    assign stage4 = (ctrl[0] && ctrl[1]) ? (stage3 >> 2) : stage3;\n    assign out = stage4;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  assign b1 = rst ? b0 : b0;\n\n  PE pe0 (.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1 (.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg <= 0;\n      c <= 0;\n    end else begin\n      b_reg <= b;\n      c <= a * b_reg;\n    end\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_out;\n  wire [31:0] pc;\n\n  fetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .fetch_out(fetch_out),\n    .pc(pc)\n  );\n\n  decode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .fetch_out(fetch_out),\n    .decode_out(decode_out)\n  );\n\n  execute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .decode_out(decode_out),\n    .execute_out(execute_out)\n  );\n\n  memory_stage memory(\n    .clk(clk),\n    .rst(rst),\n    .execute_out(execute_out),\n    .memory_out(memory_out)\n  );\n\n  writeback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .memory_out(memory_out),\n    .writeback_out(writeback_out)\n  );\n\n  assign res_reg_file = writeback_out;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] fetch_out,\n  output reg [31:0] pc\n);\n  wire [31:0] instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\n\n  assign instr = instr_mem[pc];\n\n  assign fetch_out = instr;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetch_out,\n  output [31:0] decode_out\n);\n  // Decoding logic\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] decode_out,\n  output [31:0] execute_out\n);\n  // Execution logic\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] execute_out,\n  output [31:0] memory_out\n);\n  // Memory stage logic\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] memory_out,\n  output [31:0] writeback_out\n);\n  // Writeback logic\nendmodule\n"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [31:0] b1, b2, b3;\n  reg [31:0] b0_reg, b1_reg, b2_reg;\n  \n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  PE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  PE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n    end\n  end\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst) c <= 0;\n    else c <= c + (a * b);\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetched_instr, executed_instr;\n\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .fetched_instr(fetched_instr));\n    execute_stage execute(.clk(clk), .instr(fetched_instr), .reg_file(reg_file), .executed_instr(executed_instr));\n    writeback_stage writeback(.clk(clk), .reg_file(reg_file), .executed_instr(executed_instr), .out_reg_file(out_reg_file));\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output reg [31:0] fetched_instr\n);\n    reg [4:0] pc;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            pc <= 5'b00000;\n        else\n            pc <= pc + 1;\n    end\n    always @(posedge clk) begin\n        fetched_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] executed_instr\n);\n    always @(posedge clk) begin\n        case(instr[6:0])\n            7'b0000001: executed_instr <= reg_file[instr[10:7]] + reg_file[instr[15:12]];\n            7'b0000011: executed_instr <= reg_file[instr[10:7]] - reg_file[instr[15:12]];\n            default: executed_instr <= 32'bx;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] reg_file [0:31],\n    input [31:0] executed_instr,\n    output reg [31:0] out_reg_file  \n);\n    always @(posedge clk) begin\n        reg_file[executed_instr[15:11]] <= executed_instr;\n        out_reg_file <= reg_file[executed_instr[15:11]];\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [3:0] cnt_out;\n    wire [9:0] acc_out;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .cnt_in(cnt_out),\n        .acc_out(acc_out)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_in(cnt_out),\n        .valid_out(valid_out)\n    );\n\n    // Output data\n    assign data_out = acc_out;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg [3:0]    cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (valid_in) begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   cnt_in,\n    output reg [9:0]    acc_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc_out <= 0;\n        end else if (cnt_in == 4) begin\n            acc_out <= acc_out + data_in;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   cnt_in,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end else if (cnt_in == 4) begin\n            valid_out <= 1;\n        end else if (cnt_in > 4) begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n// Local signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [3:0] ctr;\nwire [7:0] shift_reg;\nwire done;\n\n// Instances\nabs_value abs_dividend_inst(\n    .dividend(dividend),\n    .sign(sign),\n    .abs_value(abs_dividend)\n);\n\nneg_value neg_divisor_inst(\n    .dividend(divisor),\n    .sign(sign),\n    .neg_value(neg_divisor)\n);\n\ndivider_control ctrl_inst(\n    .clk(clk),\n    .rst(rst),\n    .abs_dividend(abs_dividend),\n    .neg_divisor(neg_divisor),\n    .ctr(ctr),\n    .done(done)\n);\n\nresult_management res_mgmt_inst(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .done(done),\n    .shift_reg(shift_reg),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] abs_value\n);\n\nalways @(*) begin\n    if (sign) begin\n        abs_value = -dividend;\n    end else begin\n        abs_value = dividend;\n    end\nend\n\nendmodule\n\nmodule neg_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] neg_value\n);\n\nalways @(*) begin\n    if (sign) begin\n        neg_value = dividend;\n    end else begin\n        neg_value = -dividend;\n    end\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [3:0] ctr,\n    output reg done\n);\n\nreg [7:0] q, r;\nreg [2:0] state;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        ctr <= 4'b0;\n        state <= 3'b0;\n        done <= 1'b0;\n    end else begin\n        case (state)\n            3'b000: begin\n                q <= {8{1'b0}};\n                r <= abs_dividend;\n                ctr <= 4'b0;\n                done <= 1'b0;\n                state <= 3'b001;\n            end\n            3'b001: begin\n                if (r[7] == 1'b0) begin\n                    state <= 3'b010;\n                end else begin\n                    q[ctr] <= 1'b1;\n                    r <= r - neg_divisor;\n                    ctr <= ctr + 1'b1;\n                end\n            end\n            3'b010: begin\n                if (ctr == 4) begin\n                    done <= 1'b1;\n                    state <= 3'b100;\n                end else begin\n                    state <= 3'b001;\n                end\n            end\n            3'b100: begin\n                state <= 3'b101;\n            end\n            3'b101: begin\n                state <= 3'b110;\n            end\n            3'b110: begin\n                state <= 3'b111;\n            end\n            3'b111: begin\n                done <= 1'b0;\n                state <= 3'b000;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    // Prepare dividend and divisor to the correct bit width\n    prep_dividend prep(\n        .A(A),\n        .B(B),\n        .result(dividend),\n        .odd(divisor)\n    );\n\n    // Perform division\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    always @(*) begin\n        result = { {16{1'b0}}, A };\n        odd = { {16{1'b0}}, B };\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] remainder;\n    reg [31:0] quotient;\n    reg [4:0] counter;\n    reg [4:0] shift_amount;\n\n    always @(*) begin\n        shift_amount = 0;\n        remainder = { {16{1'b0}}, dividend[31:16] };\n        divisor = { {16{1'b0}}, divisor };\n        quotient = 0;\n\n        while (shift_amount < 32) begin\n            shift_amount = shift_amount + 1;\n            shifted_dividend = { remainder[31:0], 1'b0 };\n            shifted_divisor = { divisor[31:0], 1'b0 };\n            remainder = shifted_dividend;\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient = quotient << 1;\n                remainder = remainder - shifted_divisor;\n            end\n        end\n        result = quotient;\n        odd = remainder;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_quotient; // Temporary quotient\n    wire [15:0] temp_remainder; // Temporary remainder\n\n    // Instantiate the control unit\n    div_control ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\n// Submodule for the control logic\nmodule div_control (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [3:0] index;\n    reg [3:0] i;\n\n    // Initialize the temporary quotient and remainder\n    always @(*) begin\n        quotient = 16'b0;\n        remainder = 16'b0;\n    end\n\n    // Shift the dividend and compare it with the divisor\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        index = 0;\n        i = 0;\n\n        while (index < 16) begin\n            if (dividend >= divisor) begin\n                quotient[index] = 1'b1;\n                dividend = dividend - divisor;\n            end else begin\n                quotient[index] = 1'b0;\n            end\n            index = index + 1;\n        end\n\n        remainder = dividend;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum, carry;\n\nassign B_comp = ~B + 1;\n\nadder_8bit adder_inst(.A(A), .B(B_comp), .sum(sum), .carry(carry));\nassign D = sum;\nassign B_out = carry[0];\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\ninput [7:0] A, B;\noutput [7:0] sum;\noutput carry;\n\nwire [7:0] carry_level;\nwire [6:0] sum_level;\n\nassign carry_level[0] = 1'b0;\nassign sum_level[0] = A[0] ^ B[0] ^ carry_level[0];\n\ngenvar i;\ngenerate\n    for (i = 0; i < 7; i = i + 1) begin : adder_loop\n        assign carry_level[i + 1] = (A[i] & B[i]) | (A[i] & carry_level[i]) | (B[i] & carry_level[i]);\n        assign sum_level[i + 1] = A[i] ^ B[i] ^ carry_level[i];\n    end\nendgenerate\n\nassign sum = {sum_level, carry_level[7]};\nassign carry = carry_level[7];\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\nwire [15:0] borrow;\n\n// Intermediate signals\nwire [31:0] A_16, B_16;\nwire [15:0] S_16_0, S_16_1, S_16_2, S_16_3;\n\n// Instance of 16-bit subtractor\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .B_in(1'b0),\n    .Diff(S_16_0),\n    .B_out(borrow[0])\n);\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .B_in(borrow[0]),\n    .Diff(S_16_1),\n    .B_out(borrow[1])\n);\n\nassign Diff = {S_16_1, S_16_0};\nassign B_out = borrow[1];\n\nendmodule\n\nmodule sub_16bit(A, B, B_in, Diff, B_out);\ninput [15:0] A, B;\ninput B_in;\noutput [15:0] Diff;\noutput B_out;\n\nwire [14:0] borrow;\n\n// 16-bit subtraction\nassign {Diff, B_out} = A - B - B_in;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n    wire [63:0] B_neg;\n    wire [63:0] B_out_neg;\n    wire B_out_neg_neg;\n    wire [63:0] D_neg;\n\n    // 2's complement of B\n    assign B_neg = ~B + 1;\n    assign B_out_neg = ~(B_neg[63] | D_neg[63:0]);\n    assign B_out_neg_neg = ~(B_neg[63] | (~D_neg[63:0] & ~D_neg[62:0]));\n    assign D_neg = A + B_neg;\n\n    // 2's complement of A\n    assign D = ~A + 1;\n    assign B_out = ~(D[63] | D_neg[63:0]);\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n    wire [31:0] B_neg;\n    wire [31:0] B_out_neg;\n    wire B_out_neg_neg;\n    wire [31:0] D_neg;\n\n    // 2's complement of B\n    assign B_neg = ~B + 1;\n    assign B_out_neg = ~(B_neg[31] | D_neg[31:0]);\n    assign B_out_neg_neg = ~(B_neg[31] | (~D_neg[31:0] & ~D_neg[30:0]));\n    assign D_neg = A + B_neg;\n\n    // 2's complement of A\n    assign D = ~A + 1;\n    assign B_out = ~(D[31] | D_neg[31:0]);\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n    wire [15:0] B_neg;\n    wire [15:0] B_out_neg;\n    wire B_out_neg_neg;\n    wire [15:0] D_neg;\n\n    // 2's complement of B\n    assign B_neg = ~B + 1;\n    assign B_out_neg = ~(B_neg[15] | D_neg[15:0]);\n    assign B_out_neg_neg = ~(B_neg[15] | (~D_neg[15:0] & ~D_neg[14:0]));\n    assign D_neg = A + B_neg;\n\n    // 2's complement of A\n    assign D = ~A + 1;\n    assign B_out = ~(D[15] | D_neg[15:0]);\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n    wire [7:0] B_neg;\n    wire [7:0] B_out_neg;\n    wire B_out_neg_neg;\n    wire [7:0] D_neg;\n\n    // 2's complement of B\n    assign B_neg = ~B + 1;\n    assign B_out_neg = ~(B_neg[7] | D_neg[7:0]);\n    assign B_out_neg_neg = ~(B_neg[7] | (~D_neg[7:0] & ~D_neg[6:0]));\n    assign D_neg = A + B_neg;\n\n    // 2's complement of A\n    assign D = ~A + 1;\n    assign"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n    wire [3:0] borrow_out;\n    \n    // Instantiate the 4-bit full subtractor blocks\n    sub_4bit sub1(A[3:0], B[3:0], D[3:0], borrow_out[0]);\n    sub_4bit sub2(A[7:4], B[7:4], D[7:4], borrow_out[1]);\n    sub_4bit sub3(A[11:8], B[11:8], D[11:8], borrow_out[2]);\n    sub_4bit sub4(A[15:12], B[15:12], D[15:12], borrow_out[3]);\n    \n    // Calculate the borrow-out\n    assign B_out = borrow_out[3];\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n    wire [3:0] B_neg;\n    wire [2:0] borrow_out;\n    \n    // Compute the negative of B\n    assign B_neg = ~B + 1;\n    \n    // Instantiate the BLS\n    bls_4bit bls(A, B_neg, D, borrow_out);\n    \n    // Calculate the borrow-out\n    assign B_out = borrow_out[2];\nendmodule\n\nmodule bls_4bit(A, B, D, borrow_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output [2:0] borrow_out;\n    wire [3:0] B_complement, B_complement_out;\n    wire [2:0] borrow_internal;\n    \n    // Compute the complement of B\n    assign B_complement = ~B + 1;\n    \n    // Instantiate the first full subtractor\n    full_subtractor_4bit fs0(A[3:0], B_complement[3:0], D[3:0], borrow_internal[0]);\n    \n    // Instantiate the remaining full subtractors\n    full_subtractor_4bit fs1(A[7:4], B_complement[7:4], D[7:4], borrow_internal[1]);\n    full_subtractor_4bit fs2(A[11:8], B_complement[11:8], D[11:8], borrow_internal[2]);\n    full_subtractor_4bit fs3(A[15:12], B_complement[15:12], D[15:12], borrow_internal[3]);\n    \n    // Calculate the borrow-out\n    assign borrow_out = borrow_internal;\nendmodule\n\nmodule full_subtractor_4bit(A, B, D, borrow_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output borrow_out;\n    wire [3:0] B_complement, D_internal;\n    wire borrow_internal;\n    \n    // Compute the complement of B\n    assign B_complement = ~B + 1;\n    \n    // Instantiate the half subtractor\n    half_subtractor_4bit hs(A, B_complement, D_internal, borrow_internal);\n    \n    // Generate the D output\n    assign D = D_internal;\n    assign borrow_out = borrow_internal;\nendmodule\n\nmodule half_subtractor_4bit(A, B, D, borrow_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output borrow_out;\n    wire [1:0] borrow_internal;\n    \n    // Instantiate the 2-bit half subtractor\n    half_subtractor_2bit hs0(A[3:2], B[3:2], D[3:2], borrow_internal[0]);\n    half_subtractor_2bit hs1(A[1:0], B"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] subtraction_result;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .subtraction_result(subtraction_result),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (~borrow & (subtraction_result != 0));\n    assign A_equal = (borrow == 0 && subtraction_result == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtraction_result,  // Result of subtraction\n    output borrow\n);\n    wire [31:0] A_complement, B_complement;\n    wire [31:0] sum;\n    wire [32:0] temp_sum;\n\n    // 2's complement of input A\n    assign A_complement = ~A + 1;\n    // 2's complement of input B\n    assign B_complement = ~B + 1;\n\n    // Subtracting 2's complement of B from 2's complement of A\n    adder_32bit add_inst (\n        .A(A_complement),\n        .B(B_complement),\n        .sum(sum)\n    );\n\n    // Add the borrow bit to the sum\n    assign subtraction_result = sum[31:0];\n    assign borrow = sum[32];\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sum\n);\n    wire [32:0] temp_sum;\n\n    // Full adder operation\n    full_adder fa0(A[0], B[0], 1'b0, sum[0], temp_sum[0]);\n    full_adder fa1(A[1], B[1], temp_sum[0], sum[1], temp_sum[1]);\n    full_adder fa2(A[2], B[2], temp_sum[1], sum[2], temp_sum[2]);\n    full_adder fa3(A[3], B[3], temp_sum[2], sum[3], temp_sum[3]);\n    full_adder fa4(A[4], B[4], temp_sum[3], sum[4], temp_sum[4]);\n    full_adder fa5(A[5], B[5], temp_sum[4], sum[5], temp_sum[5]);\n    full_adder fa6(A[6], B[6], temp_sum[5], sum[6], temp_sum[6]);\n    full_adder fa7(A[7], B[7], temp_sum[6], sum[7], temp_sum[7]);\n    full_adder fa8(A[8], B[8], temp_sum[7], sum[8], temp_sum[8]);\n    full_adder fa9(A[9], B[9], temp_sum[8], sum[9], temp_sum[9]);\n    full_adder fa10(A[10], B[10], temp_sum[9], sum[10], temp_sum[10]);\n    full_adder fa11(A[11], B[11], temp_sum[10], sum[11], temp_sum[11]);\n    full_adder fa12(A[12], B[12], temp_sum[11], sum[12], temp_sum[12]);\n    full_adder fa13(A[13], B[13], temp_sum[12], sum[13], temp_sum[13]);\n    full_adder fa14(A[14], B[14], temp_sum[13], sum["}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\n\nwire [32:1] C1, C2, C3;\nwire C16, C17, C18, C19, C20, C21, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31;\n\ncla_16bit CLA1 (.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .S(S[15:0]), .Cout(C1));\ncla_16bit CLA2 (.A(A[31:16]), .B(B[31:16]), .Cin(1'b0), .S(S[31:16]), .Cout(C2));\n\nassign C32 = C1[15] | C2[15];\nassign C31 = C1[14] | C2[14];\nassign C30 = C1[13] | C2[13];\nassign C29 = C1[12] | C2[12];\nassign C28 = C1[11] | C2[11];\nassign C27 = C1[10] | C2[10];\nassign C26 = C1[9] | C2[9];\nassign C25 = C1[8] | C2[8];\nassign C24 = C1[7] | C2[7];\nassign C23 = C1[6] | C2[6];\nassign C22 = C1[5] | C2[5];\nassign C21 = C1[4] | C2[4];\nassign C20 = C1[3] | C2[3];\nassign C19 = C1[2] | C2[2];\nassign C18 = C1[1] | C2[1];\nassign C17 = C1[0] | C2[0];\nassign C16 = C1[15] | C2[15] | C31;\n\nendmodule\n\nmodule cla_16bit(A,B,Cin,S,Cout);\ninput [15:0] A,B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [16:0] sum;\n\nassign sum[15:0] = A ^ B;\nassign sum[16] = Cin;\nassign S = sum[15:0] ^ sum[16:1];\nassign Cout = sum[16] ^ Cin;\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    assign cout = carry[3];\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n    assign cout = carry[0];\nendmodule\n\nmodule carry_select_adder_slice_4bit_2(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n    assign cout = carry[0];\nendmodule\n\nmodule carry_select_adder_slice_4bit_3(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [7:0] carry;\n\n    // Instantiate 8 1-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Implement 8-bit adder logic here\n    // Example:\n    wire [7:0] sum;\n    wire [7:0] carry;\n    assign {Co, sum} = a + b + Cin;\n    assign y = sum;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [7:0] carry;\n    adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [31:0] product; // Product register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    assign yout = product;\n\nendmodule\n\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n\n    reg [3:0] count; // Shift count register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            done <= 0;\n        end else begin\n            if (start) begin\n                count <= 1;\n                done <= 0;\n            end else if (count == 4) begin\n                count <= 0;\n                done <= 1;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    reg [31:0] p; // Product register\n    reg [4:0] c; // Shift count\n    reg [15:0] a; // Multiplicand register\n    reg [15:0] b; // Multiplier register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            p <= 0;\n            a <= 0;\n            b <= 0;\n            c <= 0;\n        end else begin\n            if (c == 15) begin\n                p <= p + b;\n                a <= ain;\n                b <= bin;\n                c <= 0;\n            end else if (a[0] == 1'b1) begin\n                p <= p + b;\n            end\n            a <= a >> 1;\n            b <= b >> 1;\n            c <= c + 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            product <= p;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 16'b0;\n        end else begin\n            if (up_down) begin\n                next_count <= current_count + 1;\n            end else begin\n                next_count <= current_count - 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'b0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule to handle state initialization\n    ring_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // Submodule to handle state transition\n    ring_transition transition (\n        .clk(clk),\n        .out(out)\n    );\n\nendmodule\n\nmodule ring_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule ring_transition (\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= (out >> 1) | (out << 7);\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end else begin\n            out <= out;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n    wire [63:0] curr_Q;\n\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .curr_Q(curr_Q),\n        .next_Q(next_Q)\n    );\n\n    JC_logic logic_inst (\n        .curr_Q(curr_Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = curr_Q;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         curr_Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= curr_Q;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         curr_Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(*) begin\n        next_Q = curr_Q;\n        next_Q[0] = curr_Q[63];\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 49) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_div_4;\n    wire clk_div_3;\n\n    // Counter Submodule Instantiation\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_4(clk_div_4),\n        .clk_div_3(clk_div_3)\n    );\n\n    // Clock Average Generator Submodule Instantiation\n    clk_average u_clk_average(\n        .clk(clk_div_4),\n        .clk_div(clk_div)\n    );\n\n    // Clock Adjustment Submodule Instantiation\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div_3(clk_div_3),\n        .clk_div_4(clk_div_4),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div_4,\n    output reg          clk_div_3\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div_4 <= 0;\n            clk_div_3 <= 0;\n        end else if (cnt >= 3) begin\n            cnt <= 0;\n            clk_div_4 <= ~clk_div_4;\n            clk_div_3 <= ~clk_div_3;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    output reg          clk_div\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge clk) begin\n        if (cnt == 0) begin\n            clk_div <= ~clk_div;\n            cnt <= 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_3,\n    input               clk_div_4,\n    output reg          clk_div\n);\n\n    always @(negedge clk) begin\n        clk_div <= clk_div_3 | clk_div_4;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    wire clk_div1, clk_div2;\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n    assign clk_div = clk_div1 | clk_div2;\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nwire clk_div_en;\nreg [3:0] cnt_reg, cnt_next;\n\nassign clk_div_en = (cnt_reg == (NUM_DIV >> 1) - 1);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 0;\n    else if (clk_div_en)\n        cnt_reg <= 0;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    cnt_next = cnt_reg + 1;\nend\n\nassign clk_div = clk_div_en ? ~clk : 1'b0;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt <= 0;\n    else if (cnt == (NUM_DIV >> 1) - 1)\n        cnt <= 0;\n    else\n        cnt <= cnt + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clkdiv(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 8;\n\nreg [3:0] cnt_reg, cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 0;\n    else if (cnt_reg == (NUM_DIV >> 1) - 1)\n        cnt_reg <= 0;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    cnt_next = cnt_reg + 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (cnt_reg == (NUM_DIV >> 1) - 1)\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire [31:0] sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result;\n    wire [31:0] add_result_zero, sub_result_zero, and_result_zero, or_result_zero, xor_result_zero, nor_result_zero;\n    wire [31:0] sll_result_zero, srl_result_zero, sra_result_zero, sllv_result_zero, srlv_result_zero, srav_result_zero;\n    wire add_carry, sub_borrow, add_overflow, sub_overflow;\n    wire [31:0] lui_result;\n\n    // Submodules\n    adder add(\n        .a(a),\n        .b(b),\n        .sum(add_result),\n        .carry_out(add_carry)\n    );\n    adder_sub addu(\n        .a(a),\n        .b(b),\n        .sum(sub_result),\n        .borrow_out(sub_borrow)\n    );\n    logic_and and1(\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n    logic_or or1(\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n    logic_xor xor1(\n        .a(a),\n        .b(b),\n        .result(xor_result)\n    );\n    logic_nor nor1(\n        .a(a),\n        .b(b),\n        .result(nor_result)\n    );\n    shift_left_logic sll_inst(\n        .a(a),\n        .b(b),\n        .result(sll_result)\n    );\n    shift_right_logic srl_inst(\n        .a(a),\n        .b(b),\n        .result(srl_result)\n    );\n    shift_right_arithmetic sra_inst(\n        .a(a),\n        .b(b),\n        .result(sra_result)\n    );\n    shift_left_variable sllv_inst(\n        .a(a),\n        .b(b),\n        .result(sllv_result)\n    );\n    shift_right_variable srlv_inst(\n        .a(a),\n        .b(b),\n        .result(srlv_result)\n    );\n    shift_right_arithmetic_variable srav_inst(\n        .a(a),\n        .b(b),\n        .result(srav_result)\n    );\n    lui_instruction lui_inst(\n        .a(a),\n        .b(b),\n        .result(lui_result)\n    );\n    slt_instruction slt_inst(\n        .a(a),\n        .b(b),\n        .result(lui_result)\n    );\n    sltu_instruction sltu_inst(\n        .a(a),\n        .b(b),\n        .result(lui_result)\n    );\n\n    // Operation selection\n    assign r = aluc[5:0] == 6'b100000 ? add_result :\n               aluc[5:0] == 6'b100001 ? addu.sum :\n               aluc[5:0] == 6'b100010 ? sub_result :\n               aluc[5:0] == 6'b100011 ? subu.sum :\n               aluc[5:0] == 6'b100100 ? and_result :\n               aluc[5:0] == 6'b100101 ? or_result :\n               aluc[5:0] == 6'b100110 ? xor_result :\n               aluc[5:0] == 6'b100111 ? nor_result :\n               aluc[5"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] product;\n    wire [31:0] next_value;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(next_value),\n        .product(product),\n        .new_value(next_value)\n    );\n\n    assign c = next_value;\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [63:0] product,\n    output reg [31:0] new_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            new_value <= 0;\n        end else begin\n            new_value <= current_value + product[31:0];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    // Instruction from RAM\n    ins_p ins_p1 (.clk(clk), .rst(rst), .data(data), .ins(ins1));\n    // Instruction from ROM\n    ins_p ins_p2 (.clk(clk), .rst(rst), .data(data), .ins(ins2));\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\nmodule ins_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 0;\n            ad1_reg <= 0;\n            ad2_reg <= 0;\n        end else begin\n            ad1_reg <= data[4:0];\n            ad2_reg <= data[7:0];\n            ins_reg <= data[7:3];\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt(\n        .clk(clk),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    reg enable;\n\n    initial begin\n        count <= 0;\n        enable <= 1;\n    end\n\n    always @(posedge clk) begin\n        if (enable && (count >= (freq - 1))) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (count >= (freq - 1)) begin\n            enable <= 0;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial begin\n        wave_out <= 0;\n    end\n\n    always @(posedge clk) begin\n        wave_out <= ~wave_out;\n    end\n\n    always @(posedge clk) begin\n        if (count >= (freq - 1)) begin\n            wave_out <= 1;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\nreg [4:0] wave_reg;\nreg [1:0] state_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wave_reg <= 5'b0;\n        state_reg <= 2'b00;\n    end else begin\n        case (state_reg)\n            2'b00: wave_reg <= wave_reg + 1;\n            2'b01: wave_reg <= wave_reg - 1;\n            default: ;\n        endcase\n    end\nend\n\nassign wave = wave_reg;\n\nendmodule\n\nmodule state_controller (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= 2'b00;\n    end else begin\n        case (state)\n            2'b00: state <= 2'b01;\n            2'b01: state <= 2'b00;\n            default: ;\n        endcase\n    end\nend\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wave <= 5'b0;\n    end else begin\n        wave <= wave + 1;\n    end\nend\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n            default: q <= 8'bx;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux4to1_8 (\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    always @(*) begin\n        case (sel)\n            2'b00: q = d0;\n            2'b01: q = d1;\n            2'b10: q = d2;\n            2'b11: q = d3;\n            default: q = 8'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    mux2X1 mux1 (in[3:0], in[7:4], ctrl[1], stage1);\n    mux2X1 mux2 (in[7:4], in[3:0], ctrl[1], stage2);\n    mux2X1 mux3 (stage1, stage2, ctrl[0], stage3);\n\n    // Stage 2\n    mux2X1 mux4 (stage1[3:0], stage1[7:4], ctrl[2], stage1);\n    mux2X1 mux5 (stage2[7:4], stage2[3:0], ctrl[2], stage2);\n    mux2X1 mux6 (stage3, stage2[7:4], ctrl[2], stage3);\n\n    // Stage 3\n    mux2X1 mux7 (stage1[7:4], stage1[3:0], ctrl[2], stage1);\n    mux2X1 mux8 (stage2[3:0], stage2[7:4], ctrl[2], stage2);\n    mux2X1 mux9 (stage3, stage2[3:0], ctrl[2], stage3);\n\n    // Final output\n    assign out = stage3;\n\nendmodule\n\nmodule mux2X1 (a, b, sel, out);\n    input a, b, sel;\n    output out;\n\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  assign b1 = rst ? 16'b0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) c <= 0;\n    else c <= c + (a * b);\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  wire [31:0] fetched_instr;\n  wire [31:0] alu_result;\n  wire [3:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .fetched_instr(fetched_instr));\n  decode_stage decode(.clk(clk), .fetched_instr(fetched_instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute(.clk(clk), .rs1(rs1), .rs2(rs2), .op(op), .alu_result(alu_result));\n  memory_stage memory(.clk(clk), .alu_result(alu_result), .alu_result_next(alu_result_next));\n  writeback_stage writeback(.clk(clk), .alu_result_next(alu_result_next), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\n  reg [5:0] pc = 0;\n  reg [31:0] alu_result_next;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [5:0] pc,\n  output reg [31:0] fetched_instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      fetched_instr <= 0;\n    end else begin\n      fetched_instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] fetched_instr,\n  output reg [3:0] rs1,\n  output reg [3:0] rs2,\n  output reg [3:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk) begin\n    {rd, rs2, rs1, op} <= fetched_instr;\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [3:0] rs1,\n  input [3:0] rs2,\n  input [5:0] op,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk) begin\n    case (op)\n      6'b001000: alu_result <= reg_file[rs1] + reg_file[rs2];\n      6'b011000: alu_result <= reg_file[rs1] - reg_file[rs2];\n      default: alu_result <= 0;\n    endcase\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_result,\n  output reg [31:0] alu_result_next\n);\n  always @(posedge clk) begin\n    alu_result_next <= alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] alu_result_next,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk) begin\n    res_reg_file[rd] <= alu_result_next;\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n\n  // Passing b0 to pe0\n  assign b1 = b0;\n  assign b2 = b1;\n  assign b3 = b2;\n\n  // Passing b0_reg to pe1, pe2, pe3\n  assign b1_reg = b0_reg;\n  assign b2_reg = b1_reg;\n\n  // Connecting PEs\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1_reg),\n    .c(c1)\n  );\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2_reg),\n    .c(c2)\n  );\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n    end\n  end\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= c + (a * b);\n    end\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr_fetch;\n    wire [31:0] result;\n    wire [4:0] rd, rs1, rs2;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .instr_fetch(instr_fetch)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .instr_fetch(instr_fetch),\n        .reg_file(reg_file),\n        .result(result),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .rd(rd),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] instr_fetch\n);\n    reg [4:0] pc;\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            pc <= 0;\n        else\n            pc <= pc + 1;\n    end\n\n    always @(*) begin\n        instr_fetch = instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_fetch,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] result,\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2\n);\n    always @(*) begin\n        case(instr_fetch[6:0])\n            6'b000000: begin\n                {rd, rs1, rs2, result} = instr_fetch;\n                result = reg_file[rs1] + reg_file[rs2];\n            end\n            6'b001000: begin\n                {rd, rs1, rs2, result} = instr_fetch;\n                result = reg_file[rs1] - reg_file[rs2];\n            end\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_reg_file <= 32'b0;\n        else\n            out_reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_out;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_out(data_out)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt_out),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) cnt_out <= 0;\n        else if (valid_in) cnt_out <= cnt_out + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) data_out <= 0;\n        else if (valid_in) data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt_out,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) valid_out <= 0;\n        else if (cnt_out == 2'b11) valid_out <= 1;\n        else valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend, neg_divisor;\nwire [7:0] quotient, remainder;\n\n// Compute absolute value of dividend and divisor\nabs_value abs_dividend_inst (.a(dividend), .b(abs_dividend));\nabs_value neg_divisor_inst (.a(divisor), .b(neg_divisor));\n\n// Calculate remainder and quotient\ndiv_logic div_logic_inst (\n    .clk(clk),\n    .rst(rst),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Manage result validity\nresult_mgmt res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input [7:0] a,\n    output [7:0] b\n);\n    assign b = (a[7]) ? -a : a;\nendmodule\n\nmodule div_logic(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    output reg [7:0] quotient,    \n    output reg [7:0] remainder\n);\n\n    reg [7:0] shift_reg;\n    reg [2:0] counter;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            quotient <= 0;\n            remainder <= 0;\n            shift_reg <= 0;\n            counter <= 0;\n        end else begin\n            if(counter < 8) begin\n                shift_reg <= {shift_reg[6:0], dividend[0]};\n                if(shift_reg[7]) begin\n                    remainder <= shift_reg - divisor;\n                    shift_reg <= remainder;\n                end\n                counter <= counter + 1;\n            end else begin\n                quotient <= shift_reg[7:0];\n            end\n        end\n    end\n\nendmodule\n\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        if(rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end else begin\n            if(opn_valid) begin\n                if(res_ready) begin\n                    res_valid <= 1;\n                    result <= {result[7:0], result[15:8]};\n                end else begin\n                    res_valid <= 0;\n                end\n            end else begin\n                res_valid <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] prepared_dividend;\n    wire [31:0] prepared_divisor;\n\n    prep_dividend prep(\n        .dividend(A),\n        .divisor(B),\n        .prepared_dividend(prepared_dividend),\n        .prepared_divisor(prepared_divisor)\n    );\n\n    div_operation div_op(\n        .dividend(prepared_dividend),\n        .divisor(prepared_divisor),\n        .quotient(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] prepared_dividend,\n    output reg [31:0] prepared_divisor\n);\n\n    always @(*) begin\n        prepared_dividend = {dividend[31:16], dividend[15:0]};\n        prepared_divisor = {divisor, 16'h0000};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] mask;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        mask = 32'hFFFFFFFF;\n    end\n\n    always @(*) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            quotient = shifted_dividend >> 16;\n            remainder = shifted_dividend - (shifted_divisor << 16);\n        end else begin\n            quotient = 0;\n            remainder = shifted_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [7:0] dividend, divisor, quotient, remainder;\n    wire [3:0] i;\n\n    // Control unit\n    div_control ctrl (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Control unit\nmodule div_control (\n    input wire [15:0] A,       // Dividend\n    input wire [7:0] B,        // Divisor\n    output reg [7:0] dividend, // Dividend\n    output reg [7:0] divisor,  // Divisor\n    output reg [7:0] quotient, // Quotient\n    output reg [7:0] remainder // Remainder\n);\n\n    // Initialize\n    initial begin\n        dividend = A[15:8];\n        divisor = B;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    // Divide logic\n    always @(*) begin\n        for (i = 0; i < 8; i = i + 1) begin\n            if (dividend >= divisor) begin\n                dividend = dividend - divisor;\n                quotient[7 - i] = 1;\n            end else begin\n                quotient[7 - i] = 0;\n            end\n            divisor = {divisor[6:0], 1'b0};\n        end\n        remainder = dividend;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire [7:0] B_sum;\nwire [8:0] carry;\n\nassign B_complement = ~B + 1;\n\nadder_8bit adder_inst(.A(A), .B(B_complement), .Cin(1'b0), .Sum(B_sum), .Cout(B_out));\n\nassign D = B_sum;\n\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\ninput [7:0] A, B;\ninput Cin;\noutput [7:0] Sum;\noutput Cout;\n\nwire [7:0] B_complement;\nwire [8:0] carry;\n\nassign B_complement = ~B + 1;\nassign {Cout, carry} = A + B_complement + Cin;\nassign Sum = carry[7:0];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1, S2;\n\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1),\n    .B_out(B_out)\n);\n\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2),\n    .B_out(B_out)\n);\n\nassign Diff = {S2, S1};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [15:0] A_inv, B_inv;\nwire [16:0] diff_add;\n\n// Inverting A and B\nassign A_inv = ~A;\nassign B_inv = ~B;\n\n// 16-bit addition of A + B + borrow\nassign diff_add = A_inv + B_inv + B_out;\n\nassign Diff = diff_add[15:0];\nassign B_out = diff_add[16];\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire B0, B1;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D1),\n        .B_out(B1)\n    );\n\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] D0, D1;\n    wire B0, B1;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D1),\n        .B_out(B1)\n    );\n\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] D0, D1;\n    wire B0, B1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .B_out(B1)\n    );\n\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow;\n\nsub4 sub1(A[1:0], B[1:0], D[1:0], borrow[0]);\nsub4 sub2(A[3:2], B[3:2], D[3:2], borrow[1]);\nsub4 sub3(A[5:4], B[5:4], D[5:4], borrow[2]);\nsub4 sub4(A[7:6], B[7:6], D[7:6], borrow[3]);\n\nassign B_out = borrow[3];\nendmodule\n\nmodule sub4(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] B_neg;\n\nassign B_neg = ~B;\n\nfull_subtractor fs0(.A(A), .B(B[0]), .D(D[0]), .B_out(B_out));\nfull_subtractor fs1(.A(B_neg[0]), .B(A[1]), .D(D[1]), .B_out(fs0.B_in));\nfull_subtractor fs2(.A(B_neg[1]), .B(A[2]), .D(D[2]), .B_out(fs1.B_in));\nfull_subtractor fs3(.A(B_neg[2]), .B(A[3]), .D(D[3]), .B_out(fs2.B_in));\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\ninput A, B;\noutput D, B_out;\n\nassign D = A ^ B;\nassign B_out = ~(A & B);\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff; // Intermediate difference between A and B\n    wire borrow; // Borrow from subtraction\n\n    subtractor_32bit sub_inst(\n        .A(A), \n        .B(B), \n        .diff(diff), \n        .borrow(borrow)\n    );\n\n    assign A_greater = ~borrow & (diff != 0);\n    assign A_equal = ~borrow & (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A, \n    input [31:0] B, \n    output [31:0] diff,\n    output borrow\n);\n    wire [32:0] sum; // 33-bit sum to handle overflow\n\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [32:1] C15,C16,C17,C18,C19,C20,C21,C22,C23,C24,C25,C26,C27,C28,C29,C30,C31;\nwire [32:1] P15,P16,P17,P18,P19,P20,P21,P22,P23,P24,P25,P26,P27,P28,P29,P30,P31;\nwire [32:1] G15,G16,G17,G18,G19,G20,G21,G22,G23,G24,G25,G26,G27,G28,G29,G30,G31;\nwire [32:1] G15_P15,G16_P16,G17_P17,G18_P18,G19_P19,G20_P20,G21_P21,G22_P22,G23_P23,G24_P24,G25_P25,G26_P26,G27_P27,G28_P28,G29_P29,G30_P30,G31_P31;\nwire [32:1] C15_P15,C16_P16,C17_P17,C18_P18,C19_P19,C20_P20,C21_P21,C22_P22,C23_P23,C24_P24,C25_P25,C26_P26,C27_P27,C28_P28,C29_P29,C30_P30,C31_P31;\n\nCLA1 CLA1(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G15), .P(P15), .Cout(C15));\nCLA1 CLA2(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G16), .P(P16), .Cout(C16));\nCLA1 CLA3(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G17), .P(P17), .Cout(C17));\nCLA1 CLA4(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G18), .P(P18), .Cout(C18));\nCLA1 CLA5(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G19), .P(P19), .Cout(C19));\nCLA1 CLA6(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G20), .P(P20), .Cout(C20));\nCLA1 CLA7(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G21), .P(P21), .Cout(C21));\nCLA1 CLA8(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .G(G22), .P(P22), .Cout(C22));\nCLA1 CLA9(.A(A[15:0]), .B(B[1"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [1:0] carry;\n    wire [15:0] sum0, sum1;\n    wire [3:0] csa_carry;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder rca1 (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum0),\n        .cout(carry[0])\n    );\n\n    // 4-bit carry select adder\n    ripple_carry_adder rca2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum1[3:0]),\n        .cout(csa_carry[0])\n    );\n    ripple_carry_adder rca3 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum1[7:4]),\n        .cout(csa_carry[1])\n    );\n    ripple_carry_adder rca4 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(csa_carry[1]),\n        .sum(sum1[11:8]),\n        .cout(csa_carry[2])\n    );\n    ripple_carry_adder rca5 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(csa_carry[2]),\n        .sum(sum1[15:12]),\n        .cout(csa_carry[3])\n    );\n\n    // 4-bit carry select\n    assign sum = cin ? ~(sum1) : sum1;\n    assign cout = csa_carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n\n    assign cout = c[3];\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [1:0] csa_carry;\n    wire [15:0] slice_sum;\n\n    ripple_carry_adder rca1 (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(slice_sum[3:0]),\n        .cout(csa_carry[0])\n    );\n    ripple_carry_adder rca2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(csa_carry[0]),\n        .sum(slice_sum[7"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n    assign Co = carry[1];\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n    wire [7:0] carry_c;\n    assign sum = a ^ b ^ Cin;\n    assign carry_c = (a & b) | (Cin & (a ^ b));\n    assign y = sum;\n    assign Co = carry_c[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [2:0] c;\n    assign c[0] = cin;\n    \n    fa FA0 (.a(a[0]), .b(b[0]), .cin(c[0]), .sum(sum[0]), .cout(c[1]));\n    fa FA1 (.a(a[1]), .b(b[1]), .cin(c[1]), .sum(sum[1]), .cout(c[2]));\n    fa FA2 (.a(a[2]), .b(b[2]), .cin(c[2]), .sum(sum[2]), .cout(c[0]));\n    fa FA3 (.a(a[3]), .b(b[3]), .cin(c[0]), .sum(sum[3]), .cout(c[1]));\n    fa FA4 (.a(a[4]), .b(b[4]), .cin(c[1]), .sum(sum[4]), .cout(c[2]));\n    fa FA5 (.a(a[5]), .b(b[5]), .cin(c[2]), .sum(sum[5]), .cout(c[0]));\n    fa FA6 (.a(a[6]), .b(b[6]), .cin(c[0]), .sum(sum[6]), .cout(c[1]));\n    fa FA7 (.a(a[7]), .b(b[7]), .cin(c[1]), .sum(sum[7]), .cout(c[2]));\n    \n    assign cout = c[2];\nendmodule\n\nmodule fa(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Submodule instances.\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .shift(ctrl_shift)\n);\n\nreg_unit reg_unit_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ain(ain),\n    .bin(bin),\n    .shift(ctrl_shift),\n    .product(product)\n);\n\nmultiplier_unit mul_unit_inst (\n    .clk(clk),\n    .ain(ain),\n    .bin(bin),\n    .shift(ctrl_shift),\n    .product(product)\n);\n\nassign yout = product;\nassign done = ctrl_done;\n\nendmodule\n\n// Control Unit submodule implementation.\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift\n);\n\nreg [4:0] cnt;\nreg start_reg;\nreg done;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        start_reg <= 0;\n        done <= 0;\n    end else begin\n        if (start) begin\n            cnt <= 0;\n            start_reg <= 1;\n            done <= 0;\n        end else if (start_reg) begin\n            if (cnt == 5'd16) begin\n                start_reg <= 0;\n                done <= 1;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nend\n\nassign shift = cnt;\nendmodule\n\n// Register Unit submodule implementation.\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift,  // Shift count.\n    output reg [31:0] product\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0;\n    end else if (start) begin\n        product <= {bin[15 - shift], bin[15:shift]} << 16;\n    end\nend\n\nendmodule\n\n// Multiplier Unit submodule implementation.\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift,  // Shift count.\n    output reg [31:0] product\n);\n\nalways @(posedge clk) begin\n    product <= product + ({bin[15 - shift], bin[15:shift]} << 16);\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\n\n// Instantiate the counter logic module\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count_in(count),\n    .count_out(next_count)\n);\n\n// Instantiate the counter register module\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count_out(count)\n);\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count_in,\n    output reg [15:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count_out <= 0;\n    else if (up_down)\n        count_out <= count_in + 1;\n    else\n        count_out <= count_in - 1;\nend\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count_out <= 0;\n    else\n        count_out <= next_count;\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // State Initialization Submodule\n    ring_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State Transition Submodule\n    ring_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule ring_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001; // Initial state (LSB)\n        end\n    end\nendmodule\n\nmodule ring_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out,\n    output reg [7:0] out_next\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_next <= 8'b0000_0001; // Initial state (LSB)\n        end else begin\n            out_next <= (out == 8'b1111_1111) ? 8'b0000_0001 : out + 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count_value;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instantiate the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q_next(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .Q(reg_inst.Q),\n        .next_Q(next_Q)\n    );\n\n    assign Q = reg_inst.Q;\n\nendmodule\n\n// Submodule for register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q_next,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n            Q_next <= 64'b0;\n        end else begin\n            Q <= Q_next;\n        end\n    end\n\nendmodule\n\n// Submodule for logic\nmodule JC_logic(\n    input [63:0] Q,\n    output reg [63:0] next_Q\n);\n\n    always @(*) begin\n        next_Q = Q & (Q - 1);\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 1) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4_avg;\n    wire clk_3_avg;\n    wire clk_4_adj;\n    wire clk_3_adj;\n    \n    // Instantiate counter\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4_avg)\n    );\n    \n    // Instantiate clock average generator\n    clk_average u_clk_average(\n        .clk_in(clk_4_avg),\n        .clk_out(clk_3_avg)\n    );\n    \n    // Instantiate clock adjustment\n    clk_adjustment u_clk_adjustment(\n        .clk_in(clk_3_avg),\n        .clk_out(clk_3_adj)\n    );\n    \n    // Divide input clock by 3.5 using a double-edge clocking technique\n    assign clk_div = clk_3_adj | clk_4_adj;\n    \nendmodule\n\n// Counter submodule\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n    localparam CLK_CNT_LIMIT = 10 - 1; // 10 clock cycles\n    reg [CLK_CNT_LIMIT:0] cnt_d, cnt_q;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            cnt_d <= 0;\n            clk_div <= 0;\n        end\n        else if(cnt_q == CLK_CNT_LIMIT) begin\n            cnt_d <= 0;\n            clk_div <= ~clk_div;\n        end\n        else begin\n            cnt_d <= cnt_q + 1'b1;\n            clk_div <= clk_div;\n        end\n    end\n    \n    assign clk_div = cnt_q == CLK_CNT_LIMIT;\n    \nendmodule\n\n// Clock average generator submodule\nmodule clk_average(\n    input               clk_in,\n    output reg          clk_out\n);\n    reg [1:0] clk_cnt;\n    always @(posedge clk_in) begin\n        clk_cnt <= clk_cnt + 1;\n        clk_out <= clk_cnt[1];\n    end\nendmodule\n\n// Clock adjustment submodule\nmodule clk_adjustment(\n    input               clk_in,\n    output reg          clk_out\n);\n    reg clk_out_d;\n    always @(posedge clk_in) begin\n        clk_out_d <= ~clk_in;\n        clk_out <= clk_out_d;\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [$clog2(NUM_DIV)-1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end else begin\n            clk_div <= 1;\n            cnt <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [$clog2(NUM_DIV)-1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end else begin\n            clk_div <= 1;\n            cnt <= 0;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    localparam NUM_DIV = 4;\n\n    wire clk_div_en;\n    reg [3:0] cnt;\n    reg clk_div_int;\n\n    // Counter Submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_max(NUM_DIV / 2 - 1),\n        .cnt(cnt)\n    );\n\n    // Clock Divider Submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div_int)\n    );\n\n    // Connect the outputs\n    assign clk_div = clk_div_int;\n\nendmodule\n\n// Counter Submodule\nmodule counter(\n    input clk,\n    input rst_n,\n    input [3:0] cnt_max,\n    output reg [3:0] cnt\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (cnt == cnt_max) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\n// Clock Divider Submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (clk_div_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lu_result;\n    wire add_carry, add_overflow;\n    wire slt_flag, sltu_flag;\n    \n    add add_inst(.a(a), .b(b), .c(aluc[4:0]), .r(add_result), .carry(add_carry), .overflow(add_overflow));\n    add addu_inst(.a(a), .b(b), .c(aluc[4:0]), .r(sub_result));\n    sub sub_inst(.a(a), .b(b), .c(aluc[4:0]), .r(sub_result));\n    and and_inst(.a(a), .b(b), .r(and_result));\n    or or_inst(.a(a), .b(b), .r(or_result));\n    xor xor_inst(.a(a), .b(b), .r(xor_result));\n    nor nor_inst(.a(a), .b(b), .r(nor_result));\n    slt slt_inst(.a(a), .b(b), .flag(slt_flag));\n    sltu sltu_inst(.a(a), .b(b), .flag(sltu_flag));\n    sll sll_inst(.a(a), .b(b[4:0]), .r(sll_result));\n    srl srl_inst(.a(a), .b(b[4:0]), .r(srl_result));\n    sra sra_inst(.a(a), .b(b[4:0]), .r(sra_result));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result));\n    srav srav_inst(.a(a), .b(b), .r(srav_result));\n    lui lui_inst(.a(a), .b(b), .r(lu_result));\n    \n    assign r = aluc[5] ? lu_result : aluc[4] ? srav_result : aluc[3] ? sllv_result : aluc[2] ? srlv_result : aluc[1] ? srl_result : aluc[0] ? sra_result : sll_result;\n    assign zero = |r;\n    assign carry = aluc[4] ? add_carry : aluc[3] ? add_overflow : aluc[2] ? add_overflow : aluc[1] ? add_overflow : aluc[0] ? add_overflow : 0;\n    assign negative = r[31];\n    assign overflow = aluc[4] ? add_overflow : aluc[3] ? 0 : aluc[2] ? add_overflow : aluc[1] ? add_overflow : aluc[0] ? add_overflow : 0;\n    assign flag = aluc[4] ? sltu_flag : aluc[3] ? 0 : aluc[2] ? slt_flag : aluc[1] ? 0 : aluc[0] ? 0 : 0;\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, input [4:0] c, output [31:0] r, output carry, output overflow);\n    assign r = a + b + c;\n    assign carry = (a[31] & b[31]) | (a[31] & c) | (b[31] & c);\n    assign overflow = (a[31] ^ b[31]) & (a[31] ^ r[31]) & (b[31] ^ r[31]);\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, input [4:0] c, output [31:0]"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] product;\n    wire [31:0] new_result;\n\n    // Instantiate multiplier\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    // Instantiate accumulator\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .new_result(new_result)\n    );\n\n    assign c = new_result;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] new_result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            new_result <= 0;\n        end else begin\n            new_result <= new_result + product[31:0];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    // Instruction fetching from register\n    ins_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad(ad11)\n    );\n\n    // Instruction fetching from RAM/ROM\n    ins_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad(ad22)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad22[4:0];\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\n// Instruction fetching module for registers\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\nendmodule\n\n// Instruction fetching module for RAM/ROM\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [7:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\n// Instantiate the counter module\ncounter cnt(\n    .clk(clk),\n    .enable(1'b1),\n    .freq(freq),\n    .count(count)\n);\n\n// Instantiate the wave generator module\nwave_generator wg(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == freq - 1) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    wave_out <= (count % freq == 0);\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    wire [1:0] state;\n\n    // State control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    // Waveform generation module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\n// State control module\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\n// Waveform generation module\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] out0, out1, out2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(out0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(out0),\n        .q(out1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(out1),\n        .q(out2)\n    );\n\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = out0;\n            2'b10: q = out1;\n            2'b11: q = out2;\n            default: q = d;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2;\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\nendmodule\n\nModule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] shifted_1, shifted_2, shifted_3, shifted_4;\n\nmux2X1 ins_17 (in[1], in[0], ctrl[2], shifted_1[0], shifted_1[1]);\nmux2X1 ins_16 (in[3], in[2], ctrl[2], shifted_2[2], shifted_2[3]);\nmux2X1 ins_15 (in[5], in[4], ctrl[2], shifted_3[4], shifted_3[5]);\nmux2X1 ins_14 (in[7], in[6], ctrl[2], shifted_4[6], shifted_4[7]);\n\nmux2X1 ins_13 (shifted_1, in[1], ctrl[1], shifted_2[0], shifted_2[1]);\nmux2X1 ins_12 (shifted_2, shifted_3, ctrl[1], shifted_3[0], shifted_3[1]);\nmux2X1 ins_11 (shifted_3, shifted_4, ctrl[1], shifted_4[0], shifted_4[1]);\nmux2X1 ins_10 (shifted_4, in[3], ctrl[0], shifted_4[2], shifted_4[3]);\n\nmux2X1 ins_27 (in[7], in[6], ctrl[0], shifted_4[6], shifted_4[7]);\nmux2X1 ins_26 (in[5], in[4], ctrl[0], shifted_3[4], shifted_3[5]);\nmux2X1 ins_25 (in[3], in[2], ctrl[0], shifted_2[2], shifted_2[3]);\nmux2X1 ins_24 (in[1], in[0], ctrl[0], shifted_1[0], shifted_1[1]);\n\nmux2X1 ins_23 (shifted_4[6], shifted_4[7], ctrl[0], out[6], out[7]);\nmux2X1 ins_22 (shifted_3[4], shifted_3[5], ctrl[0], out[4], out[5]);\nmux2X1 ins_21 (shifted_2[2], shifted_2[3], ctrl[0], out[2], out[3]);\nmux2X1 ins_20 (shifted_1[0], shifted_1[1], ctrl[0], out[0], out[1]);\n\nmux2X1 ins_07 (in[6], in[5], ctrl[0], out[4], out[5]);\nmux2X1 ins_06 (in[4], in[3], ctrl[0], out[2], out[3]);\nmux2X1 ins_05 (in[2], in[1], ctrl[0], out[0], out[1]);\nmux2X1 ins_04 (in[0], in[0], ctrl[0], out[0], out[1]);\n\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out0, out1);\ninput in0, in1, sel;\noutput out0, out1;\nassign out0 = sel ? in1 : in0;\nassign out1 = sel ? in0 : in1;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n\n  // Delayed b0 output to b1\n  reg [15:0] b1_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) b1_reg <= 0;\n    else     b1_reg <= b0;\n  end\n  assign b1 = b1_reg;\n\n  // PEs\n  PE pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] accum;\n  always @(posedge clk) begin\n    accum <= a * b + accum;\n  end\n  assign c = accum;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_res;\n  wire [31:0] wb_reg;\n  \n  // Stage: Fetch\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instr(instr)\n  );\n  \n  // Stage: Decode\n  decode_stage decode (\n    .clk(clk),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n  \n  // Stage: Execute\n  execute_stage execute (\n    .clk(clk),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .op(op),\n    .alu_res(alu_res)\n  );\n  \n  // Stage: Memory\n  memory_stage memory (\n    .clk(clk),\n    .alu_res(alu_res),\n    .alu_res_reg(wb_reg)\n  );\n  \n  // Stage: Writeback\n  writeback_stage writeback (\n    .clk(clk),\n    .wb_reg(wb_reg),\n    .res_reg_file(res_reg_file[rd])\n  );\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem[0:31],\n  output reg [31:0] pc,\n  output reg [31:0] instr\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      pc <= 0;\n    else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk) begin\n    rs1 <= instr[19:15];\n    rs2 <= instr[24:20];\n    rd <= instr[11:7];\n    op <= instr[31:26];\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output reg [31:0] alu_res\n);\n  always @(posedge clk) begin\n    case(op)\n      6'b000000: alu_res <= rs1 + rs2;\n      6'b000010: alu_res <= rs1 - rs2;\n      default: alu_res <= 0;\n    endcase\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_res,\n  output reg [31:0] alu_res_reg\n);\n  always @(posedge clk) begin\n    alu_res_reg <= alu_res;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] wb_reg,\n  output reg [31:0] res_reg_file[0:31]\n);\n  always @(posedge clk) begin\n    res_reg_file[0] <= wb_reg;\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  // Assign outputs\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\n  // Instantiate PEs\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0_reg)\n  );\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_reg)\n  );\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2_reg)\n  );\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3_reg)\n  );\n\n  // Delay b0, b1, b2, b3 by 1 clock cycle\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\nendmodule\n\n// PE module\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  wire [31:0] product;\n\n  assign product = a * b;\n  assign c = product + c;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr;\n    wire [31:0] decoded_instr;\n    wire [31:0] result;\n\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .fetched_instr(fetched_instr));\n    execute_stage execute(.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .reg_file(reg_file), .decoded_instr(decoded_instr));\n    writeback_stage writeback(.clk(clk), .rst(rst), .decoded_instr(decoded_instr), .reg_file(reg_file), .result(result));\n    \n    assign out_reg_file = result;\n    \n    reg [4:0] pc = 0;\n    \nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetched_instr <= 0;\n        end else begin\n            fetched_instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] decoded_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            decoded_instr <= 0;\n        end else begin\n            case (fetched_instr[6:0])\n                6'b000000: decoded_instr <= reg_file[fetched_instr[19:15]] + reg_file[fetched_instr[24:20]];\n                6'b000001: decoded_instr <= reg_file[fetched_instr[19:15]] - reg_file[fetched_instr[24:20]];\n                default: decoded_instr <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] decoded_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= decoded_instr;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [3:0] cnt_out;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .cnt_out(cnt_out),\n        .data_out(data_out)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt_out),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [3:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (valid_in) begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   cnt_out,\n\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end else if (cnt_out == 4) begin\n            data_out <= data_in + data_out;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   cnt_out,\n\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end else if (cnt_out == 4) begin\n            valid_out <= 1;\n        end else if (cnt_out == 0) begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend, abs_divisor, neg_divisor;\n    wire [15:0] quotient, remainder;\n    wire div_complete;\n\n    // Calculate absolute values\n    abs_value abs_dividend_m(\n        .dividend(dividend),\n        .abs_value(abs_dividend)\n    );\n    abs_value abs_divisor_m(\n        .dividend(divisor),\n        .abs_value(abs_divisor)\n    );\n\n    // Calculate negative divisor\n    neg_value neg_divisor_m(\n        .dividend(divisor),\n        .sign(sign),\n        .neg_value(neg_divisor)\n    );\n\n    // Control logic\n    divider_control ctrl_m(\n        .clk(clk),\n        .rst(rst),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .sign(sign),\n        .opn_valid(opn_valid),\n        .div_complete(div_complete),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result management\n    result_management res_mgmt_m(\n        .clk(clk),\n        .rst(rst),\n        .div_complete(div_complete),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    output reg [7:0] abs_value\n);\n\n    always @(*) begin\n        abs_value = dividend;\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] neg_value\n);\n\n    always @(*) begin\n        if(sign == 1)\n            neg_value = -dividend;\n        else\n            neg_value = dividend;\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire sign,\n    input wire opn_valid,\n    output reg div_complete,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [2:0] cnt;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            cnt <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            div_complete <= 0;\n        end\n        else begin\n            if(opn_valid) begin\n                cnt <= 0;\n                shift_reg <= {1'b1, dividend};\n                quotient <= 0;\n                remainder <= 0;\n                div_complete <= 0;\n            end\n            else begin\n                if(cnt < 8) begin\n                    if(shift_reg[0] == 1'b1) begin\n                        shift_reg <= shift_reg >> 1;\n                        quotient <= quotient << 1;\n                        quotient[0] <= 1'b1;\n                    end\n                    else begin\n                        shift_reg <= shift_reg >> 1;\n                        quotient <= quotient << 1;\n                        quotient[0] <= 1'b0;\n                    end\n                    cnt <= cnt + 1;\n                end\n                else begin\n                    shift_reg <= shift_reg >> 1;\n                    quotient <= quotient << 1;\n                    remainder <= shift_reg;\n                    div_complete <= 1;\n                end\n            end\n        end\n    end\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n   "}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    prep_dividend prep (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n    always @(*) begin\n        dividend = {A, 16'b0};\n        divisor = B;\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [15:0] dividend_reg;\n    reg [15:0] divisor_reg;\n    reg [15:0] q_reg;\n    reg [15:0] r_reg;\n    reg [15:0] count;\n\n    always @(*) begin\n        dividend_reg = dividend;\n        divisor_reg = divisor;\n        q_reg = 0;\n        r_reg = 0;\n        count = 0;\n    end\n\n    always @(posedge divisor_reg[15]) begin\n        while (dividend_reg[15:0] >= divisor_reg) begin\n            dividend_reg = dividend_reg - divisor_reg;\n            q_reg = q_reg + 1;\n        end\n        remainder = dividend_reg;\n        quotient = q_reg;\n        count = count + 1;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] dividend, quotient, remainder;\n    wire [7:0] divisor;\n    wire [7:0] shifted_dividend;\n    wire [2:0] counter;\n\n    assign dividend = A;\n    assign divisor = B;\n\n    div_ctrl ctrl (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder),\n        .counter(counter)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder,\n    output reg [2:0] counter\n);\n\n    reg [7:0] shifted_divisor;\n\n    always @(*) begin\n        shifted_divisor = divisor;\n        quotient = 0;\n        remainder = dividend;\n        counter = 0;\n\n        while (remainder > 0) begin\n            quotient = quotient << 1;\n            shifted_divisor = shifted_divisor << 1;\n\n            if (remainder >= shifted_divisor) begin\n                quotient = quotient + 1;\n                remainder = remainder - shifted_divisor;\n            end\n\n            if (counter == 15) begin\n                shifted_divisor = divisor;\n                counter = 0;\n            end else begin\n                counter = counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire [7:0] B_complement_sum;\nwire borrow_out;\n\nassign B_complement = ~B + 1;\nassign {borrow_out, B_complement_sum} = adder_8bit(A, B_complement);\n\nassign D = A - B_complement_sum;\nassign B_out = borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, C_in);\ninput [7:0] A;\ninput [7:0] B;\ninput C_in;\noutput [7:0] sum;\noutput C_out;\n\nwire [6:0] carry;\n\nfull_adder fa0(.A(A[0]), .B(B[0]), .C_in(C_in), .Sum(sum[0]), .C_out(carry[0]));\nfull_adder fa1(.A(A[1]), .B(B[1]), .C_in(carry[0]), .Sum(sum[1]), .C_out(carry[1]));\nfull_adder fa2(.A(A[2]), .B(B[2]), .C_in(carry[1]), .Sum(sum[2]), .C_out(carry[2]));\nfull_adder fa3(.A(A[3]), .B(B[3]), .C_in(carry[2]), .Sum(sum[3]), .C_out(carry[3]));\nfull_adder fa4(.A(A[4]), .B(B[4]), .C_in(carry[3]), .Sum(sum[4]), .C_out(carry[4]));\nfull_adder fa5(.A(A[5]), .B(B[5]), .C_in(carry[4]), .Sum(sum[5]), .C_out(carry[5]));\nfull_adder fa6(.A(A[6]), .B(B[6]), .C_in(carry[5]), .Sum(sum[6]), .C_out(carry[6]));\nfull_adder fa7(.A(A[7]), .B(B[7]), .C_in(carry[6]), .Sum(sum[7]), .C_out(C_out));\n\nendmodule\n\nmodule full_adder(A, B, C_in, Sum, C_out);\ninput A, B, C_in;\noutput Sum, C_out;\n\nassign Sum = A ^ B ^ C_in;\nassign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\n\nsub_16bit S1(A[15:0], B[15:0], S1_out);\nsub_16bit S2(A[31:16], B[31:16], S2_out);\n\nassign Diff = {S2_out, S1_out};\nassign B_out = S2_out[15];\n\nendmodule\n\nmodule sub_16bit(A, B, Diff);\ninput [15:0] A, B;\noutput [15:0] Diff;\n\nwire [15:0] B_complement;\nwire [15:0] Diff_16_1;\n\nassign B_complement = ~B;\n\n// First 16-bit subtractor\nsub_8bit S1(A[7:0], B_complement[7:0], Diff_16_1[7:0]);\nsub_8bit S2(A[15:8], B_complement[15:8], Diff_16_1[15:8]);\n\nassign Diff = {Diff_16_1[15:8], Diff_16_1[7:0]};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff);\ninput [7:0] A, B;\noutput [7:0] Diff;\n\nwire [7:0] B_complement;\nwire [7:0] Diff_8_1;\nwire B_1;\n\nassign B_complement = ~B;\n\n// First 8-bit subtractor\nsub_4bit S1(A[3:0], B_complement[3:0], Diff_8_1[3:0]);\nsub_4bit S2(A[7:4], B_complement[7:4], Diff_8_1[7:4]);\n\nassign Diff = {Diff_8_1[7:4], Diff_8_1[3:0]};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff);\ninput [3:0] A, B;\noutput [3:0] Diff;\n\nwire [3:0] B_complement;\nwire [3:0] Diff_4_1;\nwire B_1;\n\nassign B_complement = ~B;\n\n// First 4-bit subtractor\nsub_2bit S1(A[1:0], B_complement[1:0], Diff_4_1[1:0]);\nsub_2bit S2(A[3:2], B_complement[3:2], Diff_4_1[3:2]);\n\nassign Diff = {Diff_4_1[3:2], Diff_4_1[1:0]};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff);\ninput [1:0] A, B;\noutput [1:0] Diff;\n\nwire [1:0] B_complement;\nwire [1:0] Diff_2_1;\nwire B_1;\n\nassign B_complement = ~B;\n\n// First 2-bit subtractor\nsub_1bit S1(A[0], B_complement[0], Diff_2_1[0]);\nsub_1bit S2(A[1], B_complement[1], Diff_2_1[1]);\n\nassign Diff = Diff_2_1;\n\nendmodule\n\nmodule sub_1bit(A, B_complement, Diff);\ninput A, B_complement;\noutput Diff;\n\nassign Diff = A ^ B_complement;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire [31:0] B0, B1;\n    wire B_out0, B_out1;\n\n    // Instantiate 32-bit subtractors\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    // Generate D and B_out\n    assign D = {D1, D0};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] D0, D1;\n    wire [15:0] B0, B1;\n    wire B_out0, B_out1;\n\n    // Instantiate 16-bit subtractors\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    // Generate D and B_out\n    assign D = {D1, D0};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] D0, D1;\n    wire [7:0] B0, B1;\n    wire B_out0, B_out1;\n\n    // Instantiate 8-bit subtractors\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    // Generate D and B_out\n    assign D = {D1, D0};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] D0, D1;\n    wire [3:0] B0, B1;\n    wire B_out0, B_out1;\n\n    // Instantiate 4-bit subtractors\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    // Generate"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    bls_1bit bls0(.A(A[1:0]), .B(B[1:0]), .B_in(1'b1), .D(D[1:0]), .B_out(borrow[0]));\n    bls_1bit bls1(.A(A[3:2]), .B(B[3:2]), .B_in(borrow[0]), .D(D[3:2]), .B_out(borrow[1]));\n    bls_1bit bls2(.A(A[5:4]), .B(B[5:4]), .B_in(borrow[1]), .D(D[5:4]), .B_out(borrow[2]));\n    bls_1bit bls3(.A(A[7:6]), .B(B[7:6]), .B_in(borrow[2]), .D(D[7:6]), .B_out(borrow[3]));\n\n    assign B_out = borrow[3];\nendmodule\n\nmodule bls_1bit(A, B, B_in, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    input B_in;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] not_B = ~B;\n    wire [1:0] A_xor_not_B = A ^ not_B;\n    wire [1:0] B_or_not_B_in = B | ~B_in;\n\n    assign D = A_xor_not_B ^ B_or_not_B_in;\n    assign B_out = (~A_xor_not_B) & (A & B_in);\nendmodule\n\nmodule sub1(A, B, B_in, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    input B_in;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    bls_1bit bls0(.A(A[0]), .B(B[0]), .B_in(B_in), .D(D[0]), .B_out(borrow[0]));\n    bls_1bit bls1(.A(A[1]), .B(B[1]), .B_in(borrow[0]), .D(D[1]), .B_out(borrow[1]));\n    bls_1bit bls2(.A(A[2]), .B(B[2]), .B_in(borrow[1]), .D(D[2]), .B_out(borrow[2]));\n    bls_1bit bls3(.A(A[3]), .B(B[3]), .B_in(borrow[2]), .D(D[3]), .B_out(borrow[3]));\n\n    assign B_out = borrow[3];\nendmodule\n\nmodule sub2(A, B, B_in, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    input B_in;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    bls_1bit bls0(.A(A[3:0]), .B(B[3:0]), .B_in(B_in), .D(D[3:0]), .B_out(borrow[0]));\n    bls_1bit bls1(.A(A[7:4]), .B(B[7:4]), .B_in(borrow[0]), .D(D[7:4]), .B_out(borrow[1]));\n\n    assign B_out = borrow[1];\nendmodule\n\nmodule sub3(A, B, B_in, D, B_out);\n    input [11:0] A;\n    input [1"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] borrow;\n    wire [31:0] diff;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .borrow(borrow),\n        .diff(diff)\n    );\n\n    assign A_greater = ~borrow[31];\n    assign A_equal = ~|diff;\n    assign A_less = borrow[31] | |diff;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] borrow,\n    output [31:0] diff\n);\n    wire [32:0] borrow_next;\n\n    assign borrow = borrow_next[31:0];\n    assign diff = A - B - borrow_next;\n    assign borrow_next = {1'b0, diff[31:1]};\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [3:0] carry;\n\nCLA1 CLA1(.A(A[15:0]), .B(B[15:0]), .Cin(1'b0), .S(S[15:0]), .Cout(carry[0]));\nCLA2 CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(carry[0]), .S(S[31:16]), .Cout(carry[1]));\n\nassign C32 = carry[1];\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:0] A,B;\ninput Cin;\noutput [15:0] S;\noutput Cout;\n\nwire [15:0] B_not, sum, carry;\n\nnot(B_not, B);\n\nassign carry[0] = Cin;\nassign carry[1] = A[0]&B[0] | A[0]&B_not[0] | B[0]&B_not[0];\nassign carry[2] = A[1]&B[1] | A[1]&B_not[1] | B[1]&B_not[1] | A[1]&B[1]&B_not[1] | A[1]&B_not[1]&B[1];\nassign carry[3] = A[2]&B[2] | A[2]&B_not[2] | B[2]&B_not[2] | A[2]&B[2]&B_not[2] | A[2]&B_not[2]&B[2];\nassign carry[4] = A[3]&B[3] | A[3]&B_not[3] | B[3]&B_not[3] | A[3]&B[3]&B_not[3] | A[3]&B_not[3]&B[3];\nassign carry[5] = A[4]&B[4] | A[4]&B_not[4] | B[4]&B_not[4] | A[4]&B[4]&B_not[4] | A[4]&B_not[4]&B[4];\nassign carry[6] = A[5]&B[5] | A[5]&B_not[5] | B[5]&B_not[5] | A[5]&B[5]&B_not[5] | A[5]&B_not[5]&B[5];\nassign carry[7] = A[6]&B[6] | A[6]&B_not[6] | B[6]&B_not[6] | A[6]&B[6]&B_not[6] | A[6]&B_not[6]&B[6];\nassign carry[8] = A[7]&B[7] | A[7]&B_not[7] | B[7]&B_not[7] | A[7]&B[7]&B_not[7] | A[7]&B_not[7]&B[7];\nassign carry[9] = A[8]&B[8] | A[8]&B_not[8] | B[8]&B_not[8] | A[8]&B[8]&B_not[8] | A[8]&B_not[8]&B[8];\nassign carry[10] = A[9]&B[9] | A[9]&B_not[9] | B[9]&B_not[9] | A[9]&B[9]&B_not[9] | A[9]&B_not[9]&B[9];\nassign carry[11] = A[10]&B[10] | A[10]&B_not[10] | B[10]&B_not[10] | A[10]&B[10]&B_not["}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    \n    wire [3:0] c_out;\n    wire [15:0] s;\n\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s[3:0]), .cout(c_out[0]));\n    ripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(c_out[0]), .sum(s[7:4]), .cout(c_out[1]));\n    ripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(c_out[1]), .sum(s[11:8]), .cout(c_out[2]));\n    ripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(c_out[2]), .sum(s[15:12]), .cout(c_out[3]));\n    \n    assign sum = s;\n    assign cout = c_out[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    \n    wire [4:0] c;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    assign cout = c[3];\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    \n    wire [3:0] c_out;\n    wire [15:0] s;\n    \n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s[3:0]), .cout(c_out[0]));\n    carry_select_adder_4bit csa_slice1(.a(s[3:0]), .b(s[7:4]), .cin(c_out[0]), .sum(s[7:4]), .cout(c_out[1]));\n    carry_select_adder_4bit csa_slice2(.a(s[7:4]), .b(s[11:8]), .cin(c_out[1]), .sum(s[11:8]), .cout(c_out[2]));\n    carry_select_adder_4bit csa_slice3(.a(s[11:8]), .b(s[15:12]), .cin(c_out[2]), .sum(s[15:12]), .cout(c_out[3]));\n    \n    assign sum = s;\n    assign cout = c_out[3];\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    \n    wire [3:0] c;\n    \n    full_adder fa0(.a(a[0]), ."}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n    wire [7:0] sum;\n\n    // Instantiate 8-bit adders for each 8-bits\n    adder_8bit add8_inst1 (.a(a[7:0]), .b(b[7:0]), .Cin(Cin), .y(sum[7:0]), .Co(carry[0]));\n    adder_8bit add8_inst2 (.a(a[15:8]), .b(b[15:8]), .Cin(carry[0]), .y(sum[15:8]), .Co(carry[1]));\n\n    // Final carry-out\n    assign Co = carry[1];\n    assign y = sum;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n    wire [6:0] carry;\n\n    // Adder for each 8-bits\n    adder_4bit add4_inst1 (.a(a[3:0]), .b(b[3:0]), .Cin(Cin), .y(sum[3:0]), .Co(carry[0]));\n    adder_4bit add4_inst2 (.a(a[7:4]), .b(b[7:4]), .Cin(carry[0]), .y(sum[7:4]), .Co(carry[1]));\n\n    // Final carry-out\n    assign Co = carry[1];\n    assign y = sum;\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [3:0] sum;\n    wire [2:0] carry;\n\n    // Adder for each 4-bits\n    adder_2bit add2_inst1 (.a(a[1:0]), .b(b[1:0]), .Cin(Cin), .y(sum[1:0]), .Co(carry[0]));\n    adder_2bit add2_inst2 (.a(a[3:2]), .b(b[3:2]), .Cin(carry[0]), .y(sum[3:2]), .Co(carry[1]));\n\n    // Final carry-out\n    assign Co = carry[1];\n    assign y = sum;\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    wire [1:0] sum;\n    wire carry_out;\n\n    // Simple addition\n    assign {Co, sum} = a + b + Cin;\n\n    assign y = sum;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [3:0] c;\n\n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[6];\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [4:0] shift_count; // Shift count register.\n    wire [31:0] product;    // Product register.\n    wire [15:0] m, b;       // Register for input signals.\n    wire start_d;            // D flip-flop for start signal.\n    wire reset_d;            // D flip-flop for reset signal.\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .start_d(start_d),\n        .reset_d(reset_d),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start_d(start_d),\n        .reset_d(reset_d),\n        .ain(ain),\n        .bin(bin),\n        .m(m),\n        .b(b)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .m(m),\n        .b(b),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = reset_d | start_d;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg start_d, // D flip-flop for start signal.\n    output reg reset_d, // D flip-flop for reset signal.\n    output reg [4:0] shift_count // Shift count register.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            start_d <= 1'b0;\n            reset_d <= 1'b1;\n            shift_count <= 5'd0;\n        end else begin\n            start_d <= start;\n            reset_d <= 1'b1;\n            if (start_d) begin\n                shift_count <= 5'd0;\n            end else if (shift_count != 5'd15) begin\n                shift_count <= shift_count + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start_d,      // D flip-flop for start signal.\n    input reset_d,      // D flip-flop for reset signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] m, // Register for input a.\n    output reg [15:0] b  // Register for input b.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m <= 16'd0;\n            b <= 16'd0;\n        end else if (reset_d) begin\n            m <= ain;\n            b <= bin;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] m,     // Multiplicand (a) with a data width of 16 bits.\n    input [15:0] b,     // Multiplier (b) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count.\n    output reg [31:0] product  // Product register.\n);\n\n    always @(posedge clk) begin\n        if (shift_count == 5'd0) begin\n           "}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(current_count),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(current_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_count <= 16'b0;\n        else begin\n            if (up_down)\n                next_count <= current_count + 1;\n            else\n                next_count <= current_count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    input wire [15:0] current_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 16'b0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // Submodule to initialize the ring counter\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(next_state)\n    );\n\n    // Submodule to transition between states\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out),\n        .next_state(next_state)\n    );\n\nendmodule\n\n// Submodule to initialize the ring counter\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\n// Submodule to transition between states\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out,\n    output reg [7:0] next_state\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_state <= 8'b0000_0001;\n        end else begin\n            next_state <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_in(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else if (valid_count) begin\n            if (count_out == 4'd11)\n                count_out <= 4'b0000;\n            else\n                count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count_in;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_Q;\n\n    // Instantiate the register and logic submodules\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    JC_logic logic_inst(\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n    end\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input [63:0] Q,\n    output reg [63:0] Q_next\n);\n    always @(*) begin\n        Q_next = {Q[62:0], Q[63]}; // Rotate by 1\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 3) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4cycle, clk_3cycle;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_4cycle)\n    );\n\n    clk_average u_clk_average (\n        .clk_div(clk_4cycle),\n        .clk_div_3cycle(clk_3cycle)\n    );\n\n    clk_adjustment u_clk_adjustment (\n        .clk_div(clk_3cycle),\n        .clk_div_n(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7; // 3.5x division factor\n\n    reg [31:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == (2 * MUL2_DIV_CLK - 1)) begin\n            cnt <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk_div,\n    output reg          clk_div_3cycle\n);\n\n    reg [1:0] clk_div_reg;\n\n    always @(posedge clk_div) begin\n        clk_div_reg <= {clk_div_reg[0], clk_div};\n        clk_div_3cycle <= clk_div_reg[1];\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk_div,\n    output reg          clk_div_n\n);\n\n    reg clk_div_n_d;\n\n    always @(posedge clk_div) begin\n        clk_div_n_d <= ~clk_div_n;\n        clk_div_n <= clk_div_n_d;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end else begin\n            cnt <= 0;\n            clk_div <= 1;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt < NUM_DIV - 1) begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end else begin\n            cnt <= 0;\n            clk_div <= 1;\n        end\n    end\n\nendmodule\n\n`timescale 1ns/1ps\n\nmodule freq_divbyodd_tb;\n    reg clk;\n    reg rst_n;\n\n    wire clk_div;\n\n    freq_divbyodd u_freq_divbyodd (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div)\n    );\n\n    always begin\n        clk = 0;\n        #10 clk = 1;\n        #10 clk = 0;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8; // Division factor\n\nwire clk_div_en;\nwire [3:0] counter;\n\nassign clk_div_en = counter == NUM_DIV/2-1;\n\ncounter_divider u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_en(clk_div_en),\n    .counter_out(counter)\n);\n\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg [3:0] counter\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (clk_div_en) begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out;\n    wire [31:0] sll_out, srl_out, sra_out, sllv_out, srlv_out, srav_out;\n    wire [31:0] lui_out;\n    wire add_zero, add_carry, sub_zero, sub_borrow, slt_out, sltu_out;\n    wire add_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow;\n    \n    adder add(.a(a), .b(b), .r(add_out), .zero(add_zero), .carry(add_carry));\n    adder sub(.a(a), .b(b), .r(sub_out), .zero(sub_zero), .carry(sub_borrow));\n    and_or and_or(.a(a), .b(b), .r(and_out), .r(or_out), .r(nor_out));\n    logic_op logic_op(.a(a), .b(b), .r(and_out), .r(or_out), .r(nor_out));\n    shift_left shift_left(.a(a), .b(b), .r(sll_out), .overflow(sll_overflow));\n    shift_right shift_right(.a(a), .b(b), .r(srl_out), .overflow(srl_overflow));\n    shift_right shift_right_arithmetic shift_right_arithmetic(.a(a), .b(b), .r(sra_out), .overflow(sra_overflow));\n    shift_left_variable shift_left_variable(.a(a), .b(b), .r(sllv_out), .overflow(sllv_overflow));\n    shift_right_variable shift_right_variable(.a(a), .b(b), .r(srlv_out), .overflow(srlv_overflow));\n    shift_right_variable shift_right_arithmetic_variable shift_right_arithmetic_variable(.a(a), .b(b), .r(srav_out), .overflow(srav_overflow));\n    lui lui(.a(a), .b(b), .r(lui_out));\n    \n    assign r = aluc[5:0] == 6'b000000 ? a :\n              aluc[5:0] == 6'b000001 ? add_out :\n              aluc[5:0] == 6'b000010 ? sub_out :\n              aluc[5:0] == 6'b000011 ? sub_out :\n              aluc[5:0] == 6'b000100 ? and_out :\n              aluc[5:0] == 6'b000101 ? or_out :\n              aluc[5:0] == 6'b000110 ? xor_out :\n              aluc[5:0] == 6'b000111 ? nor_out :\n              aluc[5:0] == 6'b001010 ? slt_out :\n              aluc[5:0] == 6'b001011 ? sltu_out :\n              aluc[5:0] == 6'b000000 ? sll_out :\n              aluc[5:0] == 6'b000010 ? srl_out :\n              aluc[5:0] == 6'b000011 ? sra_out :\n              aluc[5:0] == 6'b000100 ? sllv_out :\n              aluc[5:0] == 6'b000110 ? srlv_out :\n              aluc[5:0] == 6'b000111 ? srav_out :\n              aluc[5:0] == 6'b001111 ? lui_out : 32'bx"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] product;\n    wire [31:0] next_value;\n    wire [31:0] current_value;\n\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .current_value(current_value),\n        .next_value(next_value),\n        .product(product)\n    );\n\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [63:0] next_value,\n    input [63:0] product\n);\n    reg [31:0] current_value_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value_reg <= 0;\n        else\n            current_value_reg <= current_value_reg + next_value;\n    end\n\n    assign current_value = current_value_reg;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad22;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    ins_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad22)\n    );\n\n    ins_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    assign ins = fetch[0] ? ins1 : ins2;\n    assign ad1 = fetch[0] ? ad11 : ad12;\n    assign ad2 = fetch[1] ? ad22 : 8'b0;\n\nendmodule\n\nmodule ins_p (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\ncounter cnt(\n    .clk(clk),\n    .enable(1'b1),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wg(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            if (wave == 5'd31) begin\n                wave <= 5'd0;\n            end else begin\n                wave <= wave + 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] inter_q[2:0];\n    my_dff8 u0 (.clk(clk), .d(d), .q(inter_q[0]));\n    my_dff8 u1 (.clk(clk), .d(inter_q[0]), .q(inter_q[1]));\n    my_dff8 u2 (.clk(clk), .d(inter_q[1]), .q(inter_q[2]));\n\n    always @(posedge clk) begin\n        q <= (sel == 2'b00) ? d : (sel == 2'b01) ? inter_q[0] : (sel == 2'b10) ? inter_q[1] : inter_q[2];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire w0, w1, w2;\n\n    // Instance of D flip-flop\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(w0)\n    );\n\n    // Instance of D flip-flop\n    my_dff u1 (\n        .clk(clk),\n        .d(w0),\n        .q(w1)\n    );\n\n    // Instance of D flip-flop\n    my_dff u2 (\n        .clk(clk),\n        .d(w1),\n        .q(w2)\n    );\n\n    assign q = w2;\n\nendmodule\n\nModule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_by_4;\n    wire [7:0] shifted_by_2;\n    wire [7:0] shifted_by_1;\n\n    assign shifted_by_4 = ctrl[2] ? {in[3:0], in[7:4]} : in;\n    assign shifted_by_2 = ctrl[1] ? {shifted_by_4[1:0], shifted_by_4[7:2]} : shifted_by_4;\n    assign shifted_by_1 = ctrl[0] ? {shifted_by_2[0], shifted_by_2[7:1]} : shifted_by_2;\n\n    assign out = shifted_by_1;\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input sel;\n    input in0, in1;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  assign b1 = b0;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 0;\n    else\n      c <= c + a * b;\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [31:0] next_pc;\n\n  fetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(next_pc)\n  );\n  decode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.instr),\n    .rs1(fetch.rs1),\n    .rs2(fetch.rs2),\n    .rd(fetch.rd),\n    .op(fetch.op)\n  );\n  execute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .rs1(decode.rs1),\n    .rs2(decode.rs2),\n    .rd(decode.rd),\n    .op(decode.op),\n    .alu_res(alu_res)\n  );\n  memory_stage memory(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(execute.alu_res),\n    .pc(next_pc)\n  );\n  writeback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .res(memory.res),\n    .rd(decode.rd),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign next_pc = next_pc + 4;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] instr,\n  output reg [31:0] pc,\n  output reg [31:0] rs1,\n  output reg [31:0] rs2,\n  output reg [31:0] rd,\n  output reg [1:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      instr <= 0;\n      pc <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 4;\n      rs1 <= instr[19:15];\n      rs2 <= instr[24:20];\n      rd <= instr[11:7];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [31:0] rs1,\n  output reg [31:0] rs2,\n  output reg [31:0] rd,\n  output reg [1:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[19:15];\n      rs2 <= instr[24:20];\n      rd <= instr[11:7];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [31:0] rd,\n  input [1:0] op,\n  output reg [31:0] alu_res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res <= 0;\n    end else begin\n      case (op)\n        2'b00: alu_res <= rs1 + rs2;\n        2'b01: alu_res <= rs1 - rs2;\n        default: alu_res <= 0;\n     "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0_reg)\n  );\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1_reg),\n    .c(c1_reg)\n  );\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2_reg),\n    .c(c2_reg)\n  );\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3_reg),\n    .c(c3_reg)\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= c0_reg + b0_reg * a0;\n      c1_reg <= c1_reg + b1_reg * a1;\n      c2_reg <= c2_reg + b2_reg * a2;\n      c3_reg <= c3_reg + b3_reg * a3;\n    end\n  end\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) c <= 0;\n    else c <= c + a * b;\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr;\n    wire [31:0] instr_type;\n    wire [31:0] op1, op2, res;\n    wire [4:0] dest;\n\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(fetched_instr), .instr_type(instr_type));\n    execute_stage execute(.clk(clk), .rst(rst), .instr_type(instr_type), .op1(op1), .op2(op2), .res(res), .dest(dest));\n    writeback_stage writeback(.clk(clk), .rst(rst), .dest(dest), .res(res), .reg_file(reg_file), .out_reg_file(out_reg_file));\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] pc,\n    output reg [31:0] fetched_instr\n);\n    reg [4:0] pc_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            pc_reg <= 0;\n        else begin\n            pc <= pc_reg;\n            fetched_instr <= instr_mem[pc_reg];\n            pc_reg <= pc_reg + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_type,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] res,\n    output reg [4:0] dest\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res <= 0;\n            dest <= 0;\n        end else begin\n            case(instr_type)\n                32'b00000000000000000000000000000000: res <= op1 + op2;\n                32'b00000000000000000000000000000001: res <= op1 - op2;\n                default: res <= 0;\n            endcase\n            dest <= instr_type[15:11];\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] dest,\n    input [31:0] res,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file[dest] <= res;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [2:0] cnt_out;\n    wire [9:0] data_acc;\n    wire valid_out_i;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_acc(data_acc)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out),\n        .valid_out(valid_out_i)\n    );\n\n    assign data_out = data_acc;\n    assign valid_out = valid_out_i;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   cnt_out\n);\n\n    reg [2:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (valid_in)\n            cnt <= cnt + 1;\n    end\n\n    assign cnt_out = cnt;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [9:0]   data_acc\n);\n\n    reg [9:0] data_sum;\n\n    always @(posedge clk) begin\n        if (valid_in)\n            data_sum <= data_sum + data_in;\n    end\n\n    assign data_acc = data_sum;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               valid_in,\n    input       [2:0]   cnt_out,\n    output reg          valid_out\n);\n\n    always @(posedge clk) begin\n        if (valid_in && cnt_out == 3)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend, abs_divisor;\nwire [7:0] neg_divisor_mod;\nwire [3:0] counter;\nwire [7:0] shift_reg;\nwire [7:0] quotient;\nwire [7:0] remainder;\n\n// Instantiate submodules\nabs_value abs_dividend_inst(.dividend(dividend), .sign(sign), .abs_value(abs_dividend));\nabs_value abs_divisor_inst(.dividend(divisor), .sign(sign), .abs_value(abs_divisor));\nneg_value neg_divisor_inst(.abs_value(abs_divisor), .neg_value(neg_divisor_mod));\ndivider_control ctrl_inst(.clk(clk), .rst(rst), .opn_valid(opn_valid), .counter(counter));\nresult_management res_mgmt_inst(.clk(clk), .rst(rst), .counter(counter), .shift_reg(shift_reg), .quotient(quotient), .remainder(remainder), .res_ready(res_ready), .res_valid(res_valid));\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] abs_value\n);\n    always @(*) begin\n        if (sign)\n            abs_value = -dividend;\n        else\n            abs_value = dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire [7:0] abs_value,\n    output reg [7:0] neg_value\n);\n    always @(*) begin\n        neg_value = -abs_value;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            counter <= 0;\n        else if (opn_valid)\n            counter <= 1;\n        else if (counter > 0)\n            counter <= counter + 1;\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire [7:0] quotient,\n    input wire [7:0] remainder,\n    input wire res_ready,\n    output reg res_valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (res_ready) begin\n            res_valid <= 1;\n        end else if (counter == 0) begin\n            res_valid <= 0;\n        end\n    end\nendmodule\n\nmodule radix2_div_top(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n    wire [7:0] abs_dividend, abs_divisor;\n    wire [7:0] neg_divisor_mod;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [15:0] final_result;\n\n    assign abs_dividend = dividend;\n    assign abs_divisor = divisor;\n\n    // Instantiate submodules\n    abs_value abs_dividend_inst(.dividend(dividend), .sign(sign), .abs_value(abs_dividend));\n    abs_value abs_divisor_inst(.dividend(divisor), .sign(sign), .abs_value(abs_divisor));\n    neg_"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] A_prep;\n    wire [15:0] B_prep;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep (\n        .dividend(A),\n        .divisor(B),\n        .prep_dividend(A_prep),\n        .prep_divisor(B_prep)\n    );\n\n    div_operation div_op (\n        .dividend(A_prep),\n        .divisor(B_prep),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] prep_dividend,\n    output reg [15:0] prep_divisor\n);\n\n    always @(*) begin\n        prep_dividend = {dividend[31:16], dividend[31:16]};\n        prep_divisor = {divisor, 16'b0};\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] counter;\n\n    always @(*) begin\n        shifted_dividend = {dividend[31:16], dividend[31:16]};\n        shifted_divisor = {divisor, 16'b0};\n        quotient = 0;\n        remainder = 0;\n        counter = 0;\n    end\n\n    always @(posedge shifted_dividend[31:0] or posedge shifted_divisor[15:0]) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            quotient = {quotient[30:0], 1'b1};\n            remainder = shifted_dividend;\n        end else begin\n            shifted_dividend = shifted_dividend << 1;\n            remainder = shifted_dividend;\n            counter = counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [3:0] i;\n\n    control_unit ctrl (.A(A), .B(B), .result(result), .odd(odd));\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] shifted_dividend;\n    wire [3:0] i;\n\n    // Initialize variables\n    initial begin\n        result = 16'b0;\n        odd = 16'b0;\n    end\n\n    // Shift dividend left\n    always @* begin\n        shifted_dividend = A << i;\n    end\n\n    // Compare with divisor\n    always @* begin\n        if (shifted_dividend >= B) begin\n            shifted_dividend = shifted_dividend - B;\n            result = result | (1 << i);\n        end\n    end\n\n    // Increment i\n    always @* begin\n        if (shifted_dividend >= B) begin\n            i = i + 1;\n        end\n    end\n\n    // Update remainder\n    always @* begin\n        odd = shifted_dividend;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_compl;\n    wire carry;\n\n    assign B_compl = ~B + 1;\n    assign {carry, D} = adder_8bit(A, B_compl);\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(a, b, c_in);\n    input [7:0] a, b;\n    input c_in;\n    output [7:0] sum;\n    output c_out;\n\n    wire c1, c2, c3;\n    assign {c1, sum[0]} = full_adder(a[0], b[0], c_in);\n    assign {c2, sum[1]} = full_adder(a[1], b[1], c1);\n    assign {c3, sum[2]} = full_adder(a[2], b[2], c2);\n    assign {c_out, sum[3]} = full_adder(a[3], b[3], c3);\n    assign {sum[4], sum[5]} = full_adder(a[4], b[4], c3);\n    assign {sum[6], sum[7]} = full_adder(a[6], b[6], c3);\nendmodule\n\nmodule full_adder(a, b, c_in);\n    input a, b, c_in;\n    output sum, c_out;\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\n\nsub_16bit S1(A[15:0], B[15:0], S1_out);\nsub_16bit S2(A[31:16], B[31:16], S2_out);\n\nassign Diff[15:0] = S1_out;\nassign Diff[31:16] = S2_out;\nassign B_out = S2_out[15];\n\nendmodule\n\nmodule sub_16bit(A, B, Diff);\ninput [15:0] A, B;\noutput [15:0] Diff;\n\nwire [14:0] B_neg, A_neg, Diff_15, Diff_16;\nwire borrow_in;\n\nassign B_neg = ~B + 1;\nassign A_neg = ~A + 1;\n\nsub_16bit S1(A_neg, B_neg, Diff_15);\nsub_16bit S2(Diff_15, 16'b0, Diff_16);\n\nassign Diff = Diff_16;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_in;\n    wire [31:0] borrow;\n    wire B_out_internal;\n\n    assign B_in = B;\n\n    sub_32bit sub0(.A(A[31:0]), .B(B_in[31:0]), .D(D[31:0]), .B_out(borrow[0]));\n    sub_32bit sub1(.A(A[63:32]), .B(B_in[63:32]), .D(D[63:32]), .B_out(borrow[1]));\n\n    assign B_out = borrow[1];\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] borrow;\n    wire B_out_internal;\n\n    sub_16bit sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(borrow[0]));\n    sub_16bit sub1(.A(A[31:16]), .B(B[31:16]), .D(D[31:16]), .B_out(borrow[1]));\n\n    assign B_out = borrow[1];\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] borrow;\n    wire B_out_internal;\n\n    sub_8bit sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(borrow[0]));\n    sub_8bit sub1(.A(A[15:8]), .B(B[15:8]), .D(D[15:8]), .B_out(borrow[1]));\n\n    assign B_out = borrow[1];\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] borrow;\n    wire B_out_internal;\n\n    sub_4bit sub0(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(borrow[0]));\n    sub_4bit sub1(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(borrow[1]));\n    sub_4bit sub2(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(borrow[2]));\n    sub_4bit sub3(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(borrow[3]));\n\n    assign B_out = borrow[3];\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] borrow;\n    wire B_out_internal;\n\n    sub_2bit sub0(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(borrow[0]));\n    sub_2bit sub1(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(borrow[1]));\n\n    assign B_out = borrow[1];\n\nendmodule\n\nmodule sub_2bit("}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] borrow;\n\n    sub_4bit sub1(A[1:0], B[1:0], D[1:0], borrow[0]);\n    sub_4bit sub2(A[3:2], B[3:2], D[3:2], borrow[1]);\n    sub_4bit sub3(A[5:4], B[5:4], D[5:4], borrow[2]);\n    sub_4bit sub4(A[7:6], B[7:6], D[7:6], borrow[3]);\n    assign B_out = borrow[3];\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [2:0] borrow;\n\n    sub_2bit sub1(A[1:0], B[1:0], D[1:0], borrow[0]);\n    sub_2bit sub2(A[3:2], B[3:2], D[3:2], borrow[1]);\n    assign B_out = borrow[1];\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [2:0] A;\n    input [2:0] B;\n    output [2:0] D;\n    output B_out;\n\n    wire [1:0] borrow;\n\n    sub_1bit sub1(A[1:0], B[1:0], D[1:0], borrow[0]);\n    assign B_out = borrow[0];\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] result;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(result)\n    );\n\n    assign A_greater = (result == 32'b0);\n    assign A_equal = (result == 32'b0);\n    assign A_less = (result[31] == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    wire [31:0] borrow;\n\n    assign result = A - B;\n    assign borrow = A[31] ^ B[31];\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire [32:1] C;\n\n    wire [16:1] C16;\n    wire C160,C161,C162,C163;\n\n    cla_32bit CLA1(.A(A[32:16]), .B(B[32:16]), .S(S[32:16]), .Cin(C[32]), .Cout(C160));\n    cla_32bit CLA2(.A(A[16:1]), .B(B[16:1]), .S(S[16:1]), .Cin(C160), .Cout(C161));\n\n    assign C32 = C162 & C163;\nendmodule\n\nmodule cla_32bit(A,B,S,Cin,Cout);\n    input [32:1] A,B;\n    input Cin;\n    output [32:1] S;\n    output Cout;\n\n    wire [31:0] P,G;\n    wire [32:1] C;\n    genvar i;\n    generate\n        assign P = A ^ B;\n        assign G = A & B;\n        assign C[32] = Cin;\n        for(i=1; i<32; i=i+1) begin : CLA_gen\n            assign C[i] = G[i-1] | (P[i-1] & C[i-1]);\n        end\n        assign S = P ^ C;\n        assign Cout = G[31];\n    endgenerate\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    adder_4bit adder0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n    adder_4bit adder1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n    adder_4bit adder2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n    adder_4bit adder3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    assign cout = carry[3];\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    adder_2bit adder0(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n    adder_2bit adder1(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n\n    assign cout = carry[1];\nendmodule\n\nmodule adder_2bit(a, b, cin, sum, cout);\n    input [1:0] a, b;\n    input cin;\n    output [1:0] sum;\n    output cout;\n\n    wire c1, c2;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(cout));\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    adder_2bit adder0(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slice[1:0]), .cout(carry[0]));\n    adder_2bit adder1(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slice[3:2]), .cout(carry[1]));\n    adder_2bit adder2(.a(a[3:2]), .b(b[3:2]), .cin(cin), .sum(sum_slice[3:2]), .cout(carry[2]));\n\n    assign {cout, sum} = {carry[2], sum_slice};\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    adder_2bit adder0(.a(a[1:0]), .b("}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [7:0] carry;\n    wire [15:0] y_internal;\n\n    // Instantiate the adder for each 8 bits\n    add8_8 add8_inst1 (.a(a[7:0]), .b(b[7:0]), .Cin(Cin), .y(y_internal[7:0]), .Co(carry[0]));\n    add8_8 add8_inst2 (.a(a[15:8]), .b(b[15:8]), .Cin(carry[0]), .y(y_internal[15:8]), .Co(carry[1]));\n\n    assign y = y_internal;\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Wire declarations\n    wire [6:0] carry;\n\n    // 1st add\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(Cin), .sum(y[0]), .Cout(carry[0]));\n    // 2nd add\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(carry[0]), .sum(y[1]), .Cout(carry[1]));\n    // 3rd add\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(carry[1]), .sum(y[2]), .Cout(carry[2]));\n    // 4th add\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(carry[2]), .sum(y[3]), .Cout(carry[3]));\n    // 5th add\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(carry[3]), .sum(y[4]), .Cout(carry[4]));\n    // 6th add\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(carry[4]), .sum(y[5]), .Cout(carry[5]));\n    // 7th add\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(carry[5]), .sum(y[6]), .Cout(carry[6]));\n    // 8th add\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(carry[6]), .sum(y[7]), .Cout(Co));\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire sum,\n    output wire Cout\n);\n    assign {Cout, sum} = a + b + Cin;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [6:0] carry;\n\n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Submodule instantiation\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ctrl_done(done)\n);\n\nreg_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ain(ain),\n    .bin(bin),\n    .done(done),\n    .yout(yout)\n);\n\nendmodule\n\n// Control Unit Submodule\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n\nreg [3:0] shift_cnt;\nreg [15:0] multiplicand, multiplier;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 0;\n        done <= 0;\n        multiplicand <= 0;\n        multiplier <= 0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 0;\n            multiplicand <= ain;\n            multiplier <= bin;\n            done <= 0;\n        end else if (shift_cnt < 15) begin\n            shift_cnt <= shift_cnt + 1;\n            done <= 0;\n        end else begin\n            done <= 1;\n        end\n    end\nend\n\nendmodule\n\n// Register Unit Submodule\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input done,         // Chip output flag signal.\n    output reg [31:0] yout // Product output with a data width of 32 bits.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        yout <= 0;\n    end else begin\n        if (start) begin\n            yout <= 0;\n        end else if (done) begin\n            yout <= yout + multiplier;\n        end\n    end\nend\n\nendmodule\n\n// Multiplier Unit Submodule\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input done,         // Chip output flag signal.\n    output reg [31:0] yout // Product output with a data width of 32 bits.\n);\n\nreg [15:0] temp_yout;\nreg [3:0] shift_cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        temp_yout <= 0;\n        shift_cnt <= 0;\n    end else begin\n        if (start) begin\n            temp_yout <= 0;\n            shift_cnt <= 0;\n        end else if (shift_cnt < 15) begin\n            shift_cnt <= shift_cnt + 1;\n            temp_yout <= temp_yout + (bin << shift_cnt);\n        end else begin\n            yout <= temp_yout;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (up_down) begin\n            next_count = current_count + 1;\n        end else begin\n            next_count = current_count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n    wire [7:0] state;\n\n    // Submodule for initialization\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(state)\n    );\n\n    // Submodule for state transition\n    ring_transition transition (\n        .clk(clk),\n        .state(state),\n        .next_state(out)\n    );\n\nendmodule\n\n// Submodule for initial state\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (reset) out <= 8'b0000_0001;\n    end\nendmodule\n\n// Submodule for ring transition\nmodule ring_transition (\n    input wire clk,\n    input wire [7:0] state,\n    output reg [7:0] next_state\n);\n    always @(posedge clk) begin\n        if (state == 8'b1111_1111) next_state <= 8'b0000_0001;\n        else next_state <= state >> 1;\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n    wire [3:0] next_count;\n\n    // Instance of the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    // Instance of the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] next_count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            next_count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                next_count <= 4'b0000;\n            else\n                next_count <= count + 1;\n        end else\n            next_count <= count;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n        else\n            out <= out;\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Submodule for storing the state of the counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q;\n        end\n    end\n\nendmodule\n\n// Submodule for calculating the next state of the counter\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_next <= 64'b0;\n        end else begin\n            Q_next <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_en, clk_10_en, clk_1_en;\n    reg clk_50_out, clk_10_out, clk_1_out;\n    reg [2:0] clk_50_cnt, clk_10_cnt, clk_1_cnt;\n\n    // Submodule for 50MHz\n    clk_div_2 clk_50_div (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_50_out),\n        .CLK_en(clk_50_en)\n    );\n\n    // Submodule for 10MHz\n    clk_div_10 clk_10_div (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_10_out),\n        .CLK_en(clk_10_en)\n    );\n\n    // Submodule for 1MHz\n    clk_div_100 clk_1_div (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_1_out),\n        .CLK_en(clk_1_en)\n    );\n\n    // Output logic\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\n    // Reset logic\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_50_cnt <= 0;\n            clk_10_cnt <= 0;\n            clk_1_cnt <= 0;\n            clk_50_out <= 0;\n            clk_10_out <= 0;\n            clk_1_out <= 0;\n        end\n    end\n\nendmodule\n\n// Generate 50MHz clock\nmodule clk_div_2 (\n    input CLK_in,\n    output CLK_out,\n    output CLK_en\n);\n\n    reg out_en;\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in) begin\n        if (cnt == 1) begin\n            out_en <= ~out_en;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\n    assign CLK_en = out_en;\n    assign CLK_out = CLK_in & out_en;\n\nendmodule\n\n// Generate 10MHz clock\nmodule clk_div_10 (\n    input CLK_in,\n    output CLK_out,\n    output CLK_en\n);\n\n    reg out_en;\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in) begin\n        if (cnt == 4) begin\n            out_en <= ~out_en;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\n    assign CLK_en = out_en;\n    assign CLK_out = CLK_in & out_en;\n\nendmodule\n\n// Generate 1MHz clock\nmodule clk_div_100 (\n    input CLK_in,\n    output CLK_out,\n    output CLK_en\n);\n\n    reg out_en;\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in) begin\n        if (cnt == 49) begin\n            out_en <= ~out_en;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\n    assign CLK_en = out_en;\n    assign CLK_out = CLK_in & out_en;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire [1:0] clk_count;\n    wire clk_div_1, clk_div_2;\n\n    // Counter Submodule Instantiation\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_count(clk_count)\n    );\n\n    // Clock Average Generator Submodule Instantiation\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_count(clk_count),\n        .clk_div_1(clk_div_1)\n    );\n\n    // Clock Adjustment Submodule Instantiation\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div_1(clk_div_1),\n        .clk_div_2(clk_div_2)\n    );\n\n    assign clk_div = clk_div_1 | clk_div_2;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [1:0]    clk_count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) clk_count <= 0;\n        else if (clk_count == 3) clk_count <= 0;\n        else clk_count <= clk_count + 1;\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input [1:0]         clk_count,\n    output reg          clk_div_1\n);\n\n    reg clk_div_2;\n\n    always @(posedge clk) begin\n        if (clk_count == 2) clk_div_2 <= 1'b1;\n        if (clk_count == 3) begin\n            clk_div_2 <= 1'b0;\n            clk_div_1 <= 1'b1;\n        end\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_1,\n    output reg          clk_div_2\n);\n\n    always @(negedge clk) clk_div_2 <= clk_div_1;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    \n    wire clk_div1, clk_div2;\n    \n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n    \n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n    \n    assign clk_div = clk_div1 | clk_div2;\n    \nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    \n    reg [3:0] cnt;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    \n    reg [3:0] cnt;\n    \n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 8; // Divide frequency by 8\n\n    reg [3:0] cnt;\n    wire clk_div_en;\n\n    // Counter Submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt)\n    );\n\n    // Clock Divider Submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\n// Counter Submodule\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (cnt == (NUM_DIV / 2 - 1)) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\n// Clock Divider Submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n\n    reg clk_div_en_q;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_en_q <= 1'b0;\n        end else begin\n            clk_div_en_q <= clk_div_en;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (clk_div_en_q) begin\n            clk_div <= ~clk_div;\n        end\n    end\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] r_add, r_sub, r_and, r_or, r_xor, r_nor;\n    wire c_add, c_sub;\n    wire n_add, n_sub;\n    wire o_add, o_sub;\n    wire g_add, g_sub;\n    \n    adder add(.a(a), .b(b), .r(r_add), .c(c_add));\n    addu addu(.a(a), .b(b), .r(r_sub), .c(c_sub));\n    and and1(.a(a), .b(b), .r(r_and));\n    or or1(.a(a), .b(b), .r(r_or));\n    xor xor1(.a(a), .b(b), .r(r_xor));\n    nor nor1(.a(a), .b(b), .r(r_nor));\n    slt slt_inst(.a(a), .b(b), .r(r_add), .c(c_add), .n(n_add), .o(o_add));\n    sltu sltu_inst(.a(a), .b(b), .r(r_sub), .c(c_sub), .n(n_sub), .o(o_sub));\n    sll sll(.a(a), .b(b), .r(r));\n    srl srl(.a(a), .b(b), .r(r));\n    sra sra(.a(a), .b(b), .r(r));\n    sllv sllv(.a(a), .b(b), .r(r));\n    srlv srlv(.a(a), .b(b), .r(r));\n    srav srav(.a(a), .b(b), .r(r));\n    lui lui_inst(.a(a), .b(b), .r(r));\n    \n    assign zero = r == 32'b0;\n    assign carry = aluc == 6'b100000 ? c_add : aluc == 6'b100001 ? c_sub : 1'b0;\n    assign negative = aluc == 6'b100000 ? n_add : aluc == 6'b100001 ? n_sub : 1'b0;\n    assign overflow = aluc == 6'b100000 ? o_add : aluc == 6'b100001 ? o_sub : 1'b0;\n    assign flag = aluc == 6'b101010 ? g_add : aluc == 6'b101011 ? g_sub : 1'b0;\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\n    assign {carry, r} = a + b;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\n    assign {carry, r} = a + b;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output borrow\n);\n    assign {borrow, r} = a - b;\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output borrow\n);\n    assign {borrow, r} = a - b;\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a & b;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r ="}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [63:0] mult_res;\nwire [31:0] current_value;\n\n// Instantiate the multiplier\nmult_32x32 u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_res(mult_res)\n);\n\n// Instantiate the accumulator\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_res(mult_res[31:0]),\n    .current_value(current_value)\n);\n\n// Assign the output\nassign c = current_value;\n\nendmodule\n\n// Submodule for multiplication\nmodule mult_32x32(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_res\n);\nassign mult_res = a * b;\nendmodule\n\n// Submodule for accumulation\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] mult_res,\n    output reg [31:0] current_value\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        current_value <= 0;\n    else\n        current_value <= current_value + mult_res;\nend\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12, ad21, ad22;\n\n    // Submodule to hold instruction from RAM/ROM\n    ins_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad(ad11)\n    );\n    // Submodule to hold instruction from register\n    ins_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad(ad22)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            case(fetch)\n                2'b01: begin\n                    ins <= ins1;\n                    ad1 <= ad11;\n                    ad2 <= ad21;\n                end\n                2'b10: begin\n                    ins <= ins2;\n                    ad1 <= ad12;\n                    ad2 <= ad22;\n                end\n                default: ;\n            endcase\n        end\n    end\nendmodule\n\n// Submodule to hold an instruction\nmodule ins_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\n// Instantiate the counter and wave generator\ncounter cnt(\n    .clk(clk),\n    .enable(freq != 0),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wg(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable && (count >= freq - 1))\n        count <= 0;\n    else if (enable)\n        count <= count + 1;\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    wave_out <= (count % freq == 0);\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: state <= 2'b00;\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                default: wave_reg <= 5'd0;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_inst.wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_inst.wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            case (state_inst.state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                default: wave_reg <= 5'd0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    always @(*) begin\n        case(sel)\n            2'b00: q = q2;\n            2'b01: q = q1;\n            2'b10: q = q0;\n            2'b11: q = d;\n            default: q = q2;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (clk, d, q0);\n    my_dff u1 (clk, q0, q1);\n    my_dff u2 (clk, q1, q2);\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage0, stage1, stage2, stage3;\n\n    mux2X1 ins_17 (stage0, in[7], stage1, ctrl[2], ctrl[1], ctrl[0]);\n    mux2X1 ins_16 (stage1, in[6], stage2, ctrl[2], ctrl[1], ctrl[0]);\n    mux2X1 ins_15 (stage2, in[5], stage3, ctrl[2], ctrl[1], ctrl[0]);\n    mux2X1 ins_14 (stage3, in[4], in[3], in[2], in[1], in[0], stage3, ctrl[2], ctrl[1], ctrl[0]);\n\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out);\n    input in0, in1, sel;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .p(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .p(c1)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [31:0] product;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 0;\n    end else begin\n      product <= a * b;\n    end\n  end\n\n  assign p = product;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetched_instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_result;\n  wire [31:0] writeback_result;\n  wire [4:0] pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetched_instr(fetched_instr)\n  );\n\n  decode_stage decode (\n    .fetched_instr(fetched_instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .reg_file(reg_file),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .memory_result(writeback_result)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .writeback_result(writeback_result),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 5'd0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output reg [31:0] fetched_instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      fetched_instr <= instr_mem[pc];\n  end\nendmodule\n\nmodule decode_stage(\n  input [31:0] fetched_instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(*) begin\n    {rd, rs1, rs2, op} = fetched_instr;\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 32'd0;\n    else\n      case (op)\n        6'b000000: alu_result <= reg_file[rs1] + reg_file[rs2];\n        6'b000010: alu_result <= reg_file[rs1] - reg_file[rs2];\n        default: alu_result <= 32'd0;\n      endcase\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] memory_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      memory_result <= 32'd0;\n    else\n      memory_result <= alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input r"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b1_reg, b2_reg, b3_reg;\n  \n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  \n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n  \n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b1_reg <= b0;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n  \n  assign b1 = b0;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n  \nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr;\n    wire [4:0] rd, rs1, rs2;\n    wire [5:0] op;\n    wire [31:0] rd_val, rs1_val, rs2_val, result;\n\n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr(instr)\n    );\n    execute_stage execute(\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .reg_file(reg_file),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .rd_val(rd_val),\n        .rs1_val(rs1_val),\n        .rs2_val(rs2_val),\n        .result(result)\n    );\n    writeback_stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .rd(rd),\n        .result(result),\n        .reg_file(reg_file)\n    );\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] instr\n);\n    assign instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [31:0] rd_val,\n    output reg [31:0] rs1_val,\n    output reg [31:0] rs2_val,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            rd_val <= 0;\n            rs1_val <= 0;\n            rs2_val <= 0;\n            result <= 0;\n        end else begin\n            rd <= instr[11:7];\n            rs1 <= instr[19:15];\n            rs2 <= instr[24:20];\n            rd_val <= reg_file[rd];\n            rs1_val <= reg_file[rs1];\n            rs2_val <= reg_file[rs2];\n            case (instr[31:26])\n                6'b001001: result <= rs1_val + rs2_val; // Add\n                6'b001011: result <= rs1_val - rs2_val; // Sub\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] rd,\n    input [31:0] result,\n    input [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[rd] <= 0;\n        end else begin\n            reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_out;\n    wire [9:0] data_accumulator_out;\n    wire valid_output_out;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_accumulator_out(data_accumulator_out)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt_out),\n        .data_accumulator_out(data_accumulator_out),\n        .valid_output_out(valid_output_out)\n    );\n\n    assign data_out = data_accumulator_out;\n    assign valid_out = valid_output_out;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (valid_in) begin\n            cnt_out <= cnt_out + 1;\n        end else begin\n            cnt_out <= 0;\n        end\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output reg  [9:0]   data_accumulator_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulator_out <= 0;\n        end else if (valid_in) begin\n            data_accumulator_out <= data_accumulator_out + data_in;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt_out,\n    input       [9:0]   data_accumulator_out,\n\n    output reg          valid_output_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_output_out <= 0;\n        end else if (cnt_out == 3) begin\n            valid_output_out <= 1;\n        end else begin\n            valid_output_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] shift_reg;\n    wire [3:0] count;\n    wire done;\n\n    // Instantiate submodules\n    abs_value abs_dividend_inst(.dividend(dividend), .sign(sign), .abs_value(abs_dividend));\n    neg_value neg_divisor_mod(.dividend(divisor), .sign(sign), .abs_value(neg_divisor));\n    divider_control ctrl(.clk(clk), .rst(rst), .opn_valid(opn_valid), .count(count), .done(done));\n    result_management res_mgmt(.clk(clk), .rst(rst), .done(done), .res_ready(res_ready), .count(count), .res_valid(res_valid), .result(result));\n\nendmodule\n\nmodule abs_value(\n    input [7:0] dividend,\n    input sign,\n    output [7:0] abs_value\n);\n    assign abs_value = (sign) ? (~dividend + 1) : dividend;\nendmodule\n\nmodule neg_value(\n    input [7:0] dividend,\n    input sign,\n    output [7:0] abs_value\n);\n    assign abs_value = (sign) ? dividend : (~dividend + 1);\nendmodule\n\nmodule divider_control(\n    input clk,\n    input rst,\n    input opn_valid,\n    output reg [3:0] count,\n    output reg done\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            done <= 0;\n        end else if (opn_valid) begin\n            count <= 0;\n            done <= 0;\n        end else if (count < 3) begin\n            count <= count + 1;\n            done <= 0;\n        end else if (count == 3) begin\n            done <= 1;\n        end\n    end\nendmodule\n\nmodule result_management(\n    input clk,\n    input rst,\n    input done,\n    input res_ready,\n    input [3:0] count,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end else if (done && res_ready) begin\n            res_valid <= 1;\n            result <= result;\n        end else begin\n            res_valid <= 0;\n            result <= 0;\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend, divisor;\n\n    // Prepare inputs\n    prep_dividend prep (\n        .A(A),\n        .B(B),\n        .prep_dividend(dividend),\n        .prep_divisor(divisor)\n    );\n\n    // Divide\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Prepare dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] prep_dividend, // 32-bit prepared dividend\n    output reg [15:0] prep_divisor  // 16-bit prepared divisor\n);\n    always @(*) begin\n        prep_dividend = {A[31:16], A[31:16]}; // Extend to 32-bit\n        prep_divisor = B;\n    end\nendmodule\n\n// Perform division operation\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit prepared dividend\n    input wire [15:0] divisor,  // 16-bit prepared divisor\n    output reg [31:0] result,    // 32-bit quotient\n    output reg [31:0] odd        // 32-bit remainder\n);\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n    reg [31:0] shifted_dividend;\n\n    always @(*) begin\n        shifted_dividend = dividend >> 16; // Shift dividend\n        result = 0;\n        odd = 0;\n        for (int i = 0; i < 32; i++) begin\n            result = result << 1;\n            odd = odd << 1;\n            if (shifted_dividend >= divisor) begin\n                result = result + 1;\n                shifted_dividend = shifted_dividend - divisor;\n            end\n            shifted_dividend = shifted_dividend << 1;\n        end\n        odd = remainder;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Submodule for control\n    div_control ctrl (\n        .A(A),\n        .B(B),\n        .q(result),\n        .r(odd)\n    );\n\nendmodule\n\n// Submodule for control\nmodule div_control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] q,       // 16-bit quotient\n    output reg [15:0] r        // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [15:0] a_copy;\n    reg [7:0] b_copy;\n\n    // Initialize internal variables\n    initial begin\n        a_copy = A;\n        b_copy = B;\n        r = 16'b0;\n    end\n\n    // Shift dividend left and compare with divisor\n    always @(*) begin\n        if (a_copy[15:8] > B) begin\n            a_copy = {a_copy[14:0], 1'b0};\n            r = {r[14:0], a_copy[15]};\n            q = q + 1;\n        end\n    end\n\n    // Finalize results\n    always @(*) begin\n        if (a_copy[7:0] > B) begin\n            a_copy = {a_copy[6:0], 1'b0};\n            r = {r[13:0], a_copy[15:8]};\n            q = q + 2;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire carry;\n\nassign B_complement = ~B;\n\nadder_8bit adder_inst(.A(A), .B(B_complement), .Cin(1'b1), .Sum(D), .Cout(B_out));\n\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\ninput [7:0] A;\ninput [7:0] B;\ninput Cin;\noutput [7:0] Sum;\noutput Cout;\n\nwire [7:0] C;\n\nfull_adder FA0(.A(A[0]), .B(B[0]), .Cin(Cin), .Sum(Sum[0]), .Cout(C[0]));\nfull_adder FA1(.A(A[1]), .B(B[1]), .Cin(C[0]), .Sum(Sum[1]), .Cout(C[1]));\nfull_adder FA2(.A(A[2]), .B(B[2]), .Cin(C[1]), .Sum(Sum[2]), .Cout(C[2]));\nfull_adder FA3(.A(A[3]), .B(B[3]), .Cin(C[2]), .Sum(Sum[3]), .Cout(C[3]));\nfull_adder FA4(.A(A[4]), .B(B[4]), .Cin(C[3]), .Sum(Sum[4]), .Cout(C[4]));\nfull_adder FA5(.A(A[5]), .B(B[5]), .Cin(C[4]), .Sum(Sum[5]), .Cout(C[5]));\nfull_adder FA6(.A(A[6]), .B(B[6]), .Cin(C[5]), .Sum(Sum[6]), .Cout(C[6]));\nfull_adder FA7(.A(A[7]), .B(B[7]), .Cin(C[6]), .Sum(Sum[7]), .Cout(Cout));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire B_out_1, B_out_2;\n\n    // Instantiate 16-bit subtractors\n    sub_16bit S1_inst(.A(A[15:0]), .B(B[15:0]), .Diff(S1), .B_out(B_out_1));\n    sub_16bit S2_inst(.A(A[31:16]), .B(B[31:16]), .Diff(S2), .B_out(B_out_2));\n\n    // Construct output differences\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = B_out_1 | B_out_2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] D1, D2, D3;\n    wire B_out_1, B_out_2, B_out_3;\n\n    // Instantiate 8-bit subtractors\n    sub_8bit D1_inst(.A(A[7:0]), .B(B[7:0]), .Diff(D1), .B_out(B_out_1));\n    sub_8bit D2_inst(.A(A[15:8]), .B(B[15:8]), .Diff(D2), .B_out(B_out_2));\n    sub_8bit D3_inst(.A(A[15:8]), .B(B[15:8]), .Diff(D3), .B_out(B_out_3));\n\n    // Construct output differences\n    assign Diff[7:0] = D1;\n    assign Diff[15:8] = D2;\n    assign Diff[15:8] = D3;\n    assign B_out = B_out_1 | B_out_2 | B_out_3;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [7:0] D1, D2;\n    wire B_out_1, B_out_2;\n\n    // Instantiate 4-bit subtractors\n    sub_4bit D1_inst(.A(A[3:0]), .B(B[3:0]), .Diff(D1), .B_out(B_out_1));\n    sub_4bit D2_inst(.A(A[7:4]), .B(B[7:4]), .Diff(D2), .B_out(B_out_2));\n\n    // Construct output differences\n    assign Diff[3:0] = D1;\n    assign Diff[7:4] = D2;\n    assign B_out = B_out_1 | B_out_2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [3:0] D1, D2, D3;\n    wire B_out_1, B_out_2, B_out_3;\n\n    // Instantiate 2-bit subtractors\n    sub_2bit D1_inst(.A(A[1:0]), .B(B[1:0]), .Diff(D1), .B_out(B_out_1));\n    sub_2bit D2_inst(.A(A[3:2]), .B(B[3:2]), .Diff(D2), .B_out(B_out_2));\n    sub_2bit D3_inst(.A(A[3:2]), .B(B[3:2]), .Diff(D3"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] D1, D2;\nwire [15:0] borrow[2:0];\n\nsub_32bit sub0(\n    .A(A[31:0]),\n    .B(B[31:0]),\n    .D(D1),\n    .borrow(borrow[0])\n);\n\nsub_32bit sub1(\n    .A(A[63:32]),\n    .B(B[63:32]),\n    .D(D2),\n    .borrow(borrow[1])\n);\n\nassign D = D1 + D2 + {64'b0, borrow[1]};\nassign B_out = borrow[1];\nendmodule\n\nmodule sub_32bit(A, B, D, borrow);\ninput [31:0] A, B;\noutput [31:0] D;\noutput borrow;\n\nwire [31:0] D1, D2;\nwire b_out1, b_out2;\n\nsub_16bit sub0(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .D(D1),\n    .borrow(b_out1)\n);\n\nsub_16bit sub1(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .D(D2),\n    .borrow(b_out2)\n);\n\nassign D = D1 + D2 + {32'b0, b_out2};\nassign borrow = b_out2;\nendmodule\n\nmodule sub_16bit(A, B, D, borrow);\ninput [15:0] A, B;\noutput [15:0] D;\noutput borrow;\n\nwire [15:0] D1, D2;\nwire b_out1, b_out2;\n\nsub_8bit sub0(\n    .A(A[7:0]),\n    .B(B[7:0]),\n    .D(D1),\n    .borrow(b_out1)\n);\n\nsub_8bit sub1(\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .D(D2),\n    .borrow(b_out2)\n);\n\nassign D = D1 + D2 + {16'b0, b_out2};\nassign borrow = b_out2;\nendmodule\n\nmodule sub_8bit(A, B, D, borrow);\ninput [7:0] A, B;\noutput [7:0] D;\noutput borrow;\n\nwire [7:0] D1, D2;\nwire b_out1, b_out2;\n\nsub_4bit sub0(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .D(D1),\n    .borrow(b_out1)\n);\n\nsub_4bit sub1(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .D(D2),\n    .borrow(b_out2)\n);\n\nassign D = D1 + D2 + {4'b0, b_out2};\nassign borrow = b_out2;\nendmodule\n\nmodule sub_4bit(A, B, D, borrow);\ninput [3:0] A, B;\noutput [3:0] D;\noutput borrow;\n\nwire [3:0] D1, D2;\nwire b_out1, b_out2;\n\nsub_2bit sub0(\n    .A(A[1:0]),\n    .B(B[1:0]),\n    .D(D1),\n    .borrow(b_out1)\n);\n\nsub_2bit sub1(\n    .A(A[3:2]),\n    .B(B[3:2]),\n    .D(D2),\n    .borrow(b_out2)\n);\n\nassign D = D1 + D2 + {2'b0,"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\nwire [3:0] b_in, b_out_temp;\nwire borrow_in;\nwire [16:1] d_temp;\ninteger i;\n\nsub1 sub1(\n    .A(A[3:0]), .B(B[3:0]), .B_in(b_in[0]), .B_out(b_out_temp[0]),\n    .D(d_temp[3:0])\n);\nsub2 sub2(\n    .A(A[7:4]), .B(B[7:4]), .B_in(b_in[1]), .B_out(b_out_temp[1]),\n    .D(d_temp[7:4])\n);\nsub3 sub3(\n    .A(A[11:8]), .B(B[11:8]), .B_in(b_in[2]), .B_out(b_out_temp[2]),\n    .D(d_temp[11:8])\n);\nsub4 sub4(\n    .A(A[15:12]), .B(B[15:12]), .B_in(b_in[3]), .B_out(b_out_temp[3]),\n    .D(d_temp[15:12])\n);\nassign B_out = b_out_temp[3];\nassign D = d_temp;\nendmodule\n\nmodule sub1(A, B, B_in, B_out, D);\ninput [3:0] A, B;\ninput B_in;\noutput B_out;\noutput [3:0] D;\nwire [3:0] B_not;\n\nassign B_not = ~B;\nassign {B_out, D} = A + B_not + B_in;\nendmodule\n\nmodule sub2(A, B, B_in, B_out, D);\ninput [3:0] A, B;\ninput B_in;\noutput B_out;\noutput [3:0] D;\nwire [3:0] B_not;\n\nassign B_not = ~B;\nassign {B_out, D} = A + B_not + B_in;\nendmodule\n\nmodule sub3(A, B, B_in, B_out, D);\ninput [3:0] A, B;\ninput B_in;\noutput B_out;\noutput [3:0] D;\nwire [3:0] B_not;\n\nassign B_not = ~B;\nassign {B_out, D} = A + B_not + B_in;\nendmodule\n\nmodule sub4(A, B, B_in, B_out, D);\ninput [3:0] A, B;\ninput B_in;\noutput B_out;\noutput [3:0] D;\nwire [3:0] B_not;\n\nassign B_not = ~B;\nassign {B_out, D} = A + B_not + B_in;\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    // Internal wires\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Assign outputs\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0) && (borrow == 1);\n    assign A_less = (diff == 0) && (borrow == 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,  // First 32-bit input operand\n    input [31:0] B,  // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow // Borrow signal\n);\n\n    wire [31:0] B_not;\n    wire [31:0] A_minus_B;\n    wire [31:0] A_minus_B_not;\n    wire [31:0] A_minus_B_not_diff;\n    wire [31:0] B_not_diff;\n\n    // Complement B\n    assign B_not = ~B;\n\n    // Subtract B from A\n    assign A_minus_B = A ^ B;\n    assign A_minus_B_not = A_minus_B ^ B_not;\n    assign A_minus_B_not_diff = A_minus_B_not ^ B_not;\n\n    // Subtract B from A's complement\n    assign B_not_diff = A_minus_B_not_diff ^ B_not;\n\n    // Outputs\n    assign diff = A_minus_B_not_diff;\n    assign borrow = (A_minus_B & ~B_not_diff);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    \n    wire [15:1] carry;\n    \n    CLA CLA1(A[15:1],B[15:1],carry[0],S[15:1]);\n    CLA CLA2(A[31:16],B[31:16],carry[1],S[31:16]);\n    \n    assign C32 = carry[1];\nendmodule\n\nmodule CLA(A,B,Cin,S);\n    input [15:1] A,B;\n    input Cin;\n    output [15:1] S;\n    \n    wire [16:1] p,g;\n    wire [16:2] c;\n    assign p = A + B;\n    assign g = A & B;\n    \n    assign c[1] = Cin;\n    assign c[2] = g[1];\n    assign c[3] = g[3];\n    assign c[4] = g[7];\n    assign c[5] = g[15];\n    assign c[6] = g[31];\n    assign c[7] = g[63];\n    assign c[8] = g[127];\n    assign c[9] = g[255];\n    assign c[10] = g[511];\n    assign c[11] = g[1023];\n    assign c[12] = g[2047];\n    assign c[13] = g[4095];\n    assign c[14] = g[8191];\n    assign c[15] = g[16383];\n    \n    assign S = p ^ c[16:1];\n    assign C32 = c[16];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_part;\n\n// First 4 bits\nadder_4bit rca0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_part[0]), .cout(carry[0]));\n// Second 4 bits\nadder_4bit rca1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_part[1]), .cout(carry[1]));\n// Third 4 bits\nadder_4bit rca2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_part[2]), .cout(carry[2]));\n// Fourth 4 bits\nadder_4bit rca3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_part[3]), .cout(carry[3]));\n\nassign sum = {sum_part[3], sum_part[2], sum_part[1], sum_part[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 2 bits\nadder_2bit rca0(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n// Third 2 bits\nadder_2bit rca1(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n// Fourth bit\nassign {sum[0], cout} = a[0] ^ b[0] ^ cin;\n\nendmodule\n\nmodule adder_2bit(a, b, cin, sum, cout);\ninput [1:0] a, b;\ninput cin;\noutput [1:0] sum;\noutput cout;\n\nwire c0, c1;\n\n// First bit\nassign {sum[0], c0} = a[0] ^ b[0] ^ cin;\n// Second bit\nassign {sum[1], c1} = a[1] ^ b[1] ^ c0;\n\nassign cout = c1;\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_part;\n\n// First 2 bits\nadder_2bit rca0(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_part[0]), .cout(carry[0]));\n// Third 2 bits\nadder_2bit rca1(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_part[1]), .cout(carry[1]));\n// Fourth bit\nassign {sum[0], carry[0]} = a[0] ^ b[0] ^ cin;\n\n// Select sum and carry\nassign sum = {sum_part[3], sum_part[2], sum_part[1], sum_part[0]};\nassign cout = carry[3];\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n    wire [15:0] sum;\n\n    assign carry[0] = Cin;\n\n    add8_8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(carry[0]),\n        .y(sum[7:0]),\n        .Co(carry[1])\n    );\n\n    add8_8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[1]),\n        .y(sum[15:8]),\n        .Co(Co)\n    );\n\n    assign y = sum;\n\nendmodule\n\nmodule add8_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n    wire carry_in;\n\n    assign carry_in = Cin;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(carry_in), .y(y[0]), .Co(sum[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(sum[0]), .y(y[1]), .Co(sum[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(sum[1]), .y(y[2]), .Co(sum[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(sum[2]), .y(y[3]), .Co(sum[3]));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(sum[3]), .y(y[4]), .Co(sum[4]));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(sum[4]), .y(y[5]), .Co(sum[5]));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(sum[5]), .y(y[6]), .Co(sum[6]));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(sum[6]), .y(y[7]), .Co(Co));\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [6:0] carry;\n    \n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [4:0] count; // Shift count register.\n    wire [15:0] a_reg, b_reg; // Register for multiplicand and multiplier.\n    wire [31:0] product; // Product register.\n    wire add_a, add_b; // Shift control signals.\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .count(count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a_in(ain),\n        .b_in(bin),\n        .a_out(a_reg),\n        .b_out(b_reg)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a_in(a_reg),\n        .b_in(b_reg),\n        .count(count),\n        .product(product),\n        .add_a(add_a),\n        .add_b(add_b)\n    );\n\n    assign yout = product;\n    assign done = ctrl.done;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] count // Shift count register.\n);\n\n    reg start_r; // Starts the operation.\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 5'd0;\n            start_r <= 1'b0;\n        end else begin\n            if (start && !start_r) begin\n                count <= 5'd0;\n                start_r <= 1'b1;\n            end else if (count == 5'd15) begin\n                start_r <= 1'b0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a_in,  // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b_in,  // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_out, // Register for multiplicand.\n    output reg [15:0] b_out // Register for multiplier.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_out <= 16'd0;\n            b_out <= 16'd0;\n        end else begin\n            a_out <= a_in;\n            b_out <= b_in;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] a_in,  // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b_in,  // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] count,  // Shift count.\n    output reg [31:0] product, // Product register.\n    output reg add_a, add_b // Shift control signals.\n);\n\n    always @(posedge clk) begin\n        add_a = a_in[count];\n        add_b = b_in[count];\n        if (add_a) begin\n            product <= product + b_in;\n        end else if (add_b) begin\n            product <= product - b_in;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n    always @(*) begin\n        if (reset) begin\n            next_count = 0;\n        end else if (up_down) begin\n            next_count = count + 1;\n        end else begin\n            next_count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            next_count <= count;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // Submodule for initial state initialization\n    initial_state init (\n        .reset(reset),\n        .out(next_state)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .out(out),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] out,\n    output reg [7:0] next_state\n);\n\n    always @(posedge clk) begin\n        next_state <= (out == 8'b1111_1110) ? 8'b0000_0001 : out << 1;\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count_out;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instantiate the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] Q_next;\n\n    // Instantiate the register and logic\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q_next(Q_next)\n    );\n\n    JC_logic logic_inst(\n        .Q(Q_next),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_next <= 64'b0;\n    end\n\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\n    always @(*) begin\n        Q_next = (Q & (Q - 1'b1)) | (Q & (Q >> 1));\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n    wire clk_50_internal;\n    wire clk_10_internal;\n    wire clk_1_internal;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_internal)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_internal)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_internal)\n    );\n\n    assign CLK_50 = clk_50_internal;\n    assign CLK_10 = clk_10_internal;\n    assign CLK_1 = clk_1_internal;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 1) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 4) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_div_0, clk_div_1;\n\n    // Counter submodule\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_0(clk_div_0),\n        .clk_div_1(clk_div_1)\n    );\n\n    // Clock average generator submodule\n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div_0(clk_div_0),\n        .clk_div_1(clk_div_1),\n        .clk_div(clk_div_0)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div_1(clk_div_1),\n        .clk_div_0(clk_div_0),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div_0,\n    output reg          clk_div_1\n);\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div_0 <= 0;\n            clk_div_1 <= 0;\n        end else if (cnt == 1) begin\n            cnt <= 0;\n            clk_div_0 <= 1;\n            clk_div_1 <= 0;\n        end else if (cnt == 3) begin\n            cnt <= 0;\n            clk_div_0 <= 0;\n            clk_div_1 <= 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div_0,\n    input               clk_div_1,\n    output reg          clk_div\n);\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge clk_div_0 or negedge clk_div_1) begin\n        if (!clk_div_0 || !clk_div_1) begin\n            cnt <= 0;\n            clk_div <= clk_div_0;\n        end else if (cnt == 1) begin\n            cnt <= 0;\n            clk_div <= 1;\n        end else if (cnt == 2) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_1,\n    input               clk_div_0,\n    output reg          clk_div\n);\n    reg clk_div_1_negedge, clk_div_0_negedge;\n\n    always @(negedge clk or negedge clk_div_1 or negedge clk_div_0) begin\n        if (!clk_div_1) begin\n            clk_div_1_negedge <= 1;\n        end else if (!clk_div_0) begin\n            clk_div_0_negedge <= 1;\n        end else begin\n            clk_div_1_negedge <= 0;\n            clk_div_0_negedge <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        clk_div <= clk_div_0_negedge | clk_div_1_negedge;\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1;\nwire clk_div2;\n\npos_edge_counter u_pos_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nreg [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n        cnt <= 0;\n    end else if (cnt == NUM_DIV - 1) begin\n        clk_div <= ~clk_div;\n        cnt <= 0;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nreg [3:0] cnt;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n        cnt <= 0;\n    end else if (cnt == NUM_DIV - 1) begin\n        clk_div <= ~clk_div;\n        cnt <= 0;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    reg [3:0] counter;\n    wire clk_div_divider;\n\n    // Counter submodule\n    counter_mod counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_divider)\n    );\n\n    // Clock divider submodule\n    clk_divider_mod clk_divider_inst(\n        .clk(clk),\n        .clk_div(clk_div_divider)\n    );\n\n    assign clk_div = clk_div_divider;\nendmodule\n\nmodule counter_mod(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 1'b0;\n        end else begin\n            if (counter == (NUM_DIV/2 - 1)) begin\n                counter <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider_mod(\n    input clk,\n    output reg clk_div\n);\n    reg rst_n;\n    always @(posedge clk) begin\n        rst_n <= 1'b1;\n        clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, sll_out, srl_out, sra_out, slt_out, sltu_out, lui_out;\n    wire add_zero, add_carry, sub_zero, sub_carry;\n    wire slt_flag, sltu_flag;\n    wire [31:0] sll_out_b, srl_out_b, sra_out_b;\n\n    // Instantiate submodules\n    add add(\n        .a(a),\n        .b(b),\n        .r(add_out)\n    );\n    addu addu(\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    sub sub(\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    subu subu(\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    and and1(\n        .a(a),\n        .b(b),\n        .r(and_out)\n    );\n    or or1(\n        .a(a),\n        .b(b),\n        .r(or_out)\n    );\n    xor xor1(\n        .a(a),\n        .b(b),\n        .r(xor_out)\n    );\n    nor nor1(\n        .a(a),\n        .b(b),\n        .r(nor_out)\n    );\n    sll sll(\n        .a(a),\n        .b(b),\n        .r(sll_out)\n    );\n    srl srl(\n        .a(a),\n        .b(b),\n        .r(srl_out)\n    );\n    sra sra(\n        .a(a),\n        .b(b),\n        .r(sra_out)\n    );\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_out)\n    );\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_out)\n    );\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_out)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_out :\n               (aluc == 6'b100001) ? addu.r :\n               (aluc == 6'b100010) ? sub_out :\n               (aluc == 6'b100011) ? subu.r :\n               (aluc == 6'b100100) ? and_out :\n               (aluc == 6'b100101) ? or_out :\n               (aluc == 6'b100110) ? xor_out :\n               (aluc == 6'b100111) ? nor_out :\n               (aluc == 6'b101010) ? slt_out :\n               (aluc == 6'b101011) ? sltu_out :\n               (aluc == 6'b000000) ? sll_out :\n               (aluc == 6'b000010) ? srl_out :\n               (aluc == 6'b000011) ? sra_out :\n               (aluc == 6'b000100) ? {a[31], sll_out[31:1]} :\n               (aluc == 6'b000110) ? {a[31], srl_out[31:1]} :\n               (aluc == 6'b000111) ? {a[31], sra_out[31:1]} :\n               (aluc == 6'b00"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] result;\n\n    // Instantiate the multiplier module\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(result)\n    );\n\n    // Instantiate the accumulator module\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .c(c)\n    );\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] c\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            c <= 0;\n        else\n            c <= c + result[31:0];\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    ins_p1 ins_p1_i (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad(ad11)\n    );\n    assign ins[0] = ins1[0];\n    assign ad1[0] = ad11[0];\n    assign ad1[1] = ad11[1];\n    assign ad1[2] = ad11[2];\n    assign ad1[3] = ad11[3];\n    assign ad1[4] = ad11[4];\n\n    ins_p2 ins_p2_i (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad(ad22)\n    );\n    assign ins[1] = ins2[0];\n    assign ins[2] = ins2[1];\n    assign ad2 = ad22;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [7:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad <= data;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n\n    // Instantiating the counter module\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiating the wave generator module\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\n// Counter Module\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Wave Generator Module\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    wire inc_wave, dec_wave;\n\n    // State control\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\n    // Waveform generation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: wave <= inc_wave;\n                2'b01: wave <= dec_wave;\n                default: wave <= wave;\n            endcase\n        end\n    end\n\n    assign inc_wave = (wave == 5'd31) ? 5'd0 : wave + 1;\n    assign dec_wave = (wave == 5'd0) ? 5'd31 : wave - 1;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            if (wave == 5'd31) begin\n                wave <= 5'd0;\n            end else begin\n                wave <= wave + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'bz;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2;\n\n    // Instances of the D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage1, stage2, stage3, stage4;\n\n// Stage 1\nbarrel_shifter_4 stage1_inst (\n    .in(in),\n    .ctrl(ctrl),\n    .out(stage1)\n);\n\n// Stage 2\nbarrel_shifter_2 stage2_inst (\n    .in(stage1),\n    .ctrl(ctrl),\n    .out(stage2)\n);\n\n// Stage 3\nbarrel_shifter_1 stage3_inst (\n    .in(stage2),\n    .ctrl(ctrl),\n    .out(stage3)\n);\n\n// Stage 4\nbarrel_shifter_0 stage4_inst (\n    .in(stage3),\n    .ctrl(ctrl),\n    .out(stage4)\n);\n\n// Output\nassign out = stage4;\n\nendmodule\n\n// Submodule for 4-position shift\nmodule barrel_shifter_4 (in, ctrl, out);\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage1, stage2, stage3;\n\n// Stage 1\nassign stage1 = in;\n\n// Stage 2\nassign stage2 = ctrl[1] ? {stage1[3:0], stage1[7:4]} : stage1;\n\n// Stage 3\nassign stage3 = ctrl[2] ? {stage2[1:0], stage2[7:2]} : stage2;\n\n// Output\nassign out = ctrl[2] ? stage3 : stage2;\n\nendmodule\n\n// Submodule for 2-position shift\nmodule barrel_shifter_2 (in, ctrl, out);\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage1, stage2;\n\n// Stage 1\nassign stage1 = in;\n\n// Stage 2\nassign stage2 = ctrl[1] ? {stage1[3:0], stage1[7:4]} : stage1;\n\n// Output\nassign out = ctrl[1] ? stage2 : in;\n\nendmodule\n\n// Submodule for 1-position shift\nmodule barrel_shifter_1 (in, ctrl, out);\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage1;\n\n// Stage 1\nassign stage1 = in;\n\n// Output\nassign out = ctrl[0] ? {stage1[3:0], stage1[7:4]} : stage1;\n\nendmodule\n\n// Submodule for 0-position shift\nmodule barrel_shifter_0 (in, ctrl, out);\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nassign out = in;\n\nendmodule\n\n// Submodule for 2-to-1 multiplexer\nmodule mux2X1 (in0, in1, sel, out);\ninput [1:0] in0, in1;\ninput sel;\noutput [1:0] out;\n\nassign out = sel ? in1 : in0;\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  reg [31:0] c0_reg, c1_reg;\n\n  assign b1 = b0;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0_reg)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_reg)\n  );\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 0;\n    else\n      c <= c + (a * b);\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .pc_next(pc_next), .instr(instr));\n  decode_stage decode(.clk(clk), .rst(rst), .instr(instr), .decode_instr(decode_instr));\n  execute_stage execute(.clk(clk), .rst(rst), .decode_instr(decode_instr), .reg_file(reg_file), .alu_res(alu_res));\n  memory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .alu_res_next(alu_res_next));\n  writeback_stage writeback(.clk(clk), .rst(rst), .alu_res_next(alu_res_next), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\n  reg [4:0] pc_next = 0;\n  reg [31:0] instr;\n  reg [31:0] decode_instr;\n  reg [31:0] alu_res_next;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output [4:0] pc_next,\n  output reg [31:0] instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_next <= 1;\n    else\n      pc_next <= pc + 1;\n  end\n  always @(posedge clk) begin\n    instr <= instr_mem[pc];\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [31:0] decode_instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      decode_instr <= 0;\n    else begin\n      decode_instr[7:0] <= instr[6:0];\n      decode_instr[15:8] <= instr[11:7];\n      decode_instr[23:16] <= instr[19:13];\n      decode_instr[31:24] <= instr[30:20];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] decode_instr,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_res <= 0;\n    else begin\n      case (decode_instr[6:0])\n        7'b000000, 7'b000100, 7'b001100: alu_res <= reg_file[decode_instr[15:11]] + reg_file[decode_instr[20:16]];\n        7'b100000, 7'b100100, 7'b101100: alu_res <= reg_file[decode_instr[15:11]] - reg_file[decode_instr[20:16]];\n        default: alu_res <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output reg [31:0] alu_res_next\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_res_next <= 0;\n    else\n      alu_res_"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  \n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n    end\n  end\n\n  PE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  PE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  PE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= c_reg + (a * b);\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\nwire [31:0] pc = 32'b00000000000000000000000000000000;\nwire [31:0] fetched_instr;\nwire [31:0] op0, op1;\nwire [31:0] result;\nwire [4:0] dest_reg;\n\nfetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetched_instr(fetched_instr)\n);\n\nexecute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .reg_file(reg_file),\n    .op0(op0),\n    .op1(op1),\n    .dest_reg(dest_reg),\n    .result(result)\n);\n\nwriteback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .dest_reg(dest_reg),\n    .result(result)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] fetched_instr\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst) fetched_instr <= 0;\n    else fetched_instr <= instr_mem[pc];\nend\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] op0,\n    output reg [31:0] op1,\n    output reg [4:0] dest_reg,\n    output reg [31:0] result\n);\nalways @(posedge clk) begin\n    {dest_reg, op1, op0} = fetched_instr;\n    case(fetched_instr[6:0])\n        7'b0000000: result = op0 + op1;\n        7'b0000001: result = op0 - op1;\n        default: result = op0;\n    endcase\nend\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    input [4:0] dest_reg,\n    input [31:0] result\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst) reg_file[dest_reg] <= 0;\n    else reg_file[dest_reg] <= result;\nend\nendmodule\n\nmodule stagepipe3_tb;\nreg clk;\nreg rst;\nreg [31:0] instr_mem [0:31];\nreg [31:0] reg_file [0:31];\nreg [31:0] out_reg_file [0:31];\n\ninitial begin\n    clk = 0;\n    rst = 1;\n    #10 rst = 0;\n    #1000 $finish;\nend\n\nalways #(10/2) clk = ~clk;\n\nassign instr_mem = 32'b10000000000000000000000000000000;\n\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_next;\n    wire [9:0] accu_next;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_next(cnt_next)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .accu_next(accu_next)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_next(cnt_next),\n        .valid_out(valid_out)\n    );\n\n    // Output ports\n    assign data_out = accu_next;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [1:0]   cnt_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_next <= 2'b00;\n        else if (valid_in)\n            cnt_next <= cnt_next + 1;\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accu_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accu_next <= 10'b0;\n        else\n            accu_next <= accu_next + data_in;\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt_next,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (cnt_next == 2'b11)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n// Submodule instances\nabs_value abs_dividend(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .in(dividend),\n    .out(abs_dividend)\n);\n\nneg_value neg_divisor_mod(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .in(divisor),\n    .out(neg_divisor_mod)\n);\n\ndivider_control ctrl(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .rdy_to_send(res_ready),\n    .div_done(res_valid)\n);\n\nresult_management res_mgmt(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .div_done(res_valid),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] in,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 0;\n    else\n        out <= sign ? ~in + 1 : in;\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] in,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 0;\n    else\n        out <= sign ? ~in + 1 : ~in;\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire rdy_to_send,\n    output reg div_done\n);\n\nreg [2:0] ctr;\nreg [7:0] shift;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        ctr <= 0;\n        shift <= 0;\n        div_done <= 0;\n    end else if (opn_valid && !rdy_to_send) begin\n        ctr <= 3;\n        shift <= 0;\n        div_done <= 0;\n    end else if (ctr > 0 && rdy_to_send) begin\n        ctr <= ctr - 1;\n        shift <= shift << 1;\n        if (ctr == 1) div_done <= 1;\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire div_done,\n    output reg [15:0] result\n);\n\nreg [7:0] quotient;\nreg [7:0] remainder;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else if (opn_valid && div_done) begin\n        result <= {remainder, quotient};\n    end\nend\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend, divisor;\n    wire [31:0] quotient, remainder;\n\n    prep_dividend prep_dividend_inst (\n        .dividend_in(A),\n        .divisor_in(B),\n        .dividend_out(dividend),\n        .divisor_out(divisor)\n    );\n\n    div_operation div_op_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Prepare the dividend and divisor by adjusting their bit widths.\nmodule prep_dividend(\n    input wire [31:0] dividend_in,\n    input wire [15:0] divisor_in,\n    output wire [31:0] dividend_out,\n    output wire [31:0] divisor_out\n);\n\n    assign dividend_out = dividend_in;\n    assign divisor_out = {divisor_in, 16'b0};\n\nendmodule\n\n// Divide operation module.\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n\n    always @(*) begin\n        quotient_reg = 32'b0;\n        remainder_reg = dividend;\n        while (remainder_reg >= divisor) begin\n            remainder_reg = remainder_reg - divisor;\n            quotient_reg = quotient_reg + 1;\n        end\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] q, r;\n    wire [7:0] shifter;\n    wire [7:0] mask;\n    wire [15:0] temp_q;\n    wire [15:0] temp_r;\n\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n\n    // Internal variables\n    reg [7:0] shifter;\n    reg [7:0] mask;\n    reg [15:0] temp_q;\n    reg [15:0] temp_r;\n\n    // Divisor mask\n    assign mask = (1 << B);\n\n    // Shift divisor\n    always @(*) begin\n        shifter = {B, 1'b0};\n    end\n\n    // Divide loop\n    always @(*) begin\n        temp_q = 16'h0;\n        temp_r = A;\n        while (temp_r >= B) begin\n            if (temp_r >= shifter) begin\n                temp_q = temp_q + mask;\n                temp_r = temp_r - shifter;\n            end\n            shifter = shifter << 1;\n            if (shifter == 0) begin\n                shifter = mask;\n            end\n        end\n    end\n\n    // Assign outputs\n    always @(*) begin\n        result = temp_q;\n        odd = temp_r;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire [7:0] sum;\nwire borrow;\n\n// Complement operation\nassign B_complement = ~B + 1;\n\n// Instantiate the 8-bit adder\nadder_8bit adder_inst (\n    .A(A),\n    .B(B_complement),\n    .sum(sum),\n    .borrow(borrow)\n);\n\n// Output\nassign D = sum;\nassign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, sum, borrow);\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] sum;\noutput borrow;\n\nwire [6:0] carry;\n\nfull_adder fa0 (.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\nfull_adder fa1 (.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\nfull_adder fa2 (.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\nfull_adder fa3 (.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\nfull_adder fa4 (.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\nfull_adder fa5 (.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\nfull_adder fa6 (.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\nfull_adder fa7 (.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(borrow));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A;\ninput B;\ninput Cin;\noutput Sum;\noutput Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\nwire [15:0] S1, S2;\n\nsub_16bit S1(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1),\n    .B_out(B_out)\n);\n\nsub_16bit S2(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2),\n    .B_out(B_out)\n);\n\nassign Diff = {S2, S1};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [14:0] C;\nwire [15:0] D, B_in;\n\nassign B_in = {B[14], B[15:1]};\nassign D = A - B_in;\nassign C = D[15] ? 1 : 0;\n\nassign Diff = D;\nassign B_out = C;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] B0, D0;\n    wire B_out0, B_out1;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[31:0]),\n        .B_out(B_out1)\n    );\n\n    assign D[63:32] = D0;\n    assign B_out = B_out1;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [7:0] B0, D0, D1, D2;\n    wire B_out0, B_out1, B_out2;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    sub_8bit sub2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .D(D2),\n        .B_out(B_out2)\n    );\n\n    assign D[7:0] = D0;\n    assign D[15:8] = D1;\n    assign D[23:16] = D2;\n    assign B_out = B_out2;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] B0, D0, D1, D2;\n    wire B_out0, B_out1, B_out2;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    assign D[3:0] = D0;\n    assign D[7:4] = D1;\n    assign B_out = B_out1;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] B0, D0, D1;\n    wire B_out0, B_out1;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D0),\n        .B_out(B_out0)\n    );\n\n    sub_2bit sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D1),\n        .B_out(B_out1)\n    );\n\n    assign D[1:0] = D0;\n    assign D[3:2] = D1;\n    assign B_out = B_out1;\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow_out;\n\n// Instantiate the 4-bit full subtractors\nsubtractor sub1(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(borrow_out[0]));\nsubtractor sub2(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(borrow_out[1]));\nsubtractor sub3(.A(A[11:8]), .B(B[11:8]), .D(D[11:8]), .B_out(borrow_out[2]));\nsubtractor sub4(.A(A[15:12]), .B(B[15:12]), .D(D[15:12]), .B_out(borrow_out[3]));\n\n// Calculate borrow-out\nassign B_out = borrow_out[3];\n\nendmodule\n\nmodule subtractor(A, B, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] B_complement;\nwire [2:0] carry;\n\nassign B_complement = ~B;\n\nfull_subtractor fs0(.A(A[0]), .B(B_complement[0]), .D(D[0]), .C_out(carry[0]));\nfull_subtractor fs1(.A(A[1]), .B(B_complement[1]), .D(D[1]), .C_out(carry[1]));\nfull_subtractor fs2(.A(A[2]), .B(B_complement[2]), .D(D[2]), .C_out(carry[2]));\nfull_subtractor fs3(.A(A[3]), .B(B_complement[3]), .D(D[3]), .C_out(carry[3]));\n\nassign B_out = carry[2];\n\nendmodule\n\nmodule full_subtractor(A, B, D, C_out);\ninput A;\ninput B;\noutput D;\noutput C_out;\n\nassign D = A ^ B;\nassign C_out = A & B;\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] result;\n    wire borrow;\n    \n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(result),\n        .borrow(borrow)\n    );\n    \n    assign A_greater = result[31];\n    assign A_equal = ~|result;\n    assign A_less = ~borrow;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] result,\n    output borrow\n);\n    wire [32:0] sub_result;\n    wire [31:0] A_B;\n    \n    assign A_B = A - B;\n    assign sub_result = {1'b0, A_B}; // 33-bit result for borrow detection\n    assign result = A_B;\n    assign borrow = sub_result[32];\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\nwire [15:1] C16;\nwire [32:1] B_shifted;\nwire [32:1] C16_sum;\n\n// Adder shifted inputs\nassign B_shifted = {16'b0,B};\n\n// CLA1 and CLA2\nCLA CLA1(.A(A[15:0]),.B(B_shifted[15:0]),.Cin(1'b0),.Sum(C16[0]),.Cout(C16[1]));\nCLA CLA2(.A(A[31:16]),.B(B_shifted[31:16]),.Cin(C16[0]),.Sum(C16[1]),.Cout(C16[2]));\n\n// Sum and carry\nassign C32 = C16[2];\nassign S = {C16[2],C16_sum};\nassign C16_sum = {C16[1:0],C16[2],C16[2:1]};\n\nendmodule\n\nmodule CLA (A,B,Cin,Sum,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] Sum;\noutput Cout;\n\n// Compute sum and carry\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A&B)|(Cin&(A^B));\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] sum_slice0, sum_slice1, sum_slice2, sum_slice3;\n    wire [3:0] carry_slice0, carry_slice1, carry_slice2, carry_slice3;\n\n    // Carry-select adder for the upper 4 bits\n    adder_4bit rca0(.a(a[15:12]), .b(b[15:12]), .cin(cin), .sum(sum_slice3), .cout(carry_slice3[0]));\n    adder_4bit rca1(.a(a[11:8]), .b(b[11:8]), .cin(carry_slice3[0]), .sum(sum_slice2), .cout(carry_slice3[1]));\n    adder_4bit rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry_slice3[1]), .sum(sum_slice1), .cout(carry_slice3[2]));\n    adder_4bit rca3(.a(a[3:0]), .b(b[3:0]), .cin(carry_slice3[2]), .sum(sum_slice0), .cout(carry_slice3[3]));\n\n    // Select the sum and carry based on the carry-in\n    assign sum = {sum_slice3, sum_slice2, sum_slice1, sum_slice0};\n    assign cout = carry_slice3[3];\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    adder_4bit_add add0(.a(a), .b(b), .cin(cin), .sum(sum), .cout(c[0]));\n    adder_4bit_add add1(.a(a), .b(b), .cin(c[0]), .sum(sum), .cout(c[1]));\n    adder_4bit_add add2(.a(a), .b(b), .cin(c[1]), .sum(sum), .cout(c[2]));\n    adder_4bit_add add3(.a(a), .b(b), .cin(c[2]), .sum(sum), .cout(c[3]));\nendmodule\n\nmodule adder_4bit_add(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    // First 4-bit adder\n    adder_4bit rca0(.a(a[15:12]), .b(b[15:12]), .cin(cin), .sum(sum[15:12]), .cout(carry[0]));\n    adder_4bit rca1(.a(a[11:8]), .b(b[11:8]), .cin(carry[0]), .sum(sum[11:8]), .cout(carry[1]));\n    adder_4bit rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry[1]), .sum(sum[7:4]), .cout(carry[2]));\n    adder_4bit rca3(.a(a[3:0]), .b(b[3:0]), .cin(carry[2]), .sum(sum[3:"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n    wire [1:0] sum;\n\n    // Instantiate 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(sum[0]),\n        .Co(carry[0])\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(sum[1]),\n        .Co(carry[1])\n    );\n\n    // Assign outputs\n    assign y = {sum[1], sum[0]};\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [6:0] sum;\n    wire [6:0] carry;\n\n    // Generate 7-bit sum and carry\n    assign sum = a + b + Cin;\n    assign carry[6:0] = {1'b0, a[7], b[7], Cin};\n\n    // Assign outputs\n    assign y = sum;\n    assign Co = carry[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [2:0] carry;\n\n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nreg [31:0] product;     // Register to hold the product value.\nreg [4:0] shift_cnt;    // Register to hold the shift count.\n\n// Control Unit\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .shift_cnt(shift_cnt)\n);\n\n// Register Unit\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ain(ain),\n    .bin(bin)\n);\n\n// Multiplier Unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .ain(reg_unit.ain),\n    .bin(reg_unit.bin),\n    .shift_cnt(shift_cnt),\n    .product(product)\n);\n\nassign yout = product;\nassign done = ctrl.done;\n\nendmodule\n\nmodule control_unit (\n    input clk,            // Chip clock signal.\n    input rst_n,          // Active-low reset signal.\n    input start,          // Chip enable signal.\n    output reg [4:0] shift_cnt  // Register to hold the shift count.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 0;\n    end else if (start) begin\n        shift_cnt <= 0;\n    end else if (shift_cnt < 15) begin\n        shift_cnt <= shift_cnt + 1;\n    end\nend\n\nendmodule\n\nmodule register_unit (\n    input clk,            // Chip clock signal.\n    input rst_n,          // Active-low reset signal.\n    input start,          // Chip enable signal.\n    input [15:0] ain,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin      // Input b (multiplier) with a data width of 16 bits.\n);\n\nreg [15:0] a;             // Register to hold the multiplicand.\nreg [15:0] b;             // Register to hold the multiplier.\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else if (start) begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,            // Chip clock signal.\n    input [15:0] ain,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,     // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_cnt, // Register to hold the shift count.\n    output reg [31:0] product // Register to hold the product value.\n);\n\nreg [31:0] temp_product;  // Temporary product register.\n\nalways @(posedge clk) begin\n    if (shift_cnt == 0) begin\n        temp_product <= 0;\n    end else begin\n        temp_product <= temp_product + (bin << (shift_cnt - 1));\n    end\n    product <= temp_product;\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\n// Implement the logic part\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            next_count <= (up_down) ? current_count + 1 : current_count - 1;\n        end\n    end\n\nendmodule\n\n// Implement the register part\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // Submodule for state initialization\n    ring_initial init (\n        .reset(reset),\n        .next_state(next_state)\n    );\n\n    // Submodule for state transition\n    ring_transition transition (\n        .clk(clk),\n        .next_state(next_state),\n        .out(out)\n    );\n\nendmodule\n\nmodule ring_initial (\n    input wire reset,\n    output reg [7:0] next_state\n);\n\n    always @ (reset) begin\n        if (reset) begin\n            next_state <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule ring_transition (\n    input wire clk,\n    input wire [7:0] next_state,\n    output reg [7:0] out\n);\n\n    always @ (posedge clk) begin\n        out <= next_state;\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count_out;\n    wire [3:0] next_count;\n    wire [3:0] next_out;\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .next_count(next_count)\n    );\n\n    // Instantiate output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .next_out(next_out)\n    );\n\n    assign out = next_out;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out,\n    output reg [3:0] next_count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n            next_count <= 4'b0000;\n        end else if (valid_count) begin\n            next_count <= (count_out == 4'd11) ? 4'b0000 : count_out + 1;\n        end else begin\n            next_count <= count_out;\n        end\n    end\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] next_out\n);\n    always @(posedge rst_n or negedge rst_n) begin\n        if (!rst_n) begin\n            next_out <= 4'b0000;\n        end else if (valid_count) begin\n            next_out <= count_out;\n        end else begin\n            next_out <= next_out;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst(\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= Q;\n        end\n    end\n\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input [63:0]       Q,\n    output reg [63:0]  Q_next\n);\n\n    always @(*) begin\n        Q_next = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    // Instantiate submodules\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else if (cnt == 1) begin\n            cnt <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else if (cnt == 4) begin\n            cnt <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 0;\n            CLK_out <= 0;\n        end else if (cnt == 49) begin\n            cnt <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_int;\nwire clk_div_int2;\n\n// Counter Submodule\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_int(clk_div_int)\n);\n\n// Clock Average Generator Submodule\nclk_average u_clk_average(\n    .clk_div_int(clk_div_int),\n    .clk_div_int2(clk_div_int2)\n);\n\n// Clock Adjustment Submodule\nclk_adjustment u_clk_adjustment(\n    .clk_div_int(clk_div_int2),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter Submodule\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div_int\n);\n\nparameter CLK_DIV_LIMIT = 1 << MUL2_DIV_CLK;\n\nreg [MUL2_DIV_CLK - 1:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div_int <= 0;\n    end else if (cnt == CLK_DIV_LIMIT - 1) begin\n        cnt <= 0;\n        clk_div_int <= ~clk_div_int;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule\n\n// Clock Average Generator Submodule\nmodule clk_average(\n    input               clk_div_int,\n    output reg          clk_div_int2\n);\n\nparameter CLK_DIV_HIGH = 1;\nparameter CLK_DIV_LOW = 0;\nparameter CLK_DIV_LIMIT = 1 << MUL2_DIV_CLK;\n\nreg [MUL2_DIV_CLK - 1:0] cnt;\nreg clk_div_int_prev;\n\nalways @(posedge clk_div_int) begin\n    clk_div_int_prev <= clk_div_int;\nend\n\nalways @(posedge clk) begin\n    if (cnt == CLK_DIV_LIMIT - 1) begin\n        cnt <= 0;\n        clk_div_int2 <= clk_div_int_prev;\n    end else begin\n        cnt <= cnt + 1;\n        clk_div_int2 <= clk_div_int_prev;\n    end\nend\n\nendmodule\n\n// Clock Adjustment Submodule\nmodule clk_adjustment(\n    input               clk_div_int,\n    output reg          clk_div\n);\n\nparameter CLK_DIV_HIGH = 1;\nparameter CLK_DIV_LOW = 0;\nparameter CLK_DIV_LIMIT = 1 << MUL2_DIV_CLK;\n\nreg [MUL2_DIV_CLK - 1:0] cnt;\n\nalways @(posedge clk_div_int) begin\n    if (cnt == CLK_DIV_LIMIT - 1) begin\n        cnt <= 0;\n        clk_div <= clk_div_int;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n    wire clk_div_tmp;\n    wire clk_div_tmp2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == NUM_DIV - 2)\n            clk_div <= 1;\n        else\n            clk_div <= 0;\n        cnt <= cnt + 1;\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] cnt;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == NUM_DIV - 2)\n            clk_div <= 1;\n        else\n            clk_div <= 0;\n        cnt <= cnt + 1;\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire clk_div_out;\nwire clk_div_en;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_en(clk_div_en),\n    .clk_div(clk_div_out)\n);\n\nclk_divider u_clk_divider(\n    .clk(clk),\n    .clk_div(clk_div_out),\n    .clk_div_en(clk_div_en)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div,\n    output clk_div_out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (clk_div_en) begin\n        if (count == (NUM_DIV / 2 - 1)) begin\n            count <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nassign clk_div_out = clk_div;\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input clk_div,\n    input clk_div_en\n);\n\nreg clk_div_out;\n\nalways @(posedge clk) begin\n    if (clk_div_en)\n        clk_div_out <= ~clk_div_out;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire [31:0] slt_result, sltu_result;\n    wire [31:0] sll_result, srl_result, sra_result;\n    wire [31:0] sllv_result, srlv_result, srav_result;\n    wire [31:0] slli_result, srli_result, srai_result;\n    wire [31:0] lui_result;\n    wire [31:0] l_result;\n\n    assign r = l_result;\n    assign zero = (l_result == 32'b0);\n    assign carry = add_result[32];\n    assign negative = l_result[31];\n    assign overflow = add_result[31] ^ sub_result[31] ^ add_result[31];\n    assign flag = (luc == 6'b101010) ? slt_result : (luc == 6'b101011) ? sltu_result : 1'b0;\n\n    add add_inst(.a(a), .b(b), .r(add_result));\n    addu addu_inst(.a(a), .b(b), .r(add_result));\n    sub sub_inst(.a(a), .b(b), .r(sub_result));\n    subu subu_inst(.a(a), .b(b), .r(sub_result));\n    and and_inst(.a(a), .b(b), .r(and_result));\n    or or_inst(.a(a), .b(b), .r(or_result));\n    xor xor_inst(.a(a), .b(b), .r(xor_result));\n    nor nor_inst(.a(a), .b(b), .r(nor_result));\n    slt slt_inst(.a(a), .b(b), .r(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result));\n    sll sll_inst(.a(a), .b(b), .r(sll_result));\n    srl srl_inst(.a(a), .b(b), .r(srl_result));\n    sra sra_inst(.a(a), .b(b), .r(sra_result));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result));\n    srav srav_inst(.a(a), .b(b), .r(srav_result));\n    slli slli_inst(.a(a), .b(b), .r(slli_result));\n    srli srli_inst(.a(a), .b(b), .r(srli_result));\n    srai srai_inst(.a(a), .b(b), .r(srai_result));\n    lui lui_inst(.a(a), .b(b), .r(lui_result));\n\n    assign l_result = (aluc == 6'b100000) ? add_result : (aluc == 6'b100001) ? add_result : (aluc == 6'b100010) ? sub_result : (aluc == 6'b100011) ? sub_result : (aluc == 6'b100100) ? and_result : (aluc == 6'b100101) ? or_result : (aluc == 6'b100110) ? xor_result : (aluc == 6'b100111) ? nor_result : (aluc == 6'b101010) ? slt_result : (aluc == 6'b101011) ? sltu_result : (aluc == 6'b0000"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] mult_result;\nwire [31:0] current_value;\n\nmult_32x32 u_multiplier(.a(a), .b(b), .result(mult_result));\naccumulator u_accumulator(.clk(clk), .rst(rst), .result(mult_result), .current_value(current_value));\n\nassign c = current_value;\n\nendmodule\n\nmodule mult_32x32(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\nassign result = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        current_value <= 0;\n    else\n        current_value <= current_value + result;\nend\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodules\n    ins_reg ins_p1_i (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad(ad1_p1)\n    );\n    ins_reg ins_p2_i (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad(ad1_p2)\n    );\n\n    // Output assignment\n    assign ins = fetch[0] ? ins_p1 : ins_p2;\n    assign ad1 = fetch[0] ? ad1_p1 : ad1_p2;\n    assign ad2 = fetch[1] ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction register submodule\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad\n);\n    reg [7:0] stored_ins;\n    reg [4:0] stored_ad;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            stored_ins <= 0;\n            stored_ad <= 0;\n        end else begin\n            stored_ins <= data;\n            stored_ad <= data[4:0];\n        end\n    end\n\n    assign ins = stored_ins[7:5];\n    assign ad = stored_ad;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n\n    // Instantiate counter module\n    counter cnt(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate wave generator module\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    // Enable the counter based on frequency\n    assign enable = (freq > 0);\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count >= (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    wire [1:0] state;\n\n    // State control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    // Waveform generation module\n    waveform wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= state;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: wave <= (wave == 5'b0) ? 5'b1 : wave - 1;\n                2'b01: wave <= (wave == 5'b31) ? 5'b30 : wave + 1;\n                default: wave <= wave;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] d0, d1, d2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(d0)\n    );\n    my_dff8 u1 (\n        .clk(clk),\n        .d(d0),\n        .q(d1)\n    );\n    my_dff8 u2 (\n        .clk(clk),\n        .d(d1),\n        .q(d2)\n    );\n\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'bz;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case(sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n            default: out = 4'bz;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n    assign q = q2;\nendmodule\n\nModule for D flip-flop:\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] stage1, stage2, stage3;\n    wire [3:0] sel;\n\n    assign sel = ctrl[2:0];\n    assign stage1 = (sel[2]) ? {in[6:0], in[7]} : in;\n    assign stage2 = (sel[1]) ? {stage1[4:0], stage1[7:5]} : stage1;\n    assign stage3 = (sel[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input [3:0] sel;\n    input [7:0] in0, in1;\n    output [7:0] out;\n    wire [3:0] sel_inv;\n    assign sel_inv = ~sel;\n    assign out = (sel_inv[3:0] & in0) | (sel[3:0] & in1);\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] acc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      acc <= 0;\n    else\n      acc <= acc + (a * b);\n  end\n\n  assign c = acc;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [3:0] op;\n  wire [31:0] alu_res;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n\n  // Fetch stage\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\n\n  // Decode stage\n  decode_stage decode(.clk(clk), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n\n  // Execute stage\n  execute_stage execute(.clk(clk), .rs1(rs1), .rs2(rs2), .op(op), .alu_res(alu_res));\n\n  // Memory stage\n  memory_stage memory(.clk(clk), .alu_res(alu_res), .rd(rd), .alu_res(alu_res));\n\n  // Writeback stage\n  writeback_stage writeback(.clk(clk), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\n\n  // Pipeline registers\n  reg [31:0] pc_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) pc_reg <= 0;\n    else pc_reg <= next_pc;\n  end\n\n  assign next_pc = pc_reg + 4;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] instr\n);\n  assign instr = instr_mem[pc / 4];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [3:0] op\n);\n  always @(posedge clk) begin\n    rs1 <= instr[19:15];\n    rs2 <= instr[24:20];\n    rd <= instr[11:7];\n    op <= instr[31:27];\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [3:0] op,\n  output reg [31:0] alu_res\n);\n  always @(posedge clk) begin\n    case(op)\n      4'b0000: alu_res = 32'b0; // R-type\n      4'b0001: alu_res = rs1 + rs2; // Addition\n      4'b0010: alu_res = rs1 - rs2; // Subtraction\n      default: alu_res = 32'b0;\n    endcase\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output reg [31:0] alu_res\n);\n  always @(posedge clk) begin\n    alu_res <= alu_res;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk) begin\n    res_reg_file[rd] <= alu_res;\n  end\nendmodule\n"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  assign c0 = b0_reg * a0;\n  assign c1 = b1_reg * a1;\n  assign c2 = b2_reg * a2;\n  assign c3 = b3_reg * a3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg + 1;\n      b2_reg <= b2_reg + 1;\n    end\n  end\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] reg_c;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      reg_c <= 0;\n    else\n      reg_c <= reg_c + a * b;\n  end\n  assign c = reg_c;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr;\n    wire [4:0] rd, rs1, rs2;\n    wire [31:0] op1, op2;\n    wire [31:0] result;\n    wire [2:0] funct;\n    wire [31:0] pc;\n    wire [31:0] next_pc;\n    wire [31:0] write_data;\n    \n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc), .instr(instr));\n    execute_stage execute(.clk(clk), .rst(rst), .instr(instr), .reg_file(reg_file), .op1(op1), .op2(op2), .result(result), .funct(funct), .rd(rd), .rs1(rs1), .rs2(rs2));\n    writeback_stage writeback(.clk(clk), .rst(rst), .instr(instr), .result(result), .rd(rd), .write_data(write_data));\n    \n    assign out_reg_file = write_data;\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] next_pc,\n    output reg [31:0] instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            next_pc <= 0;\n            instr <= 0;\n        end else begin\n            next_pc <= pc + 1;\n            instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    output reg [2:0] funct,\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n        end else begin\n            {funct, rd, rs1, rs2} = instr;\n            op1 = reg_file[rs1];\n            op2 = reg_file[rs2];\n            case(funct)\n                3'b000: result = op1 + op2;\n                3'b001: result = op1 - op2;\n                default: result = 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] result,\n    input [4:0] rd,\n    output reg [31:0] write_data\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) write_data <= 0;\n        else write_data <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_out;\n    wire [9:0] data_acc;\n    wire       valid_out_inter;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_acc(data_acc)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt_out),\n        .data_acc(data_acc),\n        .valid_out(valid_out_inter)\n    );\n\n    // Assign Outputs\n    assign data_out = data_acc;\n    assign valid_out = valid_out_inter;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 2'b0;\n        end else if (valid_in) begin\n            cnt_out <= cnt_out + 2'b1;\n        end\n    end\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n\n    output reg  [9:0]   data_acc\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_acc <= 10'b0;\n        end else if (valid_in) begin\n            data_acc <= data_acc + data_in;\n        end\n    end\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt_out,\n    input       [9:0]   data_acc,\n\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n        end else if (cnt_out == 2'b11) begin\n            valid_out <= 1'b1;\n        end else if (cnt_out == 2'b10) begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor_mod;\nwire [15:0] quotient;\n\n// Instantiate submodules\nabs_value abs_dividend_inst(\n    .in(dividend),\n    .sign(sign),\n    .out(abs_dividend)\n);\n\nneg_value neg_divisor_inst(\n    .in(divisor),\n    .sign(sign),\n    .out(neg_divisor_mod)\n);\n\ndivider_control divctrl(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid)\n);\n\nresult_management resmgmt(\n    .clk(clk),\n    .rst(rst),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .quotient(quotient),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] in,\n    input wire sign,\n    output wire [7:0] out\n);\n    assign out = (sign) ? -in : in;\nendmodule\n\nmodule neg_value(\n    input wire [7:0] in,\n    input wire sign,\n    output wire [7:0] out\n);\n    assign out = (sign) ? in : -in;\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid\n);\n    reg [3:0] counter;\n    reg [3:0] shift_reg;\n    reg [15:0] quotient;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            counter <= 0;\n            shift_reg <= 0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                counter <= 1;\n                shift_reg <= 0;\n                res_valid <= 0;\n            end else if (res_ready && res_valid) begin\n                counter <= 0;\n                res_valid <= 0;\n            end else if (counter < 15) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                res_valid <= (counter == 15) ? 1'b1 : res_valid;\n            end\n        end\n    end\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_valid,\n    input wire res_ready,\n    input wire [15:0] quotient,\n    output reg [15:0] result\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            counter <= 0;\n        end else begin\n            if (res_ready) begin\n                result <= 0;\n                counter <= 0;\n            end else if (res_valid && counter < 7) begin\n                result <= {result[14:0], quotient[counter]};\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    // Submodule instantiation\n    prep_dividend prep (\n        .dividend_in(A),\n        .dividend_out(dividend),\n        .divisor_in(B),\n        .divisor_out(divisor)\n    );\n\n    div_operation div_op(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend_in,\n    output reg [31:0] dividend_out,\n    input wire [15:0] divisor_in,\n    output reg [15:0] divisor_out\n);\n    always @(*) begin\n        dividend_out = {dividend_in[15:0], 16'b0};\n        divisor_out = divisor_in;\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    // Internal variables\n    reg [31:0] dividend_copy;\n    reg [31:0] divisor_copy;\n    reg [31:0] quotient_tmp;\n    reg [31:0] remainder_tmp;\n    reg [31:0] shift;\n    reg [31:0] shifted_divisor;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor_comp;\n    reg [31:0] shifted_dividend_comp;\n    reg [31:0] bit;\n    reg [31:0] bit_tmp;\n\n    // Initialize\n    initial begin\n        dividend_copy = dividend;\n        divisor_copy = divisor;\n        quotient = 0;\n        remainder = 0;\n        shift = 0;\n        shifted_divisor = 0;\n        shifted_dividend = 0;\n        shifted_divisor_comp = 0;\n        shifted_dividend_comp = 0;\n        bit = 0;\n        bit_tmp = 0;\n    end\n\n    always @(*) begin\n        // Shift the dividend and divisor for comparison\n        shifted_divisor = {divisor_copy, 16'b0};\n        shifted_dividend = {dividend_copy, 16'b0};\n        shifted_divisor_comp = {divisor_copy, 16'b0, 16'b1};\n        shifted_dividend_comp = {dividend_copy, 16'b0, 1'b1};\n\n        // Shift the dividend and divisor to the left for comparison\n        for (bit = 0; bit < 32; bit = bit + 1) begin\n            if (shifted_divisor == shifted_dividend) begin\n                quotient_tmp = {quotient, 1'b1};\n                remainder_tmp = {remainder, 1'b0};\n            end else if (shifted_dividend == shifted_divisor_comp) begin\n                quotient_tmp = {quotient, 1'b1};\n                remainder_tmp = {remainder, 1'b1};\n            end else begin\n                quotient_tmp = quotient;\n                remainder_tmp = remainder;\n            end\n            dividend_copy = {dividend_copy[30:0], dividend_copy[31]};\n            shifted_divisor = {shifted_divisor[30:0], shifted_divisor[31]};\n            shifted_dividend = {shifted_dividend[30:0], shifted_dividend[31]};\n            shifted_divisor_comp"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_q;\n    wire [15:0] temp_r;\n\n    // Instantiate a control unit\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .temp_q(temp_q),\n        .temp_r(temp_r)\n    );\n\n    // Assign outputs\n    assign result = temp_q;\n    assign odd = temp_r;\n\nendmodule\n\n// Control unit\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] temp_q,  // Temporary quotient\n    output reg [15:0] temp_r   // Temporary remainder\n);\n\n    // Initialize temporary variables\n    initial begin\n        temp_q = 16'b0;\n        temp_r = 16'b0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        temp_q = 16'b0;\n        temp_r = A;\n\n        // Iterate through the bits of the dividend\n        for (int i = 0; i < 16; i = i + 1) begin\n            if (temp_r[7:0] >= B) begin\n                temp_q[i] = 1'b1;\n                temp_r = temp_r - B;\n            end\n            temp_r = temp_r << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n    \n    wire [7:0] B_neg;\n    wire carry;\n    \n    assign B_neg = ~B + 1;\n    \n    adder_8bit adder_inst(\n        .A(A),\n        .B(B_neg),\n        .Cin(1'b1), // Carry in is 1 for subtraction\n        .D(D),\n        .Cout(B_out)\n    );\nendmodule\n\nmodule adder_8bit(A, B, Cin, D, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] D;\n    output Cout;\n    \n    wire [7:0] sum;\n    wire [7:0] carry;\n    \n    full_adder FA0 (.A(A[0]), .B(B[0]), .Cin(Cin), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1 (.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2 (.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3 (.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4 (.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5 (.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6 (.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7 (.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n    \n    assign D = sum;\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n    \n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire B1, B2;\n\n    // Instantiate the 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit S1_inst (.A(A[15:0]), .B(B[15:0]), .Diff(S1), .B_out(B1));\n    // Instantiate the 16-bit subtractor for A[31:16] and B[31:16]\n    sub_16bit S2_inst (.A(A[31:16]), .B(B[31:16]), .Diff(S2), .B_out(B2));\n\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = B1 | B2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] B_neg;\n    wire B_inverted;\n\n    assign B_neg = ~B;\n    assign B_inverted = B[15] ? 1'b1 : 1'b0;\n\n    // Subtract 16-bit A and B\n    full_subtractor #(.WIDTH(16)) full_sub (.A(A), .B(B_neg), .B_in(B_inverted), .D(Diff), .B_out(B_out));\nendmodule\n\nmodule full_subtractor(A, B, B_in, D, B_out);\n    parameter WIDTH = 16;\n    input [WIDTH-1:0] A, B;\n    input B_in;\n    output [WIDTH-1:0] D;\n    output B_out;\n\n    wire [WIDTH-1:0] B_diff, B_neg;\n    wire [WIDTH-1:0] B_complement;\n\n    assign B_diff = A - B;\n    assign B_neg = ~B;\n\n    // Complement the 16-bit B and B_in\n    assign B_complement = (B_in) ? B_neg + 1'b1 : B_neg;\n\n    // Calculate the difference\n    assign D = B_diff - B_complement;\n\n    // Calculate the borrow\n    assign B_out = (B_diff[WIDTH-1] | (B_complement[WIDTH-1] & B_in));\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\nwire [63:0] borrow;\n\nsub_64_bit_subtractor sub0(\n    .A(A[31:0]), .B(B[31:0]), .B_out(borrow[31:0]), .D(D[31:0]));\nsub_64_bit_subtractor sub1(\n    .A(A[63:32]), .B(B[63:32]), .B_out(borrow[63:32]), .D(D[63:32]));\nendmodule\n\nmodule sub_64_bit_subtractor(A, B, B_out, D);\ninput [31:0] A, B;\noutput [31:0] B_out, D;\n\nwire [31:0] B_inverted;\n\nassign B_inverted = ~B;\n\nsub_16_bit_subtractor sub0(\n    .A(A[15:0]), .B(B_inverted[15:0]), .B_out(B_out[15:0]), .D(D[15:0]));\nsub_16_bit_subtractor sub1(\n    .A(A[31:16]), .B(B_inverted[31:16]), .B_out(B_out[31:16]), .D(D[31:16]));\nendmodule\n\nmodule sub_16_bit_subtractor(A, B, B_out, D);\ninput [15:0] A, B;\noutput [15:0] B_out, D;\n\nwire [15:0] B_inverted;\n\nassign B_inverted = ~B;\n\nsub_8_bit_subtractor sub0(\n    .A(A[7:0]), .B(B_inverted[7:0]), .B_out(B_out[7:0]), .D(D[7:0]));\nsub_8_bit_subtractor sub1(\n    .A(A[15:8]), .B(B_inverted[15:8]), .B_out(B_out[15:8]), .D(D[15:8]));\nendmodule\n\nmodule sub_8_bit_subtractor(A, B, B_out, D);\ninput [7:0] A, B;\noutput [7:0] B_out, D;\n\nwire [7:0] B_inverted;\n\nassign B_inverted = ~B;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : gen_subtract_8\n        assign D[i] = A[i] ^ B_inverted[i];\n        assign B_out[i] = (A[i] & ~B_inverted[i]) | (~A[i] & B_inverted[i]);\n    end\nendgenerate\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow1, borrow2, borrow3, borrow4;\n\nsub_4bit sub1(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_out(borrow1[0]),\n    .D(D[3:0])\n);\n\nsub_4bit sub2(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .B_out(borrow2[0]),\n    .D(D[7:4])\n);\n\nsub_4bit sub3(\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .B_out(borrow3[0]),\n    .D(D[11:8])\n);\n\nsub_4bit sub4(\n    .A(A[15:12]),\n    .B(B[15:12]),\n    .B_out(borrow4[0]),\n    .D(D[15:12])\n);\n\nassign B_out = borrow1[3] | borrow2[3] | borrow3[3] | borrow4[3];\n\nendmodule\n\nmodule sub_4bit(A, B, B_out, D);\ninput [3:0] A, B;\noutput B_out;\noutput [3:0] D;\n\nwire [3:0] B_complement;\nwire [4:0] borrow;\n\nassign B_complement = ~B + 1;\n\nfull_subtractor fs0(\n    .A(A[0]),\n    .B(B_complement[0]),\n    .B_in(1'b0),\n    .D(D[0]),\n    .B_out(borrow[0])\n);\n\nfull_subtractor fs1(\n    .A(A[1]),\n    .B(B_complement[1]),\n    .B_in(borrow[0]),\n    .D(D[1]),\n    .B_out(borrow[1])\n);\n\nfull_subtractor fs2(\n    .A(A[2]),\n    .B(B_complement[2]),\n    .B_in(borrow[1]),\n    .D(D[2]),\n    .B_out(borrow[2])\n);\n\nfull_subtractor fs3(\n    .A(A[3]),\n    .B(B_complement[3]),\n    .B_in(borrow[2]),\n    .D(D[3]),\n    .B_out(B_out)\n);\n\nendmodule\n\nmodule full_subtractor(A, B, B_in, D, B_out);\ninput A, B, B_in;\noutput D, B_out;\n\nassign D = A ^ B ^ B_in;\nassign B_out = (~A & B) | (A & ~B);\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] A_minus_B;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .Borrow(borrow),\n        .Result(A_minus_B)\n    );\n\n    assign A_greater = (A_minus_B != 0);\n    assign A_equal = (A_minus_B == 0);\n    assign A_less = ~borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output borrow,\n    output [31:0] Result\n);\n\n    wire [31:0] A_minus_B_ext;\n    wire borrow_internal;\n\n    assign A_minus_B_ext = A - B;\n    assign borrow_internal = A[31] ^ B[31] ^ A_minus_B_ext[31];\n\n    assign Result = A_minus_B_ext;\n    assign borrow = borrow_internal;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:0] C1,C2;\nwire [32:1] P,G,C;\nassign P = A ^ B;\nassign G = A & B;\nassign C[16:1] = C1[14:0] | (P[16:1] & G[15:1]);\nassign S = P ^ C;\nassign C32 = C1[15];\n\nCLA1 CLA1(.A(A[16:1]),.B(B[16:1]),.P(P[16:1]),.G(G[15:1]),.Cin(1'b0),.Cout(C1[15]));\nCLA2 CLA2(.A(A[32:17]),.B(B[32:17]),.P(P[32:17]),.G(G[31:16]),.Cin(C1[15]),.Cout(C2));\nendmodule\n\nmodule CLA1(A,B,P,G,Cin,Cout);\ninput [15:1] A,B,P,G;\ninput Cin;\noutput Cout;\n\nwire [15:0] C;\nassign C[15:1] = Cin | (P[15:1] & G[15:1]);\nassign Cout = C[15];\nendmodule\n\nmodule CLA2(A,B,P,G,Cin,Cout);\ninput [31:17] A,B,P,G;\ninput Cin;\noutput Cout;\n\nwire [15:0] C;\nassign C[15:0] = Cin | (P[15:0] & G[15:0]);\nassign Cout = C[31];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] c;\nwire [3:0] sum_s;\nwire [3:0] sum_s_mux;\nwire [3:0] sum_c;\nwire [3:0] sum_c_mux;\nwire [3:0] sum_mux;\n\n// Ripple carry adder\nripple_carry rca1(\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .sum(sum_s),\n    .cout(c[0])\n);\n\n// First 4-bit carry select adder\ncsa_slice csa_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum_s(sum_s),\n    .sum_c(c[0]),\n    .sum_mux(sum_s_mux),\n    .cout(c[1])\n);\n\n// Second 4-bit carry select adder\ncsa_slice csa_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(c[0]),\n    .sum_s(sum_s_mux),\n    .sum_c(c[1]),\n    .sum_mux(sum_s_mux),\n    .cout(c[2])\n);\n\n// Third 4-bit carry select adder\ncsa_slice csa_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(c[1]),\n    .sum_s(sum_s_mux),\n    .sum_c(c[2]),\n    .sum_mux(sum_s_mux),\n    .cout(c[3])\n);\n\n// Final sum and carry\nassign sum = {sum_s_mux, cin};\nassign cout = c[3];\n\nendmodule\n\nmodule ripple_carry(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] c;\n\nassign sum = a + b + cin;\nassign cout = c[3];\n\nendmodule\n\nmodule csa_slice(a, b, cin, sum_s, sum_c, sum_mux, cout);\ninput [3:0] a, b;\ninput cin;\ninput [3:0] sum_s;\ninput [3:0] sum_c;\noutput [3:0] sum_mux;\noutput cout;\n\nwire [3:0] sum_s_mux;\nwire [3:0] sum_c_mux;\n\nassign sum_s_mux = (cin == 1'b1) ? {sum_s[2:0], sum_s[3]} : sum_s;\nassign sum_c_mux = (cin == 1'b1) ? {sum_c[2:0], sum_c[3]} : sum_c;\n\nassign sum_mux = sum_s_mux ^ sum_c_mux;\nassign cout = sum_s_mux[3] | (sum_s_mux[2] & sum_c_mux[3]) | (sum_s_mux[1] & sum_c_mux[2]) | (sum_s_mux[0] & sum_c_mux[1]);\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n    wire [7:0] sum_0, sum_1;\n\n    // Instantiate the 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .sum(sum_0),\n        .Cout(carry[0])\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .sum(sum_1),\n        .Cout(carry[1])\n    );\n\n    assign y = {sum_1, sum_0};\n    assign Co = carry[1];\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] sum,\n    output wire Cout\n);\n    wire [8:0] carry;\n    genvar i;\n\n    // Add 8-bit inputs with carry-in\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : adder_loop\n            full_adder fa (\n                .a(a[i]),\n                .b(b[i]),\n                .Cin(carry[i]),\n                .sum(sum[i]),\n                .Cout(carry[i + 1])\n            );\n        end\n    endgenerate\n\n    // Final carry-out\n    assign Cout = carry[8];\nendmodule\n\nmodule full_adder (\n    input a, b, Cin,\n    output sum, Cout\n);\n    assign sum = a ^ b ^ Cin;\n    assign Cout = (a & b) | (b & Cin) | (a & Cin);\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    wire [6:0] carry;\n    \n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nreg [15:0] a, b;      // Registers for inputs a and b.\nreg [31:0] p;         // Register to hold the product.\n\n// Control Unit\nwire [4:0] count;     // Counter to track the multiplication.\nwire [31:0] p_next;   // Next product value.\nwire done_next;       // Next done flag.\n\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .done(done_next),\n    .p_next(p_next),\n    .count(count)\n);\n\n// Register Unit\nreg [31:0] p_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) p_reg <= 32'd0;\n    else p_reg <= p_next;\nend\n\n// Multiplier Unit\nwire [15:0] a_shifted;\nassign a_shifted = {a[14:0], 1'b0};\nwire [15:0] b_shifted;\nassign b_shifted = {b[14:0], 1'b0};\nwire [31:0] p_temp;\nassign p_temp = p_reg + (a_shifted & b_shifted);\n\n// Output Assignment\nassign yout = p_temp;\nassign done = done_next;\n\nendmodule\n\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input done,         // Current done flag.\n    output [31:0] p_next, // Next product value.\n    output [4:0] count   // Current multiplication counter.\n);\n\nreg [4:0] cnt;         // Multiplication counter.\nreg done_reg;          // Done flag.\nreg [31:0] p_reg;      // Next product value.\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 5'd0;\n        done_reg <= 1'b0;\n        p_reg <= 32'd0;\n    end else begin\n        if (start) begin\n            cnt <= 5'd0;\n            done_reg <= 1'b0;\n            p_reg <= 32'd0;\n        end else if (cnt == 5'd15) begin\n            cnt <= 5'd0;\n            done_reg <= 1'b1;\n        end else begin\n            cnt <= cnt + 1;\n            done_reg <= 1'b0;\n        end\n    end\nend\n\nassign p_next = p_reg;\nassign done = done_reg;\n\nendmodule\n\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [15:0] a,    // Register a.\n    output [15:0] b    // Register b.\n);\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else if (start) begin\n        a_reg <= ain;\n        b_reg <= bin;\n    end\nend\n\nassign a = a_reg;\nassign b = b_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\n// Logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 16'b0;\n        end else begin\n            if (up_down) begin\n                next_count <= current_count + 1;\n            end else begin\n                next_count <= current_count - 1;\n            end\n        end\n    end\n\nendmodule\n\n// Register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'b0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    // Submodule for initialization\n    init_submodule init (\n        .clk(clk),\n        .reset(reset),\n        .state(out),\n        .next_state(next_state)\n    );\n\n    // Submodule for transition\n    transition_submodule transition (\n        .clk(clk),\n        .state(out),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule init_submodule (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state,\n    output reg [7:0] next_state\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_state <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule transition_submodule (\n    input wire clk,\n    input wire [7:0] state,\n    output reg [7:0] next_state\n);\n\n    always @(posedge clk) begin\n        next_state <= (state == 8'b1111_1111) ? 8'b0000_0001 : state << 1;\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_q;\n\n    // Submodule for registering the state\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_q(next_q)\n    );\n\n    // Submodule for calculating the next state\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_q(next_q)\n    );\n\nendmodule\n\n// Submodule for registering the state\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_q <= 64'b0;\n        end else begin\n            next_q <= Q;\n        end\n    end\n\nendmodule\n\n// Submodule for calculating the next state\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    next_q\n);\n\n    always @(*) begin\n        next_q = {~Q[0], Q[63:1]};\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] count;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] count;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 4) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] count;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 49) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj_neg;\n    wire clk_adj_pos;\n\n    // Counter Submodule\n    counter #(\n        .CLK_DIV_CLK(7)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_4)\n    );\n\n    // Clock Average Generator Submodule\n    clk_average #(\n        .CLK_DIV_CLK(7)\n    ) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_in(clk_4),\n        .clk_avg(clk_avg)\n    );\n\n    // Clock Adjustment Submodule\n    clk_adjustment #(\n        .CLK_DIV_CLK(7)\n    ) u_clk_adjustment (\n        .clk_in(clk_avg),\n        .clk_adj_neg(clk_adj_neg),\n        .clk_adj_pos(clk_adj_pos)\n    );\n\n    // Intermediate Logic\n    assign clk_div = clk_adj_neg | clk_adj_pos;\n\nendmodule\n\n// Counter Submodule\nmodule counter #(\n    parameter CLK_DIV_CLK = 4\n)(\n    input               clk,\n    input               rst_n,\n    output reg          clk_out\n);\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_out <= 0;\n        end else if (count == CLK_DIV_CLK - 1) begin\n            count <= 0;\n            clk_out <= ~clk_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Clock Average Generator Submodule\nmodule clk_average #(\n    parameter CLK_DIV_CLK = 4\n)(\n    input               clk,\n    input               rst_n,\n    input               clk_in,\n    output reg          clk_avg\n);\n\n    reg [3:0] count;\n    reg clk_avg_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_avg_reg <= 0;\n            clk_avg <= 0;\n        end else if (count == CLK_DIV_CLK - 1) begin\n            count <= 0;\n            clk_avg_reg <= ~clk_avg_reg;\n            clk_avg <= clk_avg_reg;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\n// Clock Adjustment Submodule\nmodule clk_adjustment #(\n    parameter CLK_DIV_CLK = 4\n)(\n    input               clk_in,\n    output reg          clk_adj_neg,\n    output reg          clk_adj_pos\n);\n\n    reg [3:0] count;\n    reg clk_adj_neg_reg;\n    reg clk_adj_pos_reg;\n\n    always @(posedge clk_in or negedge clk_in) begin\n        if (!clk_in) begin\n            count <= 0;\n            clk_adj_neg_reg <= 0;\n            clk_adj_pos_reg <= 0;\n            clk_adj_neg <= 0;\n            clk_adj_pos <= 0;\n        end else if (count == CLK_DIV_CLK - 1) begin\n            count <= 0;\n            clk_adj_neg_reg <= ~clk_adj_neg_reg;\n            clk_adj_pos_reg <= ~clk_adj_pos_reg;\n            clk_adj_neg <= clk_adj_neg_reg;\n           "}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [$clog2(NUM_DIV) - 1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            clk_div <= 1;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [$clog2(NUM_DIV) - 1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == NUM_DIV - 1) begin\n            clk_div <= 1;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 8;\n\n    wire [3:0] counter_out;\n    wire clk_div_out;\n    wire clk_div_en;\n\n    reg [3:0] counter_reg;\n    reg clk_div_reg;\n\n    // Counter\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock divider\n    clk_divider u_clk_divider(\n        .clk(clk),\n        .clk_div_in(clk_div_out),\n        .clk_div_en(clk_div_en)\n    );\n\n    assign clk_div_out = counter_out == (NUM_DIV / 2 - 1) ? 1'b1 : 1'b0;\n    assign clk_div_en = counter_out == (NUM_DIV / 2 - 1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (count_out == (NUM_DIV / 2 - 1))\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input clk_div_in,\n    input clk_div_en,\n    output reg clk_div\n);\n    always @(posedge clk) begin\n        if (clk_div_en)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out, slt_out, sltu_out;\n    wire add_zero, add_carry, sub_zero, sub_borrow, and_zero, or_zero, xor_zero, nor_zero;\n    wire slt_result, sltu_result;\n    wire add_neg, sub_neg;\n    wire add_ovf, sub_ovf;\n    \n    adder add(\n        .a(a),\n        .b(b),\n        .result(add_out),\n        .zero(add_zero),\n        .carry(add_carry),\n        .neg(add_neg),\n        .ovf(add_ovf)\n    );\n    addu addu(\n        .a(a),\n        .b(b),\n        .result(add_out),\n        .zero(add_zero),\n        .carry(add_carry),\n        .neg(add_neg),\n        .ovf(add_ovf)\n    );\n    subtractor sub(\n        .a(a),\n        .b(b),\n        .result(sub_out),\n        .zero(sub_zero),\n        .borrow(sub_borrow),\n        .neg(sub_neg),\n        .ovf(sub_ovf)\n    );\n    subtractoru subu(\n        .a(a),\n        .b(b),\n        .result(sub_out),\n        .zero(sub_zero),\n        .borrow(sub_borrow),\n        .neg(sub_neg),\n        .ovf(sub_ovf)\n    );\n    and_gate and1(\n        .a(a),\n        .b(b),\n        .result(and_out),\n        .zero(and_zero)\n    );\n    or_gate or1(\n        .a(a),\n        .b(b),\n        .result(or_out),\n        .zero(or_zero)\n    );\n    xor_gate xor1(\n        .a(a),\n        .b(b),\n        .result(xor_out),\n        .zero(xor_zero)\n    );\n    nor_gate nor1(\n        .a(a),\n        .b(b),\n        .result(nor_out),\n        .zero(nor_zero)\n    );\n    slt_module slt_inst(\n        .a(a),\n        .b(b),\n        .result(slt_result)\n    );\n    sltu_module sltu_inst(\n        .a(a),\n        .b(b),\n        .result(sltu_result)\n    );\n    // Shift logic\n    assign r = (aluc == 6'b000000) ? a << b[4:0] : (aluc == 6'b000010) ? a >> b[4:0] : (aluc == 6'b000011) ? $signed(a >>> b[4:0]) : (aluc == 6'b000100) ? a << b : (aluc == 6'b000110) ? $signed(a >>> b) : (aluc == 6'b000111) ? $signed(a >>> b) : (aluc == 6'b001111) ? {18'b0, b[15:0]} : add_out;\n    assign zero = (aluc == 6'b000000) ? add_zero : (aluc == 6'b000010) ? sub_zero : (aluc == 6'b000011) ? sub_zero : (aluc == 6'b000100) ? and_zero : (aluc == 6'b000110) ? or_zero : (aluc == 6'b000111) ? nor_zero : (aluc == 6'b001111) ? 1'b0 : (aluc == 6'b100000) ? add"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nreg [31:0] current_value;\n\nwire [63:0] product;\n\n// Instantiate the multiplier\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .product(product)\n);\n\n// Instantiate the accumulator\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .product(product),\n    .current_value(current_value)\n);\n\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    assign product = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12, ad21, ad22;\n    wire [7:0] data1, data2;\n    submodule ins_p1 ins_p2;\n\n    assign ins1 = ins_p1.ins;\n    assign ad11 = ins_p1.ad;\n    assign data1 = ins_p1.data;\n    assign ins2 = ins_p2.ins;\n    assign ad12 = ins_p2.ad;\n    assign data2 = ins_p2.data;\n\n    assign ins = fetch[0] ? ins1 : ins2;\n    assign ad1 = fetch[0] ? ad11 : ad12;\n    assign ad2 = fetch[1] ? data2 : ad22;\n\n    always @(posedge clk) begin\n        if (~rst) begin\n            ins_p1.rst;\n            ins_p2.rst;\n        end\n        if (fetch[0]) ins_p1.fetch(data);\n        else if (fetch[1]) ins_p2.fetch(data);\n    end\nendmodule\n\nmodule submodule (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad,\n    output [7:0] data_out\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad_reg;\n    reg [7:0] data_reg;\n\n    assign ins = ins_reg;\n    assign ad = ad_reg;\n    assign data_out = data_reg;\n\n    always @(posedge clk) begin\n        if (~rst) begin\n            ins_reg <= 0;\n            ad_reg <= 0;\n            data_reg <= 0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad_reg <= data[4:0];\n            data_reg <= data;\n        end\n    end\n\n    initial begin\n        ins_reg <= 0;\n        ad_reg <= 0;\n        data_reg <= 0;\n    end\n\n    task fetch;\n        input [7:0] data;\n        begin\n            ins_reg <= data[7:5];\n            ad_reg <= data[4:0];\n            data_reg <= data;\n        end\n    endtask\n\n    task rst;\n        begin\n            ins_reg <= 0;\n            ad_reg <= 0;\n            data_reg <= 0;\n        end\n    endtask\nendmodule\n\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire [7:0] enable;\n\ncounter cnt(\n    .clk(clk),\n    .enable(freq),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wg(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input [7:0] enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nreg [7:0] cnt;\n\nalways @(posedge clk) begin\n    if(cnt >= (freq - 1)) begin\n        cnt <= 0;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if(enable) begin\n        count <= cnt;\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    if(count == (freq - 1)) begin\n        wave_out <= 0;\n    end else if(count == 0) begin\n        wave_out <= 1;\n    end\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state_reg, state_next;\n    reg [4:0] wave_reg, wave_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            state_reg <= state_next;\n            wave_reg <= wave_next;\n        end\n    end\n\n    always @(*) begin\n        case (state_reg)\n            2'b00: wave_next = wave_reg + 1;\n            2'b01: wave_next = wave_reg - 1;\n            default: wave_next = wave_reg;\n        endcase\n        state_next = state_reg;\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            state <= 2'b01;\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            wave <= wave + 1;\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(sel or q0 or q1 or q2)\n        case(sel)\n            2'b00: q = q0;\n            2'b01: q = q1;\n            2'b10: q = q2;\n            2'b11: q = d;\n        endcase\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule\n\nmodule mux4to1_8bit (\n    input [1:0] sel,\n    input [7:0] d0, d1, d2,\n    output [7:0] q\n);\n    reg [7:0] q_reg;\n\n    always @(*)\n        case(sel)\n            2'b00: q_reg = d0;\n            2'b01: q_reg = d1;\n            2'b10: q_reg = d2;\n            2'b11: q_reg = 8'bzzzzzzzz;\n        endcase\n\n    assign q = q_reg;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire w0, w1, w2;\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(w0)\n    );\n    my_dff u1 (\n        .clk(clk),\n        .d(w0),\n        .q(w1)\n    );\n    my_dff u2 (\n        .clk(clk),\n        .d(w1),\n        .q(w2)\n    );\n    assign q = w2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[2]) ? {stage1[1:0], stage1[7:2]} : stage1;\n    assign stage3 = (ctrl[2]) ? {stage2[2:0], stage2[7:3]} : stage2;\n    assign stage4 = (ctrl[2]) ? {stage3[3:0], stage3[7:4]} : stage3;\n    assign stage5 = (ctrl[1]) ? {stage4[1:0], stage4[7:2]} : stage4;\n    assign stage6 = (ctrl[1]) ? {stage5[2:0], stage5[7:3]} : stage5;\n    assign stage7 = (ctrl[0]) ? {stage6[3:0], stage6[7:4]} : stage6;\n    assign stage8 = (ctrl[0]) ? {stage7[1:0], stage7[7:2]} : stage7;\n\n    assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (sel, sel_in, sel_out);\n    input sel;\n    input sel_in, sel_out;\n    output sel_out;\n\n    assign sel_out = sel ? sel_in : sel_out;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n  wire [15:0] b1_next;\n  wire [31:0] pe0_out, pe1_out;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1_next),\n    .c(pe1_out)\n  );\n  assign b1_next = b1_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) b1_reg <= 0;\n    else b1_reg <= b0;\n  end\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] acc;\n  always @(posedge clk or posedge rst) begin\n    if (rst) acc <= 0;\n    else acc <= acc + a * b;\n  end\n  assign c = acc;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [31:0] pc;\n\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\n  decode_stage decode(.clk(clk), .pc(pc), .instr(fetch.instr), .alu_res(alu_res));\n  execute_stage execute(.clk(clk), .alu_res(alu_res));\n  memory_stage memory(.clk(clk), .alu_res(alu_res));\n  writeback_stage writeback(.clk(clk), .res_reg_file(writeback.res_reg_file));\n\n  assign res_reg_file = writeback.res_reg_file;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem[31:0],\n  output reg [31:0] pc\n);\n  reg [31:0] pc_reg;\n  reg [31:0] instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc_reg + 1;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      instr <= 0;\n    else\n      instr <= instr_mem[pc_reg];\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input [31:0] pc,\n  input [31:0] instr,\n  output [31:0] alu_res\n);\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n\n  assign rs1 = instr[31:27];\n  assign rs2 = instr[26:22];\n  assign rd = instr[21:17];\n  assign op = instr[15:0];\n\n  wire [31:0] rs1_val, rs2_val;\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk) begin\n    rs1_val <= reg_file[rs1];\n    rs2_val <= reg_file[rs2];\n    alu_res_reg <= (op == 6'b011001) ? rs1_val + rs2_val : rs1_val - rs2_val;\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input [31:0] alu_res\n);\n  // No operation.\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_res\n);\n  // No operation.\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  output reg [31:0] res_reg_file[31:0]\n);\n  always @(posedge clk) begin\n    res_reg_file <= alu_res;\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  wire [15:0] b1, b2, b3;\n  \n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  // Instantiate the PEs\n  PE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  PE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  PE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  // Update the pipeline registers\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n      b3_reg <= b3;\n    end\n  end\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) c <= 0;\n    else c <= c + a * b;\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\nwire [31:0] fetch_instr;\nwire [31:0] exec_result;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\n\nfetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(0), .instr(fetch_instr));\nexecute_stage execute (.clk(clk), .rst(rst), .instr(fetch_instr), .reg_file(reg_file), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .result(exec_result));\nwriteback_stage writeback (.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .result(exec_result), .reg_file(reg_file));\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            instr <= 32'b0;\n        end else begin\n            instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [5:0] op,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [4:0] rd,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            op <= 6'b0;\n            rs1 <= 5'b0;\n            rs2 <= 5'b0;\n            rd <= 5'b0;\n            result <= 32'b0;\n        end else begin\n            op <= instr[31:26];\n            rs1 <= instr[25:20];\n            rs2 <= instr[19:15];\n            rd <= instr[14:10];\n            case(op)\n                6'b001000: result <= reg_file[rs1] + reg_file[rs2];\n                6'b001010: result <= reg_file[rs1] - reg_file[rs2];\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [5:0] op,\n    input [4:0] rs1,\n    input [4:0] rs2,\n    input [4:0] rd,\n    input [31:0] result,\n    input [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            reg_file[rd] <= 32'b0;\n        end else begin\n            reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] count;\n    wire [9:0] data_accum;\n    wire new_count;\n\n    // Counter Module Instance\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count_out(count)\n    );\n\n    // Data Accumulator Module Instance\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_accum(data_accum)\n    );\n\n    // Valid Output Module Instance\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_accum(data_accum),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 2'b0;\n        end else if (valid_in) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n\n    output reg  [9:0]   data_accum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accum <= 10'b0;\n        end else if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [9:0]   data_accum,\n\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n        end else if (valid_in && (data_accum[9:8] == 2'b11)) begin\n            valid_out <= 1'b1;\n        end else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [15:0] remainder;\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [2:0] count;\n    wire div_done;\n    wire [7:0] shift_reg;\n\n    // Submodule instances\n    abs_value abs_dividend_inst (.dividend(dividend), .sign(sign), .abs_val(abs_dividend));\n    neg_value neg_divisor_mod_inst (.dividend(divisor), .sign(sign), .neg_val(neg_divisor));\n    div_control ctrl_inst (.clk(clk), .rst(rst), .divisor(neg_divisor), .div_done(div_done), .count(count));\n    res_mgmt res_mgmt_inst (.clk(clk), .rst(rst), .res_ready(res_ready), .div_done(div_done), .count(count), .result(result), .remainder(remainder));\n\n    // Calculate the remainder\n    assign remainder = abs_dividend - (divisor << count);\n\nendmodule\n\nmodule abs_value(\n    input wire [7:0] dividend,    \n    input wire sign,       \n    output reg [7:0] abs_val\n);\n\n    always @(*) begin\n        if (sign) begin\n            abs_val = ~dividend + 1;\n        end else begin\n            abs_val = dividend;\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire [7:0] dividend,    \n    input wire sign,       \n    output reg [7:0] neg_val\n);\n\n    always @(*) begin\n        if (sign) begin\n            neg_val = dividend;\n        end else begin\n            neg_val = ~dividend + 1;\n        end\n    end\n\nendmodule\n\nmodule div_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] divisor,    \n    output reg div_done,   \n    output reg [2:0] count\n);\n\n    reg [2:0] next_count;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            div_done <= 1'b0;\n        end else begin\n            count <= next_count;\n            div_done <= (next_count == 3'd7);\n        end\n    end\n\n    always @(*) begin\n        next_count = count + 3'd1;\n    end\n\nendmodule\n\nmodule res_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,   \n    input wire div_done,   \n    input wire [2:0] count,   \n    input wire [15:0] result,   \n    output reg res_valid,   \n    output reg [15:0] remainder\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n            remainder <= 16'd0;\n        end else begin\n            if (div_done && res_ready) begin\n                res_valid <= 1'b1;\n                remainder <= result;\n            end else begin\n                res_valid <= 1'b0;\n                remainder <= 16'd0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend, divisor;\n    wire [31:0] quotient, remainder;\n\n    // Prepare dividend and divisor.\n    prep_dividend prep_mod(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division.\n    div_operation div_mod(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs.\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Submodule to prepare dividend and divisor.\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [31:0] divisor\n);\n\n    always @(*) begin\n        dividend = { {16{1'b0}}, A }; // Extend dividend to 32-bits.\n        divisor = { {16{1'b0}}, B }; // Extend divisor to 32-bits.\n    end\n\nendmodule\n\n// Submodule to perform division.\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    integer i;\n\n    always @(*) begin\n        remainder = dividend;\n        quotient = 32'b0;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient[i] = 1'b1;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n            remainder = { remainder[30:0], 1'b0 };\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [7:0] D;\n    wire [15:0] Q, R;\n    wire [15:0] A_temp;\n\n    assign D = B;\n    assign A_temp = A;\n\n    div_ctrl ctrl (\n        .D(D),\n        .A(A_temp),\n        .Q(Q),\n        .R(R)\n    );\n\n    assign result = Q;\n    assign odd = R;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [7:0] D,        // 8-bit divisor\n    input wire [15:0] A,       // 16-bit dividend\n    output reg [15:0] Q,        // 16-bit quotient\n    output reg [15:0] R         // 16-bit remainder\n);\n\n    reg [15:0] D_temp;\n    reg [2:0] i;\n    reg [15:0] A_temp;\n    reg [15:0] Q_temp;\n    reg [15:0] R_temp;\n\n    always @(*) begin\n        D_temp = D;\n        A_temp = A;\n        Q_temp = 16'd0;\n        R_temp = 16'd0;\n        i = 0;\n    end\n\n    always @(posedge D_temp[7] or posedge D_temp[15]) begin\n        if (D_temp[7]) begin\n            i <= 0;\n            Q_temp[i] <= 1'b0;\n            R_temp <= A_temp;\n        end else if (D_temp[15]) begin\n            Q_temp <= Q_temp | (16'b1 << i);\n            R_temp <= R_temp - A_temp;\n            i <= i + 1;\n        end else begin\n            Q_temp <= Q_temp;\n            R_temp <= R_temp;\n        end\n    end\n\n    always @(posedge D_temp[7] or posedge D_temp[15]) begin\n        Q <= Q_temp;\n        R <= R_temp;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_compl;\nwire borrow;\n\n// Complement B\nassign B_compl = ~B + 1;\n\n// Perform subtraction\nadder_8bit adder_inst(.A(A), .B(B_compl), .D(D), .B_out(borrow));\n\nassign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] C;\nwire carry;\n\nfull_adder FA0(.a(A[0]), .b(B[0]), .cin(0), .sum(D[0]), .cout(C[0]));\nfull_adder FA1(.a(A[1]), .b(B[1]), .cin(C[0]), .sum(D[1]), .cout(C[1]));\nfull_adder FA2(.a(A[2]), .b(B[2]), .cin(C[1]), .sum(D[2]), .cout(C[2]));\nfull_adder FA3(.a(A[3]), .b(B[3]), .cin(C[2]), .sum(D[3]), .cout(C[3]));\nfull_adder FA4(.a(A[4]), .b(B[4]), .cin(C[3]), .sum(D[4]), .cout(C[4]));\nfull_adder FA5(.a(A[5]), .b(B[5]), .cin(C[4]), .sum(D[5]), .cout(C[5]));\nfull_adder FA6(.a(A[6]), .b(B[6]), .cin(C[5]), .sum(D[6]), .cout(C[6]));\nfull_adder FA7(.a(A[7]), .b(B[7]), .cin(C[6]), .sum(D[7]), .cout(C[7]));\n\nassign B_out = C[7];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1, S2;\n\nsub_16bit S1_inst(.A(A[15:0]), .B(B[15:0]), .Diff(S1), .B_out(B_out));\nsub_16bit S2_inst(.A(A[31:16]), .B(B[31:16]), .Diff(S2), .B_out(B_out));\n\nassign Diff[15:0] = S1;\nassign Diff[31:16] = S2;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [14:0] S;\nwire b_in;\n\nassign b_in = B_out;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 16; i = i + 1) begin : bit_sub\n        assign Diff[i] = A[i] ^ B[i] ^ b_in;\n        assign b_in = A[i] & B[i] | A[i] & b_in | B[i] & b_in;\n    end\nendgenerate\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .borrow(borrow0)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D1),\n        .borrow(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign B_out = borrow1;\nendmodule\n\nmodule sub_32bit(A, B, D, borrow);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output borrow;\n\n    wire [15:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D0),\n        .borrow(borrow0)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D1),\n        .borrow(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign borrow = borrow1;\nendmodule\n\nmodule sub_16bit(A, B, D, borrow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output borrow;\n\n    wire [7:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .borrow(borrow0)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .borrow(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign borrow = borrow1;\nendmodule\n\nmodule sub_8bit(A, B, D, borrow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output borrow;\n\n    wire [3:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D0),\n        .borrow(borrow0)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D1),\n        .borrow(borrow1)\n    );\n\n    assign D = {D1, D0};\n    assign borrow = borrow1;\nendmodule\n\nmodule sub_4bit(A, B, D, borrow);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output borrow;\n\n    wire [1:0] D0, D1;\n    wire borrow0, borrow1;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D0),\n        .borrow(borrow0)\n    );\n\n    sub_2bit sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D1),\n        .borrow(borrow1)\n    );\n\n    assign"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow_out;\n\nsub_4bit sub1(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_out(borrow_out[0])\n);\n\nsub_4bit sub2(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .B_out(borrow_out[1])\n);\n\nsub_4bit sub3(\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .B_out(borrow_out[2])\n);\n\nsub_4bit sub4(\n    .A(A[15:12]),\n    .B(B[15:12]),\n    .B_out(borrow_out[3])\n);\n\nassign D[15:0] = A - B;\nassign B_out = borrow_out[3];\n\nendmodule\n\nmodule sub_4bit(A, B, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput B_out;\n\nwire [3:0] D;\nwire [2:0] borrow;\n\nfull_sub_4bit fsub1(\n    .A(A),\n    .B(B),\n    .D(D),\n    .B_out(borrow[0])\n);\nfull_sub_4bit fsub2(\n    .A(D),\n    .B(B),\n    .D(D),\n    .B_out(borrow[1])\n);\nfull_sub_4bit fsub3(\n    .A(D),\n    .B(B),\n    .D(D),\n    .B_out(borrow[2])\n);\n\nassign B_out = borrow[2];\n\nendmodule\n\nmodule full_sub_4bit(A, B, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] D;\noutput B_out;\n\nwire [2:0] borrow;\n\nsub_3bit sub1(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_out(borrow[0])\n);\nsub_3bit sub2(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .B_out(borrow[1])\n);\nsub_3bit sub3(\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .B_out(borrow[2])\n);\n\nassign D[3:0] = A[3:0] - B[3:0];\nassign B_out = borrow[2];\n\nendmodule\n\nmodule sub_3bit(A, B, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput B_out;\n\nwire [2:0] borrow;\n\nfull_sub_3bit fsub1(\n    .A(A),\n    .B(B),\n    .D(A),\n    .B_out(borrow[0])\n);\nfull_sub_3bit fsub2(\n    .A(A),\n    .B(B),\n    .D(A),\n    .B_out(borrow[1])\n);\nfull_sub_3bit fsub3(\n    .A(A),\n    .B(B),\n    .D(A),\n    .B_out(borrow[2])\n);\n\nassign B_out = borrow[2];\n\nendmodule\n\nmodule full_sub_3bit(A, B, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] borrow;\n\nsub_2bit sub1(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .B_"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire borrow;\n\nsubtractor_32bit sub_inst(\n    .A(A), \n    .B(B), \n    .D(sub_result), \n    .B_neg(borrow)\n);\n\nassign A_greater = ~borrow & (sub_result != 32'd0);\nassign A_equal = ~borrow & (sub_result == 32'd0);\nassign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] D,  // Difference\n    output B_neg       // Borrow\n);\n\nwire [31:0] B_neg_not;\nwire [31:0] B_neg_xor;\n\nassign B_neg_not = ~B;\nassign B_neg_xor = B_neg_not ^ B;\nassign D = A ^ B_neg_xor;\nassign B_neg = ~(|(A & B_neg_xor));\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\n\nwire [32:1] c1,c2,c3,c4,c5,c6,c7,c8;\nwire [32:1] p1,p2,p3,p4,p5,p6,p7,p8;\n\ncla_16bit CLA1(\n    .A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .P(p1), .G(c1), .Cout(c2)\n);\ncla_16bit CLA2(\n    .A(A[32:17]), .B(B[32:17]), .Cin(c2), .P(p2), .G(c3), .Cout(c4)\n);\ncla_16bit CLA3(\n    .A(A[32:17]), .B(B[32:17]), .Cin(c4), .P(p3), .G(c5), .Cout(c6)\n);\ncla_16bit CLA4(\n    .A(A[32:17]), .B(B[32:17]), .Cin(c6), .P(p4), .G(c7), .Cout(c8)\n);\ncla_16bit CLA5(\n    .A(A[16:1]), .B(B[16:1]), .Cin(c8), .P(p5), .G(c9), .Cout(c10)\n);\ncla_16bit CLA6(\n    .A(A[16:1]), .B(B[16:1]), .Cin(c10), .P(p6), .G(c11), .Cout(c12)\n);\ncla_16bit CLA7(\n    .A(A[16:1]), .B(B[16:1]), .Cin(c12), .P(p7), .G(c13), .Cout(c14)\n);\ncla_16bit CLA8(\n    .A(A[16:1]), .B(B[16:1]), .Cin(c14), .P(p8), .G(c15), .Cout(c16)\n);\n\nassign S = p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;\nassign C32 = c16;\n\nendmodule\n\nmodule cla_16bit(A,B,Cin,P,G,Cout);\ninput [16:1] A;\ninput [16:1] B;\ninput Cin;\noutput [16:1] P;\noutput G;\noutput Cout;\n\nwire [16:1] g,p;\nwire [16:1] c;\nwire [16:1] c1,c2,c3;\nwire [16:1] p1,p2,p3;\nwire [16:1] g1,g2,g3;\n\nassign c1[16:1] = {16{Cin}};\nassign c2[16:1] = c1[16:1] | (A[16:1] & B[16:1]);\nassign c3[16:1] = c2[16:1] | (A[16:1] & ~B[16:1]);\n\nassign p1[16:1] = A[16:1] ^ B[16:1] ^ c1[16:1];\nassign p2[16:1] = p1[16:1] ^ A[16:1];\nassign p3[16:1] = p2[16:1] ^ B[16:1];\n\nassign g1[16:1] = A[16:1] & B[16:1];\nassign g2[16:1] = A[16:1] & ~B[16:1];\nassign g3"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c;\n    wire [3:0] s;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(s[0]),\n        .cout(c[0])\n    );\n\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c[0]),\n        .sum(s[1]),\n        .cout(c[1])\n    );\n\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c[1]),\n        .sum(s[2]),\n        .cout(c[2])\n    );\n\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c[2]),\n        .sum(s[3]),\n        .cout(c[3])\n    );\n\n    assign sum = {s[3], s[2], s[1], s[0]};\n    assign cout = c[3];\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n    wire [3:0] s;\n\n    ripple_carry_adder rca1(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(s[0]),\n        .cout(c[0])\n    );\n\n    ripple_carry_adder rca2(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(s[1]),\n        .cout(c[1])\n    );\n\n    ripple_carry_adder rca3(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(s[2]),\n        .cout(c[2])\n    );\n\n    ripple_carry_adder rca4(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(s[3]),\n        .cout(c[3])\n    );\n\n    assign sum = {s[3], s[2], s[1], s[0]};\n    assign cout = c[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    wire c1, c2;\n\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n    wire [3:0] s;\n\n    ripple_carry_adder rca1(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(s[0]),\n        .cout(c[0])\n    );\n\n    ripple_carry_adder rca2(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(s[1]),\n        .cout(c[1])\n    );\n\n    ripple_"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n\n    // Instantiate 8-bit adder\n    add8 add8_inst1 (.a(a[7:0]), .b(b[7:0]), .Cin(Cin), .y(y[7:0]), .Co(carry[0]));\n    add8 add8_inst2 (.a(a[15:8]), .b(b[15:8]), .Cin(carry[0]), .y(y[15:8]), .Co(carry[1]));\n\n    // Final carry\n    assign Co = carry[1];\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [6:0] carry;\n    wire [7:0] g, p, c;\n    genvar i;\n\n    // Generate partial products\n    for (i = 0; i < 8; i = i + 1) begin\n        assign g[i] = a[i] & b[i];\n        assign p[i] = a[i] ^ b[i];\n    end\n\n    // Generate carry chains\n    for (i = 0; i < 7; i = i + 1) begin\n        assign c[i+1] = g[i] | (p[i] & c[i]);\n    end\n    assign c[0] = g[0] | (p[0] & Cin);\n\n    // Sum\n    for (i = 0; i < 8; i = i + 1) begin\n        assign y[i] = p[i] ^ c[i];\n    end\n\n    // Final carry\n    assign Co = c[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    wire [3:0] carry;\n    \n    FA FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4 (.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5 (.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6 (.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7 (.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\n```\n"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control unit\nwire [3:0] shift_count;\nassign shift_count[3:1] = {3{1'b0}};\nassign shift_count[0] = start | (shift_count[3:1] != {3{1'b0}});\n\n// Register unit\nwire [15:0] a_reg, b_reg;\nreg [31:0] p_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n        p_reg <= 0;\n    end else begin\n        a_reg <= ain;\n        b_reg <= bin;\n        p_reg <= 0;\n    end\nend\n\n// Multiplier unit\nwire [15:0] shifted_b;\nassign shifted_b = b_reg << shift_count[2:0];\nwire [31:0] shifted_p;\nassign shifted_p = p_reg << 1;\nalways @(posedge clk) begin\n    if (start) begin\n        p_reg <= {shifted_p[30:0], shifted_b[0]};\n    end\nend\n\n// Output assignment\nassign yout = p_reg;\nassign done = start & ~|shift_count[3:1];\n\nendmodule\n\n// Control unit\nmodule ctrl_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [3:0] shift_count, // Shift count.\n    output [3:0] next_shift_count // Next shift count.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        next_shift_count <= 4'b0000;\n    end else begin\n        next_shift_count <= (shift_count != 4'b1111) ? shift_count + 1 : shift_count;\n    end\nend\n\nendmodule\n\n// Register unit\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [15:0] a_reg, // Register a.\n    output [15:0] b_reg // Register b.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end else begin\n        a_reg <= start ? ain : a_reg;\n        b_reg <= start ? bin : b_reg;\n    end\nend\n\nendmodule\n\n// Multiplier unit\nmodule mul_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] shifted_b, // Shifted multiplier.\n    input [15:0] shifted_p, // Shifted product.\n    output [31:0] shifted_p_next // Shifted product after multiplication.\n);\n\nalways @(posedge clk) begin\n    shifted_p_next <= {shifted_p[30:0], shifted_b[0]};\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_count <= 16'd0;\n        else\n            next_count <= up_down ? current_count + 1 : current_count - 1;\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 16'd0;\n        else\n            current_count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n    wire [7:0] next_out;\n\n    // State initialization module\n    ring_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // State transition module\n    ring_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .in(out),\n        .next_out(next_out)\n    );\n\nendmodule\n\n// State initialization module\nmodule ring_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\n// State transition module\nmodule ring_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg [7:0] next_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_out <= 8'b0000_0001;\n        end else begin\n            next_out <= in == 8'b1111_1111 ? 8'b0000_0001 : in + 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out_current(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] out_current,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= out_current;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\n    // Instantiate the logic\n    JC_logic logic_inst (\n        .current_Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         next_Q,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= next_Q;\n    end\n\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input [63:0]         current_Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(*) begin\n        next_Q = current_Q;\n        next_Q[0] = ~next_Q[63];\n        next_Q[1:63] = current_Q[0:62];\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_50_internal, CLK_10_internal, CLK_1_internal;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50_internal)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10_internal)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1_internal)\n    );\n\n    assign CLK_50 = CLK_50_internal;\n    assign CLK_10 = CLK_10_internal;\n    assign CLK_1 = CLK_1_internal;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 2'b0;\n        end\n        else begin\n            if (cnt == 2'b10) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 2'b0;\n            end\n            else begin\n                cnt <= cnt + 2'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 4'b0000;\n        end\n        else begin\n            if (cnt == 4'b1001) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 4'b0000;\n            end\n            else begin\n                cnt <= cnt + 4'b0001;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 6'b000000;\n        end\n        else begin\n            if (cnt == 6'b111111) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 6'b000000;\n            end\n            else begin\n                cnt <= cnt + 6'b000001;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_div_4;\n    wire clk_div_3;\n\n    // Counter\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_4)\n    );\n\n    // Average Clock Generator\n    clk_average u_clk_average (\n        .clk(clk),\n        .clk_div_4(clk_div_4),\n        .clk_div_3(clk_div_3)\n    );\n\n    // Clock Adjustment\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_div_4(clk_div_4),\n        .clk_div_3(clk_div_3)\n    );\n\n    // Final output\n    assign clk_div = clk_div_4 | clk_div_3;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end else if (cnt == 7) begin\n            cnt <= 0;\n            clk_div <= ~clk_div;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div_4,\n    output reg          clk_div_3\n);\n    reg [1:0] clk_div_4_d;\n    reg [1:0] clk_div_3_d;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_4_d <= 0;\n            clk_div_3_d <= 0;\n            clk_div_3 <= 0;\n        end else begin\n            clk_div_4_d <= {clk_div_4_d[0], clk_div_4};\n            clk_div_3_d <= {clk_div_3_d[0], clk_div_3_d[0], clk_div_3_d[0], clk_div_4};\n            clk_div_3 <= clk_div_3_d[1] | clk_div_3_d[2];\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_4,\n    input               clk_div_3\n);\n    output clk_div_3_neg;\n    output clk_div_4_neg;\n\n    assign clk_div_3_neg = ~clk_div_3;\n    assign clk_div_4_neg = ~clk_div_4;\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1;\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end else if (count == DIV_VALUE) begin\n            clk_div <= ~clk_div;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1;\n    reg [3:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n            count <= 0;\n        end else if (count == DIV_VALUE) begin\n            clk_div <= ~clk_div;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 4;\n\n    wire [3:0] cnt;\n    wire clk_div_i;\n\n    // Counter submodule\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .q(cnt)\n    );\n\n    // Clock divider submodule\n    clk_divider u_clk_divider (\n        .clk_in(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_i)\n    );\n\n    assign clk_div = clk_div_i;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 0;\n        end else if (q == NUM_DIV/2 - 1) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk_in,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk_in or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (q == NUM_DIV/2 - 1) begin\n            clk_div <= ~clk_div;\n        end\n    end\n\n    reg [3:0] q;\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, addu_result, sub_result, subu_result, and_result, or_result, xor_result, nor_result;\nwire [31:0] sll_result, srl_result, sra_result;\nwire slt_result, sltu_result;\n\nadder add(.a(a), .b(b), .r(add_result));\nadder addu(.a(a), .b(b), .r(addu_result));\nsubtractor sub(.a(a), .b(b), .r(sub_result));\nsubtractor subu(.a(a), .b(b), .r(subu_result));\nand_gate and1(.a(a), .b(b), .r(and_result));\nor_gate or1(.a(a), .b(b), .r(or_result));\nxor_gate xor1(.a(a), .b(b), .r(xor_result));\nnot_gate nor1(.a(a), .b(b), .r(nor_result));\nslt_module slt_inst(.a(a), .b(b), .r(slt_result));\nsltu_module sltu_inst(.a(a), .b(b), .r(sltu_result));\nsll_module sll(.a(a), .b(b[4:0]), .r(sll_result));\nsrl_module srl(.a(a), .b(b[4:0]), .r(srl_result));\nsra_module sra(.a(a), .b(b[4:0]), .r(sra_result));\nlui lui_inst(.a(a), .b(b[31:12]), .r(r));\n\nassign r = aluc[5] ? addu_result : aluc[4] ? subu_result : aluc[3] ? sll_result : aluc[2] ? srl_result : aluc[1] ? sra_result : aluc[0] ? nor_result : aluc[6] ? sltu_result : aluc[7] ? slt_result : aluc[5] ? xor_result : aluc[4] ? or_result : aluc[3] ? and_result : aluc[2] ? nor_result : aluc[1] ? srl_result : aluc[0] ? slt_result : aluc[6] ? xor_result : aluc[7] ? sltu_result : aluc[5] ? sra_result : aluc[4] ? sll_result : aluc[3] ? add_result : aluc[2] ? sub_result : aluc[1] ? or_result : aluc[0] ? and_result : 32'b0;\nassign zero = r == 32'b0;\nassign carry = aluc[5] ? 1'b0 : aluc[4] ? 1'b0 : aluc[3] ? 1'b0 : aluc[2] ? 1'b0 : aluc[1] ? 1'b0 : aluc[0] ? 1'b0 : aluc[6] ? 1'b0 : aluc[7] ? 1'b0 : aluc[5] ? 1'b0 : aluc[4] ? 1'b0 : aluc[3] ? 1'b0 : aluc[2] ? 1'b0 : aluc[1] ? 1'b0 : aluc[0] ? 1'b0 : aluc[6] ? 1'b0 : aluc[7] ? 1'b0 : aluc[5] ? 1'b0 : aluc[4] ? 1'b0 : aluc[3] ? r[31] : aluc[2] ? r[31] : aluc[1] ? 1'b0 : aluc[0] ? 1'b0 : aluc[6] ? 1'b0 : aluc[7] ? 1'b0 : aluc[5] ? 1'b0 : aluc[4] ? 1'b0 : aluc[3] ? r[31"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Instance of the multiplication module\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .c(multiplication_result)\n);\n\n// Instance of the accumulator module\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .current_value(current_value),\n    .new_value(multiplication_result[31:0]),\n    .result(c)\n);\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] c\n);\nassign c = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output reg [31:0] result\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 0;\n    else\n        result <= result + new_value;\nend\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1)\n    );\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = fetch[0] ? ins1 : ins2;\n    assign ad1 = fetch[0] ? ad11 : ad12;\n    assign ad2 = fetch[1] ? ad21 : ad22;\n\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else if (fetch)\n            ins <= data[7:5];\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\n\ncounter cnt(\n    .clk(clk),\n    .enable(1'b1),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] div_freq = 1'b1 << (8'd32 - freq);\n\nwave_generator wg(\n    .clk(clk),\n    .count(count),\n    .freq(div_freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire [1:0] state;\n    wire [4:0] wave_reg;\n\n    // State control module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    // Waveform generation module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave_reg(wave_reg)\n    );\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b11;\n                2'b11: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_reg <= 5'b00000;\n        else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 5'b00001;\n                2'b01: wave_reg <= wave_reg - 5'b00001;\n                default: wave_reg <= wave_reg;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [2:0] q_temp;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q_temp[0]));\n    my_dff8 u1 (.clk(clk), .d(q_temp[0]), .q(q_temp[1]));\n    my_dff8 u2 (.clk(clk), .d(q_temp[1]), .q(q_temp[2]));\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q_temp[0];\n            2'b10: q = q_temp[1];\n            2'b11: q = q_temp[2];\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule mux4to1_4bit (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = in;\n            2'b01: out = in << 1;\n            2'b10: out = in << 2;\n            2'b11: out = in << 3;\n        endcase\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect the outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage1_out, stage2_out, stage3_out;\nwire [7:0] stage4_out, stage5_out, stage6_out;\n\nmux2X1 ins_17 (in[15:8], in[7:0], ctrl[2], stage1_out);\nmux2X1 ins_16 (stage1_out, in, ctrl[1], stage2_out);\nmux2X1 ins_15 (stage2_out, in, ctrl[0], stage3_out);\n\nmux2X1 ins_14 (in[14:8], in[7:0], ctrl[2], stage4_out);\nmux2X1 ins_13 (stage4_out, in[13:8], ctrl[1], stage5_out);\nmux2X1 ins_12 (stage5_out, in[11:8], ctrl[0], stage6_out);\n\nmux2X1 ins_11 (in[10:8], in[7:0], ctrl[2], stage1_out);\nmux2X1 ins_10 (stage1_out, in[9:8], ctrl[1], stage2_out);\nmux2X1 ins_07 (stage2_out, in[7:8], ctrl[0], stage3_out);\n\nmux2X1 ins_06 (in[6:8], in[7:0], ctrl[2], stage4_out);\nmux2X1 ins_05 (stage4_out, in[5:8], ctrl[1], stage5_out);\nmux2X1 ins_04 (stage5_out, in[3:8], ctrl[0], stage6_out);\n\nmux2X1 ins_03 (in[2:8], in[7:0], ctrl[2], stage1_out);\nmux2X1 ins_02 (stage1_out, in[1:8], ctrl[1], stage2_out);\nmux2X1 ins_01 (stage2_out, in[0:8], ctrl[0], stage3_out);\n\nmux2X1 ins_00 (in[0:8], in[7:0], ctrl[2], stage4_out);\nmux2X1 ins_27 (stage4_out, in[7:0], ctrl[1], stage5_out);\nmux2X1 ins_26 (stage5_out, in[7:0], ctrl[0], stage6_out);\n\nassign out = stage6_out;\n\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out);\ninput [7:0] in0, in1;\ninput sel;\noutput [7:0] out;\nassign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\n  PE pe0 (.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1 (.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 0;\n    else\n      c <= c + (a * b);\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_out;\n\n  stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .instr(instr)\n  );\n\n  stage decode(\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  stage execute(\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .rd(rd),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  stage memory(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .mem_out(alu_out)\n  );\n\n  stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .mem_out(alu_out),\n    .res_reg_file(res_reg_file)\n  );\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] instr\n);\n  reg [4:0] pc;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule stage decode(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      {op, rs2, rs1, rd} = instr;\n    end\n  end\nendmodule\n\nmodule stage execute(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output reg [31:0] alu_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_out <= 0;\n    else begin\n      case(op)\n        6'b000000: alu_out <= rs1 + rs2;\n        6'b000001: alu_out <= rs1 - rs2;\n        default: alu_out <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule stage memory(\n  input clk,\n  input rst,\n  input [31:0] alu_out,\n  output reg [31:0] mem_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      mem_out <= 0;\n    else\n      mem_out <= alu_out;\n  end\nendmodule\n\nmodule stage writeback(\n  input clk,\n  input rst,\n  input [31:0] mem_out,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      res_reg_file <= 0;\n    else\n      res_reg_file"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  PE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0_reg));\n  PE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1_reg));\n  PE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2_reg));\n  PE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3_reg));\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 16'b0;\n      b1_reg <= 16'b0;\n      b2_reg <= 16'b0;\n      c0_reg <= 32'b0;\n      c1_reg <= 32'b0;\n      c2_reg <= 32'b0;\n      c3_reg <= 32'b0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n      c0_reg <= c0_reg + (a0 * b0);\n      c1_reg <= c1_reg + (a1 * b1);\n      c2_reg <= c2_reg + (a2 * b2);\n      c3_reg <= c3_reg + (a3 * b3);\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 32'b0;\n    end else begin\n      c_reg <= c_reg + (a * b);\n    end\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] pc;\n    wire [31:0] fetched_instr, op1, op2, result;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n\n    // Instantiate fetch_stage\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\n\n    // Instantiate execute_stage\n    execute_stage execute(.clk(clk), .fetched_instr(fetched_instr), .reg_file(reg_file), .op1(op1), .op2(op2), .result(result), .rd(rd), .opcode(opcode));\n\n    // Instantiate writeback_stage\n    writeback_stage writeback(.clk(clk), .result(result), .rd(rd), .reg_file(reg_file));\n\n    // Assign the output from the writeback stage\n    assign out_reg_file = reg_file[rd];\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem[0:31],\n    output reg [31:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 32'h0000_0000;\n            fetched_instr <= 32'h0000_0000;\n        end else begin\n            fetched_instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file[0:31],\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    output reg [4:0] rd,\n    output reg [5:0] opcode\n);\n    always @(posedge clk) begin\n        op1 <= reg_file[fetched_instr[19:15]];\n        op2 <= reg_file[fetched_instr[24:20]];\n        rd <= fetched_instr[11:7];\n        opcode <= fetched_instr[31:26];\n        case (opcode)\n            6'b000000: result <= op1 + op2;\n            6'b000010: result <= op1 - op2;\n            default: result <= 32'h0000_0000;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file[0:31]\n);\n    always @(posedge clk) begin\n        reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [3:0] cnt_out;\n    wire [9:0] data_accum;\n    wire add_en;\n    wire add_reset;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_en(add_en),\n        .add_reset(add_reset),\n        .cnt_out(cnt_out)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_en(add_en),\n        .data_in(data_in),\n        .data_accum(data_accum)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_out(cnt_out),\n        .valid_in(valid_in),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               add_en,\n    input               add_reset,\n    output reg  [3:0]   cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 0;\n        end else if (add_reset) begin\n            cnt_out <= 0;\n        end else if (add_en) begin\n            cnt_out <= cnt_out + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               add_en,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_accum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accum <= 0;\n        end else if (add_en) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   cnt_out,\n    input               valid_in,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end else if (valid_in && cnt_out == 3) begin\n            valid_out <= 1;\n            data_out <= data_out + data_in;\n        end else if (cnt_out != 3 && valid_out) begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [2:0] ctrl_out;\n    wire [7:0] remainder;\n    wire [7:0] quotient;\n\n    // Instantiating submodules\n    abs_value abs_dividend_inst(.dividend(dividend), .sign(sign), .abs_out(abs_dividend));\n    neg_value neg_divisor_inst(.divisor(divisor), .sign(sign), .neg_out(neg_divisor));\n    divider_control ctrl_inst(.clk(clk), .rst(rst), .opn_valid(opn_valid), .remainder(remainder), .quotient(quotient), .ctrl_out(ctrl_out));\n    result_management res_mgmt_inst(.clk(clk), .rst(rst), .ctrl_out(ctrl_out), .remainder(remainder), .quotient(quotient), .result(result), .res_valid(res_valid), .res_ready(res_ready));\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire [7:0] dividend,\n    input wire sign,\n    output reg [7:0] abs_out\n);\n    always @(*) begin\n        abs_out = sign ? -dividend : dividend;\n    end\nendmodule\n\n// Submodule for calculating negative value\nmodule neg_value(\n    input wire [7:0] divisor,\n    input wire sign,\n    output reg [7:0] neg_out\n);\n    always @(*) begin\n        neg_out = sign ? divisor : -divisor;\n    end\nendmodule\n\n// Submodule for divider control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [7:0] remainder,\n    output reg [7:0] quotient,\n    output reg [2:0] ctrl_out\n);\n    reg [7:0] shift_reg;\n    reg [2:0] ctrl_reg;\n    reg [2:0] ctrl_reg_next;\n    reg [2:0] counter;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            shift_reg <= 0;\n            quotient <= 0;\n            ctrl_reg <= 0;\n            ctrl_reg_next <= 0;\n            counter <= 0;\n        end else begin\n            if(opn_valid) begin\n                shift_reg <= remainder;\n                ctrl_reg <= ctrl_reg_next;\n                counter <= 0;\n            end else begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                if(shift_reg == 0) begin\n                    ctrl_reg <= ctrl_reg_next;\n                end\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        ctrl_reg_next = ctrl_reg + 1;\n        quotient = shift_reg;\n        case(ctrl_reg)\n            3'd0: begin\n                ctrl_out = 3'd0;\n            end\n            3'd1: begin\n                ctrl_out = 3'd1;\n            end\n            3'd2: begin\n                ctrl_out = 3'd2;\n            end\n            default: begin\n                ctrl_out = 3'd3;\n            end\n        endcase\n    end\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [2:0] ctrl_out,\n    input wire [7:0] remainder,\n    input wire [7:0] quotient,\n    output reg [15:0] result,\n    output reg res_valid,\n    input wire res_ready\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            result <= 0;\n            res_valid <= 0"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] prepared_dividend;\n    wire [15:0] prepared_divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep(\n        .A(A),\n        .B(B),\n        .prep_dividend(prepared_dividend),\n        .prep_divisor(prepared_divisor)\n    );\n\n    div_operation div_op(\n        .prep_dividend(prepared_dividend),\n        .prep_divisor(prepared_divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] prep_dividend,\n    output reg [15:0] prep_divisor\n);\n\n    always @(*) begin\n        prep_dividend = {32'b0, A[31:16]}; // prep 16:0\n        prep_divisor = B;\n    end\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] prep_dividend,\n    input wire [15:0] prep_divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\n    reg [31:0] dividend;\n    reg [31:0] divisor;\n    reg [31:0] quotient_tmp;\n    reg [31:0] remainder_tmp;\n    reg [5:0] count;\n\n    always @(*) begin\n        dividend = prep_dividend;\n        divisor = prep_divisor;\n        count = 0;\n        remainder_tmp = 0;\n        quotient_tmp = 0;\n        remainder = 0;\n        quotient = 0;\n    end\n\n    always @(*) begin\n        if (dividend < divisor) begin\n            remainder_tmp = dividend;\n            quotient_tmp = 0;\n        end else begin\n            remainder_tmp = dividend;\n            quotient_tmp = 1;\n        end\n        for (count = 0; count < 32; count = count + 1) begin\n            remainder_tmp = remainder_tmp - divisor;\n            if (remainder_tmp < 0) begin\n                remainder_tmp = remainder_tmp + divisor;\n                quotient_tmp = quotient_tmp + (1 << count);\n            end\n        end\n        remainder = remainder_tmp;\n        quotient = quotient_tmp;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result, temp_remainder;\n    wire [7:0] temp_divisor;\n    wire [3:0] index;\n\n    // Instantiate control unit\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .result(temp_result),\n        .remainder(temp_remainder)\n    );\n\n    assign result = temp_result;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n    reg [7:0] temp_divisor;\n    reg [3:0] index;\n\n    always @(*) begin\n        // Setup\n        result = 16'b0;\n        remainder = 16'b0;\n        temp_divisor = B;\n        index = 4'b0;\n\n        // Loop\n        while (index < 16) begin\n            if (A[index +: 8] >= temp_divisor) begin\n                result[index +: 8] = A[index +: 8] - temp_divisor;\n                remainder[index +: 8] = A[index +: 8];\n            end else begin\n                result[index +: 8] = A[index +: 8];\n                remainder[index +: 8] = A[index +: 8] - temp_divisor;\n            end\n            temp_divisor = temp_divisor << 1;\n            index = index + 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire carry;\n\n// 2's complement of B\nassign B_comp = ~B + 1;\n\n// Addition of A and B's 2's complement\nadder_8bit adder_inst(\n    .a(A),\n    .b(B_comp),\n    .sum(sum),\n    .carry(carry)\n);\n\n// Determine if borrow was generated\nassign B_out = carry;\n\n// D is the difference of A and B's 2's complement\nassign D = sum;\n\nendmodule\n\n// Full Adder Module\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\nassign {cout, sum} = a + b + cin;\nendmodule\n\n// 8-bit Adder Module\nmodule adder_8bit(a, b, sum, carry);\ninput [7:0] a, b;\noutput [7:0] sum;\noutput carry;\nwire [7:0] cin = 0;\nassign {carry, sum} = a + b + cin;\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire b1, b2;\n\n    // Instantiate the two 16-bit subtractors\n    sub_16bit S1_inst(.A(A[15:0]), .B(B[15:0]), .Diff(S1), .B_out(b1));\n    sub_16bit S2_inst(.A(A[31:16]), .B(B[31:16]), .Diff(S2), .B_out(b2));\n\n    // Generate the difference\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n\n    // Borrow-out\n    assign B_out = b1 & b2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] C;\n    wire c_out;\n\n    // Generate the carry and difference\n    assign C = A ^ B;\n    assign Diff = A - B;\n    assign c_out = ~(A[0] | (B[0] & C[15]));\n\n    // Borrow-out\n    assign B_out = c_out;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] B_not;\n    wire [63:0] D_sub1;\n    wire [63:0] D_sub2;\n    wire B_out1;\n    wire B_out2;\n\n    assign B_not = ~B;\n    assign {B_out1, D_sub1} = sub16bit(A, B_not);\n    assign {B_out2, D_sub2} = sub16bit(D_sub1, B_not);\n\n    assign {B_out, D} = sub16bit(D_sub2, B_not);\nendmodule\n\nmodule sub16bit(A, B_not, B_out1, B_out2, D);\n    input [63:0] A;\n    input [63:0] B_not;\n    input B_out1;\n    input B_out2;\n    output [63:0] D;\n    wire [63:0] D_sub1;\n    wire [63:0] D_sub2;\n    wire B_out3;\n    wire B_out4;\n\n    assign {B_out3, D_sub1} = sub8bit(A[63:48], B_not[63:48], B_out1, 1'b0);\n    assign {B_out4, D_sub2} = sub8bit(D_sub1[63:48], B_not[63:48], B_out2, 1'b0);\n\n    assign {B_out2, D} = sub8bit(D_sub2[63:48], B_not[63:48], B_out3, 1'b0);\nendmodule\n\nmodule sub8bit(A, B_not, B_out, borrow);\n    input [7:0] A;\n    input [7:0] B_not;\n    input B_out;\n    input borrow;\n    output [7:0] D;\n    output B_out2;\n\n    wire [7:0] D_sub;\n    wire B_out3;\n\n    assign {B_out3, D_sub} = sub4bit(A[7:4], B_not[7:4], B_out, borrow);\n    assign {B_out2, D} = sub4bit(D_sub[7:4], B_not[7:4], B_out3, borrow);\nendmodule\n\nmodule sub4bit(A, B_not, B_out, borrow);\n    input [3:0] A;\n    input [3:0] B_not;\n    input B_out;\n    input borrow;\n    output [3:0] D;\n    output B_out2;\n\n    wire [3:0] D_sub;\n    wire B_out3;\n\n    assign {B_out3, D_sub} = sub2bit(A[3:2], B_not[3:2], B_out, borrow);\n    assign {B_out2, D} = sub2bit(D_sub[3:2], B_not[3:2], B_out3, borrow);\nendmodule\n\nmodule sub2bit(A, B_not, B_out, borrow);\n    input [1:0] A;\n    input [1:0] B_not;\n    input B_out;\n    input borrow;\n    output [1:0] D;\n    output B_out2;\n\n    wire [1:0] D_sub;\n    wire B_out3;\n\n    assign {B_out3, D_sub} = sub1bit(A[1:0], B_not[1:0], B_out, borrow);\n    assign {B_out2, D} = sub1bit(D_sub[1:0], B_not[1:0], B_out3, borrow);\nendmodule\n\nmodule sub1bit(A, B_not, B_out, borrow);\n    input [0:0] A;\n    input [0:0] B_"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] borrow;\n\nsub1 sub1(\n    .A(A[1:0]),\n    .B(B[1:0]),\n    .B_out(borrow[1])\n);\nsub2 sub2(\n    .A(A[3:2]),\n    .B(B[3:2]),\n    .B_in(borrow[1]),\n    .B_out(borrow[2])\n);\nsub3 sub3(\n    .A(A[5:4]),\n    .B(B[5:4]),\n    .B_in(borrow[2]),\n    .B_out(borrow[3])\n);\nsub4 sub4(\n    .A(A[7:6]),\n    .B(B[7:6]),\n    .B_in(borrow[3]),\n    .B_out(B_out)\n);\nassign D = A - B;\n\nendmodule\n\nmodule sub1(A, B, B_out);\ninput [1:0] A, B;\noutput B_out;\n\nwire c;\n\nfull_subtractor fs0(\n    .A(A),\n    .B(B),\n    .B_in(1'b0),\n    .B_out(B_out),\n    .C_out(c)\n);\n\nendmodule\n\nmodule sub2(A, B, B_in, B_out);\ninput [1:0] A, B;\ninput B_in;\noutput B_out;\n\nwire c;\n\nfull_subtractor fs1(\n    .A(A),\n    .B(B),\n    .B_in(B_in),\n    .B_out(B_out),\n    .C_out(c)\n);\n\nendmodule\n\nmodule sub3(A, B, B_in, B_out);\ninput [1:0] A, B;\ninput B_in;\noutput B_out;\n\nwire c;\n\nfull_subtractor fs2(\n    .A(A),\n    .B(B),\n    .B_in(B_in),\n    .B_out(B_out),\n    .C_out(c)\n);\n\nendmodule\n\nmodule sub4(A, B, B_in, B_out);\ninput [1:0] A, B;\ninput B_in;\noutput B_out;\n\nwire c;\n\nfull_subtractor fs3(\n    .A(A),\n    .B(B),\n    .B_in(B_in),\n    .B_out(B_out),\n    .C_out(c)\n);\n\nendmodule\n\nmodule full_subtractor(A, B, B_in, B_out, C_out);\ninput [1:0] A, B;\ninput B_in;\noutput B_out;\noutput C_out;\n\nassign B_out = B_in ^ (A ^ B);\nassign C_out = B_in & (A ^ B);\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .D(diff),\n        .Borrow_out(borrow)\n    );\n\n    assign A_greater = (diff != 0);\n    assign A_less = borrow;\n    assign A_equal = ~(A_greater | A_less);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] D,\n    output Borrow_out\n);\n    wire [31:0] borrow_wires;\n    wire [31:0] d_wires;\n\n    // Borrow wire generation\n    assign borrow_wires[0] = 1'b0;\n    generate\n        genvar i;\n        for (i = 1; i < 32; i = i + 1) begin : borrow_gen\n            assign borrow_wires[i] = ((A[i] ^ B[i]) & (A[i] ^ borrow_wires[i-1]));\n        end\n    endgenerate\n\n    // D output generation\n    assign d_wires[0] = A[0] ^ B[0];\n    generate\n        genvar j;\n        for (j = 1; j < 32; j = j + 1) begin : d_gen\n            assign d_wires[j] = (A[j] ^ B[j]) ^ borrow_wires[j-1];\n        end\n    endgenerate\n\n    assign D = d_wires;\n    assign Borrow_out = borrow_wires[31];\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] carry;\n\nCLA1 CLA1(.A(A[15:1]), .B(B[15:1]), .Cin(1'b0), .S(S[15:1]), .Cout(carry[1]));\nCLA2 CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(carry[1]), .S(S[31:16]), .Cout(carry[2]));\n\nassign C32 = carry[2];\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\n\nwire [14:0] g, p, c;\n\nassign g = A & B;\nassign p = A ^ B;\nassign c[0] = Cin;\nassign c[15:1] = p | (g << 1);\n\nassign S = p ^ (c << 1);\nassign Cout = g[15];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\ninput [31:1] A,B;\ninput Cin;\noutput [31:1] S;\noutput Cout;\n\nwire [15:1] carry;\n\nCLA1 CLA1(.A(A[15:1]), .B(B[15:1]), .Cin(1'b0), .S(S[15:1]), .Cout(carry[1]));\nCLA1 CLA2(.A(A[31:16]), .B(B[31:16]), .Cin(carry[1]), .S(S[31:16]), .Cout(carry[2]));\n\nassign Cout = carry[2];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] sum_0, sum_1, sum_2;\n    wire cout_0, cout_1;\n    ripple_carry_adder_4 rca0(.a(a), .b(b), .cin(cin), .sum(sum_0), .cout(cout_0));\n    ripple_carry_adder_4 rca1(.a(a), .b(b), .cin(cout_0), .sum(sum_1), .cout(cout_1));\n    ripple_carry_adder_4 rca2(.a(a), .b(b), .cin(cout_1), .sum(sum_2), .cout(cout));\n    assign sum = sum_0 ^ sum_1 ^ sum_2;\nendmodule\n\nmodule ripple_carry_adder_4(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] sum_0, sum_1;\n    wire [2:0] cout_0, cout_1;\n    ripple_carry_adder_2 rca0(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_0), .cout(cout_0[0]));\n    ripple_carry_adder_2 rca1(.a(a[3:2]), .b(b[3:2]), .cin(cout_0[0]), .sum(sum_1), .cout(cout_0[1]));\n    ripple_carry_adder_2 rca2(.a(a[3:2]), .b(b[3:2]), .cin(cout_0[1]), .sum(sum_1), .cout(cout_0[2]));\n    assign sum = sum_0 + sum_1;\n    assign cout = {cout_0, cout_1};\nendmodule\n\nmodule ripple_carry_adder_2(a, b, cin, sum, cout);\n    input [1:0] a, b;\n    input cin;\n    output [1:0] sum;\n    output cout;\n    wire [1:0] sum_0, sum_1;\n    wire cout_0, cout_1;\n    ripple_carry_adder_1 rca0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum_0), .cout(cout_0));\n    ripple_carry_adder_1 rca1(.a(a[1]), .b(b[1]), .cin(cout_0), .sum(sum_1), .cout(cout_1));\n    assign sum = sum_0 + sum_1;\n    assign cout = cout_1;\nendmodule\n\nmodule ripple_carry_adder_1(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] sum_0, sum_1, sum_2, sum_3;\n    wire [3:0] cout_0, cout_1, cout_2, cout_3;\n    carry_select_adder_slice csa_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_0), .cout(cout_0));\n    carry_select_adder_slice csa_slice2(.a(a[7:4]), .b(b[7:4]), .cin(cout_0), .sum(sum_1), .cout(cout_1));\n    carry_select_adder_slice csa_slice3(.a(a[11:8]), .b(b"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n    wire [1:0] carry2;\n\n    // First 8-bit adder\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    // Second 8-bit adder\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    // Carry logic\n    assign Co = carry[1];\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [6:0] carry;\n    wire [1:0] carry2;\n\n    // First 4-bit adder\n    adder_4bit add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(carry[0])\n    );\n\n    // Second 4-bit adder\n    adder_4bit add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(carry[0]),\n        .y(y[7:4]),\n        .Co(carry[1])\n    );\n\n    // Third 4-bit adder\n    adder_4bit add4_inst3 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .Cin(carry[1]),\n        .y(y[11:8]),\n        .Co(carry[2])\n    );\n\n    // Fourth 4-bit adder\n    adder_4bit add4_inst4 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .Cin(carry[2]),\n        .y(y[15:12]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [2:0] carry;\n\n    // First 2-bit adder\n    adder_2bit add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(carry[0])\n    );\n\n    // Second 2-bit adder\n    adder_2bit add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(carry[0]),\n        .y(y[3:2]),\n        .Co(carry[1])\n    );\n\n    // Third 2-bit adder\n    adder_2bit add2_inst3 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(carry[0]),\n        .y(y[3:2]),\n        .Co(carry[1])\n    );\n\n    // Fourth 2-bit adder\n    adder_2bit add2_inst4 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(carry[0]),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n   "}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [0:0] carry;\n\n    FA FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Intermediate signals\nreg [31:0] product;\nreg [3:0] count;\n\n// Control unit\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .count_out(count)\n);\n\n// Register unit\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ain(ain),\n    .bin(bin),\n    .count(count),\n    .product(product)\n);\n\n// Multiplier unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .count(count),\n    .bin(bin),\n    .product(product)\n);\n\n// Output assignment\nassign yout = product;\nassign done = start & ~|count;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0;\n        end else if (start) begin\n            count_out <= 4'b0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [3:0] count,\n    output reg [31:0] product\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'b0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end else if (count[3]) begin\n            product <= {product[31:16], bin};\n        end\n    end\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [3:0] count,\n    input [15:0] bin,\n    inout [31:0] product\n);\n\n    always @(posedge clk) begin\n        if (count[3]) begin\n            product <= product + ({product[31:0], 16'b0} << 16) + bin;\n        end\n    end\n\nendmodule"}
