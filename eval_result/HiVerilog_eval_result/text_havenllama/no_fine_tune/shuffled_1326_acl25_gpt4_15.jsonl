{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n/*\n    Function:\n        A 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\n    Input ports:\n        - clk: Clock signal (1-bit), used to synchronize the counting process.\n        - reset: Reset signal (1-bit), used to reset the counter to zero.\n        - up_down: Control signal (1-bit), determines the counting direction.\n            If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\n    Output ports:\n        - count [15:0]: 16-bit output representing the current counter value.\n*/\n\nwire [15:0] u_counter_logic;\nwire [15:0] u_counter_register;\n\nu_counter_logic u_counter_logic_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(u_counter_logic)\n);\n\nu_counter_register u_counter_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(u_counter_register)\n);\n\nassign count = u_counter_register;\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n/*\n    Function:\n        Calculate the next count value based on the current count and control signals.\n\n    Input ports:\n        - clk: Clock signal (1-bit), used to synchronize the counting process.\n        - reset: Reset signal (1-bit), used to reset the counter to zero.\n        - up_down: Control signal (1-bit), determines the counting direction.\n            If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\n    Output ports:\n        - count [15:0]: 16-bit output representing the current counter value.\n*/\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0000000000000000;\n    end else if (up_down) begin\n        count <= count + 1'b1;\n    end else begin\n        count <= count - 1'b1;\n    end\nend\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n/*\n    Function:\n        Update the current count value on the rising edge of the clock signal or reset it based on the reset condition.\n\n    Input ports:\n        - clk: Clock signal (1-bit), used to synchronize the counting process.\n        - reset: Reset signal (1-bit), used to reset the counter to zero.\n        - up_down: Control signal (1-bit), determines the counting direction.\n            If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\n    Output ports:\n        - count [15:0]: 16-bit output representing the current counter value.\n*/\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0000000000000000;\n    end else begin\n        count <= count;\n    end\nend\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    reg [7:0] out_reg = 8'b0000_0001;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n        end else begin\n            out_reg <= {out_reg[6:0], out_reg[7]};\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule ring_counter_init_submodule (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    reg [7:0] out_reg = 8'b0000_0001;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule ring_counter_transition_submodule (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init,\n    output wire [7:0] out\n);\n\n    reg [7:0] out_reg = 8'b0000_0001;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n        end else begin\n            out_reg <= {out_reg[6:0], out_reg[7]};\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\nwire [3:0] next_count;\n\nreg [3:0] out_reg;\nreg [3:0] count_reg;\n\nassign out = out_reg;\nassign count = count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out_reg <= 4'b0000;\n        count_reg <= 4'b0000;\n    end\n    else if (valid_count) begin\n        out_reg <= next_count;\n        count_reg <= next_count;\n    end\nend\n\nassign next_count = (count == 4'd11) ? 4'b0000 : count + 1;\n\nendmodule\n\nmodule\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_reg;\n\nassign count = count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_reg <= 4'b0000;\n    end\n    else if (valid_count) begin\n        count_reg <= (count_reg == 4'd11) ? 4'b0000 : count_reg + 1;\n    end\nend\n\nendmodule\n\nmodule\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end\n    else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n//Register submodule\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) Q <= 64'd0;\n        else Q <= Q + 1;\n    end\nendmodule\n\n//Logic submodule\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n    always @(*) begin\n        Q_next = Q;\n        Q_next[0] = Q[63];\n    end\nendmodule\n\nJC_register jc_register(.clk(clk), .rst_n(rst_n), .Q(Q));\nJC_logic jc_logic(.Q(Q), .Q_next(Q));\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg clk_50_div_2 = 0;\n    reg clk_10_div_10 = 0;\n    reg clk_1_div_100 = 0;\n\n    reg [2:0] count_50 = 0;\n    reg [2:0] count_10 = 0;\n    reg [2:0] count_1 = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_50_div_2 <= 0;\n            clk_10_div_10 <= 0;\n            clk_1_div_100 <= 0;\n            count_50 <= 0;\n            count_10 <= 0;\n            count_1 <= 0;\n        end else begin\n            clk_50_div_2 <= ~clk_50_div_2;\n            clk_10_div_10 <= ~clk_10_div_10;\n            clk_1_div_100 <= ~clk_1_div_100;\n\n            if (clk_50_div_2) begin\n                count_50 <= count_50 + 1;\n                if (count_50 == 2) begin\n                    count_50 <= 0;\n                end\n            end\n\n            if (clk_10_div_10) begin\n                count_10 <= count_10 + 1;\n                if (count_10 == 4) begin\n                    count_10 <= 0;\n                end\n            end\n\n            if (clk_1_div_100) begin\n                count_1 <= count_1 + 1;\n                if (count_1 == 49) begin\n                    count_1 <= 0;\n                end\n            end\n        end\n    end\n\n    assign CLK_50 = clk_50_div_2;\n    assign CLK_10 = clk_10_div_10;\n    assign CLK_1 = clk_1_div_100;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [2:0] count = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            if (count == 2) begin\n                count <= 0;\n            end\n        end\n    end\n\n    assign CLK = (count == 1);\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [2:0] count = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            if (count == 4) begin\n                count <= 0;\n            end\n        end\n    end\n\n    assign CLK = (count == 3);\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [2:0] count = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            if (count == 49) begin\n                count <= 0;\n            end\n        end\n    end\n\n    assign CLK = (count == 48);\n\nendmodule\n\n'''\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\n// Counter submodule\nreg [4:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 5'd0;\n    end else if (counter < MUL2_DIV_CLK) begin\n        counter <= counter + 5'd1;\n    end\nend\n\n// Clock average generator submodule\nreg clk_average_1, clk_average_2;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average_1 <= 1'b0;\n        clk_average_2 <= 1'b0;\n    end else begin\n        clk_average_1 <= (counter == 5'd4);\n        clk_average_2 <= (counter == 5'd3);\n    end\nend\n\n// Clock adjustment submodule\nreg clk_adjustment_1, clk_adjustment_2;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment_1 <= 1'b0;\n        clk_adjustment_2 <= 1'b0;\n    end else begin\n        clk_adjustment_1 <= clk_average_1;\n        clk_adjustment_2 <= clk_average_2;\n    end\nend\n\n// Clock divider submodule\nreg clk_div_1, clk_div_2;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_1 <= 1'b0;\n        clk_div_2 <= 1'b0;\n    end else begin\n        clk_div_1 <= clk_adjustment_1 | clk_adjustment_2;\n        clk_div_2 <= clk_div_1;\n    end\nend\n\nassign clk_div = clk_div_1 | clk_div_2;\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    \n    reg [3:0] pos_edge_counter = 0;\n    reg [3:0] neg_edge_counter = 0;\n    reg clk_div1 = 0;\n    reg clk_div2 = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pos_edge_counter <= 0;\n            neg_edge_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else begin\n            if (pos_edge_counter == NUM_DIV - 1) begin\n                pos_edge_counter <= 0;\n                clk_div1 <= ~clk_div1;\n            end else begin\n                pos_edge_counter <= pos_edge_counter + 1;\n            end\n            \n            if (neg_edge_counter == NUM_DIV - 1) begin\n                neg_edge_counter <= 0;\n                clk_div2 <= ~clk_div2;\n            end else begin\n                neg_edge_counter <= neg_edge_counter + 1;\n            end\n        end\n    end\n    \n    assign clk_div = clk_div1 | clk_div2;\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n`define NUM_DIV 8\n\nwire [3:0] counter_out;\n\n// Counter submodule\nreg [3:0] counter_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_reg <= 0;\n    end else begin\n        counter_reg <= counter_reg + 1;\n    end\nend\nassign counter_out = counter_reg;\n\n// Clock divider submodule\nreg clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_reg <= 0;\n    end else if (counter_out == (``NUM_DIV/2 - 1)) begin\n        clk_div_reg <= ~clk_div_reg;\n    end\nend\nassign clk_div = clk_div_reg;\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] _add_r, _sub_r;\n    wire _add_zero, _sub_zero, _add_carry, _sub_carry;\n    wire _add_negative, _sub_negative, _add_overflow, _sub_overflow;\n    wire _add_flag, _sub_flag;\n\n    assign r = _add_r | _sub_r;\n    assign zero = _add_zero | _sub_zero;\n    assign carry = _add_carry | _sub_carry;\n    assign negative = _add_negative | _sub_negative;\n    assign overflow = _add_overflow | _sub_overflow;\n    assign flag = _add_flag | _sub_flag;\n\n    add add_submodule (\n        .a(a),\n        .b(b),\n        .r(_add_r),\n        .zero(_add_zero),\n        .carry(_add_carry),\n        .negative(_add_negative),\n        .overflow(_add_overflow),\n        .flag(_add_flag)\n    );\n\n    sub sub_submodule (\n        .a(a),\n        .b(b),\n        .r(_sub_r),\n        .zero(_sub_zero),\n        .carry(_sub_carry),\n        .negative(_sub_negative),\n        .overflow(_sub_overflow),\n        .flag(_sub_flag)\n    );\n\n    assign _add_r = a + b;\n    assign _sub_r = a - b;\n\n    assign _add_zero = (a + b) == 32'b0;\n    assign _sub_zero = (a - b) == 32'b0;\n    assign _add_carry = (a + b) > 32'b0;\n    assign _sub_carry = (a - b) < 32'b0;\n\n    assign _add_negative = _add_r[31];\n    assign _sub_negative = _sub_r[31];\n    assign _add_overflow = (a[31] == b[31]) && (_add_r[31] != a[31]);\n    assign _sub_overflow = (a[31] != b[31]) && (_sub_r[31] != a[31]);\n\n    assign _add_flag = (aluc == 6'b101010) ? _add_r[31] : 1'b0;\n    assign _sub_flag = (aluc == 6'b101011) ? _sub_r[31] : 1'b0;\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign r = a + b;\n    assign zero = r == 32'b0;\n    assign carry = r > 32'b0;\n    assign negative = r[31];\n    assign overflow = (a[31] == b[31]) && (r[31] != a[31]);\n    assign flag = r[31];\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign r = a - b;\n    assign zero = r == 32'b0;\n    assign carry = r < 32'b0;\n    assign negative = r[31];\n    assign overflow = (a[31] != b[31]) && (r[31] != a[31]);\n    assign flag = r[31];\nendmodule\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] m;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nreg [63:0] mult_result;\nalways @(posedge clk or posedge rst)\n    if (rst)\n        mult_result <= 0;\n    else\n        mult_result <= a * b;\n\nassign m = mult_result;\n\n// Accumulator Submodule\nalways @(posedge clk or posedge rst)\n    if (rst)\n        current_value <= 0;\n    else\n        current_value <= current_value + m[31:0];\n\nassign c = current_value;\n\nendmodule\n\nmodule u_multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] m\n);\n\nassign m = a * b;\n\nendmodule\n\nmodule u_accumulator(\n    input [31:0] a,\n    input [31:0] b,\n    input clk,\n    input rst,\n    output [31:0] current_value\n);\n\nreg [31:0] current_value_reg;\n\nalways @(posedge clk or posedge rst)\n    if (rst)\n        current_value_reg <= 0;\n    else\n        current_value_reg <= current_value_reg + a * b;\n\nassign current_value = current_value_reg;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    reg [2:0] ins_p1;\n    reg [4:0] ad1_p1;\n    reg [7:0] ad2_p1;\n    reg [2:0] ins_p2;\n    reg [4:0] ad1_p2;\n    reg [7:0] ad2_p2;\n\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            ins_p1 <= 3'b000;\n            ad1_p1 <= 5'b00000;\n            ad2_p1 <= 8'b00000000;\n            ins_p2 <= 3'b000;\n            ad1_p2 <= 5'b00000;\n            ad2_p2 <= 8'b00000000;\n        end else begin\n            case (fetch)\n                2'b01: begin\n                    ins_p1 <= data[7:5];\n                    ad1_p1 <= data[4:0];\n                    ad2_p1 <= data;\n                end\n                2'b10: begin\n                    ins_p2 <= data[7:5];\n                    ad1_p2 <= data[4:0];\n                    ad2_p2 <= data;\n                end\n                default: begin\n                    ins_p1 <= ins_p1;\n                    ad1_p1 <= ad1_p1;\n                    ad2_p1 <= ad2_p1;\n                    ins_p2 <= ins_p2;\n                    ad1_p2 <= ad1_p2;\n                    ad2_p2 <= ad2_p2;\n                end\n            endcase\n        end\n    end\n\n    assign ins = {ins_p2, ins_p1};\n    assign ad1 = {ad1_p2, ad1_p1};\n    assign ad2 = ad2_p2;\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_p;\n    reg [4:0] ad1_p;\n    reg [7:0] ad2_p;\n\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            ins_p <= 3'b000;\n            ad1_p <= 5'b00000;\n            ad2_p <= 8'b00000000;\n        end else begin\n            ins_p <= data[7:5];\n            ad1_p <= data[4:0];\n            ad2_p <= data;\n        end\n    end\n\n    assign ins = ins_p;\n    assign ad1 = ad1_p;\n    assign ad2 = ad2_p;\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_p;\n    reg [4:0] ad1_p;\n    reg [7:0] ad2_p;\n\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            ins_p <= 3'b000;\n            ad1_p <= 5'b00000;\n            ad2_p <= 8'b00000000;\n        end else begin\n            ins_p <= data[7:5];\n            ad1_p <= data[4:0];\n            ad2_p <= data;\n        end\n    end\n\n    assign ins = ins_p;\n    assign ad1 = ad1_p;\n    assign ad2 = ad2_p;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable;\nreg [7:0] count;\nwire [7:0] next_count;\nwire [7:0] freq_next;\n\nassign enable = (freq > 0) ? 1 : 0;\nassign next_count = enable ? (count + 1) : count;\nassign freq_next = enable ? freq : 0;\n\nalways @(posedge clk) begin\n    count <= next_count;\nend\n\nassign wave_out = enable ? (count == freq_next - 1) : 0;\n\nendmodule\n\n```\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00001) begin\n                        state <= 2'b01;\n                        wave_reg <= 5'b00000;\n                    end else begin\n                        wave_reg <= wave_reg + 1;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                        wave_reg <= 5'b00001;\n                    end else begin\n                        wave_reg <= wave_reg - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n    integer i;\n\n    always @(posedge clk) begin\n        // Shift register\n        for (i = 2; i > 0; i = i - 1) begin\n            shift_reg[i] <= shift_reg[i-1];\n        end\n        shift_reg[0] <= d;\n\n        // Multiplexer\n        case (sel)\n            2'b00: q <= shift_reg[0];\n            2'b01: q <= shift_reg[1];\n            2'b10: q <= shift_reg[2];\n            2'b11: q <= d;\n            default: q <= 8'b0; // Prevent latches\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff my_dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff my_dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff my_dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n    // Stage 1\n    assign stage1 = {in[3:0], in[7:4]};\n    assign stage2 = {stage1[1:0], stage1[7:2]};\n    assign stage3 = {stage2[3:0], stage2[7:4]};\n    assign stage4 = {stage3[1:0], stage3[7:2]};\n    assign stage5 = {stage4[3:0], stage4[7:4]};\n    assign stage6 = {stage5[1:0], stage5[7:2]};\n    assign stage7 = {stage6[3:0], stage6[7:4]};\n    assign stage8 = {stage7[1:0], stage7[7:2]};\n\n    // Stage 2\n    assign stage1 = (ctrl[2] == 1) ? stage2 : stage1;\n    assign stage2 = (ctrl[2] == 1) ? stage3 : stage2;\n    assign stage3 = (ctrl[2] == 1) ? stage4 : stage3;\n    assign stage4 = (ctrl[2] == 1) ? stage5 : stage4;\n    assign stage5 = (ctrl[2] == 1) ? stage6 : stage5;\n    assign stage6 = (ctrl[2] == 1) ? stage7 : stage6;\n    assign stage7 = (ctrl[2] == 1) ? stage8 : stage7;\n\n    // Stage 3\n    assign stage1 = (ctrl[1] == 1) ? stage2 : stage1;\n    assign stage2 = (ctrl[1] == 1) ? stage3 : stage2;\n    assign stage3 = (ctrl[1] == 1) ? stage4 : stage3;\n    assign stage4 = (ctrl[1] == 1) ? stage5 : stage4;\n    assign stage5 = (ctrl[1] == 1) ? stage6 : stage5;\n    assign stage6 = (ctrl[1] == 1) ? stage7 : stage6;\n    assign stage7 = (ctrl[1] == 1) ? stage8 : stage7;\n\n    // Stage 4\n    assign stage1 = (ctrl[0] == 1) ? stage2 : stage1;\n    assign stage2 = (ctrl[0] == 1) ? stage3 : stage2;\n    assign stage3 = (ctrl[0] == 1) ? stage4 : stage3;\n    assign stage4 = (ctrl[0] == 1) ? stage5 : stage4;\n    assign stage5 = (ctrl[0] == 1) ? stage6 : stage5;\n    assign stage6 = (ctrl[0] == 1) ? stage7 : stage6;\n    assign stage7 = (ctrl[0] == 1) ? stage8 : stage7;\n\n    assign out = stage1;\n\nendmodule\n\nmodule mux2X1 (out, sel, in1, in2);\n    input sel;\n    input [7:0] in1;\n    input [7:0] in2;\n    output [7:0] out;\n\n    assign out = (sel == 1) ? in1 : in2;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  reg [15:0] b1;\n\n  // PE0\n  reg [31:0] pe0_out;\n  always @(posedge clk) begin\n    if (rst) begin\n      pe0_out <= 32'd0;\n    end else begin\n      pe0_out <= {16'd0, a0} * b0;\n    end\n  end\n\n  // PE1\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'd0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pe0_out <= 32'd0;\n    end else begin\n      pe0_out <= {16'd0, a1} * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe0_out;\n\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch;\n  wire [31:0] decode;\n  wire [31:0] execute;\n  wire [31:0] memory;\n  wire [31:0] writeback;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n\n  assign res_reg_file = writeback;\n  assign pc = 0;\n  assign next_pc = pc + 1;\n\n  stagepipe5_submodule fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetch(fetch)\n  );\n\n  stagepipe5_submodule decode_stage (\n    .fetch(fetch),\n    .decode(decode)\n  );\n\n  stagepipe5_submodule execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .execute(execute)\n  );\n\n  stagepipe5_submodule memory_stage (\n    .execute(execute),\n    .memory(memory)\n  );\n\n  stagepipe5_submodule writeback_stage (\n    .execute(execute),\n    .reg_file(res_reg_file)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= next_pc;\n  end\nendmodule\n\nmodule stagepipe5_submodule (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [31:0] pc,\n  output [31:0] fetch,\n  output [31:0] decode,\n  output [31:0] execute,\n  output [31:0] memory\n);\n  reg [31:0] pipeline_reg [0:4];\n\n  assign fetch = pipeline_reg[0];\n  assign decode = pipeline_reg[1];\n  assign execute = pipeline_reg[2];\n  assign memory = pipeline_reg[3];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n    end else begin\n      pipeline_reg[0] <= instr_mem[pc];\n      pipeline_reg[1] <= decode;\n      pipeline_reg[2] <= execute;\n      pipeline_reg[3] <= memory;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\nreg [15:0] b0_reg;\nreg [15:0] b1_reg;\nreg [15:0] b2_reg;\n\nalways @(posedge clk) begin\n  if(rst) begin\n    b0_reg <= 0;\n    b1_reg <= 0;\n    b2_reg <= 0;\n  end else begin\n    b0_reg <= b0;\n    b1_reg <= b0_reg;\n    b2_reg <= b1_reg;\n  end\nend\n\nreg [15:0] a0_reg;\nreg [15:0] a1_reg;\nreg [15:0] a2_reg;\nreg [15:0] a3_reg;\n\nalways @(posedge clk) begin\n  if(rst) begin\n    a0_reg <= 0;\n    a1_reg <= 0;\n    a2_reg <= 0;\n    a3_reg <= 0;\n  end else begin\n    a0_reg <= a0;\n    a1_reg <= a1;\n    a2_reg <= a2;\n    a3_reg <= a3;\n  end\nend\n\nreg [31:0] pe0_out;\nreg [31:0] pe1_out;\nreg [31:0] pe2_out;\nreg [31:0] pe3_out;\n\nalways @(posedge clk) begin\n  if(rst) begin\n    pe0_out <= 0;\n    pe1_out <= 0;\n    pe2_out <= 0;\n    pe3_out <= 0;\n  end else begin\n    pe0_out <= a0_reg * b0_reg;\n    pe1_out <= a1_reg * b1_reg;\n    pe2_out <= a2_reg * b2_reg;\n    pe3_out <= a3_reg * b2_reg;\n  end\nend\n\nassign c0 = pe0_out;\nassign c1 = pe1_out;\nassign c2 = pe2_out;\nassign c3 = pe3_out;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] instr;\n    wire [31:0] rs, rt;\n    wire [4:0] rd;\n    wire [5:0] op;\n    wire [31:0] out_execute;\n\n    wire [31:0] pc = 32'd0;\n\n    // Fetch Stage\n    wire [31:0] fetch;\n    assign out_reg_file = fetch;\n    assign fetch = instr_mem[pc];\n    assign pc = pc + 32'd1;\n\n    // Execute Stage\n    assign {op, rd, rs, rt} = fetch;\n    assign out_execute = (op == 6'b000000) ? (rs + rt) : (rs - rt);\n\n    // Writeback Stage\n    assign reg_file[rd] = out_execute;\n\nendmodule\n\n```\n\n## 2. \u7efc\u5408\n\n```verilog\n`timescale 1ns / 1ps\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    wire [31:0] instr;\n    wire [31:0] rs, rt;\n    wire [4:0] rd;\n    wire [5:0] op;\n    wire [31:0] out_execute;\n\n    wire [31:0] pc = 32'd0;\n\n    // Fetch Stage\n    wire [31:0] fetch;\n    assign out_reg_file = fetch;\n    assign fetch = instr_mem[pc];\n    assign pc = pc + 32'd1;\n\n    // Execute Stage\n    assign {op, rd, rs, rt} = fetch;\n    assign out_execute = (op == 6'b000000) ? (rs + rt) : (rs - rt);\n\n    // Writeback Stage\n    assign reg_file[rd] = out_execute;\n\nendmodule\n\n```\n\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nparameter           DATA_WIDTH = 8;\nparameter           COUNTER_WIDTH = 4;\n\n\n\n\n\n\n\n\nreg           [DATA_WIDTH-1:0]   accum_data;\nreg           [COUNTER_WIDTH-1:0] counter;\nwire          [COUNTER_WIDTH-1:0] next_counter;\nwire          [DATA_WIDTH-1:0]   next_accum_data;\n\nassign next_counter = (counter == COUNTER_WIDTH - 1) ? 0 : counter + 1;\nassign next_accum_data = accum_data + data_in;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        accum_data <= 0;\n        counter <= 0;\n    end\n    else begin\n        accum_data <= next_accum_data;\n        counter <= next_counter;\n    end\nend\n\nassign valid_out = (counter == COUNTER_WIDTH - 1) ? 1'b1 : 1'b0;\nassign data_out = accum_data;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg          count_out,\n    output reg          next_counter\n);\n\nparameter           COUNTER_WIDTH = 4;\n\n\n\n\n\n\n\n\nreg   [COUNTER_WIDTH-1:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        count_out <= 0;\n        next_counter <= 0;\n    end\n    else begin\n        if (counter == COUNTER_WIDTH - 1) begin\n            counter <= 0;\n            count_out <= 1;\n            next_counter <= 0;\n        end\n        else if (valid_in) begin\n            counter <= counter + 1;\n            count_out <= 0;\n            next_counter <= counter + 1;\n        end\n        else begin\n            counter <= counter;\n            count_out <= 0;\n            next_counter <= counter;\n        end\n    end\nend\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output reg          valid_out,\n    output reg  [7:0]   accum_data\n);\n\nparameter           DATA_WIDTH = 8;\n\n\n\n\n\n\n\n\nreg           [DATA_WIDTH-1:0]   next_accum_data;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        accum_data <= 0;\n        valid_out <= 0;\n    end\n    else begin\n        if (valid_in) begin\n            next_accum_data <= accum_data + data_in;\n            valid_out <= 1;\n        end\n        else begin\n            next_accum_data <= accum_data;\n            valid_out <= 0;\n        end\n        accum_data <= next_accum_data;\n    end\nend\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               count_in,\n\n    output              valid_out\n);\n\nparameter           COUNTER_WIDTH = 4;\n\n\n\n\n\n\n\n\nreg           [COUNTER_WIDTH-1:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        valid_out <= 0;\n    end\n    else begin\n        if (counter == COUNTER_WIDTH - 1) begin\n            counter <= 0;\n            valid_out <= 1;\n        end\n        else if (count_in) begin\n            counter <= counter + 1;\n            valid_out <= 0;\n        end\n        else begin\n            counter <= counter;\n            valid_out <= 0;\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] prep_dividend;\n    wire [31:0] div_op;\n\n    // The following code represents the submodules\n    // Prepare the dividend and divisor for division\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .result(prep_dividend),\n        .odd(div_op)\n    );\n\n    div_operation div_operation_inst (\n        .A(prep_dividend),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Prepare the dividend and divisor\n    // 1. Adjust the size of the dividend to 32 bits\n    // 2. Adjust the size of the divisor to 32 bits\n    // 3. Divide the dividend by the divisor using the 32-bit division algorithm\n    // 4. Extract the quotient and remainder from the division result\n\n    // Example:\n    // Step 1:\n    wire [31:0] adjusted_dividend = {A, 16'd0};\n\n    // Step 2:\n    wire [31:0] adjusted_divisor = {B, 16'd0};\n\n    // Step 3:\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Step 4:\n    assign {quotient, remainder} = adjusted_dividend / adjusted_divisor;\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Perform the division operation\n    // 1. Shift the dividend to the right by 16 bits\n    // 2. Compare the shifted dividend with the divisor\n    // 3. If the shifted dividend is greater than the divisor, subtract the divisor from the shifted dividend\n    // 4. Repeat step 2 and 3 until the shifted dividend is less than the divisor\n    // 5. The quotient is the count of the number of times step 3 is repeated\n    // 6. The remainder is the shifted dividend minus the divisor times the quotient\n\n    // Example:\n    // Step 1:\n    wire [31:0] shifted_dividend = {A[31:16], 16'd0};\n\n    // Step 2:\n    wire [31:0] shifted_divisor = {B, 16'd0};\n\n    // Step 3:\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Step 4:\n    assign {quotient, remainder} = shifted_dividend / shifted_divisor;\n\n    // Step 5:\n    assign result = quotient;\n\n    // Step 6:\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    reg [15:0] quot;\n    reg [15:0] remd;\n\n    // Control unit\n    // Implement the division algorithm here\n    \n    always @(*) begin\n        quot = 0;\n        remd = A;\n\n        for (int i = 0; i < 16; i++) begin\n            if (remd[15:8] >= B) begin\n                remd = remd + (1 << i);\n                quot = quot + (1 << (15 - i));\n            end\n\n            remd = remd << 1;\n        end\n    end\n\n    assign result = quot;\n    assign odd = remd;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nassign {B_out, D} = A - B;\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] D_sub0, D_sub1;\nwire B_out_sub0, B_out_sub1;\n\nsub_32bit sub0(A[63:32], B[63:32], D_sub0, B_out_sub0);\nsub_32bit sub1(A[31:0], B[31:0], D_sub1, B_out_sub1);\n\nassign D[63:32] = D_sub0;\nassign D[31:0] = D_sub1;\nassign B_out = B_out_sub0 | B_out_sub1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] D;\noutput B_out;\n\nwire [31:0] D_sub0, D_sub1;\nwire B_out_sub0, B_out_sub1;\n\nsub_16bit sub0(A[31:16], B[31:16], D_sub0, B_out_sub0);\nsub_16bit sub1(A[15:0], B[15:0], D_sub1, B_out_sub1);\n\nassign D[31:16] = D_sub0;\nassign D[15:0] = D_sub1;\nassign B_out = B_out_sub0 | B_out_sub1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A;\ninput [15:0] B;\noutput [15:0] D;\noutput B_out;\n\nwire [15:0] D_sub0, D_sub1;\nwire B_out_sub0, B_out_sub1;\n\nsub_8bit sub0(A[15:8], B[15:8], D_sub0, B_out_sub0);\nsub_8bit sub1(A[7:0], B[7:0], D_sub1, B_out_sub1);\n\nassign D[15:8] = D_sub0;\nassign D[7:0] = D_sub1;\nassign B_out = B_out_sub0 | B_out_sub1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] D_sub0, D_sub1;\nwire B_out_sub0, B_out_sub1;\n\nsub_4bit sub0(A[7:4], B[7:4], D_sub0, B_out_sub0);\nsub_4bit sub1(A[3:0], B[3:0], D_sub1, B_out_sub1);\n\nassign D[7:4] = D_sub0;\nassign D[3:0] = D_sub1;\nassign B_out = B_out_sub0 | B_out_sub1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] D_sub0, D_sub1;\nwire B_out_sub0, B_out_sub1;\n\nsub_2bit sub0(A[3:2], B[3:2], D_sub0, B_out_sub0);\nsub_2bit sub1(A[1:0], B[1:0], D_sub1, B_out_sub1);\n\nassign D[3:2] = D_sub0;\nassign D[1:0] = D_sub1;\nassign B_out = B_out_sub0"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A0, A1, A2, A3;\nwire [3:1] B0, B1, B2, B3;\nwire [2:1] D0, D1, D2, D3;\nwire B0_out, B1_out, B2_out, B3_out;\n\nassign A0 = A[16:15];\nassign A1 = A[15:14];\nassign A2 = A[14:13];\nassign A3 = A[13:12];\n\nassign B0 = B[16:15];\nassign B1 = B[15:14];\nassign B2 = B[14:13];\nassign B3 = B[13:12];\n\nfull_subtractor fs0 (.A(A0), .B(B0), .D(D0), .B_out(B0_out));\nfull_subtractor fs1 (.A(A1), .B(B1), .D(D1), .B_out(B1_out));\nfull_subtractor fs2 (.A(A2), .B(B2), .D(D2), .B_out(B2_out));\nfull_subtractor fs3 (.A(A3), .B(B3), .D(D3), .B_out(B3_out));\n\nassign D = {D3, D2, D1, D0};\nassign B_out = B0_out | B1_out | B2_out | B3_out;\n\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\ninput [3:1] A;\ninput [3:1] B;\noutput [3:1] D;\noutput B_out;\n\nwire [4:1] D0, D1, D2, D3;\nwire B_out0, B_out1, B_out2, B_out3;\n\nassign D0 = A[3:1] - B[3:1];\nassign D1 = A[2:1] - B[2:1] - B_out0;\nassign D2 = A[1:1] - B[1:1] - B_out1;\nassign D3 = A[0:1] - B[0:1] - B_out2;\n\nassign B_out = (D0[4] | D1[4] | D2[4] | D3[4]);\nassign D = {D3, D2, D1, D0};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] A_sub_B;\n    wire carry;\n    \n    // Comparison Logic\n    assign A_sub_B = A - B;\n    assign carry = (A_sub_B[31] == 1) ? 1 : 0;\n    \n    // Carry Generation\n    assign A_greater = carry;\n    assign A_equal = ~(A_sub_B[31] | A_sub_B);\n    assign A_less = ~carry & A_sub_B;\n    \nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] A_sub_B,\n    output carry\n);\n    assign A_sub_B = A - B;\n    assign carry = (A_sub_B[31] == 1) ? 1 : 0;\nendmodule\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\nwire [3:0] c;\nwire [3:0] c_inv;\nwire [3:0] p;\nwire [3:0] g;\nwire [3:0] sum1;\nwire [3:0] sum2;\nwire [3:0] sum3;\nwire [3:0] sum4;\nwire [3:0] sum5;\nwire [3:0] sum6;\nwire [3:0] sum7;\nwire [3:0] sum8;\n\nwire [3:0] c_inv_sum1;\nwire [3:0] c_inv_sum2;\nwire [3:0] c_inv_sum3;\nwire [3:0] c_inv_sum4;\nwire [3:0] c_inv_sum5;\nwire [3:0] c_inv_sum6;\nwire [3:0] c_inv_sum7;\nwire [3:0] c_inv_sum8;\n\nwire [3:0] s1;\nwire [3:0] s2;\nwire [3:0] s3;\nwire [3:0] s4;\nwire [3:0] s5;\nwire [3:0] s6;\nwire [3:0] s7;\nwire [3:0] s8;\n\n// Ripple carry adder\nassign {cout, sum} = a + b + cin;\n\n// Carry select adder slice\nassign c_inv_sum1 = ~c_inv[0];\nassign c_inv_sum2 = ~c_inv[1];\nassign c_inv_sum3 = ~c_inv[2];\nassign c_inv_sum4 = ~c_inv[3];\nassign s1 = (c_inv_sum1 & a[0]) | (c_inv_sum1 & b[0]) | (a[0] & b[0]);\nassign s2 = (c_inv_sum2 & a[1]) | (c_inv_sum2 & b[1]) | (a[1] & b[1]);\nassign s3 = (c_inv_sum3 & a[2]) | (c_inv_sum3 & b[2]) | (a[2] & b[2]);\nassign s4 = (c_inv_sum4 & a[3]) | (c_inv_sum4 & b[3]) | (a[3] & b[3]);\nassign sum1 = {s1, s2, s3, s4};\n\nassign c_inv_sum5 = ~c_inv[0];\nassign c_inv_sum6 = ~c_inv[1];\nassign c_inv_sum7 = ~c_inv[2];\nassign c_inv_sum8 = ~c_inv[3];\nassign s5 = (c_inv_sum5 & a[4]) | (c_inv_sum5 & b[4]) | (a[4] & b[4]);\nassign s6 = (c_inv_sum6 & a[5]) | (c_inv_sum6 & b[5]) | (a[5] & b[5]);\nassign s7 = (c_inv_sum7 & a[6]) | (c_inv_sum7 & b[6]) | (a[6] & b[6]);\nassign s8 = (c_inv_sum8 & a[7]) | (c_inv_sum8 & b[7]) | (a[7] & b[7]);\nassign sum2 = {s5, s6, s7, s8};\n\nassign sum3 = sum1 + sum2;\n\nassign c_inv = ~c;\nassign sum4 = sum3 + c_inv;\nassign sum5 = sum4 + c_inv;\nassign sum6 = sum5 + c_inv;\nassign sum7 = sum6 + c_inv;\nassign sum8 = sum7 + c_inv;\n\nassign sum = sum8;\nassign c = ~(a[15] | b[15] | sum8);\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co_temp;\n    wire [7:0] a_temp, b_temp;\n    wire [8:0] sum;\n\n    assign a_temp = a[7:0];\n    assign b_temp = b[7:0];\n    assign sum = {1'b0, a_temp} + {1'b0, b_temp} + {1'b0, Cin};\n\n    assign y[7:0] = sum[7:0];\n    assign Co = sum[8];\n\n    adder_8bit adder_8bit_inst (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co),\n        .y(y[15:8]),\n        .Co(Co_temp)\n    );\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire Co_temp;\n    wire [8:0] sum;\n\n    assign sum = {1'b0, a} + {1'b0, b} + {1'b0, Cin};\n\n    assign y[7:0] = sum[7:0];\n    assign Co = sum[8];\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [1:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    \n    full_adder fa0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n    \n    full_adder fa1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n    \n    full_adder fa2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n    \n    full_adder fa3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n    \n    full_adder fa4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c4),\n        .sum(sum[4]),\n        .cout(c5)\n    );\n    \n    full_adder fa5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c5),\n        .sum(sum[5]),\n        .cout(c6)\n    );\n    \n    full_adder fa6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c6),\n        .sum(sum[6]),\n        .cout(c7)\n    );\n    \n    full_adder fa7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c7),\n        .sum(sum[7]),\n        .cout(c8)\n    );\n    \n    assign cout = c8;\n    \nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n```\n"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [15:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\nwire shift_cnt_done = (shift_cnt == 16);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 0;\n        product <= 0;\n        done_flag <= 0;\n    end else begin\n        if (!start) begin\n            shift_cnt <= 0;\n            product <= 0;\n            done_flag <= 0;\n        end else begin\n            if (start && !done_flag) begin\n                shift_cnt <= 0;\n                product <= 0;\n                done_flag <= 0;\n            end else if (shift_cnt_done) begin\n                shift_cnt <= 0;\n                done_flag <= 1;\n            end else begin\n                shift_cnt <= shift_cnt + 1;\n                if (ain[shift_cnt]) begin\n                    product <= product + bin;\n                end\n            end\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 0;\n        reg_b <= 0;\n    end else begin\n        if (start) begin\n            reg_a <= ain;\n            reg_b <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n    wire [15:0] u_counter_register_next;\n\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_register_count),\n        .next(u_counter_register_next)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count,\n    output wire [15:0] next\n);\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0000000000000000;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 16'b0000000000000001;\n            end else begin\n                count_reg <= count_reg - 16'b0000000000000001;\n            end\n        end\n    end\n\n    assign count = count_reg;\n    assign next = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // 8-bit ring counter submodule\n    reg [7:0] state;\n    reg [2:0] pos;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 8'b0000_0001;\n            pos <= 3'b000;\n        end else begin\n            state <= {state[6:0], state[7]};\n            pos <= pos + 1;\n        end\n    end\n\n    // 8-bit state initializer submodule\n    reg [7:0] init_state;\n\n    always @(reset) begin\n        if (reset) begin\n            init_state <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule submodule_3 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state,\n    output wire [7:0] out\n);\n\n    // 8-bit state transition submodule\n    reg [2:0] pos;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pos <= 3'b000;\n        end else begin\n            pos <= pos + 1;\n        end\n    end\n\n    // 8-bit state initializer submodule\n    reg [7:0] init_state;\n\n    always @(reset) begin\n        if (reset) begin\n            init_state <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    reg [3:0] count;\n    reg [3:0] out_reg;\n\n    always @(negedge rst_n, posedge clk) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\n\n    always @(count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end\n    end\n\n    always @(negedge rst_n, posedge clk) begin\n        if (!rst_n) begin\n            out_reg <= 4'b0000;\n        end else if (valid_count) begin\n            out_reg <= count;\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(negedge rst_n, posedge clk) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\n\n    always @(count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end\n    end\n\nendmodule\n\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\n    always @(negedge rst_n, posedge clk) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_Q;\n\n// JC_register\nreg [63:0] reg_Q;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) reg_Q <= 64'b0;\n    else reg_Q <= next_Q;\nend\n\n// JC_logic\nwire [63:0] next_logic_Q;\nassign next_logic_Q[0] = reg_Q[63];\nassign next_logic_Q[63:1] = reg_Q[62:0];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= next_logic_Q;\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_reg;\nreg CLK_10_reg;\nreg CLK_1_reg;\nreg [3:0] count_50;\nreg [3:0] count_10;\nreg [3:0] count_1;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_reg <= 0;\n        CLK_10_reg <= 0;\n        CLK_1_reg <= 0;\n        count_50 <= 0;\n        count_10 <= 0;\n        count_1 <= 0;\n    end else begin\n        if (count_50 == 3) begin\n            CLK_50_reg <= ~CLK_50_reg;\n            count_50 <= 0;\n        end else begin\n            count_50 <= count_50 + 1;\n        end\n        if (count_10 == 9) begin\n            CLK_10_reg <= ~CLK_10_reg;\n            count_10 <= 0;\n        end else begin\n            count_10 <= count_10 + 1;\n        end\n        if (count_1 == 49) begin\n            CLK_1_reg <= ~CLK_1_reg;\n            count_1 <= 0;\n        end else begin\n            count_1 <= count_1 + 1;\n        end\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg CLK_out_reg;\nreg [1:0] count;\n\nalways @(posedge CLK_in) begin\n    if (count == 2) begin\n        CLK_out_reg <= ~CLK_out_reg;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg CLK_out_reg;\nreg [2:0] count;\n\nalways @(posedge CLK_in) begin\n    if (count == 3) begin\n        CLK_out_reg <= ~CLK_out_reg;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg CLK_out_reg;\nreg [4:0] count;\n\nalways @(posedge CLK_in) begin\n    if (count == 49) begin\n        CLK_out_reg <= ~CLK_out_reg;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7; // Fractional division factor\n\n// Counter Submodule\nreg [31:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n    end else if (cnt == MUL2_DIV_CLK) begin\n        cnt <= 0;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [31:0] cnt_clk_avg;\nreg avg_clk;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_clk_avg <= 0;\n        avg_clk <= 0;\n    end else if (cnt_clk_avg == MUL2_DIV_CLK / 2) begin\n        cnt_clk_avg <= 0;\n        avg_clk <= ~avg_clk;\n    end else begin\n        cnt_clk_avg <= cnt_clk_avg + 1;\n    end\nend\n\n// Clock Adjustment Submodule\nreg [31:0] cnt_clk_adj;\nreg [31:0] adj_clk;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_clk_adj <= 0;\n        adj_clk <= 0;\n    end else if (cnt_clk_adj == MUL2_DIV_CLK - 1) begin\n        cnt_clk_adj <= 0;\n        adj_clk <= ~adj_clk;\n    end else begin\n        cnt_clk_adj <= cnt_clk_adj + 1;\n    end\nend\n\n// Output\nassign clk_div = avg_clk | adj_clk;\n\nendmodule\n\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        pos_cnt <= 4'h0;\n        neg_cnt <= 4'h0;\n        clk_div1 <= 1'b0;\n        clk_div2 <= 1'b0;\n    end else begin\n        if (pos_cnt == NUM_DIV - 1) begin\n            pos_cnt <= 4'h0;\n            clk_div1 <= 1'b1;\n        end else begin\n            pos_cnt <= pos_cnt + 1;\n            clk_div1 <= 1'b0;\n        end\n\n        if (neg_cnt == NUM_DIV - 1) begin\n            neg_cnt <= 4'h0;\n            clk_div2 <= 1'b1;\n        end else begin\n            neg_cnt <= neg_cnt + 1;\n            clk_div2 <= 1'b0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n```\n\n### 2.4 \u5206\u6790\n\n\u6839\u636e\u5b9e\u9645\u5b9a\u4e49\uff0c\u8be5\u6a21\u5757\u7684\u9891\u7387\u9664\u6cd5\u5668\u53ef\u4ee5\u6839\u636e\u53c2\u6570NUM_DIV\u6765\u51b3\u5b9a\u9891\u7387\u3002\n\n### 2.5 \u603b\u7ed3\n\n- \u4f7f\u7528\u987a\u5e8f\u903b\u8f91\u5b9e\u73b0\u9891\u7387\u9664\u6cd5\u5668\n\n## 3. \u6a21\u5757\u8bbe\u8ba1\n\n### 3.1 \u6a21\u5757\u8bbe\u8ba1\n\n```verilog\nmodule freq_divbyodd (\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_cnt <= 4'h0;\n        neg_cnt <= 4'h0;\n        clk_div1 <= 1'b0;\n        clk_div2 <= 1'b0;\n    end else begin\n        if (pos_cnt == NUM_DIV - 1) begin\n            pos_cnt <= 4'h0;\n            clk_div1 <= 1'b1;\n        end else begin\n            pos_cnt <= pos_cnt + 1;\n            clk_div1 <= 1'b0;\n        end\n\n        if (neg_cnt == NUM_DIV - 1) begin\n            neg_cnt <= 4'h0;\n            clk_div2 <= 1'b1;\n        end else begin\n            neg_cnt <= neg_cnt + 1;\n            clk_div2 <= 1'b0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n```\n\n### 3.2 \u6d4b\u8bd5\n\n```verilog\nmodule freq_divbyodd_tb ();\n\nreg clk;\nreg rst_n;\nreg [3:0] clk_div;\n\n// Clock generation\nalways #20 clk = ~clk;\n\n// Test body\ninitial begin\n    clk = 0;\n    rst_n = 0;\n    wait (clk == 1);\n    rst_n = 1;\n    wait (clk_div == 1);\n    $finish;\nend\n\n// Instantiate UUT\nfreq_divbyodd uut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n```\n\n## 4. \u6d4b\u8bd5\n\n**\u8fd0\u884c\u4eff\u771f"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\nparameter NUM_DIV = 12;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 4'b0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        counter <= 4'b0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Divider Submodule\nreg clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_reg <= 1'b0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        clk_div_reg <= ~clk_div_reg;\n    end\nend\nassign clk_div = clk_div_reg;\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // add\n    add add_inst (\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n\n    // sub\n    sub sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n\n    // and\n    and and_inst (\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow),\n        .flag(and_flag)\n    );\n\n    // or\n    or or_inst (\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow),\n        .flag(or_flag)\n    );\n\n    // xor\n    xor xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow),\n        .flag(xor_flag)\n    );\n\n    // nor\n    nor nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow),\n        .flag(nor_flag)\n    );\n\n    // slt\n    slt slt_inst (\n        .a(a),\n        .b(b),\n        .r("}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n// Simple Multiplier Submodule\nwire [63:0] mult_result;\nwire [31:0] a_reg;\nwire [31:0] b_reg;\nassign mult_result = a_reg * b_reg;\n\n// Simple Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + mult_result[31:0];\n    end\nend\n\n// Main PE Module\nassign c = current_value;\n\nendmodule\n\n\"\"\"\n\nimport sys\n\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n\n    module_lines = []\n    for line in lines:\n        if line.startswith('module'):\n            module_lines = []\n            module_lines.append(line)\n        elif line == '':\n            if module_lines:\n                print('\\n'.join(module_lines))\n                module_lines = []\n        else:\n            module_lines.append(line)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n    wire [4:0] ad11;\n    wire [4:0] ad21;\n    wire [4:0] ad12;\n    wire [4:0] ad22;\n\n    // submodule\n    ins_p1 ins_p1_i (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    ins_p2 ins_p2_i (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // output\n    assign ins = (fetch == 2'b01) ? ins1[7:5] : ins2[7:5];\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            if (fetch) begin\n                ins <= data;\n                ad1 <= data[4:0];\n                ad2 <= data[7:5];\n            end\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            if (fetch) begin\n                ins <= data;\n                ad1 <= data[4:0];\n                ad2 <= data[7:5];\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable;\nreg [7:0] count;\n\nassign enable = (freq > 0) ? 1 : 0;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end else begin\n        count <= 0;\n    end\nend\n\nassign wave_out = (freq > 0) ? ~count[0] : 0;\n\nendmodule\n\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [3:0] sel4 = {sel, 2'b00};\n    \n    reg [7:0] q0, q1, q2, q3;\n    \n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(q0)\n    );\n    \n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    \n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n    \n    my_dff8 u3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n    \n    always @(posedge clk) begin\n        q <= sel4[0] ? q0 : sel4[1] ? q1 : sel4[2] ? q2 : sel4[3] ? q3 : d;\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    my_dff my_dff_inst1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff my_dff_inst2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff my_dff_inst3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput reg [7:0] out;\n\nwire [7:0] shifted;\nwire [7:0] muxout;\nwire [2:0] sel;\n\n// stage 1\nwire [7:0] mux1_in0;\nwire [7:0] mux1_in1;\n\nassign mux1_in0 = {in[3:0], in[7:4]};\nassign mux1_in1 = {in[2:0], in[7:5]};\n\nassign sel[0] = ctrl[2];\nassign muxout = (sel[0] == 1'b0) ? mux1_in0 : mux1_in1;\n\n// stage 2\nwire [7:0] mux2_in0;\nwire [7:0] mux2_in1;\n\nassign mux2_in0 = {muxout[3:0], muxout[7:4]};\nassign mux2_in1 = {muxout[2:0], muxout[7:5]};\n\nassign sel[1] = ctrl[2] | ctrl[1];\nassign muxout = (sel[1] == 2'b00) ? mux2_in0 :\n                (sel[1] == 2'b01) ? mux2_in1 :\n                (sel[1] == 2'b10) ? {mux2_in0[3:0], mux2_in0[7:4]} :\n                {mux2_in1[2:0], mux2_in1[7:5]};\n\n// stage 3\nassign sel[2] = ctrl[2] | ctrl[1] | ctrl[0];\nassign out = (sel[2] == 3'b000) ? muxout :\n             (sel[2] == 3'b001) ? {muxout[3:0], muxout[7:4]} :\n             (sel[2] == 3'b010) ? {muxout[2:0], muxout[7:5]} :\n             {muxout[1:0], muxout[7:6]};\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\ninput [1:0] sel;\ninput [7:0] in0, in1;\noutput reg [7:0] out;\n\nalways @(*) begin\n    case (sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = {in0[3:0], in0[7:4]};\n        2'b11: out = {in1[2:0], in1[7:5]};\n    endcase\nend\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  reg [15:0] b1;\n  reg [31:0] c0_r, c1_r;\n\n  // First PE\n  always @(posedge clk) begin\n    if (rst) begin\n      c0_r <= 0;\n    end else begin\n      c0_r <= a0 + b0;\n    end\n  end\n\n  // Second PE\n  always @(posedge clk) begin\n    if (rst) begin\n      c1_r <= 0;\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n      c1_r <= a1 + b1;\n    end\n  end\n\n  assign c0 = c0_r;\n  assign c1 = c1_r;\n\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  wire [4:0] pc;\n  wire [31:0] reg_file_read_1;\n  wire [31:0] reg_file_read_2;\n  wire [31:0] res_reg_file_write;\n  wire [31:0] pc_write;\n\n  fetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .reg_file_read_1(reg_file_read_1),\n    .reg_file_read_2(reg_file_read_2),\n    .pc_write(pc_write)\n  );\n\n  decode_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .alu_out(alu_out),\n    .reg_file_read_1(reg_file_read_1),\n    .reg_file_read_2(reg_file_read_2)\n  );\n\n  execute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res_reg_file_write(res_reg_file_write)\n  );\n\n  memory_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res_reg_file_write(res_reg_file_write)\n  );\n\n  writeback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .reg_file_read_2(reg_file_read_2),\n    .res_reg_file_write(res_reg_file_write),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign pc_write = pc + 1;\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [4:0] pc,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] reg_file_read_1,\n  output reg [31:0] reg_file_read_2,\n  output reg [4:0] pc_write\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file_read_1 <= 0;\n      reg_file_read_2 <= 0;\n      pc_write <= 0;\n    end else begin\n      reg_file_read_1 <= instr_mem[pc][20:15];\n      reg_file_read_2 <= instr_mem[pc][15:10];\n      pc_write <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [4:0] pc,\n  input [31:0] alu_out,\n  input [31:0] reg_file_read_1,\n  input [31:0] reg_file_read_2,\n  output reg [31:0] res_reg_file_write\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_write <= 0;\n    end else begin\n      res_reg_file_write <= alu_out;\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_out,\n  output reg [31:0] res_reg_file_write\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_write <= 0;\n    end else begin\n      res_reg_file_write <= alu_out;\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  reg [15:0] b0_reg;\n  reg [15:0] b1_reg;\n  reg [15:0] b2_reg;\n  reg [15:0] b3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  reg [15:0] a0_reg;\n  reg [15:0] a1_reg;\n  reg [15:0] a2_reg;\n  reg [15:0] a3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n    end\n    else begin\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n    end\n  end\n\n  reg [31:0] c0_reg;\n  reg [31:0] c1_reg;\n  reg [31:0] c2_reg;\n  reg [31:0] c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      c0_reg <= b0_reg * a0_reg;\n      c1_reg <= b1_reg * a1_reg;\n      c2_reg <= b2_reg * a2_reg;\n      c3_reg <= b3_reg * a3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch;\n    wire [31:0] execute;\n    wire [31:0] writeback;\n    wire [31:0] pc;\n    \n    assign pc = 32'd0;\n    \n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(fetch),\n        .pc(pc)\n    );\n    \n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(fetch),\n        .out_reg_file(execute)\n    );\n    \n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(execute),\n        .out_reg_file(writeback)\n    );\n    \n    assign out_reg_file = writeback;\n    \nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file,\n    input [31:0] pc\n);\n    wire [31:0] instr;\n    wire [4:0] rs;\n    wire [4:0] rt;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n    wire [25:0] imm;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    \n    assign instr = instr_mem[pc];\n    assign rs = instr[25:21];\n    assign rt = instr[20:16];\n    assign rd = instr[15:11];\n    assign opcode = instr[31:26];\n    assign imm = {16'd0, instr[10:0]};\n    assign op1 = reg_file[rs];\n    assign op2 = reg_file[rt];\n    \n    assign out_reg_file = result;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 32'd0;\n        end else begin\n            case (opcode)\n                6'b100000: result <= op1 + op2;\n                6'b100010: result <= op1 - op2;\n                default: result <= 32'd0;\n            endcase\n            reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    reg [9:0] data_out_r;\n    reg valid_out_r;\n\n    // Counter Module\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 2'd0;\n        end else if (valid_in) begin\n            cnt <= cnt + 2'd1;\n        end else begin\n            cnt <= 2'd0;\n        end\n    end\n\n    // Data Accumulator Module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out_r <= 10'd0;\n        end else if (cnt == 2'd3) begin\n            data_out_r <= data_in + data_out_r;\n        end else begin\n            data_out_r <= data_out_r;\n        end\n    end\n\n    // Valid Output Module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out_r <= 1'd0;\n        end else if (cnt == 2'd3) begin\n            valid_out_r <= 1'd1;\n        end else begin\n            valid_out_r <= 1'd0;\n        end\n    end\n\n    assign data_out = data_out_r;\n    assign valid_out = valid_out_r;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    output              valid_out,\n    output      [1:0]   cnt\n);\n\n    reg [1:0] cnt_r;\n    reg valid_out_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_r <= 2'd0;\n        end else if (cnt_r == 2'd3) begin\n            cnt_r <= 2'd0;\n        end else begin\n            cnt_r <= cnt_r + 2'd1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out_r <= 1'd0;\n        end else if (cnt_r == 2'd3) begin\n            valid_out_r <= 1'd1;\n        end else begin\n            valid_out_r <= 1'd0;\n        end\n    end\n\n    assign cnt = cnt_r;\n    assign valid_out = valid_out_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output      [9:0]   data_out\n);\n\n    reg [9:0] data_out_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out_r <= 10'd0;\n        end else if (valid_in) begin\n            data_out_r <= data_in + data_out_r;\n        end else begin\n            data_out_r <= data_out_r;\n        end\n    end\n\n    assign data_out = data_out_r;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt,\n    input               valid_in,\n    output              valid_out\n);\n\n    reg valid_out_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out_r <= 1'd0;\n        end else if (cnt == 2'd3) begin\n            valid_out_r <= 1'd1;\n        end else begin\n            valid_out_r <= 1'd0;\n        end"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n// Submodule implementation\n// ...\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // prep_dividend\n    // Prepare the dividend and divisor for division\n    //\n    // Output:\n    //  dividend: 32-bit dividend with 16-bit divisor shifted in\n    //  divisor: 16-bit divisor\n    //\n    // Implementation:\n    // Adjust the bit widths of the inputs to 32 bits.\n    // Shift the divisor into the upper 16 bits of the dividend\n    //\n    // Uncomment the lines below and remove the div_op module\n    // to make the code compile.\n    assign dividend = {A, {16{1'b0}}};\n    assign divisor = B;\n\n    // div_op\n    // Divide the dividend by the divisor\n    //\n    // Output:\n    //  quotient: 32-bit quotient\n    //  remainder: 32-bit remainder\n    //\n    // Implementation:\n    // Divide the dividend by the divisor using a loop\n    //\n    // Uncomment the lines below and remove the prep_dividend module\n    // to make the code compile.\n    assign {quotient, remainder} = dividend / divisor;\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] even;\n    wire [7:0] odd_bits;\n    wire [7:0] odd_bits_inv;\n    wire [7:0] odd_bits_inc;\n    wire [7:0] odd_bits_inc_inv;\n    wire [7:0] odd_bits_inc_inc;\n\n    assign odd_bits = A[7:0];\n    assign odd_bits_inv = ~odd_bits;\n    assign odd_bits_inc = odd_bits + 1;\n    assign odd_bits_inc_inv = ~odd_bits_inc;\n    assign odd_bits_inc_inc = odd_bits_inc + 1;\n\n    assign result = A[15:8] ? {odd_bits_inc_inc, odd_bits_inc_inv} : {odd_bits_inc, odd_bits_inc_inv};\n    assign odd = A[15:8] ? {odd_bits_inv, odd_bits} : {odd_bits, odd_bits_inv};\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_A;\n    wire [7:0] temp_B;\n    wire [31:0] temp_M;\n    wire [31:0] temp_D;\n    wire [31:0] temp_Q;\n    wire [7:0] temp_Q_bits;\n    wire [15:0] temp_R;\n    wire [15:0] temp_R_bits;\n\n    assign temp_A = A;\n    assign temp_B = B;\n\n    assign temp_M = {16'h0000, temp_B};\n    assign temp_D = {16'h0000, temp_A};\n    assign temp_Q = temp_D / temp_M;\n    assign temp_Q_bits = temp_Q[31:24];\n    assign temp_R = temp_D % temp_M;\n    assign temp_R_bits = temp_R[31:16];\n\n    assign result = temp_Q_bits;\n    assign odd = temp_R_bits;\n\nendmodule\n"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\nwire [7:0] B_out_comp;\n\nassign B_comp = ~B + 1;\nassign B_out_comp = ~B_out_comp_reg + 1;\n\nreg [7:0] B_out_comp_reg;\n\nalways @(A, B, B_out)\nbegin\n    {B_out_comp_reg, D} = A + B_comp;\n    B_out = B_out_comp_reg[7];\nend\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\ninput [7:0] A, B, C_in;\noutput [7:0] D;\noutput C_out;\n\nreg [7:0] D;\nreg C_out;\n\nwire [7:0] C_out_reg;\n\nassign C_out_reg = C_in | (A & B);\n\nalways @(A, B, C_in, C_out_reg)\nbegin\n    {C_out, D} = A + B + C_in;\nend\n\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\ninput A, B, C_in;\noutput D, C_out;\n\nreg D;\nreg C_out;\n\nassign D = A ^ B ^ C_in;\nassign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule\n\n'''\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (~A[31]) & (~B[31]) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = ~(A[63] ^ B[63]) & A[63] ? 1 : 0;\n\nendmodule\n\nmodule sub16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = ~(A[15] ^ B[15]) & A[15] ? 1 : 0;\n\nendmodule\n\nmodule sub8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = ~(A[7] ^ B[7]) & A[7] ? 1 : 0;\n\nendmodule\n\nmodule sub4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = ~(A[3] ^ B[3]) & A[3] ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [4:1] A1, A2, A3, A4;\nwire [4:1] B1, B2, B3, B4;\nwire [4:1] D1, D2, D3, D4;\nwire B1_out, B2_out, B3_out, B4_out;\n\nassign {B4_out, D4} = B[4:1] - A[4:1];\nassign {B3_out, D3} = B[3:1] - A[3:1] - D4[4];\nassign {B2_out, D2} = B[2:1] - A[2:1] - D3[4];\nassign {B1_out, D1} = B[1:1] - A[1:1] - D2[4];\n\nassign D = {D1, D2, D3, D4};\nassign B_out = B1_out & B2_out & B3_out & B4_out;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] A_minus_B;\nwire carry;\n\n// Subtractor Module\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .A_greater(A_greater),\n    .A_equal(A_equal),\n    .A_less(A_less),\n    .A_minus_B(A_minus_B),\n    .carry(carry)\n);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less,    \n    output [31:0] A_minus_B, \n    output carry      \n);\n\nassign A_greater = (A > B);\nassign A_equal = (A == B);\nassign A_less = ~(A >= B);\nassign A_minus_B = A - B;\nassign carry = (A_minus_B != 0);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] + B[32:1];\nassign C32 = 1;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\nwire [15:0] s0, s1, s2, s3;\nwire c0, c1, c2, c3;\nwire [3:0] csa_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] c0_s0, c0_s1, c0_s2, c0_s3;\nwire [3:0] c1_s0, c1_s1, c1_s2, c1_s3;\nwire [3:0] c2_s0, c2_s1, c2_s2, c2_s3;\nwire [3:0] c3_s0, c3_s1, c3_s2, c3_s3;\n\nassign s0 = a[0] ^ b[0] ^ cin;\nassign s1 = a[1] ^ b[1] ^ s0;\nassign s2 = a[2] ^ b[2] ^ s1;\nassign s3 = a[3] ^ b[3] ^ s2;\nassign c0 = a[0] & b[0] | a[0] & cin | b[0] & cin;\nassign c1 = a[1] & b[1] | a[1] & s0 | b[1] & s0;\nassign c2 = a[2] & b[2] | a[2] & s1 | b[2] & s1;\nassign c3 = a[3] & b[3] | a[3] & s2 | b[3] & s2;\n\nassign sum = {s3, s2, s1, s0};\nassign cout = c3;\n\nendmodule\n\nmodule adder_4bit_csa(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\nwire [3:0] s0, s1, s2, s3;\nwire c0, c1, c2, c3;\n\nassign s0 = a[0] ^ b[0] ^ cin;\nassign s1 = a[1] ^ b[1] ^ s0;\nassign s2 = a[2] ^ b[2] ^ s1;\nassign s3 = a[3] ^ b[3] ^ s2;\nassign c0 = a[0] & b[0] | a[0] & cin | b[0] & cin;\nassign c1 = a[1] & b[1] | a[1] & s0 | b[1] & s0;\nassign c2 = a[2] & b[2] | a[2] & s1 | b[2] & s1;\nassign c3 = a[3] & b[3] | a[3] & s2 | b[3] & s2;\n\nassign sum = {s3, s2, s1, s0};\nassign cout = c3;\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] s0, s1, s2, s3, s4, s5, s6, s7;\nwire [3:0] csa_cout;\nwire [3:0] sum0, sum1, sum2, sum3, sum4, sum5, sum6, sum7;\nwire [3:0] c0, c1, c2, c3, c4, c5, c6, c7;\nwire [3:0] csa_sum0, csa_sum1, csa_sum2, csa_sum3, csa_sum4, csa_sum5, csa_sum6, csa_sum7;\nwire [3:0] csa_c0, csa_c1, csa_c2, csa_c3, csa_c4, csa_c5, csa_c6, csa_c7;\n\nassign {c0, sum0} = a"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [15:0] Co_s;\n\n    // 8-bit adder\n    adder8 adder8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_s[0])\n    );\n\n    adder8 adder8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_s[0]),\n        .y(y[15:8]),\n        .Co(Co_s[1])\n    );\n\n    assign Co = Co_s[1];\n\nendmodule\n\nmodule adder8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Your code here\n    wire [7:0] Co_s;\n\n    // 4-bit adder\n    adder4 adder4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_s[0])\n    );\n\n    adder4 adder4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_s[0]),\n        .y(y[7:4]),\n        .Co(Co_s[1])\n    );\n\n    assign Co = Co_s[1];\n\nendmodule\n\nmodule adder4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    // Your code here\n    wire [3:0] Co_s;\n\n    // 2-bit adder\n    adder2 adder2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_s[0])\n    );\n\n    adder2 adder2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_s[0]),\n        .y(y[3:2]),\n        .Co(Co_s[1])\n    );\n\n    assign Co = Co_s[1];\n\nendmodule\n\nmodule adder2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    // Your code here\n    wire [1:0] Co_s;\n\n    // 1-bit adder\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | ((a ^ b) & Cin);\n\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [7:0] c;\n    wire [1:0] g, p;\n\n    assign {cout, c} = a + b + cin;\n    assign g = a ^ b;\n    assign p = a & b;\n    assign sum = {g[0], p[0], g[1], p[1], g[2], p[2], g[3], p[3], g[4], p[4], g[5], p[5], g[6], p[6], g[7], p[7]};\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nreg [31:0] product; // Product register.\nreg [4:0] shift_count; // Shift count register.\nreg done_i; // Completion flag.\n\n// Control Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 0; // Reset shift count.\n        done_i <= 0; // Reset completion flag.\n    end else if (start) begin\n        shift_count <= 5'b11111; // Set shift count.\n        done_i <= 0; // Reset completion flag.\n    end else begin\n        if (shift_count) begin\n            shift_count <= shift_count - 1; // Decrease shift count.\n        end else begin\n            done_i <= 1; // Set completion flag.\n        end\n    end\nend\n\n// Register Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0; // Reset product register.\n    end else if (start) begin\n        product <= 0; // Reset product register.\n        shift_count <= 0; // Reset shift count register.\n    end else begin\n        if (shift_count) begin\n            product <= product + (bin << shift_count); // Shift and accumulate.\n        end\n    end\nend\n\n// Multiplier Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0; // Reset product register.\n    end else if (start) begin\n        product <= 0; // Reset product register.\n        shift_count <= 0; // Reset shift count register.\n    end else begin\n        if (shift_count) begin\n            product <= product + (bin << shift_count); // Shift and accumulate.\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product; // Assign product register to output.\nassign done = done_i; // Assign completion flag to output.\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire u_counter_logic_out;\n    wire u_counter_register_out;\n\n    // Counter logic\n    assign u_counter_logic_out = (up_down == 1) ? count + 1 : count - 1;\n\n    // Counter register\n    reg [15:0] current_count;\n    assign u_counter_register_out = current_count;\n    always @(posedge clk) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= u_counter_register_out;\n        end\n    end\n\n    // Output\n    assign count = u_counter_register_out;\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output wire u_counter_logic_out\n);\n    assign u_counter_logic_out = (up_down == 1) ? count + 1 : count - 1;\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] u_counter_logic_out,\n    output wire u_counter_register_out\n);\n    reg [15:0] current_count;\n    assign u_counter_register_out = current_count;\n    always @(posedge clk) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= u_counter_logic_out;\n        end\n    end\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    initial begin\n        out <= 8'b0000_0001;\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= transition_out;\n        end\n    end\n\n    assign init_out = 8'b0000_0001;\n    assign transition_out = {~out[7], out[6:0]};\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] counter_logic_out;\n\nreg [3:0] counter;\n\nalways @(negedge rst_n, posedge clk) begin\n    if (!rst_n) begin\n        counter <= 4'b0000;\n    end else if (valid_count) begin\n        counter <= counter + 1;\n    end\nend\n\nassign counter_logic_out = (counter == 4'd11) ? 4'b0000 : counter;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] counter_logic_out,\n    output [3:0] out\n);\n\nalways @(negedge rst_n, posedge clk) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= counter_logic_out;\n    end\nend\n\nendmodule\n\nmodule\nu_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] counter;\n\nalways @(negedge rst_n, posedge clk) begin\n    if (!rst_n) begin\n        counter <= 4'b0000;\n    end else if (valid_count) begin\n        counter <= counter + 1;\n    end\nend\n\nassign out = (counter == 4'd11) ? 4'b0000 : counter;\n\nendmodule\n\nmodule\nu_output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] counter_logic_out,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(negedge rst_n, posedge clk) begin\n    if (!rst_n) begin\n        out_reg <= 4'b0000;\n    end else if (valid_count) begin\n        out_reg <= counter_logic_out;\n    end\nend\n\nassign out = out_reg;\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nreg [63:0] Q_reg;\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q_reg <= 64'd0;\n    else Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input                D,\n    output reg           Q\n);\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 1'b0;\n    else Q <= D;\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output reg [63:0]  Q_next\n);\n\nalways@(*) begin\n    Q_next = {Q[62:0], ~Q[63]};\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg clk_div_2;\nreg clk_div_10;\nreg clk_div_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2 <= 1'b0;\n        clk_div_10 <= 1'b0;\n        clk_div_100 <= 1'b0;\n    end\n    else begin\n        clk_div_2 <= ~clk_div_2;\n        clk_div_10 <= ~clk_div_10 & (clk_div_100 | clk_div_2);\n        clk_div_100 <= ~clk_div_100 & (clk_div_10 | clk_div_2);\n    end\nend\n\nassign CLK_50 = clk_div_2;\nassign CLK_10 = clk_div_10;\nassign CLK_1 = clk_div_100;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 2'b00;\n    end\n    else begin\n        if (counter == 2'b11) begin\n            counter <= 2'b00;\n        end\n        else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 2'b11);\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [3:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 4'b0000;\n    end\n    else begin\n        if (counter == 4'b1010) begin\n            counter <= 4'b0000;\n        end\n        else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 4'b1010);\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [5:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 6'b000000;\n    end\n    else begin\n        if (counter == 6'b100111) begin\n            counter <= 6'b000000;\n        end\n        else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nassign CLK_out = (counter == 6'b100111);\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK-1:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n    end else if (cnt < MUL2_DIV_CLK) begin\n        cnt <= cnt + 1;\n    end else begin\n        cnt <= 0;\n    end\nend\n\n// Clock Average Generator Submodule\nreg avg_clk;\nalways @(posedge clk) begin\n    avg_clk <= cnt[2] ? cnt[1] : cnt[0];\nend\n\n// Clock Adjustment Submodule\nreg [1:0] clk_neg;\nalways @(posedge clk) begin\n    clk_neg <= {~clk_neg[0], clk_neg[1]};\nend\n\n// Final Clock Output\nassign clk_div = avg_clk | clk_neg;\n\nendmodule\n```\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\n// Submodules\nreg [NUM_DIV - 1:0] clk_div1, clk_div2;\n\n// Submodule instantiations\npos_edge_counter u_pos_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\n// Divided clock output\nassign clk_div = |{clk_div1[NUM_DIV - 2:0], clk_div2[NUM_DIV - 2:0]};\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV - 1:0] clk_div\n);\n\nparameter NUM_DIV = 5;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n)\n        clk_div <= NUM_DIV - 1;\n    else if (clk_div == NUM_DIV - 1)\n        clk_div <= 0;\n    else\n        clk_div <= clk_div + 1;\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV - 1:0] clk_div\n);\n\nparameter NUM_DIV = 5;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (~rst_n)\n        clk_div <= NUM_DIV - 1;\n    else if (clk_div == NUM_DIV - 1)\n        clk_div <= 0;\n    else\n        clk_div <= clk_div + 1;\nend\n\nendmodule\n\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 8;\n\n    reg [3:0] counter;\n    reg clk_div_i;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_i <= 0;\n        end else begin\n            if (counter < NUM_DIV / 2 - 1) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n            end\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_i <= 0;\n        end else begin\n            if (counter == NUM_DIV / 2 - 1) begin\n                clk_div_i <= ~clk_div_i;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_i;\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_r;\nwire [31:0] sub_r;\nwire [31:0] and_r;\nwire [31:0] or_r;\nwire [31:0] xor_r;\nwire [31:0] sll_r;\nwire [31:0] srl_r;\nwire [31:0] sra_r;\nwire [31:0] slt_r;\nwire [31:0] sltu_r;\nwire [31:0] lui_r;\nwire [31:0] sllv_r;\nwire [31:0] srlv_r;\nwire [31:0] srav_r;\nwire [31:0] nor_r;\n\nwire zero_r;\nwire carry_r;\nwire negative_r;\nwire overflow_r;\n\n// ADD submodule\nwire [31:0] add_a;\nwire [31:0] add_b;\nwire [31:0] add_cin;\nwire [31:0] add_out;\n\nassign add_a = a;\nassign add_b = b;\nassign add_cin = 1;\n\n// SUB submodule\nwire [31:0] sub_a;\nwire [31:0] sub_b;\nwire [31:0] sub_binv;\nwire [31:0] sub_out;\n\nassign sub_a = a;\nassign sub_b = b;\nassign sub_binv = ~b;\n\n// AND submodule\nwire [31:0] and_a;\nwire [31:0] and_b;\nwire [31:0] and_out;\n\nassign and_a = a;\nassign and_b = b;\n\n// OR submodule\nwire [31:0] or_a;\nwire [31:0] or_b;\nwire [31:0] or_out;\n\nassign or_a = a;\nassign or_b = b;\n\n// XOR submodule\nwire [31:0] xor_a;\nwire [31:0] xor_b;\nwire [31:0] xor_out;\n\nassign xor_a = a;\nassign xor_b = b;\n\n// SLL submodule\nwire [31:0] sll_a;\nwire [31:0] sll_b;\nwire [31:0] sll_out;\n\nassign sll_a = a;\nassign sll_b = b;\n\n// SRL submodule\nwire [31:0] srl_a;\nwire [31:0] srl_b;\nwire [31:0] srl_out;\n\nassign srl_a = a;\nassign srl_b = b;\n\n// SRA submodule\nwire [31:0] sra_a;\nwire [31:0] sra_b;\nwire [31:0] sra_out;\n\nassign sra_a = a;\nassign sra_b = b;\n\n// SLT submodule\nwire [31:0] slt_a;\nwire [31:0] slt_b;\nwire [31:0] slt_out;\n\nassign slt_a = a;\nassign slt_b = b;\n\n// SLTU submodule\nwire [31:0] sltu_a;\nwire [31:0] sltu_b;\nwire [31:0] sltu_out;\n\nassign sltu_a = a;\nassign sltu_b = b;\n\n// NOR submodule\nwire [31:0] nor_a;\nwire [31:0] nor_b;\nwire [31:0] nor_out;\n\nassign nor_a = a;\nassign nor_b = b;\n\n// SLLV submodule\nwire [31:0] sllv_a;\nwire [31:0] sllv_b;\nwire [31:0] sllv_out;\n\nassign sllv_a = a;\nassign sllv_b = b"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Declare the multiplier submodule here\n\n// Declare the accumulator submodule here\n\n// Connect the submodules\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    assign ins = ins_p1 | ins_p2;\n    assign ad1 = ad1_p1 | ad1_p2;\n    assign ad2 = ad2_p1 | ad2_p2;\n\n    reg [2:0] ins_p1_r;\n    reg [4:0] ad1_p1_r;\n    reg [7:0] ad2_p1_r;\n    reg [2:0] ins_p2_r;\n    reg [4:0] ad1_p2_r;\n    reg [7:0] ad2_p2_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ins_p1_r <= 3'b0;\n            ad1_p1_r <= 5'b0;\n            ad2_p1_r <= 8'b0;\n            ins_p2_r <= 3'b0;\n            ad1_p2_r <= 5'b0;\n            ad2_p2_r <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_r <= data[7:5];\n                ad1_p1_r <= data[4:0];\n                ad2_p1_r <= 8'b0;\n            end else if (fetch == 2'b10) begin\n                ins_p1_r <= 3'b0;\n                ad1_p1_r <= 5'b0;\n                ad2_p1_r <= data;\n            end\n\n            if (fetch == 2'b11) begin\n                ins_p2_r <= data[7:5];\n                ad1_p2_r <= data[4:0];\n                ad2_p2_r <= 8'b0;\n            end else begin\n                ins_p2_r <= 3'b0;\n                ad1_p2_r <= 5'b0;\n                ad2_p2_r <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_r;\n    assign ad1_p1 = ad1_p1_r;\n    assign ad2_p1 = ad2_p1_r;\n    assign ins_p2 = ins_p2_r;\n    assign ad1_p2 = ad1_p2_r;\n    assign ad2_p2 = ad2_p2_r;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    reg [7:0] count = 0;\n    reg wave_out_reg = 0;\n    reg enable = 0;\n    wire [7:0] count_max = (freq == 0) ? 0 : freq - 1;\n\n    always @(posedge clk)\n    begin\n        if (enable)\n        begin\n            if (count == count_max)\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (count == 0)\n            wave_out_reg <= ~wave_out_reg;\n    end\n\n    assign wave_out = wave_out_reg;\n\n    always @(posedge clk)\n    begin\n        if (freq == 0)\n            enable <= 0;\n        else\n            enable <= 1;\n    end\nendmodule\n\n\n```\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state_reg, state_next;\n    reg [4:0] wave_reg, wave_next;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            state_reg <= state_next;\n            wave_reg <= wave_next;\n        end\n    end\n    \n    always @(*) begin\n        state_next = state_reg;\n        wave_next = wave_reg;\n        case (state_reg)\n            2'b00: begin // incrementing\n                if (wave_reg == 5'd31) begin\n                    state_next = 2'b01;\n                end\n            end\n            2'b01: begin // decrementing\n                if (wave_reg == 5'd0) begin\n                    state_next = 2'b00;\n                end\n            end\n        endcase\n        case (state_reg)\n            2'b00: wave_next = wave_reg + 5'd1;\n            2'b01: wave_next = wave_reg - 5'd1;\n        endcase\n    end\n    \n    assign wave = wave_reg;\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state_reg,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'd0;\n        end\n    end\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave_reg,\n    input [1:0] state_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            wave_reg <= 5'd0;\n        end\n    end\n    \n    always @(*) begin\n        case (state_reg)\n            2'b00: wave_reg = wave_reg + 5'd1;\n            2'b01: wave_reg = wave_reg - 5'd1;\n        endcase\n    end\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q1;\n            2'b01: q <= q2;\n            2'b10: q <= q3;\n            2'b11: q <= d;\n            default: q <= q1;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q1;\n            2'b01: q <= q2;\n            2'b10: q <= q3;\n            2'b11: q <= d;\n            default: q <= q1;\n        endcase\n    end\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\nreg [2:0] chain;\n\nalways @(posedge clk) begin\n    chain <= {chain[1:0], d};\nend\n\nassign q = chain[2];\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out1, mux_out2, mux_out3;\n    wire [2:0] sel;\n\n    assign sel[2] = ctrl[2];\n    assign sel[1] = ctrl[1];\n    assign sel[0] = ctrl[0];\n\n    // Stage 1: Shift by 4 positions\n    mux2X1 mux1 (mux_out1, in[7:4], in[3:0], sel[2]);\n    mux2X1 mux2 (mux_out2, mux_out1[7:4], mux_out1[3:0], sel[1]);\n    mux2X1 mux3 (mux_out3, mux_out2[7:4], mux_out2[3:0], sel[0]);\n\n    // Stage 2: Shift by 2 positions\n    mux2X1 mux4 (mux_out1, mux_out3[7:4], mux_out3[3:0], sel[2]);\n    mux2X1 mux5 (mux_out2, mux_out1[7:4], mux_out1[3:0], sel[1]);\n    mux2X1 mux6 (mux_out3, mux_out2[7:4], mux_out2[3:0], sel[0]);\n\n    // Stage 3: Shift by 1 position\n    mux2X1 mux7 (mux_out1, mux_out3[7:4], mux_out3[3:0], sel[2]);\n    mux2X1 mux8 (mux_out2, mux_out1[7:4], mux_out1[3:0], sel[1]);\n    mux2X1 mux9 (mux_out3, mux_out2[7:4], mux_out2[3:0], sel[0]);\n\n    assign out = mux_out3;\n\n    // Implementing 2-to-1 multiplexer as a simple behavioral module\n    module mux2X1 (out, in0, in1, sel);\n        input [7:0] in0, in1;\n        input sel;\n        output reg [7:0] out;\n        always @(*) begin\n            case (sel)\n                1'b0: out = in0;\n                1'b1: out = in1;\n                default: out = 8'b0;\n            endcase\n        end\n    endmodule\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  reg [15:0] b1;\n\n  // PE0\n  reg [31:0] pe0_out;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe0_out <= 0;\n      b1 <= 0;\n    end else begin\n      pe0_out <= a0 * b0;\n      b1 <= b0;\n    end\n  end\n  assign c0 = pe0_out;\n\n  // PE1\n  reg [31:0] pe1_out;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe1_out <= 0;\n      b1 <= 0;\n    end else begin\n      pe1_out <= a1 * b1;\n    end\n  end\n  assign c1 = pe1_out;\n\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res_reg_file_next;\n  wire [31:0] pc;\n  wire [31:0] op;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [31:0] rs1_reg_file;\n  wire [31:0] rs2_reg_file;\n  wire [31:0] alu_res;\n\n  reg [31:0] pc_reg;\n  reg [31:0] res_reg_file_reg [0:31];\n\n  assign res_reg_file[31:0] = res_reg_file_reg[31:0];\n  assign pc = pc_reg;\n  assign op = instr_mem[pc_reg][31:26];\n  assign rs1 = instr_mem[pc_reg][25:20];\n  assign rs2 = instr_mem[pc_reg][19:15];\n  assign rd = instr_mem[pc_reg][14:10];\n  assign rs1_reg_file = reg_file[rs1];\n  assign rs2_reg_file = reg_file[rs2];\n  assign alu_res = (op == 6'b000000) ? rs1_reg_file + rs2_reg_file : rs1_reg_file - rs2_reg_file;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc_reg <= 0;\n      res_reg_file_reg[31:0] <= 0;\n    end\n    else begin\n      pc_reg <= pc_reg + 1;\n      res_reg_file_reg[31:0] <= alu_res;\n    end\n  end\n\nendmodule\n"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\nreg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\nreg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n// PE0\nalways @(posedge clk or posedge rst)\nbegin\n  if (rst)\n    c0_reg <= 0;\n  else\n    c0_reg <= a0 * b0;\nend\n\n// PE1\nalways @(posedge clk or posedge rst)\nbegin\n  if (rst)\n  begin\n    b0_reg <= 0;\n    b1_reg <= 0;\n    c1_reg <= 0;\n  end\n  else\n  begin\n    b0_reg <= b0;\n    b1_reg <= b0_reg;\n    c1_reg <= a1 * b1_reg;\n  end\nend\n\n// PE2\nalways @(posedge clk or posedge rst)\nbegin\n  if (rst)\n  begin\n    b2_reg <= 0;\n    b3_reg <= 0;\n    c2_reg <= 0;\n  end\n  else\n  begin\n    b2_reg <= b1_reg;\n    b3_reg <= b2_reg;\n    c2_reg <= a2 * b3_reg;\n  end\nend\n\n// PE3\nalways @(posedge clk or posedge rst)\nbegin\n  if (rst)\n    c3_reg <= 0;\n  else\n    c3_reg <= a3 * b2_reg;\nend\n\nassign c0 = c0_reg;\nassign c1 = c1_reg;\nassign c2 = c2_reg;\nassign c3 = c3_reg;\n\nendmodule\n"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] pc;\nwire [31:0] instr;\nwire [31:0] op0;\nwire [31:0] op1;\nwire [31:0] op2;\nwire [31:0] op3;\nwire [31:0] out_execute;\nwire [31:0] out_writeback;\n\nreg [31:0] instr_mem_reg [0:31];\nreg [31:0] reg_file_reg [0:31];\n\nreg [31:0] pc_reg;\nreg [31:0] instr_reg;\nreg [31:0] op0_reg;\nreg [31:0] op1_reg;\nreg [31:0] op2_reg;\nreg [31:0] op3_reg;\nreg [31:0] out_execute_reg;\nreg [31:0] out_writeback_reg;\n\nassign pc = pc_reg;\nassign instr = instr_reg;\nassign op0 = op0_reg;\nassign op1 = op1_reg;\nassign op2 = op2_reg;\nassign op3 = op3_reg;\nassign out_reg_file = out_writeback_reg;\n\nstage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem_reg),\n    .reg_file(reg_file_reg),\n    .out_execute(instr_reg)\n);\n\nstage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr_reg),\n    .op0(op0_reg),\n    .op1(op1_reg),\n    .op2(op2_reg),\n    .op3(op3_reg),\n    .out_execute(out_execute_reg)\n);\n\nstage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .out_execute(out_execute_reg),\n    .op3(op3_reg),\n    .out_writeback(out_writeback_reg)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        pc_reg <= 32'd0;\n        instr_mem_reg <= 32'd0;\n        reg_file_reg <= 32'd0;\n        out_execute_reg <= 32'd0;\n        out_writeback_reg <= 32'd0;\n    end\n    else begin\n        pc_reg <= pc_reg + 1;\n        instr_mem_reg[pc_reg] <= instr_mem[pc_reg];\n        reg_file_reg <= reg_file_reg;\n        out_execute_reg <= out_execute_reg;\n        out_writeback_reg <= out_writeback_reg;\n    end\nend\n\nendmodule\n\nmodule stage (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_execute,\n    input [31:0] instr,\n    output [31:0] op0,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] op3,\n    output [31:0] out_writeback\n);\n\nreg [31:0] op0_reg;\nreg [31:0] op1_reg;\nreg [31:0] op2_reg;\nreg [31:0] op3_reg;\nreg [31:0] out_execute_reg;\nreg [31:0] out_writeback_reg;\n\nassign op0 = op0_reg;\nassign op1 = op1_reg;\nassign op2 = op2_reg;\nassign op3 = op3_reg;\nassign out_execute = out_execute_reg;\nassign out_writeback = out_writeback_reg;\n\nalways"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nreg [1:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt <= 2'd0;\n    else if (valid_in) begin\n        if (cnt == 2'd3) cnt <= 2'd0;\n        else cnt <= cnt + 1'b1;\n    end\nend\nwire count_done = (cnt == 2'd3);\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nreg [9:0] accu_data;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) accu_data <= 10'd0;\n    else if (valid_in) begin\n        accu_data <= accu_data + data_in;\n    end\nend\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nreg valid_out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) valid_out_reg <= 1'b0;\n    else if (count_done) valid_out_reg <= 1'b1;\n    else valid_out_reg <= 1'b0;\nend\nassign valid_out = valid_out_reg;\n\n//------------------------------------------------\n// Output data\n//------------------------------------------------\nassign data_out = accu_data;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    output              count_done,\n    output reg          count_en\n);\n\nreg [1:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt <= 2'd0;\n    else if (count_en) begin\n        if (cnt == 2'd3) cnt <= 2'd0;\n        else cnt <= cnt + 1'b1;\n    end\nend\nassign count_done = (cnt == 2'd3);\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg          count_en,\n    output reg          accu_valid,\n    output reg  [9:0]   accu_data\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_en <= 1'b0;\n        accu_valid <= 1'b0;\n        accu_data <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            if (count_en) begin\n                accu_data <= accu_data + data_in;\n            end else begin\n                accu_valid <= 1'b1;\n                count_en <= 1'b1;\n            end\n        end else begin\n            accu_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input               accu_valid,\n    output reg          valid_out,\n    input               count_done\n);\n\nreg [1:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt <= 2'd0;\n    else if (count_done) cnt <= 2'd0;\n    else if (valid_in) begin\n        if (cnt == 2'd3) cnt <= 2'd0;\n        else cnt <= cnt + 1'b1;\n    end\nend\nassign valid_out = valid_in & (cnt == 2'd3);\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nreg [7:0] abs_dividend;\nreg [7:0] neg_divisor;\nreg [3:0] counter;\nreg [15:0] shift_reg;\nreg [15:0] quotient;\nreg [15:0] remainder;\n\n\n// Submodules\n//\nabs_dividend = (sign) ? -dividend : dividend;\nneg_divisor = (sign) ? -divisor : divisor;\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (opn_valid && !res_valid && !res_ready) begin\n            counter <= counter + 1;\n            shift_reg <= {shift_reg[13:0], dividend[7]};\n        end else begin\n            counter <= 0;\n            shift_reg <= {shift_reg[13:0], dividend[7]};\n        end\n\n        quotient[15] <= shift_reg[15];\n        quotient[14] <= shift_reg[14];\n        quotient[13] <= shift_reg[13];\n        quotient[12] <= shift_reg[12];\n        quotient[11] <= shift_reg[11];\n        quotient[10] <= shift_reg[10];\n        quotient[9] <= shift_reg[9];\n        quotient[8] <= shift_reg[8];\n        quotient[7] <= shift_reg[7];\n        quotient[6] <= shift_reg[6];\n        quotient[5] <= shift_reg[5];\n        quotient[4] <= shift_reg[4];\n        quotient[3] <= shift_reg[3];\n        quotient[2] <= shift_reg[2];\n        quotient[1] <= shift_reg[1];\n        quotient[0] <= shift_reg[0];\n\n        if (counter == 15) begin\n            remainder <= shift_reg[15:8] - neg_divisor;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        res_valid <= 0;\n    end else begin\n        if (opn_valid && !res_valid && !res_ready) begin\n            res_valid <= 1;\n        end else if (res_ready && res_valid) begin\n            res_valid <= 0;\n        end\n    end\nend\n\nassign result = {remainder, quotient};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Prepare dividend and divisor\n// The first submodule is responsible for preparing the dividend and divisor.\n// This module takes the 32-bit dividend and 16-bit divisor and adjusts their bit widths\n// to 16-bit and 32-bit respectively. The result is a 32-bit dividend and 16-bit divisor.\n// The second submodule is responsible for dividing the prepared dividend and divisor.\n// This module takes the 16-bit dividend and 32-bit divisor and performs the division.\n// The result is a 32-bit quotient and 32-bit remainder.\n\n// Prepare dividend and divisor submodule\n// 1. Increase the width of the dividend and divisor to 32 bits.\n// 2. Assign the results of step 1 to the dividend and divisor.\n\n    wire [31:0] D;\n    wire [31:0] Q;\n    wire [31:0] R;\n    wire [31:0] odd_Q;\n\n    assign D = {A[31:16], 16'b0};\n    assign Q = {B, 16'b0};\n    assign R = D - Q;\n    assign odd_Q = R[31:16];\n\n// Divide submodule\n// 1. Divide the prepared dividend by the prepared divisor to get the quotient and remainder.\n\n    assign result = odd_Q;\n    assign odd = R;\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n// Control unit\nmodule div_16bit_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nreg [15:0] div_result, div_odd;\nreg [7:0] shift;\nreg [1:0] state;\n\nassign result = div_result;\nassign odd = div_odd;\n\nalways @(*) begin\n    div_result = 16'b0;\n    div_odd = 16'b0;\n    shift = 8'b0;\n    state = 2'b00;\n    \n    if (A[7:0] == B) begin\n        div_result = 1;\n        div_odd = A[15:8];\n        state = 2'b01;\n    end\nend\n\nalways @(posedge state) begin\n    case (state)\n        2'b00: begin\n            if (A[15:8] == B) begin\n                div_result[15:8] = 8'b1;\n                div_odd = A[7:0];\n                shift = 8'b1;\n                state = 2'b01;\n            end else if (A[15:8] > B) begin\n                div_result[15:8] = A[15:8] - B;\n                shift = 8'b1;\n                state = 2'b01;\n            end else begin\n                div_odd = A[15:8];\n                state = 2'b10;\n            end\n        end\n        2'b01: begin\n            if (div_odd[7:shift] == B) begin\n                div_result[15:shift+8] = 8'b1;\n                div_odd = div_odd[7:shift] << 1;\n                shift = shift + 1;\n                state = 2'b01;\n            end else if (div_odd[7:shift] > B) begin\n                div_result[15:shift+8] = div_odd[7:shift] - B;\n                shift = shift + 1;\n                state = 2'b01;\n            end else begin\n                div_odd = div_odd << 1;\n                state = 2'b10;\n            end\n        end\n        2'b10: begin\n            if (div_odd[7:0] == B) begin\n                div_result[15:8] = 8'b1;\n                div_odd = A[15:8];\n                state = 2'b01;\n            end else if (div_odd[7:0] > B) begin\n                div_result[15:8] = div_odd[7:0] - B;\n                state = 2'b01;\n            end else begin\n                div_odd = div_odd << 1;\n                state = 2'b01;\n            end\n        end\n    endcase\nend\n\nendmodule\n\nendmodule\n"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp, carry_out;\nwire [7:0] sum;\n\nassign B_comp = ~B + 1;\n\n// Generate the carry outs\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin\n        assign carry_out[i] = (A[i] & B_comp[i]) | (A[i] & carry_out[i+1]) | (B_comp[i+1] & carry_out[i]);\n    end\nendgenerate\n\n// Generate the sum\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin\n        assign sum[i] = A[i] ^ B_comp[i];\n    end\nendgenerate\n\nassign D = sum[7:0];\nassign B_out = carry_out[0];\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] carry_out;\n\nassign {carry_out, D} = A + B;\nassign B_out = carry_out[7];\n\nendmodule\n\nmodule full_adder(A, B, cin, sum, cout);\ninput A, B, cin;\noutput sum, cout;\n\nassign {cout, sum} = A + B + cin;\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0;\nwire [31:0] D1;\nwire [15:0] D2;\nwire [15:0] D3;\nwire [7:0] D4;\nwire [7:0] D5;\n\nwire B0;\nwire B1;\nwire B2;\nwire B3;\n\nwire B_out;\n\nsub_32bit sub0(.A(A[31:0]), .B(B[31:0]), .D(D0), .B_out(B0));\nsub_32bit sub1(.A(A[63:32]), .B(B[63:32]), .D(D1), .B_out(B1));\n\nsub_16bit sub2(.A(D0), .B(D1), .D(D2), .B_out(B2));\nsub_16bit sub3(.A(D1), .B(D0), .D(D3), .B_out(B3));\n\nsub_8bit sub4(.A(D2), .B(D3), .D(D4), .B_out(B4));\nsub_8bit sub5(.A(D3), .B(D2), .D(D5), .B_out(B5));\n\nassign D[63:0] = {D5, D4, D3, D2, D1, D0};\nassign B_out = B5;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0;\nwire [15:0] D1;\nwire [7:0] D2;\nwire [7:0] D3;\n\nwire B_out;\n\nsub_16bit sub0(.A(A[15:0]), .B(B[15:0]), .D(D0), .B_out(B0));\nsub_16bit sub1(.A(A[31:16]), .B(B[31:16]), .D(D1), .B_out(B1));\n\nsub_8bit sub2(.A(D0), .B(D1), .D(D2), .B_out(B2));\nsub_8bit sub3(.A(D1), .B(D0), .D(D3), .B_out(B3));\n\nassign D[31:0] = {D3, D2, D1, D0};\nassign B_out = B3;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A;\ninput [15:0] B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0;\nwire [7:0] D1;\n\nwire B_out;\n\nsub_8bit sub0(.A(A[7:0]), .B(B[7:0]), .D(D0), .B_out(B0));\nsub_8bit sub1(.A(A[15:8]), .B(B[15:8]), .D(D1), .B_out(B1));\n\nassign D[15:0] = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0;\nwire [3:0] D1;\nwire [1:0] D2;\nwire [1:0] D3;\n\nwire B_out;\n\nsub_4bit sub0(.A(A[3:0]), .B(B[3:0]), .D(D0), .B_out(B0"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:1] B_A_out;\n    wire [3:1] B_B_out;\n    wire [3:1] B_D_out;\n\n    // Implement 4-bit full subtractor\n    // ...\n\n    assign D[1:1] = B_A_out + B_B_out + B_D_out;\n    assign B_out = B_A_out[3] | B_B_out[3] | B_D_out[3];\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Combinational Subtractor\nassign sub_result = A - B;\nassign carry = (sub_result == 0);\n\n// Output Logic\nassign A_greater = (~carry & (sub_result != 0));\nassign A_equal = (~carry & (sub_result == 0));\nassign A_less = (carry);\n\nendmodule\n-------------------------------------------------------------------------------------------------------------------------------------\n'''\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] S0,C0;\nwire [15:1] S1,C1;\nwire [15:1] S2,C2;\nwire [15:1] S3,C3;\nwire [15:1] S4,C4;\nwire [15:1] S5,C5;\nwire [15:1] S6,C6;\nwire [15:1] S7,C7;\nwire [15:1] S8,C8;\nwire [15:1] S9,C9;\nwire [15:1] S10,C10;\nwire [15:1] S11,C11;\nwire [15:1] S12,C12;\nwire [15:1] S13,C13;\nwire [15:1] S14,C14;\nwire [15:1] S15,C15;\nwire [15:1] S16,C16;\nwire [15:1] S17,C17;\nwire [15:1] S18,C18;\nwire [15:1] S19,C19;\nwire [15:1] S20,C20;\nwire [15:1] S21,C21;\nwire [15:1] S22,C22;\nwire [15:1] S23,C23;\nwire [15:1] S24,C24;\nwire [15:1] S25,C25;\nwire [15:1] S26,C26;\nwire [15:1] S27,C27;\nwire [15:1] S28,C28;\nwire [15:1] S29,C29;\nwire [15:1] S30,C30;\nwire [15:1] S31,C31;\nwire [15:1] S32,C32;\n\n\nCLA CLA1(A[15:1],B[15:1],S0,C0);\nCLA CLA2(A[31:16],B[31:16],S1,C1);\nCLA CLA3(A[31:16],B[31:16],S2,C2);\nCLA CLA4(A[31:16],B[31:16],S3,C3);\nCLA CLA5(A[31:16],B[31:16],S4,C4);\nCLA CLA6(A[31:16],B[31:16],S5,C5);\nCLA CLA7(A[31:16],B[31:16],S6,C6);\nCLA CLA8(A[31:16],B[31:16],S7,C7);\nCLA CLA9(A[31:16],B[31:16],S8,C8);\nCLA CLA10(A[31:16],B[31:16],S9,C9);\nCLA CLA11(A[31:16],B[31:16],S10,C10);\nCLA CLA12(A[31:16],B[31:16],S11,C11);\nCLA CLA13(A[31:16],B[31:16],S12,C12);\nCLA CLA14(A[31:16],B[31:16],S13,C13);\nCLA CLA15(A[31:16],B[31:16],S14,C14);\nCLA CLA16(A[31:16],B[31:16],S15,C15);\nCLA CLA17(A[31:"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slices [3:0];\nwire [3:0] rca_slices [3:0];\nwire [3:0] cin_slices [3:0];\n\nassign csa_slices[0] = a[ 3: 0] + b[ 3: 0] + cin;\nassign rca_slices[0] = a[ 7: 4] + b[ 7: 4] + csa_slices[0][0];\nassign cin_slices[0] = {2'b00, csa_slices[0][1], csa_slices[0][2], csa_slices[0][3]};\nassign csa_slices[1] = a[11: 8] + b[11: 8] + rca_slices[0][3];\nassign rca_slices[1] = a[15:12] + b[15:12] + csa_slices[1][3];\nassign cin_slices[1] = {2'b00, csa_slices[1][1], csa_slices[1][2], csa_slices[1][3]};\nassign csa_slices[2] = a[ 3: 0] + b[ 3: 0] + cin_slices[0];\nassign rca_slices[2] = a[ 7: 4] + b[ 7: 4] + csa_slices[2][0];\nassign cin_slices[2] = {2'b00, csa_slices[2][1], csa_slices[2][2], csa_slices[2][3]};\nassign csa_slices[3] = a[11: 8] + b[11: 8] + rca_slices[2][3];\nassign rca_slices[3] = a[15:12] + b[15:12] + csa_slices[3][3];\nassign cin_slices[3] = {2'b00, csa_slices[3][1], csa_slices[3][2], csa_slices[3][3]};\n\nassign sum = rca_slices[3][3:0] + rca_slices[2][7:4] + rca_slices[1][11:8] + rca_slices[0][15:12];\nassign cout = cin_slices[3][3] | cin_slices[2][7] | cin_slices[1][11] | cin_slices[0][15];\n\nendmodule\n"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co_1, Co_2;\n\n    // 8-bit adder instantiation\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_1)\n    );\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_1),\n        .y(y[15:8]),\n        .Co(Co_2)\n    );\n    assign Co = Co_2;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire Co_1, Co_2;\n\n    // 4-bit adder instantiation\n    adder_4bit add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_1)\n    );\n    adder_4bit add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_1),\n        .y(y[7:4]),\n        .Co(Co_2)\n    );\n    assign Co = Co_2;\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire Co_1, Co_2;\n\n    // 2-bit adder instantiation\n    adder_2bit add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_1)\n    );\n    adder_2bit add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_1),\n        .y(y[3:2]),\n        .Co(Co_2)\n    );\n    assign Co = Co_2;\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    wire Co_1, Co_2;\n\n    // 1-bit adder instantiation\n    adder_1bit add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_1)\n    );\n    adder_1bit add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_1),\n        .y(y[1]),\n        .Co(Co_2)\n    );\n    assign Co = Co_2;\nendmodule\n\nmodule adder_1bit (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    // 1-bit adder logic\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [3:0] carry_out;\n    wire [3:0] sum_temp;\n    \n    // Implement 4 bit full adder\n    // You can use built-in Verilog adder if available\n    // Otherwise, you can implement a simple full adder yourself\n    \n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum_temp[0]), .cout(carry_out[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(carry_out[0]), .sum(sum_temp[1]), .cout(carry_out[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(carry_out[1]), .sum(sum_temp[2]), .cout(carry_out[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(carry_out[2]), .sum(sum_temp[3]), .cout(carry_out[3]));\n    \n    assign sum[0] = sum_temp[0];\n    assign sum[1] = sum_temp[1];\n    assign sum[2] = sum_temp[2];\n    assign sum[3] = sum_temp[3];\n    assign sum[4] = a[4] ^ b[4] ^ carry_out[0];\n    assign sum[5] = a[5] ^ b[5] ^ carry_out[1];\n    assign sum[6] = a[6] ^ b[6] ^ carry_out[2];\n    assign sum[7] = a[7] ^ b[7] ^ carry_out[3];\n    assign cout = carry_out[3];\n    \nendmodule\n\n// Implement a simple full adder\n// You can replace this with a more complex adder if necessary\n// In Verilog, you can use the built-in adder if available\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n    \nendmodule\n"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [31:0] product_reg; // Product register.\nreg [31:0] shift_count; // Shift count register.\nreg [15:0] ain_reg;     // Multiplicand register.\nreg [15:0] bin_reg;     // Multiplier register.\nreg [31:0] shift_value; // Shift value.\nreg [1:0] shift_bit;    // Shift bit.\n\n// Control Unit logic.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 32'd0;\n        product_reg <= 32'd0;\n        shift_bit <= 2'd0;\n    end else begin\n        if (start) begin\n            shift_count <= 32'd0;\n            product_reg <= 32'd0;\n            shift_bit <= 2'd0;\n        end else begin\n            shift_bit <= shift_bit + 2'd1;\n            shift_value <= {16'd0, bin_reg[shift_bit]};\n            if (shift_bit == 2'd0) begin\n                product_reg <= product_reg + shift_value;\n                shift_count <= shift_count + 32'd1;\n            end\n        end\n    end\nend\n\n// Register Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ain_reg <= 16'd0;\n        bin_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            ain_reg <= ain;\n            bin_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [31:0] multiplier; // Multiplier register.\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        multiplier <= 32'd0;\n    end else begin\n        if (start) begin\n            multiplier <= bin_reg;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product_reg;\nassign done = (shift_count == 32'd16);\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nendmodule\n\n\n\n\n\nmodule u_counter_logic (\n    input wire [15:0] count_cur,\n    input wire up_down,\n    output wire [15:0] count_next\n);\n\nendmodule\n\n\n\n\n\nmodule u_counter_register (\n    input wire [15:0] count_cur,\n    input wire clk,\n    input wire reset,\n    output wire [15:0] count_next\n);\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire init_out;\n    wire transition_out;\n\n    // Initialize the counter to its starting state.\n    // This submodule should be replaced with a proper implementation.\n    initial\n        out = 8'b0000_0001;\n\n    // Transition the counter between its states.\n    // This submodule should be replaced with a proper implementation.\n    always @(posedge clk)\n        if (reset)\n            out <= 8'b0000_0001;\n        else\n            out <= {transition_out, out[7:1]};\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    reg [3:0] count;\n    wire [3:0] next_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= next_count;\n        end\n    end\n\n    assign next_count = (count == 4'd11) ? 4'b0000 : count + 1;\n    assign out = (valid_count) ? count : out;\n\nendmodule\n\nmodule\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    reg [3:0] count;\n    wire [3:0] next_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= next_count;\n        end\n    end\n\n    assign next_count = (count == 4'd11) ? 4'b0000 : count + 1;\n    assign out = (valid_count) ? count : 4'b0000;\n\nendmodule\n\nmodule\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output [3:0] out\n);\n\n    reg [3:0] out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out_reg <= 4'b0000;\n        end else if (valid_count) begin\n            out_reg <= in;\n        end\n    end\n\n    assign out = (valid_count) ? out_reg : 4'b0000;\n\nendmodule\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register Module\nmodule JC_register(\n    input           clk,\n    input           rst_n,\n    input [63:0]    d,\n    output [63:0]   Q\n);\n    reg [63:0] Q_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_reg <= 64'b000000000000000000000000000000000000000000000000000000000000000;\n        else\n            Q_reg <= d;\n    end\n\n    assign Q = Q_reg;\nendmodule\n\n// Logic Module\nmodule JC_logic(\n    input           clk,\n    input           rst_n,\n    input [63:0]    Q,\n    output [63:0]   Q_n\n);\n    assign Q_n = {Q[0], Q[63:1]};\nendmodule\n\nendmodule\n\n```\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg [1:0] counter_2;\nreg [3:0] counter_10;\nreg [4:0] counter_100;\n\nassign CLK_50 = counter_2[1];\nassign CLK_10 = counter_10[3];\nassign CLK_1 = counter_100[4];\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter_2 <= 2'b00;\n    else\n        counter_2 <= counter_2 + 1;\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter_10 <= 4'b0000;\n    else if (counter_2 == 2'b11)\n        counter_10 <= counter_10 + 1;\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter_100 <= 5'b00000;\n    else if (counter_10 == 4'b1111)\n        counter_100 <= counter_100 + 1;\nend\n\nendmodule\n\nmodule clk_div_50 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nassign CLK_out = counter[1];\n\n// clk_div_50\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter <= 2'b00;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [3:0] counter;\n\nassign CLK_out = counter[3];\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter <= 4'b0000;\n    else if (counter == 4'b1111)\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [4:0] counter;\n\nassign CLK_out = counter[4];\n\n// clk_div_1\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter <= 5'b00000;\n    else if (counter == 5'b11111)\n        counter <= counter + 1;\nend\n\nendmodule\n\n\"\"\""}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire        clk_div_sub;\nwire        clk_div_sub_mux;\nreg         clk_div_cnt;\n\nassign clk_div = clk_div_sub & clk_div_sub_mux;\n\n// Counter Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) clk_div_cnt <= 0;\n    else if (clk_div_sub) clk_div_cnt <= 0;\n    else clk_div_cnt <= clk_div_cnt + 1'b1;\nend\n\n// Clock Average Generator Submodule\nassign clk_div_sub = (clk_div_cnt == MUL2_DIV_CLK / 2 - 1);\n\n// Clock Adjustment Submodule\nassign clk_div_sub_mux = (clk_div_sub) ? clk : ~clk;\n\nendmodule\n\n```\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    reg [3:0] u_pos_counter;\n    reg [3:0] u_neg_counter;\n    reg clk_div1;\n    reg clk_div2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            u_pos_counter <= 0;\n            u_neg_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else if (u_pos_counter == NUM_DIV - 1) begin\n            u_pos_counter <= 0;\n            clk_div1 <= 1;\n        end else begin\n            u_pos_counter <= u_pos_counter + 1;\n            clk_div1 <= 0;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            u_neg_counter <= 0;\n            clk_div2 <= 0;\n        end else if (u_neg_counter == NUM_DIV - 1) begin\n            u_neg_counter <= 0;\n            clk_div2 <= 1;\n        end else begin\n            u_neg_counter <= u_neg_counter + 1;\n            clk_div2 <= 0;\n        end\n    end\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule\n\n```\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n\n    reg [3:0] count = 0;\n    reg clk_div_r = 1;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div_r <= 1;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div_r <= ~clk_div_r;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    assign clk_div = clk_div_r;\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n    wire [31:0] xor_out;\n    wire [31:0] nor_out;\n    wire [31:0] slt_out;\n    wire [31:0] sltu_out;\n    wire [31:0] sll_out;\n    wire [31:0] srl_out;\n    wire [31:0] sra_out;\n    wire [31:0] sllv_out;\n    wire [31:0] srlv_out;\n    wire [31:0] srav_out;\n    wire [31:0] lui_out;\n\n    assign r = aluc[5:0] == 6'b100000 ? add_out :\n               aluc[5:0] == 6'b100001 ? add_out :\n               aluc[5:0] == 6'b100010 ? sub_out :\n               aluc[5:0] == 6'b100011 ? sub_out :\n               aluc[5:0] == 6'b100100 ? and_out :\n               aluc[5:0] == 6'b100101 ? or_out :\n               aluc[5:0] == 6'b100110 ? xor_out :\n               aluc[5:0] == 6'b100111 ? nor_out :\n               aluc[5:0] == 6'b101010 ? slt_out :\n               aluc[5:0] == 6'b101011 ? sltu_out :\n               aluc[5:0] == 6'b000000 ? sll_out :\n               aluc[5:0] == 6'b000010 ? srl_out :\n               aluc[5:0] == 6'b000011 ? sra_out :\n               aluc[5:0] == 6'b000100 ? sllv_out :\n               aluc[5:0] == 6'b000110 ? srlv_out :\n               aluc[5:0] == 6'b000111 ? srav_out :\n               aluc[5:0] == 6'b001111 ? lui_out : 0;\n\n    assign zero = r == 32'b0;\n    assign carry = |r[31:0];\n    assign negative = r[31];\n    assign overflow = (add_out[31] == sub_out[31] && add_out[31] != r[31]) || (add_out[31] != sub_out[31] && add_out[31] == r[31]);\n    assign flag = aluc[5:0] == 6'b101010 ? slt_out[31] : aluc[5:0] == 6'b101011 ? sltu_out[31] : 0;\n\n    add add_module(\n        .a(a),\n        .b(b),\n        .r(add_out)\n    );\n\n    addu addu_module(\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n\n    and and_module(\n        .a(a),\n        .b(b),\n        .r(and_out)\n    );\n\n    or or_module(\n        .a(a),\n        .b(b),\n        .r(or_out)\n    );\n\n    xor xor_module(\n        .a(a),\n        .b(b),\n        .r(xor_out)\n    );\n\n    nor nor_module(\n        .a(a),\n        .b(b),\n        .r(nor"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n    \n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n    \n    // Accumulator Submodule\n    reg [31:0] current_value_reg;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value_reg <= 32'd0;\n        end else begin\n            current_value_reg <= current_value_reg + multiplication_result[31:0];\n        end\n    end\n    \n    assign current_value = current_value_reg;\n    \n    // Connecting Multiplier and Accumulator\n    assign c = current_value;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [5:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [6:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register sources\n    reg [2:0] ins_p1_reg;\n    reg [5:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM sources\n    reg [2:0] ins_p2_reg;\n    reg [6:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Connect the inputs to the corresponding submodules\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    // Assign the outputs of the submodules\n    assign ins = ins_p1 | ins_p2;\n    assign ad1 = ad1_p1[5:0] | ad1_p2[6:0];\n    assign ad2 = ad2_p1 | ad2_p2;\n\n    // Synchronous reset\n    always @(posedge clk) begin\n        if (rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 6'b0;\n            ad2_p1_reg <= 8'b0;\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 7'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable = (freq != 0);\n\ncounter counter_inst (\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wave_generator_inst (\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= 1'b0;\n    end else if (count == 0) begin\n        wave_out_reg <= 1'b1;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule\n\nmodule counter (\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        count_reg <= (count_reg == (freq - 1)) ? 8'd0 : count_reg + 8'd1;\n    end\nend\n\nassign count = count_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 5'b00000;\n                end\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\n    \nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [2:0] sel2;\n    wire [7:0] dff_out [2:0];\n\n    // 3 D flip-flops with 8-bit data and 2-bit sel\n    my_dff8 u_my_dff80 (.clk(clk), .sel(sel[0]), .d(d), .q(dff_out[0]));\n    my_dff8 u_my_dff81 (.clk(clk), .sel(sel[1]), .d(dff_out[0]), .q(dff_out[1]));\n    my_dff8 u_my_dff82 (.clk(clk), .sel(sel[1]), .d(dff_out[1]), .q(dff_out[2]));\n\n    // 4-to-1 multiplexer\n    assign sel2 = {sel, 1'b0};\n    always @(posedge clk) begin\n        case (sel2)\n            3'b000: q <= d;\n            3'b001: q <= dff_out[0];\n            3'b010: q <= dff_out[1];\n            3'b011: q <= dff_out[2];\n            default: q <= 8'b0;\n        endcase\n    end\n\nendmodule\n\n// Simple D flip-flop with 8-bit data and 2-bit sel\n// Assuming the sel signal is an enable signal\nmodule my_dff8 (\n    input clk,\n    input sel,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (sel)\n            q <= d;\n    end\nendmodule\n\n```\n\n\n\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    reg q0, q1, q2;\n\n    always @(posedge clk) begin\n        q0 <= d;\n        q1 <= q0;\n        q2 <= q1;\n    end\n\n    assign q = q2;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage0, stage1, stage2;\n    wire sel;\n\n    // Stage 0\n    assign stage0 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign sel = ctrl[2];\n\n    // Stage 1\n    assign stage1 = (ctrl[1]) ? {stage0[3:0], stage0[7:4]} : stage0;\n    assign sel = sel | ctrl[1];\n\n    // Stage 2\n    assign stage2 = (ctrl[0]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign out = stage2;\n\nendmodule\n\n```\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  reg [15:0] b1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  assign c0 = a0 * b0;\n  assign c1 = a1 * b1;\n\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] result;\n  reg [31:0] pipeline_reg [0:4];\n\n  assign instr = pipeline_reg[0];\n  assign rs1 = instr[19:15];\n  assign rs2 = instr[24:20];\n  assign rd = instr[11:7];\n  assign op = instr[31:26];\n  assign result = pipeline_reg[3];\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n      pipeline_reg[4] <= 0;\n    end else begin\n      pipeline_reg[0] <= instr_mem[pipeline_reg[0]];\n      pipeline_reg[1] <= pipeline_reg[0];\n      pipeline_reg[2] <= pipeline_reg[1];\n      pipeline_reg[3] <= pipeline_reg[2];\n      pipeline_reg[4] <= pipeline_reg[3];\n    end\n  end\n\n  always @(posedge clk) begin\n    if (rst)\n      res_reg_file[rd] <= 0;\n    else\n      res_reg_file[rd] <= result;\n  end\n\n  always @(posedge clk) begin\n    if (rst)\n      pipeline_reg[0] <= 0;\n    else if (op == 6'b000000) begin\n      pipeline_reg[0] <= reg_file[rs1] + reg_file[rs2];\n    end else if (op == 6'b001000) begin\n      pipeline_reg[0] <= reg_file[rs1] - reg_file[rs2];\n    end else\n      pipeline_reg[0] <= 0;\n  end\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] next_pc,\n  output [31:0] instr\n);\n  assign next_pc = pc + 1;\n  assign instr = instr_mem[pc];\n\n  always @(posedge clk) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= next_pc;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {op, rs2, rs1, rd} = instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] result\n);\n  wire [31:0] rs1_val, rs2_val;\n\n  assign rs1_val = rs1;\n  assign rs2_val = rs2;\n\n  always @(posedge clk) begin\n    if (rst)\n      result <= 0;\n    else if (op == 6'b000000)\n      result <= rs1_val + rs2_val;\n    else if (op == 6'b001000)\n      result <= rs1_val - rs2_val;\n    else\n      result <= 0;\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [31:0] result,\n  output [31:0] next_instr,\n "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [31:0] pe0, pe1, pe2, pe3;\n  reg [31:0] r_pe0, r_pe1, r_pe2, r_pe3;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      pe0 <= 32'b0;\n      pe1 <= 32'b0;\n      pe2 <= 32'b0;\n      pe3 <= 32'b0;\n      r_pe0 <= 32'b0;\n      r_pe1 <= 32'b0;\n      r_pe2 <= 32'b0;\n      r_pe3 <= 32'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      pe0 <= a0*b0;\n      pe1 <= a1*b1;\n      pe2 <= a2*b2;\n      pe3 <= a3*b3;\n      r_pe0 <= pe0;\n      r_pe1 <= pe1;\n      r_pe2 <= pe2;\n      r_pe3 <= pe3;\n    end\n  end\n\n  assign c0 = pe0;\n  assign c1 = r_pe0 + pe1;\n  assign c2 = r_pe1 + pe2;\n  assign c3 = r_pe2 + pe3;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] pc;\n    wire [31:0] fetch_instr;\n    wire [31:0] execute_instr;\n    wire [31:0] writeback_instr;\n    wire [31:0] execute_result;\n    wire [31:0] writeback_reg;\n    wire [31:0] writeback_data;\n\n    reg [31:0] out_reg_file;\n\n    // Fetch stage\n    wire [31:0] fetch_stage_out;\n    stagepipe3_fetch_stage fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch_instr(fetch_instr)\n    );\n\n    // Execute stage\n    stagepipe3_execute_stage execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .execute_instr(execute_instr),\n        .reg_file(reg_file),\n        .execute_result(execute_result)\n    );\n\n    // Writeback stage\n    stagepipe3_writeback_stage writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .writeback_reg(writeback_reg),\n        .writeback_data(writeback_data),\n        .writeback_instr(writeback_instr)\n    );\n\n    assign out_reg_file = writeback_data;\n\nendmodule\n\nmodule stagepipe3_fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetch_instr\n);\n    reg [31:0] fetch_instr;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetch_instr <= 32'h00000000;\n        else\n            fetch_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule stagepipe3_execute_stage(\n    input clk,\n    input rst,\n    input [31:0] execute_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] execute_result\n);\n    reg [31:0] execute_result;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            execute_result <= 32'h00000000;\n        else begin\n            case (execute_instr[5:0])\n                6'b000000: execute_result <= reg_file[execute_instr[10:6]] + reg_file[execute_instr[15:11]];\n                6'b000001: execute_result <= reg_file[execute_instr[10:6]] - reg_file[execute_instr[15:11]];\n                default: execute_result <= 32'h00000000;\n            endcase\n        end\n    end\nendmodule\n\nmodule stagepipe3_writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] writeback_reg,\n    input [31:0] writeback_data,\n    input [31:0] writeback_instr,\n    output [31:0] writeback_instr\n);\n    reg [31:0] writeback_instr;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            writeback_instr <= 32'h00000000;\n        else\n            writeback_instr <= writeback_data;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                new_data;\n\n    // Counter Module\n    reg                 count;\n    reg                 u_counter_valid;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            u_counter_valid <= 0;\n        end else begin\n            u_counter_valid <= valid_in & ~count[0];\n            if (new_data) begin\n                count <= 1;\n            end else if (u_counter_valid) begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    // Data Accumulator Module\n    reg     [7:0]   accumulator;\n    reg     [7:0]   data_in_d;\n    reg             valid_in_d;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accumulator <= 0;\n            data_in_d <= 0;\n            valid_in_d <= 0;\n        end else begin\n            data_in_d <= data_in;\n            valid_in_d <= valid_in;\n            if (u_counter_valid) begin\n                accumulator <= accumulator + data_in;\n            end\n        end\n    end\n\n    // Valid Output Module\n    reg                 u_valid_output_valid;\n    reg     [9:0]       u_data_out;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            u_valid_output_valid <= 0;\n            u_data_out <= 0;\n        end else begin\n            u_valid_output_valid <= count == 4;\n            u_data_out <= accumulator;\n        end\n    end\n\n    assign new_data = valid_in_d & ~count[0];\n    assign valid_out = u_valid_output_valid;\n    assign data_out = u_data_out;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               u_counter_valid,\n\n    output              valid_out,\n    output      [1:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            valid_out <= 0;\n        end else begin\n            if (u_counter_valid) begin\n                if (count == 2) begin\n                    count <= 0;\n                    valid_out <= 1;\n                end else begin\n                    count <= count + 1;\n                    valid_out <= 0;\n                end\n            end else begin\n                count <= 0;\n                valid_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg                 valid_in_d;\n    reg     [7:0]       data_in_d;\n    reg                 u_valid_output_valid;\n    reg     [9:0]       u_data_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_in_d <= 0;\n            valid_in_d <= 0;\n            u_valid_output_valid <= 0;\n            u_data_out <= 0;\n        end else begin\n            data_in_d <= data_in;\n            valid_in_d <= valid_in;\n            u_valid_output_valid <= valid_in_d;\n            if (u_valid_output_valid) begin\n                u_data_out <= u_data_out + data_in_d;\n            end\n        end\n    end\n\n    assign valid_out = u_valid_output_valid;\n    assign data_out = u_data_out;\n\nendmodule\n\nmodule u_valid"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    // Prepare inputs for division\n    prep_dividend prep_div (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [31:0] divisor  // 32-bit divisor\n);\n    assign dividend = {16'd0, A}; // Change width of dividend\n    assign divisor = {16'd0, B}; // Change width of divisor\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    integer i;\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    always @(*) begin\n        quotient = 32'b0;\n        remainder = dividend;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = quotient << 1;\n                quotient = quotient | 1'b1;\n            end else begin\n                quotient = quotient << 1;\n                quotient = quotient | 1'b0;\n            end\n\n            remainder = remainder << 1;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    always @(*) begin\n        quotient = 16'd0;\n        remainder = A;\n\n        // Looping logic\n        for (integer i = 0; i < 16; i = i + 1) begin\n            if (remainder >= B) begin\n                quotient = quotient << 1;\n                quotient = quotient + 16'd1;\n                remainder = remainder - B;\n            end else begin\n                quotient = quotient << 1;\n            end\n            remainder = remainder << 1;\n        end\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_not, B_inverted;\nwire [7:0] D_temp;\nwire [7:0] carry;\nwire B_out_temp;\n\nnot (B_not, B);\nand (B_inverted[0], B_not[0], A[0]);\ngenvar i;\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin: full_adder_loop\n        assign B_inverted[i] = ~B[i] & A[i];\n        and (carry[i], B_not[i], A[i]);\n        or (D_temp[i], B_inverted[i], carry[i]);\n    end\nendgenerate\n\nor (B_out_temp, carry[7], B_not[7]);\nassign D = D_temp;\nassign B_out = B_out_temp;\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] carry;\nwire B_out_temp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin: full_adder_loop\n        assign carry[i] = B[i] ^ A[i];\n        assign D[i] = carry[i] ^ A[i];\n    end\nendgenerate\n\nor (B_out_temp, carry[7], B_not[7]);\nassign B_out = B_out_temp;\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff_16bit;\nwire B_out_16bit;\n\nsub_16bit sub_16bit_inst1 (A[15:0], B[15:0], Diff_16bit, B_out_16bit);\nsub_16bit sub_16bit_inst2 (A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [8:0] Diff_8bit;\nwire B_out_8bit;\n\nsub_8bit sub_8bit_inst1 (A[7:0], B[7:0], Diff_8bit, B_out_8bit);\nsub_8bit sub_8bit_inst2 (A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [4:0] Diff_4bit;\nwire B_out_4bit;\n\nsub_4bit sub_4bit_inst1 (A[3:0], B[3:0], Diff_4bit, B_out_4bit);\nsub_4bit sub_4bit_inst2 (A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [2:0] Diff_2bit;\nwire B_out_2bit;\n\nsub_2bit sub_2bit_inst1 (A[1:0], B[1:0], Diff_2bit, B_out_2bit);\nsub_2bit sub_2bit_inst2 (A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nassign Diff[1:0] = A[1:0] - B[1:0];\nassign B_out = (A[1] < B[1]) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = (A[63] ^ B[63]) ? 1'b0 : (A[63] ^ D[63]);\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = (B0 & B1);\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = (B0 & B1);\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = (A[7] ^ B[7]) ? 1'b0 : (A[7] ^ D[7]);\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1]  D_0, D_1, D_2, D_3;\nwire [3:1]  B_0, B_1, B_2, B_3;\nwire        B_out;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire borrow;\n\n// Comparison Logic\nassign subtraction_result = A - B;\nassign borrow = (A < B);\nassign A_greater = ~borrow & (subtraction_result != 0);\nassign A_equal = (A == B);\nassign A_less = borrow;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input wire [32:1] A, B;\n    output wire [32:1] S;\n    output wire C32;\n    \n    wire [15:1] C16;\n    \n    CLA1 CLA1(.A(A[16:1]), .B(B[16:1]), .S(S[16:1]), .C32(C16[1]));\n    CLA2 CLA2(.A(A[32:17]), .B(B[32:17]), .S(S[32:17]), .C32(C16[2]));\n    \n    assign C32 = C16[1] | C16[2];\nendmodule\n\nmodule CLA1(A,B,S,C32);\n    input wire [15:1] A, B;\n    output wire [15:1] S;\n    output wire C32;\n    \n    wire [7:1] C8;\n    \n    CLA1 CLA1(.A(A[7:3]), .B(B[7:3]), .S(S[7:3]), .C32(C8[1]));\n    CLA2 CLA2(.A(A[15:8]), .B(B[15:8]), .S(S[15:8]), .C32(C8[2]));\n    \n    assign C32 = C8[1] | C8[2];\nendmodule\n\nmodule CLA2(A,B,S,C32);\n    input wire [7:1] A, B;\n    output wire [7:1] S;\n    output wire C32;\n    \n    wire [3:1] C4;\n    \n    CLA1 CLA1(.A(A[3:1]), .B(B[3:1]), .S(S[3:1]), .C32(C4[1]));\n    CLA2 CLA2(.A(A[7:4]), .B(B[7:4]), .S(S[7:4]), .C32(C4[2]));\n    \n    assign C32 = C4[1] | C4[2];\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_cout[1:0];\nwire [3:0] csa_sum[1:0];\n\nwire [3:0] sum1, sum2, sum3;\nwire [1:0] csa_cout1, csa_cout2;\n\n// 4-bit ripple carry adder\nwire [3:0] rca_sum;\nwire [3:0] rca_cout;\n\nassign rca_sum[0] = a[0] ^ b[0] ^ cin;\nassign rca_sum[1] = a[1] ^ b[1] ^ rca_sum[0];\nassign rca_sum[2] = a[2] ^ b[2] ^ rca_sum[1];\nassign rca_sum[3] = a[3] ^ b[3] ^ rca_sum[2];\n\nassign rca_cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;\nassign rca_cout[1] = a[1] & b[1] | a[1] & rca_sum[0] | b[1] & rca_sum[0];\nassign rca_cout[2] = a[2] & b[2] | a[2] & rca_sum[1] | b[2] & rca_sum[1];\nassign rca_cout[3] = a[3] & b[3] | a[3] & rca_sum[2] | b[3] & rca_sum[2];\n\nassign sum1 = {rca_sum[3], rca_sum[2], rca_sum[1], rca_sum[0]};\nassign csa_cout1 = {rca_cout[3], rca_cout[2], rca_cout[1], rca_cout[0]};\n\n// 4-bit carry select adder\nassign sum2[0] = csa_cout1[0] ? a[0] : b[0];\nassign sum2[1] = csa_cout1[1] ? a[1] : b[1];\nassign sum2[2] = csa_cout1[2] ? a[2] : b[2];\nassign sum2[3] = csa_cout1[3] ? a[3] : b[3];\n\nassign csa_cout2[0] = csa_cout1[0] ? csa_cout1[0] : csa_cout1[1];\nassign csa_cout2[1] = csa_cout1[2] ? csa_cout1[2] : csa_cout1[3];\n\nassign sum3 = {csa_cout2[1], csa_cout2[0], sum2[3], sum2[2], sum2[1], sum2[0]};\n\nassign sum = {sum3[1], sum3[0], sum3[5], sum3[4], sum3[3], sum3[2], sum3[1], sum3[0]};\nassign cout = csa_cout2[1];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nadder_16bit_csa adder0(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(cout));\nadder_16bit_csa adder1(.a(a[7:4]), .b(b[7:4]), .cin(cout), .sum(sum[7:4]), .cout(cout));\nadder_16bit_csa adder2(.a(a[11:8]), .b(b[11:8]), .cin(cout), .sum(sum[11:8]), .cout(cout));\nadder_16bit_csa adder3(.a(a[15:12]), .b(b[15:12]),"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_i;\n    \n    // Implement the 8-bit adder\n    // ...\n    \n    assign Co = Co_i[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [2:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    wire cout0, cout1, cout2, cout3, cout4, cout5, cout6, cout7;\n    \n    // Full adder (FA)\n    assign {cout0, sum[0]} = a[0] + b[0] + cin;\n    assign {cout1, sum[1]} = a[1] + b[1] + cout0;\n    assign {cout2, sum[2]} = a[2] + b[2] + cout1;\n    assign {cout3, sum[3]} = a[3] + b[3] + cout2;\n    assign {cout4, sum[4]} = a[4] + b[4] + cout3;\n    assign {cout5, sum[5]} = a[5] + b[5] + cout4;\n    assign {cout6, sum[6]} = a[6] + b[6] + cout5;\n    assign {cout7, sum[7]} = a[7] + b[7] + cout6;\n    assign cout = cout7;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit Submodule.\nreg [7:0] shift_cnt;\nreg [31:0] product;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 8'h00;\n        done_reg <= 1'b0;\n        product <= 32'h00000000;\n    end else begin\n        if (start) begin\n            shift_cnt <= 8'h00;\n            done_reg <= 1'b0;\n        end else if (shift_cnt != 8'h00) begin\n            shift_cnt <= shift_cnt + 1'b1;\n            done_reg <= 1'b0;\n            if (product[15:0] == bin) begin\n                product <= product + {16'h0000, 1'b1};\n                done_reg <= 1'b1;\n            end else begin\n                product <= product << 1;\n            end\n        end else begin\n            done_reg <= 1'b1;\n        end\n    end\nend\n\n// Register Unit Submodule.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'h0000;\n        b_reg <= 16'h0000;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit Submodule.\nreg [31:0] shifted_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shifted_b <= 32'h00000000;\n    end else begin\n        if (shift_cnt != 8'h00) begin\n            shifted_b <= b_reg << shift_cnt;\n        end else begin\n            shifted_b <= b_reg;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'h00000000;\n    end else begin\n        if (start) begin\n            product <= 32'h00000000;\n        end else if (shift_cnt != 8'h00) begin\n            if (product[15:0] == shifted_b[15:0]) begin\n                product <= product + {16'h0000, 1'b1};\n            end else begin\n                product <= product << 1;\n            end\n        end else begin\n            product <= product << 16;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n// Modules\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'd0;\n    end else begin\n        count <= up_down ? count + 1 : count - 1;\n    end\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'd0;\n    end else begin\n        count <= up_down ? count + 1 : count - 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Implement the ring counter logic here\n\nendmodule\n```\n\n## 8. Verilog code for a 8-bit binary counter with a carry out\n\n```verilog\n`ifdef TEST\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output wire [7:0] out,\n        output wire carry_out\n    );\n`else\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output reg [7:0] out,\n        output reg carry_out\n    );\n`endif\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b00000001;\n            carry_out <= 1'b0;\n        end else begin\n            out <= out + 1;\n            carry_out <= (out == 8'b11111111) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule\n```\n\n## 9. Verilog code for a 16-bit binary counter with carry out\n\n```verilog\n`ifdef TEST\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output wire [15:0] out,\n        output wire carry_out\n    );\n`else\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output reg [15:0] out,\n        output reg carry_out\n    );\n`endif\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 16'b0000000000000001;\n            carry_out <= 1'b0;\n        end else begin\n            out <= out + 1;\n            carry_out <= (out == 16'b1111111111111111) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule\n```\n\n## 10. Verilog code for a 4-bit binary counter with carry out\n\n```verilog\n`ifdef TEST\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output wire [3:0] out,\n        output wire carry_out\n    );\n`else\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output reg [3:0] out,\n        output reg carry_out\n    );\n`endif\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0001;\n            carry_out <= 1'b0;\n        end else begin\n            out <= out + 1;\n            carry_out <= (out == 4'b1111) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule\n```\n\n## 11. Verilog code for a binary counter with a 2-bit binary weight\n\n```verilog\n`ifdef TEST\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output wire [1:0] out,\n        output wire carry_out\n    );\n`else\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output reg [1:0] out,\n        output reg carry_out\n    );\n`endif\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 2'b01;\n            carry_out <= 1'b0;\n        end else begin\n            out <= out + 1;\n            carry_out <= (out == 2'b11) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule\n```\n\n## 12. Verilog code for a binary counter with a 1-bit binary weight\n\n```verilog\n`ifdef TEST\n    module top_module (\n        input wire clk,\n        input wire reset,\n        output wire out,\n        output wire carry_out\n    );\n`else\n   "}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'd0;\n    else if (valid_count)\n        count_r <= count_r + 4'd1;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'd0;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'd0;\n        else\n            count_r <= count_r + 4'd1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'd0;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nreg [63:0] Q_reg;\n\n// JC_register\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        Q_reg <= 64'h0000000000000000;\n    else\n        Q_reg <= Q_reg + 1;\nend\n\n// JC_logic\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        Q <= 64'h0000000000000000;\n    else\n        Q <= Q_reg[0] ? Q_reg : Q;\nend\n\nendmodule\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]        D,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        Q_reg <= 64'h0000000000000000;\n    else\n        Q_reg <= D;\nend\n\nassign Q = Q_reg;\n\nendmodule\nmodule JC_logic(\n    input [63:0]        D,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(*)\nbegin\n    Q_reg = D[0] ? D : Q_reg;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\n\nmodule JC_counter (\n    input clk,\n    input rst_n,\n    output reg [63:0] Q\n);\n\nwire [63:0] D;\n\n// Register\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q <= 64'h0000000000000000;\n    else\n        Q <= D[63:0];\nend\n\n// Logic\nassign D = {Q[62:0], Q[63]};\n\nendmodule\n\n\nmodule JC_register (\n    input clk,\n    input rst_n,\n    input [63:0] D,\n    output reg [63:0] Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q <= 64'h0000000000000000;\n    else\n        Q <= D;\nend\n\nendmodule\n\nmodule JC_logic (\n    input [63:0] D,\n    output reg [63:0] Q\n);\n\nalways @(*) begin\n    Q = D[63] ? D : Q;\nend\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire RST_n;\n    assign RST_n = ~RST;\n\n    reg [1:0] counter_50;\n    reg [3:0] counter_10;\n    reg [4:0] counter_1;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter_50 <= 0;\n            counter_10 <= 0;\n            counter_1 <= 0;\n        end else begin\n            if (counter_50 == 2) begin\n                counter_50 <= 0;\n            end else begin\n                counter_50 <= counter_50 + 1;\n            end\n\n            if (counter_10 == 4) begin\n                counter_10 <= 0;\n            end else begin\n                counter_10 <= counter_10 + 1;\n            end\n\n            if (counter_1 == 49) begin\n                counter_1 <= 0;\n            end else begin\n                counter_1 <= counter_1 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = counter_50[1];\n    assign CLK_10 = counter_10[3];\n    assign CLK_1 = counter_1[4];\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [0:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[0];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 3) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[2];\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [4:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 49) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[4];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_int1, clk_div_int2;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK-1:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) counter <= {MUL2_DIV_CLK{1'b0}};\n    else counter <= counter + 1;\nend\n\n// Clock Average Generator Submodule\nreg [MUL2_DIV_CLK-1:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) clk_average <= {MUL2_DIV_CLK{1'b0}};\n    else clk_average <= counter;\nend\n\n// Clock Adjustment Submodule\nreg [MUL2_DIV_CLK-1:0] clk_adjustment;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) clk_adjustment <= {MUL2_DIV_CLK{1'b0}};\n    else clk_adjustment <= clk_average;\nend\n\nassign clk_div_int1 = counter[MUL2_DIV_CLK-1] & counter[MUL2_DIV_CLK-2];\nassign clk_div_int2 = counter[MUL2_DIV_CLK-2] & counter[MUL2_DIV_CLK-3];\n\nassign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_edge_counter;\nreg [3:0] neg_edge_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_edge_counter < NUM_DIV - 1) begin\n        pos_edge_counter <= pos_edge_counter + 1;\n        clk_div1 <= 0;\n    end else begin\n        pos_edge_counter <= 0;\n        clk_div1 <= 1;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_edge_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_edge_counter < NUM_DIV - 1) begin\n        neg_edge_counter <= neg_edge_counter + 1;\n        clk_div2 <= 0;\n    end else begin\n        neg_edge_counter <= 0;\n        clk_div2 <= 1;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 2;\n\n    // Counter submodule\n    reg [3:0] counter_q;\n    reg [3:0] counter_n;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_q <= 0;\n        end else begin\n            counter_q <= counter_n;\n        end\n    end\n\n    always @(*) begin\n        counter_n = counter_q + 1;\n    end\n\n    // Clock divider submodule\n    reg div_clk_q;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            div_clk_q <= 0;\n        end else begin\n            div_clk_q <= ~div_clk_q;\n        end\n    end\n\n    assign clk_div = div_clk_q;\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] a_ = a, b_ = b;\n    wire [31:0] r_;\n    wire carry_;\n    wire zero_;\n    wire negative_;\n    wire overflow_;\n    wire flag_;\n    \n    wire [31:0] result;\n    wire [31:0] result_add;\n    wire [31:0] result_sub;\n    \n    wire [31:0] result_and;\n    wire [31:0] result_or;\n    wire [31:0] result_xor;\n    wire [31:0] result_nor;\n    \n    wire [31:0] result_sll;\n    wire [31:0] result_srl;\n    wire [31:0] result_sra;\n    \n    wire [31:0] result_slt;\n    wire [31:0] result_sltu;\n    \n    wire [31:0] result_lui;\n    \n    // add\n    add addu (\n        .a(a_),\n        .b(b_),\n        .r(result_add)\n    );\n    // sub\n    sub subu (\n        .a(a_),\n        .b(b_),\n        .r(result_sub)\n    );\n    \n    // and\n    and and1 (\n        .a(a_),\n        .b(b_),\n        .r(result_and)\n    );\n    // or\n    or or1 (\n        .a(a_),\n        .b(b_),\n        .r(result_or)\n    );\n    // xor\n    xor xor1 (\n        .a(a_),\n        .b(b_),\n        .r(result_xor)\n    );\n    // nor\n    nor nor1 (\n        .a(a_),\n        .b(b_),\n        .r(result_nor)\n    );\n    \n    // sll\n    sll sll1 (\n        .a(a_),\n        .b(b_),\n        .r(result_sll)\n    );\n    // srl\n    srl srl1 (\n        .a(a_),\n        .b(b_),\n        .r(result_srl)\n    );\n    // sra\n    sra sra1 (\n        .a(a_),\n        .b(b_),\n        .r(result_sra)\n    );\n    \n    // slt\n    slt slt1 (\n        .a(a_),\n        .b(b_),\n        .r(result_slt)\n    );\n    // sltu\n    sltu sltu1 (\n        .a(a_),\n        .b(b_),\n        .r(result_sltu)\n    );\n    \n    // lui\n    lui lui1 (\n        .a(a_),\n        .b(b_),\n        .r(result_lui)\n    );\n    \n    // select operation\n    assign r = (aluc == 6'b100000) ? result_add :\n               (aluc == 6'b100001) ? result_add :\n               (aluc == 6'b100010) ? result_sub :\n               (aluc == 6'b100011) ? result_sub :\n               (aluc == 6'b100100) ? result_and :\n               (aluc == 6'b100101) ? result_or :\n               (aluc == 6'b100110) ? result_xor :\n               (aluc == 6'b100111) ? result_nor :\n               (aluc == 6'b000000) ? result_sll :\n               (aluc == 6'b000010) ? result_srl :\n               (aluc == 6'b000011) ? result_sra :\n               (aluc == 6'b000100) ? result_sll :\n               (aluc == 6'b"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n// Multiplier Submodule\nwire [31:0] u_multiplier_result;\nwire [31:0] u_accumulator_result;\n\n// Accumulator Submodule\nreg [31:0] current_value;\n\n// Interconnect\nassign c = u_accumulator_result;\n\n// Submodules\npe_multiplier u_multiplier (\n    .clk(clk),\n    .rst(rst),\n    .a(a),\n    .b(b),\n    .result(u_multiplier_result)\n);\n\npe_accumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .result(u_multiplier_result),\n    .current_value(current_value)\n);\n\nendmodule\n\nmodule pe_multiplier (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    reg [63:0] result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result_reg <= 0;\n        end else begin\n            result_reg <= a * b;\n        end\n    end\n\n    assign result = result_reg[31:0];\nendmodule\n\nmodule pe_accumulator (\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Ins1\n    // -----------------\n    assign ins_p1 = ins_p1 + 1;\n    assign ad1_p1 = ad1_p1 + 1;\n    assign ad2_p1 = ad2_p1 + 1;\n\n    // Ins2\n    // -----------------\n    assign ins_p2 = ins_p2 + 1;\n    assign ad1_p2 = ad1_p2 + 1;\n    assign ad2_p2 = ad2_p2 + 1;\n\n    // Output\n    // -----------------\n    assign ins = {ins_p1, ins_p2};\n    assign ad1 = {ad1_p1, ad1_p2};\n    assign ad2 = {ad2_p1, ad2_p2};\n\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nreg [7:0] count = 0;\nwire enable = (freq > 0);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nassign wave_out = (count == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [4:0] wave_reg;\n    reg [1:0] state_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave_reg <= 5'b0;\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    if (wave_reg == 5'd31)\n                        state_reg <= 2'b01;\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0)\n                        state_reg <= 2'b00;\n                    wave_reg <= wave_reg - 1;\n                end\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\n    \nendmodule\n\nmodule state_inst(\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state_reg;\n        end\n    end\n    \n    assign state = state_reg;\n    \nendmodule\n\nmodule wave_inst(\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [4:0] wave_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave_reg <= 5'b0;\n        end else begin\n            if (wave_reg == 5'd31)\n                wave_reg <= 5'd0;\n            else if (wave_reg == 5'd0)\n                wave_reg <= wave;\n            else if (wave_reg == wave)\n                wave_reg <= wave_reg + 1;\n            else if (wave_reg == wave_reg - 1)\n                wave_reg <= wave_reg - 1;\n        end\n    end\n    \nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    // 8-bit D flip-flop\n    reg [7:0] u0_d, u0_q;\n    always @(posedge clk) begin\n        u0_d <= d;\n        u0_q <= u0_d;\n    end\n\n    // 8-bit D flip-flop\n    reg [7:0] u1_d, u1_q;\n    always @(posedge clk) begin\n        u1_d <= u0_q;\n        u1_q <= u1_d;\n    end\n\n    // 8-bit D flip-flop\n    reg [7:0] u2_d, u2_q;\n    always @(posedge clk) begin\n        u2_d <= u1_q;\n        u2_q <= u2_d;\n    end\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= u0_q;\n            2'b01: q <= u1_q;\n            2'b10: q <= u2_q;\n            2'b11: q <= d;\n            default: q <= 8'b0;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    my_dff8 my_dff8_inst0 (.clk(clk), .d(d), .q(u0_q));\n    my_dff8 my_dff8_inst1 (.clk(clk), .d(u0_q), .q(u1_q));\n    my_dff8 my_dff8_inst2 (.clk(clk), .d(u1_q), .q(u2_q));\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= u0_q;\n            2'b01: q <= u1_q;\n            2'b10: q <= u2_q;\n            2'b11: q <= d;\n            default: q <= 8'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2;\n\n    my_dff dff0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\n```\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output reg [7:0] out;\n    wire [7:0] stage1, stage2, stage3;\n    wire [3:0] sel;\n\n    assign sel[0] = ctrl[2];\n    assign sel[1] = ctrl[1];\n    assign sel[2] = ctrl[0];\n\n    // Stage 1\n    assign stage1 = (sel[2]) ? {in[1:0], in[7:2]} : in;\n    // Stage 2\n    assign stage2 = (sel[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    // Stage 3\n    assign stage3 = (sel[0]) ? {stage2[1:0], stage2[7:2]} : stage2;\n    assign out = stage3;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'd0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  wire [31:0] pe0 = a0 + (b0 << 16);\n  wire [31:0] pe1 = a1 + (b1 << 16);\n\n  assign c0 = pe0;\n  assign c1 = pe1;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  reg [31:0] pipeline_reg [0:4];\n  reg [31:0] pc;\n\n  wire [31:0] res;\n\n  assign res_reg_file = pipeline_reg[4];\n\n  fetch_stage fetch_stage0 (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .res(pipeline_reg[0])\n  );\n\n  decode_stage decode_stage0 (\n    .clk(clk),\n    .rst(rst),\n    .res(pipeline_reg[0]),\n    .reg_file(reg_file),\n    .res_reg_file(pipeline_reg[1])\n  );\n\n  execute_stage execute_stage0 (\n    .clk(clk),\n    .rst(rst),\n    .res(pipeline_reg[1]),\n    .reg_file(reg_file),\n    .res_reg_file(pipeline_reg[2])\n  );\n\n  memory_stage memory_stage0 (\n    .clk(clk),\n    .rst(rst),\n    .res(pipeline_reg[2]),\n    .res_reg_file(pipeline_reg[3])\n  );\n\n  writeback_stage writeback_stage0 (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(pipeline_reg[3]),\n    .res_reg_file(pipeline_reg[4])\n  );\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 0;\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n      pipeline_reg[3] <= 0;\n      pipeline_reg[4] <= 0;\n    end else begin\n      pipeline_reg[0] <= pipeline_reg[0];\n      pipeline_reg[1] <= pipeline_reg[1];\n      pipeline_reg[2] <= pipeline_reg[2];\n      pipeline_reg[3] <= pipeline_reg[3];\n      pipeline_reg[4] <= pipeline_reg[4];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule fetch_stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] res\n);\n  reg [31:0] pipeline_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pipeline_reg <= 0;\n    end else begin\n      pipeline_reg <= instr_mem[pc];\n    end\n  end\n\n  assign res = pipeline_reg;\nendmodule\n\nmodule decode_stage (\n  input clk,\n  input rst,\n  input [31:0] res,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] pipeline_reg [0:2];\n\n  wire [4:0] rs1, rs2, rd;\n  wire [1:0] op;\n\n  assign rs1 = res[31:27];\n  assign rs2 = res[26:22];\n  assign rd = res[20:16];\n  assign op = res[5:4];\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pipeline_reg[0] <= 0;\n      pipeline_reg[1] <= 0;\n      pipeline_reg[2] <= 0;\n    end else begin\n      pipeline_reg[0] <= rs1;\n      pipeline_reg[1] <= rs2;\n      pipeline_reg[2] <= rd;\n    end\n  end\n\n  assign res_reg_file[0] = pipeline_reg[0];\n  assign res_reg_file[1] = pipeline_reg[1];\n  assign res_reg_file[2] ="}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [15:0] pe0, pe1, pe2, pe3;\n  reg [31:0] pe0_out, pe1_out, pe2_out, pe3_out;\n  reg [31:0] pe0_reg, pe1_reg, pe2_reg, pe3_reg;\n  reg [15:0] pe0_a, pe1_a, pe2_a, pe3_a;\n  reg [15:0] pe0_b, pe1_b, pe2_b, pe3_b;\n  \n  always @(posedge clk) begin\n    if(rst) begin\n      pe0_reg <= 32'b0;\n      pe1_reg <= 32'b0;\n      pe2_reg <= 32'b0;\n      pe3_reg <= 32'b0;\n      pe0_out <= 32'b0;\n      pe1_out <= 32'b0;\n      pe2_out <= 32'b0;\n      pe3_out <= 32'b0;\n      pe0_a <= 16'b0;\n      pe1_a <= 16'b0;\n      pe2_a <= 16'b0;\n      pe3_a <= 16'b0;\n      pe0_b <= 16'b0;\n      pe1_b <= 16'b0;\n      pe2_b <= 16'b0;\n      pe3_b <= 16'b0;\n    end else begin\n      pe0_reg <= pe0_out;\n      pe1_reg <= pe1_out;\n      pe2_reg <= pe2_out;\n      pe3_reg <= pe3_out;\n      pe0_a <= a0;\n      pe1_a <= pe0_out[15:0];\n      pe2_a <= pe1_out[15:0];\n      pe3_a <= pe2_out[15:0];\n      pe0_b <= b0;\n      pe1_b <= pe0_out[15:0];\n      pe2_b <= pe1_out[15:0];\n      pe3_b <= pe2_out[15:0];\n    end\n  end\n\n  always @(posedge clk) begin\n    pe0 <= a0*b0;\n    pe1 <= pe0_a*pe0_b;\n    pe2 <= pe1_a*pe1_b;\n    pe3 <= pe2_a*pe2_b;\n  end\n\n  assign c0 = pe0_reg;\n  assign c1 = pe1_reg;\n  assign c2 = pe2_reg;\n  assign c3 = pe3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] fetch_out;\nwire [31:0] execute_out;\nwire [31:0] writeback_out;\nwire [31:0] pc;\n\nstagepipe3_submodule fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .out(fetch_out),\n    .pc(pc)\n);\n\nstagepipe3_submodule execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .reg_file(reg_file),\n    .out(execute_out)\n);\n\nstagepipe3_submodule writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(execute_out),\n    .reg_file(reg_file),\n    .out(writeback_out)\n);\n\nassign out_reg_file = writeback_out;\n\nendmodule\n\nmodule stagepipe3_submodule (\n    input clk,\n    input rst,\n    input [31:0] instr [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out,\n    output [31:0] pc\n);\n\nreg [31:0] fetch_out;\nreg [31:0] execute_out;\nreg [31:0] writeback_out;\nreg [31:0] pc_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        fetch_out <= 32'd0;\n        execute_out <= 32'd0;\n        writeback_out <= 32'd0;\n        pc_reg <= 32'd0;\n    end else begin\n        fetch_out <= instr[pc_reg];\n        execute_out <= reg_file[instr[pc_reg][20:16]] + reg_file[instr[pc_reg][15:11]];\n        writeback_out <= execute_out;\n        pc_reg <= pc_reg + 32'd4;\n    end\nend\n\nassign out = fetch_out;\nassign pc = pc_reg;\n\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nparameter CNT_WIDTH = 4;\n\n// Counter Module\nreg [CNT_WIDTH-1:0] cnt_reg;\nreg [CNT_WIDTH-1:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt_reg <= {CNT_WIDTH{1'b0}};\n    else        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    cnt_next = cnt_reg;\n\n    if (valid_in) cnt_next = cnt_reg + 1'b1;\nend\n\nassign valid_out = cnt_reg == {CNT_WIDTH{1'b1}};\n\n// Data Accumulator Module\nreg [9:0] data_accum_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) data_accum_reg <= 10'h000;\n    else        data_accum_reg <= data_accum_next;\nend\n\nalways @(*) begin\n    data_accum_next = data_accum_reg;\n\n    if (valid_in) data_accum_next = data_accum_reg + data_in;\nend\n\nassign data_out = data_accum_reg;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n\n    output              valid_out,\n    output      [3:0]   count\n);\n\nparameter CNT_WIDTH = 4;\n\n// Counter Module\nreg [CNT_WIDTH-1:0] cnt_reg;\nreg [CNT_WIDTH-1:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt_reg <= {CNT_WIDTH{1'b0}};\n    else        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    cnt_next = cnt_reg;\n\n    if (cnt_reg == {CNT_WIDTH{1'b1}}) cnt_next = 4'h0;\n    else                             cnt_next = cnt_reg + 1'b1;\nend\n\nassign valid_out = cnt_reg == {CNT_WIDTH{1'b1}};\n\n// Data Accumulator Module\nassign count = cnt_reg;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n// Data Accumulator Module\nreg [9:0] data_accum_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) data_accum_reg <= 10'h000;\n    else        data_accum_reg <= data_accum_next;\nend\n\nalways @(*) begin\n    data_accum_next = data_accum_reg;\n\n    if (valid_in) data_accum_next = data_accum_reg + data_in;\nend\n\nassign valid_out = valid_in;\nassign data_out = data_accum_reg;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n\n    input       [3:0]   count,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n// Valid Output Module\nreg [9:0] data_out_reg;\nreg valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out_reg <= 10'h000;\n        valid_out_reg <= 1'b0;\n    end\n    else begin\n        data_out_reg <= data_out_next;\n       "}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    \n    // Implementation of radix-2 divider goes here\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (opn_valid && !res_ready) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\n    \n    always @(*) begin\n        result = {remainder[15:8], quotient[15:8]};\n    end\n    \nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Submodule: prep_dividend\n// Prepares the dividend and divisor to be 16-bit and 32-bit, respectively,\n// and outputs them in a packed format.\n\n// Submodule: div_operation\n// Performs the division operation using the shift-and-compare method.\n\n// Instantiate the two submodules\nprep_dividend pdiv(\n    .A(A),\n    .B(B),\n    .odd(odd),\n    .prep(prep)\n);\n\ndiv_operation dop(\n    .A(prep[31:0]), // Use only the 32-bit part\n    .B(prep[47:32]), // Use only the 16-bit part\n    .odd(odd),\n    .result(result)\n);\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [63:0] odd,\n    output wire [39:0] prep\n);\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] odd,\n    output wire [31:0] result\n);\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    module control_unit (\n        input wire [15:0] dividend,\n        input wire [7:0] divisor,\n        output reg [15:0] quotient,\n        output reg [15:0] remainder\n    );\n\n        // Bit shift the dividend\n        reg [15:0] temp_dividend;\n        always @(*) begin\n            temp_dividend = dividend;\n            quotient = 16'b0;\n            remainder = 16'b0;\n        end\n\n        // Perform division algorithm\n        integer i;\n        always @(*) begin\n            for (i = 0; i < 16; i = i + 1) begin\n                // Check if divisor is greater than or equal to temp_dividend\n                if (divisor >= temp_dividend) begin\n                    // Update quotient and remainder\n                    quotient[15 - i] = 1;\n                    temp_dividend = temp_dividend - divisor;\n                    remainder = remainder + (1 << i);\n                end\n                // Shift temp_dividend\n                temp_dividend = temp_dividend << 1;\n            end\n        end\n    endmodule\n\n    // Connect input and output ports to control unit\n    control_unit ctrl_unit (\n        .dividend(A),\n        .divisor(B),\n        .quotient(result),\n        .remainder(odd)\n    );\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\nwire [7:0] B_inv;\nwire [7:0] temp;\nwire [3:0] i;\n\nassign B_inv = ~B;\nassign temp = A + B_inv;\n\nalways @(*)\nbegin\n    D[7] = temp[7];\n    B_out = temp[7];\n    for (i = 6; i >= 0; i = i - 1)\n    begin\n        D[i] = temp[i] ^ B_out;\n        B_out = (temp[i] & B_out) | (B_out & temp[i]);\n    end\nend\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\nwire [7:0] B_inv;\nwire [7:0] temp;\nwire [3:0] i;\n\nassign B_inv = ~B;\nassign temp = A + B_inv;\n\nalways @(*)\nbegin\n    D[7] = temp[7];\n    B_out = temp[7];\n    for (i = 6; i >= 0; i = i - 1)\n    begin\n        D[i] = temp[i] ^ B_out;\n        B_out = (temp[i] & B_out) | (B_out & temp[i]);\n    end\nend\n\nendmodule\n\nmodule full_adder(A, B, Cin, D, Cout);\ninput A, B, Cin;\noutput D, Cout;\n\nassign D = A ^ B ^ Cin;\nassign Cout = (A & B) | (B & Cin) | (A & Cin);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [15:0] A1;\nwire [15:0] B1;\nwire [15:0] D1;\nwire [7:0] A2;\nwire [7:0] B2;\nwire [7:0] D2;\nwire [3:0] A3;\nwire [3:0] B3;\nwire [3:0] D3;\nwire [1:0] A4;\nwire [1:0] B4;\nwire [1:0] D4;\nwire [0:0] A5;\nwire [0:0] B5;\nwire [0:0] D5;\n\n// Replace the submodule instantiations with direct definition\n// of the 32-bit subtractor, 16-bit subtractor, and 8-bit subtractor\n\nwire [31:0] B_out_0;\nwire [31:0] B_out_1;\nwire [15:0] B_out_2;\nwire [7:0] B_out_3;\nwire [3:0] B_out_4;\nwire [1:0] B_out_5;\nwire [0:0] B_out_6;\n\nassign B_out = B_out_0 | B_out_1 | B_out_2 | B_out_3 | B_out_4 | B_out_5 | B_out_6;\n\nassign D[63:32] = D1;\nassign D[31:0] = D2;\nassign D[15:8] = D3;\nassign D[7:0] = D4;\nassign D[3:0] = D5;\n\nassign B_out_0 = B[31:0] ? B[31:0] : 1'b0;\nassign B_out_1 = B[15:0] ? B[15:0] : 1'b0;\nassign B_out_2 = B[7:0] ? B[7:0] : 1'b0;\nassign B_out_3 = B[3:0] ? B[3:0] : 1'b0;\nassign B_out_4 = B[1:0] ? B[1:0] : 1'b0;\nassign B_out_5 = B[0] ? B[0] : 1'b0;\nassign B_out_6 = B[0] ? B[0] : 1'b0;\n\nassign D1[15:0] = A[63:48] - B[63:48];\nassign D1[31:16] = A[47:16] - B[47:16];\n\nassign D2[7:0] = A[15:8] - B[15:8];\nassign D2[15:8] = A[7:0] - B[7:0];\n\nassign D3[3:0] = A[3:0] - B[3:0];\nassign D3[7:4] = A[3:0] - B[3:0];\n\nassign D4[1:0] = A[1:0] - B[1:0];\nassign D4[3:2] = A[1:0] - B[1:0];\n\nassign D5[0] = A[0] - B[0];\nassign D5[2] = A[0] - B[0];\n\nendmodule\n"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13, D14, D15;\nwire [3:1] A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15;\nwire [3:1] B_out;\n\nassign B_out[1:1] = B1[1:1] & ~B2[1:1] & B3[1:1] & ~B4[1:1] & B5[1:1] & ~B6[1:1] & ~B7[1:1] & B8[1:1] & ~B9[1:1] & ~B10[1:1] & ~B11[1:1] & B12[1:1] & ~B13[1:1] & B14[1:1] & B15[1:1];\n\nassign D1[1:1] = A1[1:1] - B1[1:1];\nassign D2[1:1] = A2[1:1] - B2[1:1];\nassign D3[1:1] = A3[1:1] - B3[1:1];\nassign D4[1:1] = A4[1:1] - B4[1:1];\nassign D5[1:1] = A5[1:1] - B5[1:1];\nassign D6[1:1] = A6[1:1] - B6[1:1];\nassign D7[1:1] = A7[1:1] - B7[1:1];\nassign D8[1:1] = A8[1:1] - B8[1:1];\nassign D9[1:1] = A9[1:1] - B9[1:1];\nassign D10[1:1] = A10[1:1] - B10[1:1];\nassign D11[1:1] = A11[1:1] - B11[1:1];\nassign D12[1:1] = A12[1:1] - B12[1:1];\nassign D13[1:1] = A13[1:1] - B13[1:1];\nassign D14[1:1] = A14[1:1] - B14[1:1];\nassign D15[1:1] = A15[1:1] - B15[1:1];\n\nassign D[16:1] = {D15[1:1], D14[1:1], D13[1:1], D12[1:1], D11[1:1], D10[1:1], D9[1:1], D8[1:1], D7[1:1], D6[1:1], D5[1:1], D4[1:1], D3[1:1], D2[1:1], D1[1:1]};\n\nassign A1[1:1] = A[16:16];\nassign A2[1:1] = A[15:15];\nassign A3[1:1] = A[14:14];\nassign A4[1:1] = A[13:13];\nassign A5[1:1] = A[12:12];\nassign A6[1:1] = A[11:11];\nassign A7[1:1] = A[10:10];\nassign A8[1:1] = A[9:9];\nassign A"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] sub_result;\n    wire carry;\n    \n    // Subtraction module\n    assign sub_result = A - B;\n    assign carry = (sub_result[31] == 0);\n    \n    // Comparator module\n    assign A_greater = carry;\n    assign A_equal = (sub_result == 0);\n    assign A_less = (sub_result[31] == 1);\n    \nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] AC[1:16];\nwire [15:1] BC[1:16];\nwire [15:1] SC[1:16];\nwire [15:1] CC[1:16];\nwire [15:1] CC4[1:16];\nwire [15:1] CC8[1:16];\nwire [15:1] CC16[1:16];\nwire [15:1] CC32[1:16];\nwire [15:1] CC64[1:16];\nwire [15:1] CC128[1:16];\n\nassign S[16:1] = SC[1:16];\nassign C32 = CC32[16];\n\ngenvar i;\ngenerate\n    for(i=1; i<=16; i=i+1)\n    begin:C16\n        assign AC[i] = A[2*i];\n        assign BC[i] = B[2*i];\n        assign CC[i] = CC[i-1] ^ AC[i];\n        assign CC4[i] = CC[i] ^ CC[i-1];\n        assign CC8[i] = CC4[i] ^ CC4[i-1];\n        assign CC16[i] = CC8[i] ^ CC8[i-1];\n        assign CC32[i] = CC16[i] ^ CC16[i-1];\n        assign CC64[i] = CC32[i] ^ CC32[i-1];\n        assign CC128[i] = CC64[i] ^ CC64[i-1];\n        assign SC[i] = CC128[i] ^ BC[i];\n    end\nendgenerate\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_bit;\n    wire [3:0] rca1, rca2, rca3;\n    wire [1:0] csa1, csa2;\n\n    ripple_carry_adder rca1_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .cout(carry[0]),\n        .sum(rca1)\n    );\n\n    ripple_carry_adder rca2_inst (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .cout(carry[1]),\n        .sum(rca2)\n    );\n\n    ripple_carry_adder rca3_inst (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .cout(carry[2]),\n        .sum(rca3)\n    );\n\n    carry_select_adder csa1_inst (\n        .a(rca1),\n        .b(rca2),\n        .cin(carry[2]),\n        .sum(sum_bit[0]),\n        .cout(carry[3])\n    );\n\n    carry_select_adder csa2_inst (\n        .a(rca3),\n        .b(a[15:12]),\n        .cin(carry[3]),\n        .sum(sum_bit[1]),\n        .cout(cout)\n    );\n\n    assign sum = {sum_bit[1], sum_bit[0]};\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, cout, sum);\n    input [3:0] a, b;\n    input cin;\n    output cout;\n    output [3:0] sum;\n\n    wire [4:0] temp;\n\n    assign temp[0] = a[0] ^ b[0];\n    assign temp[1] = a[1] ^ b[1];\n    assign temp[2] = a[2] ^ b[2];\n    assign temp[3] = a[3] ^ b[3];\n    assign temp[4] = cin;\n\n    assign sum = temp[0] ^ temp[1] ^ temp[2] ^ temp[3] ^ temp[4];\n    assign cout = (a[3] & b[3]) | (a[3] & temp[4]) | (b[3] & temp[4]);\nendmodule\n\nmodule carry_select_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [2:0] carry;\n    wire [2:0] sum_bit;\n\n    ripple_carry_adder rca1_inst (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .cin(cin),\n        .cout(carry[0]),\n        .sum(sum_bit[0])\n    );\n\n    ripple_carry_adder rca2_inst (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .cin(carry[0]),\n        .cout(carry[1]),\n        .sum(sum_bit[1])\n    );\n\n    assign sum = {sum_bit[1], sum_bit[0]};\n    assign cout = carry[1];\nendmodule\n"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire C1, C2, C3, C4, C5, C6, C7, C8;\n    wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire [7:0] C0, C1_, C2_, C3_, C4_, C5_, C6_, C7_;\n    wire [7:0] Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    assign C1 = a[0] ^ b[0];\n    assign C2 = a[1] ^ b[1];\n    assign C3 = a[2] ^ b[2];\n    assign C4 = a[3] ^ b[3];\n    assign C5 = a[4] ^ b[4];\n    assign C6 = a[5] ^ b[5];\n    assign C7 = a[6] ^ b[6];\n\n    assign C0 = a[7] ^ b[7];\n    assign C1_ = C1 ^ Cin;\n    assign C2_ = C2 ^ C1_;\n    assign C3_ = C3 ^ C2_;\n    assign C4_ = C4 ^ C3_;\n    assign C5_ = C5 ^ C4_;\n    assign C6_ = C6 ^ C5_;\n    assign C7_ = C7 ^ C6_;\n\n    assign y0 = a[0] ^ b[0];\n    assign y1 = a[1] ^ b[1];\n    assign y2 = a[2] ^ b[2];\n    assign y3 = a[3] ^ b[3];\n    assign y4 = a[4] ^ b[4];\n    assign y5 = a[5] ^ b[5];\n    assign y6 = a[6] ^ b[6];\n    assign y7 = a[7] ^ b[7];\n\n    assign Co0 = a[7] ^ b[7];\n    assign Co1 = C1 ^ C0;\n    assign Co2 = C2 ^ Co1;\n    assign Co3 = C3 ^ Co2;\n    assign Co4 = C4 ^ Co3;\n    assign Co5 = C5 ^ Co4;\n    assign Co6 = C6 ^ Co5;\n    assign Co7 = C7 ^ Co6;\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7;\n    \n    // First bit adder\n    full_adder fa0_inst (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0),\n        .cout(fa1)\n    );\n    \n    // Second bit adder\n    full_adder fa1_inst (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa1),\n        .sum(fa2),\n        .cout(fa3)\n    );\n    \n    // Third bit adder\n    full_adder fa2_inst (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa3),\n        .sum(fa4),\n        .cout(fa5)\n    );\n    \n    // Fourth bit adder\n    full_adder fa3_inst (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa5),\n        .sum(fa6),\n        .cout(fa7)\n    );\n    \n    // Fifth bit adder\n    full_adder fa4_inst (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa7),\n        .sum(fa0),\n        .cout(fa5)\n    );\n    \n    // Sixth bit adder\n    full_adder fa5_inst (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa5),\n        .sum(fa1),\n        .cout(fa6)\n    );\n    \n    // Seventh bit adder\n    full_adder fa6_inst (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa6),\n        .sum(fa2),\n        .cout(fa7)\n    );\n    \n    // Eighth bit adder\n    full_adder fa7_inst (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa7),\n        .sum(sum),\n        .cout(cout)\n    );\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout\n);\n    \n    assign {cout, sum} = a + b + cin;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit submodule.\nreg [31:0] shift_count;\nreg [31:0] product;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 32'd0;\n        product <= 32'd0;\n        done_reg <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 32'd0;\n            product <= 32'd0;\n        end else begin\n            if (shift_count < 32'd16) begin\n                shift_count <= shift_count + 1;\n            end else begin\n                shift_count <= 32'd0;\n                done_reg <= 1'b1;\n            end\n        end\n    end\nend\n\n// Register Unit submodule.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit submodule.\nreg [15:0] a_shifted;\nreg [15:0] b_shifted;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_shifted <= 16'd0;\n        b_shifted <= 16'd0;\n    end else begin\n        if (shift_count < 32'd16) begin\n            a_shifted <= a_reg >> shift_count;\n            b_shifted <= b_reg >> shift_count;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n    end else begin\n        if (shift_count < 32'd16) begin\n            if (a_shifted[0] == 1'b1) begin\n                product <= product + b_shifted;\n            end\n        end else begin\n            product <= product >> 1;\n        end\n    end\nend\n\n// Output assignment.\nassign yout = product;\nassign done = done_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n// Use the standard count module for the counter logic.\n// Use the standard count register for the counter register.\n\nendmodule\n\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    assign next_count = up_down ? count + 1 : count - 1;\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output wire [15:0] count_next\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk) begin\n        if (reset)\n            count_reg <= 16'b0;\n        else\n            count_reg <= count_next;\n    end\n\n    assign count_next = count_reg;\n\nendmodule\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initializing the counter\n    submodule init (\n        input wire clk,\n        input wire reset,\n        output reg [7:0] out\n    );\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                out <= 8'b0000_0001;\n            end\n        end\n    endmodule\n\n    // Submodule for cyclic state transition\n    submodule transition (\n        input wire clk,\n        input wire reset,\n        input wire [7:0] out,\n        output reg [7:0] out\n    );\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                out <= 8'b0000_0001;\n            end else begin\n                out <= {out[6:0], out[7]};\n            end\n        end\n    endmodule\n\n    // Connect the submodules to form the ring counter\n    initial begin\n        init u_init (\n            .clk(clk),\n            .reset(reset),\n            .out(out)\n        );\n        transition u_transition (\n            .clk(clk),\n            .reset(reset),\n            .out(out),\n            .out(out)\n        );\n    end\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nassign count = count_r;\n\n// counter_logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nassign out = out_r;\n\n// output_register\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] Q_JC;\n\n// Instantiate the JC_register module\nJC_register reg_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(Q_JC)\n);\n\n// Instantiate the JC_logic module\nJC_logic logic_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q_JC(Q_JC),\n    .Q(Q)\n);\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= Q_reg + 1;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q_JC,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= {Q_JC[62:0], Q_JC[63]};\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg [1:0] count_50 = 2'b00;\nreg [1:0] count_10 = 2'b00;\nreg [2:0] count_1 = 3'b000;\n\nreg CLK_50_out = 1'b0;\nreg CLK_10_out = 1'b0;\nreg CLK_1_out = 1'b0;\n\n// Clock divider by 2\nmodule clk_div_2 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg [0:0] count = 1'b0;\n\nassign CLK_out = count[0];\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count <= 1'b0;\n    else\n        count <= count + 1'b1;\nend\n\nendmodule\n\n// Clock divider by 10\nmodule clk_div_10 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg [2:0] count = 3'b000;\n\nassign CLK_out = count[2];\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count <= 3'b000;\n    else if (count == 3'b101)\n        count <= 3'b000;\n    else\n        count <= count + 1'b1;\nend\n\nendmodule\n\n// Clock divider by 100\nmodule clk_div_100 (\n    input CLK_in,\n    output CLK_out\n);\n\nreg [2:0] count = 3'b000;\n\nassign CLK_out = count[2];\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count <= 3'b000;\n    else if (count == 3'b101)\n        count <= 3'b000;\n    else\n        count <= count + 1'b1;\nend\n\nendmodule\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter\n    MUL2_DIV_CLK       = 7; // division factor: (1/2 + 1/4 + 1/8 + ... + 1/(2^MUL2_DIV_CLK))\n\n// Counter Submodule\nreg [31:0]            counter_reg;\nreg [31:0]            counter_next;\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        counter_reg <= {MUL2_DIV_CLK+1{1'b0}};\n    end\n    else\n    begin\n        counter_reg <= counter_next;\n    end\nend\n\nassign counter_next = counter_reg + 1;\n\n// Clock Average Generator Submodule\nreg [1:0]             clk_average_reg;\nreg [1:0]             clk_average_next;\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        clk_average_reg <= {2{1'b0}};\n    end\n    else\n    begin\n        clk_average_reg <= clk_average_next;\n    end\nend\n\nassign clk_average_next = (counter_reg[MUL2_DIV_CLK-1:0] == MUL2_DIV_CLK[2:0]) ? 2'd1 : 2'd0;\n\n// Clock Adjustment Submodule\nreg [1:0]             clk_adjustment_reg;\nreg [1:0]             clk_adjustment_next;\n\nalways @ (negedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        clk_adjustment_reg <= {2{1'b0}};\n    end\n    else\n    begin\n        clk_adjustment_reg <= clk_adjustment_next;\n    end\nend\n\nassign clk_adjustment_next = {clk_average_reg[1], clk_average_reg[0]};\n\n// Final Clock Output\nassign clk_div = clk_adjustment_reg[1] | clk_adjustment_reg[0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          counter_reg\n);\n\nparameter\n    MUL2_DIV_CLK       = 7; // division factor: (1/2 + 1/4 + 1/8 + ... + 1/(2^MUL2_DIV_CLK))\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        counter_reg <= {MUL2_DIV_CLK+1{1'b0}};\n    end\n    else\n    begin\n        counter_reg <= counter_reg + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input [1:0]         clk_average_reg,\n    input [1:0]         clk_average_next,\n    input               clk,\n    output reg          clk_div\n);\n\nalways @ (posedge clk or posedge clk_average_next[1])\nbegin\n    if (clk_average_next[1])\n    begin\n        clk_div <= clk_average_reg[1] | clk_average_reg[0];\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input [1:0]         clk_adjustment_reg,\n    input [1:0]         clk_adjustment_next,\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\nalways @ (negedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        clk_div <= {clk_adjustment_reg[1], clk_adjustment_reg[0]};\n    end\n    else\n    begin\n       "}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire pos_edge_clk_div;\n    wire neg_edge_clk_div;\n\n    // POS_EDGE_COUNTER\n    reg [3:0] pos_edge_counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) pos_edge_counter <= 0;\n        else if (pos_edge_counter < NUM_DIV - 1) pos_edge_counter <= pos_edge_counter + 1;\n    end\n    assign pos_edge_clk_div = (pos_edge_counter == NUM_DIV - 1);\n\n    // NEG_EDGE_COUNTER\n    reg [3:0] neg_edge_counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) neg_edge_counter <= 0;\n        else if (neg_edge_counter < NUM_DIV - 1) neg_edge_counter <= neg_edge_counter + 1;\n    end\n    assign neg_edge_clk_div = (neg_edge_counter == NUM_DIV - 1);\n\n    assign clk_div = pos_edge_clk_div | neg_edge_clk_div;\nendmodule\n\n------------------------------------------------\n\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    localparam NUM_DIV = 4;\n    reg [3:0] counter_reg = 0;\n    reg clk_div_reg = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            counter_reg <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if(counter_reg == (NUM_DIV - 1) / 2) begin\n                counter_reg <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end else begin\n                counter_reg <= counter_reg + 1;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] r;\n    wire zero;\n    wire carry;\n    wire negative;\n    wire overflow;\n    wire flag;\n\n    wire [31:0] add_r;\n    wire [31:0] sub_r;\n    wire [31:0] and_r;\n    wire [31:0] or_r;\n    wire [31:0] xor_r;\n    wire [31:0] nor_r;\n    wire [31:0] slt_r;\n    wire [31:0] sltu_r;\n    wire [31:0] sll_r;\n    wire [31:0] srl_r;\n    wire [31:0] sra_r;\n    wire [31:0] sllv_r;\n    wire [31:0] srlv_r;\n    wire [31:0] srav_r;\n    wire [31:0] lui_r;\n\n    // submodules\n    add add_inst (\n        .r(add_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    sub sub_inst (\n        .r(sub_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    and and_inst (\n        .r(and_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    or or_inst (\n        .r(or_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    xor xor_inst (\n        .r(xor_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    nor nor_inst (\n        .r(nor_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    slt slt_inst (\n        .r(slt_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    sltu sltu_inst (\n        .r(sltu_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    sll sll_inst (\n        .r(sll_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    srl srl_inst (\n        .r(srl_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    sra sra_inst (\n        .r(sra_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        .overflow(overflow),\n        .a(a),\n        .b(b)\n    );\n\n    sllv sllv_inst (\n        .r(sllv_r),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative),\n        ."}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n//=============================================================================\n// Submodule: u_multiplier\n// Multiplier Submodule\n//=============================================================================\n\n// Multiplier Submodule Implementation\n\n//=============================================================================\n// Submodule: u_accumulator\n// Accumulator Submodule\n//=============================================================================\n\n// Accumulator Submodule Implementation\n\n//=============================================================================\n// Main Module\n//=============================================================================\n\nreg [31:0] current_value;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + u_multiplier.c;\n    end\nend\n\nassign c = current_value;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Declare submodules\n    // FIXME: Replace with actual submodules\n    // Example: ins_p1 = ins_p1_inst.ins;\n    // Example: ad1_p1 = ad1_p1_inst.ad1;\n    // Example: ad2_p1 = ad2_p1_inst.ad2;\n\n    assign ins = {ins_p1, ins_p2};\n    assign ad1 = {ad1_p1, ad1_p2};\n    assign ad2 = {ad2_p1, ad2_p2};\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1\n);\n    reg [2:0] ins_p1;\n    reg [4:0] ad1_p1;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 3'b0;\n            ad1_p1 <= 5'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1 <= data[7:5];\n            ad1_p1 <= data[4:0];\n        end\n    end\n\n    assign ins = ins_p1;\n    assign ad1 = ad1_p1;\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [7:0] ad2\n);\n    reg [2:0] ins_p2;\n    reg [7:0] ad2_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2 <= 3'b0;\n            ad2_p2 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data[7:5];\n            ad2_p2 <= data;\n        end\n    end\n\n    assign ins = ins_p2;\n    assign ad2 = ad2_p2;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable = (freq > 0);\n\n// Counter Module\nreg [7:0] count_reg = 0;\nalways @(posedge clk) begin\n    if (enable) begin\n        count_reg <= (count_reg == (freq - 1)) ? 0 : count_reg + 1;\n    end\nend\nassign count = count_reg;\n\n// Wave Generator Module\nreg wave_out_reg = 0;\nalways @(posedge clk) begin\n    if (enable) begin\n        wave_out_reg <= (count == 0);\n    end\nend\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule signal_generator_state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] wave\n);\n\n    reg [1:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave == 2'b11) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave == 2'b00) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = state;\n\nendmodule\n\nmodule signal_generator_wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            if (wave_reg == 5'b11111) begin\n                wave_reg <= 5'b00000;\n            end else begin\n                wave_reg <= wave_reg + 1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    my_dff8 u0 (.clk(clk), .d(d[0]), .q(q[0]));\n    my_dff8 u1 (.clk(clk), .d(q[0]), .q(q[1]));\n    my_dff8 u2 (.clk(clk), .d(q[1]), .q(q[2]));\n\n    always @(posedge clk) begin\n        q <= {q[6:0], d[7]};\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    d_flip_flop d_flip_flop_inst1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    d_flip_flop d_flip_flop_inst2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    d_flip_flop d_flip_flop_inst3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input d,\n    output q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] stage0_out, stage1_out, stage2_out, stage3_out;\n\nmux2X1 mux0 (.sel(ctrl[2]), .in0(in), .in1(stage0_out), .out(stage0_out));\nmux2X1 mux1 (.sel(ctrl[1]), .in0(stage0_out), .in1(stage1_out), .out(stage1_out));\nmux2X1 mux2 (.sel(ctrl[0]), .in0(stage1_out), .in1(stage2_out), .out(stage2_out));\nmux2X1 mux3 (.sel(ctrl[0]), .in0(stage2_out), .in1(stage3_out), .out(stage3_out));\n\nassign out = stage3_out;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\ninput sel;\ninput in0, in1;\noutput out;\n\nassign out = sel ? in1 : in0;\n\nendmodule\n\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n  wire [15:0] b1_delayed;\n\n  // PE0\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe0_out <= 0;\n    end else begin\n      pe0_out <= {a0, b0};\n    end\n  end\n\n  // PE1\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe1_out <= 0;\n    end else begin\n      pe1_out <= {a1, b1_delayed};\n    end\n  end\n\n  assign b1_delayed = (b1 == 0) ? 0 : b1;\n\n  // Delayed assignment of b1\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  reg [31:0] pipe_reg [0:4]; // pipeline registers\n  reg [31:0] pc; // program counter\n  reg [5:0] instr; // instruction\n  reg [4:0] rd; // destination register\n  reg [4:0] rs1; // first source register\n  reg [4:0] rs2; // second source register\n  reg [5:0] op; // operation\n  reg [31:0] alu_out; // ALU output\n\n  wire [31:0] instr_mem_in;\n  wire [31:0] reg_file_in;\n  wire [31:0] reg_file_out;\n  wire [31:0] writeback_in;\n  wire [31:0] writeback_out;\n\n  wire clk;\n  wire rst;\n  wire instr_mem_in;\n  wire reg_file_in;\n  wire reg_file_out;\n  wire writeback_in;\n  wire writeback_out;\n\n  // Fetch stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipe_reg[0] <= 0;\n      pc <= 0;\n    end else begin\n      pipe_reg[0] <= instr_mem_in;\n      pc <= pc + 1;\n    end\n  end\n\n  assign instr_mem_in = instr_mem[pc];\n\n  // Decode stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipe_reg[1] <= 0;\n      instr <= 0;\n      rd <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      op <= 0;\n    end else begin\n      instr <= pipe_reg[0][31:26];\n      rd <= pipe_reg[0][20:16];\n      rs1 <= pipe_reg[0][19:15];\n      rs2 <= pipe_reg[0][24:20];\n      op <= pipe_reg[0][5:0];\n      pipe_reg[1] <= {pipe_reg[0][31:20], op, rd, rs1, rs2};\n    end\n  end\n\n  // Execute stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipe_reg[2] <= 0;\n      alu_out <= 0;\n    end else begin\n      alu_out <= (op == 6'b000000) ?\n                  reg_file_in[rs1] + reg_file_in[rs2] :\n                  reg_file_in[rs1] - reg_file_in[rs2];\n      pipe_reg[2] <= {alu_out, 6'b000000, rd, rs1, rs2};\n    end\n  end\n\n  assign reg_file_in = reg_file[pipe_reg[1][20:16]];\n\n  // Memory stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipe_reg[3] <= 0;\n      alu_out <= 0;\n    end else begin\n      pipe_reg[3] <= {alu_out, 6'b000000, rd, rs1, rs2};\n    end\n  end\n\n  // Writeback stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipe_reg[4] <= 0;\n      alu_out <= 0;\n    end else begin\n      reg_file_out <= pipe_reg[3][31:0];\n      pipe_reg[4] <= {alu_out, 6'b000000, rd, rs1, rs2};\n    end\n  end\n\n  assign writeback_in = reg_file_out;\n  assign writeback_out = pipe_reg[4][31:0];\n  assign res_reg_file = writeback_out;\n\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  \n  reg [31:0] b1, b2, b3;\n  reg [31:0] pe0_out, pe1_out, pe2_out, pe3_out;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 32'b0;\n      b2 <= 32'b0;\n      b3 <= 32'b0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n  \n  // pe0\n  assign pe0_out = a0 * b0;\n  \n  // pe1\n  assign pe1_out = a1 * b1;\n  \n  // pe2\n  assign pe2_out = a2 * b2;\n  \n  // pe3\n  assign pe3_out = a3 * b3;\n  \n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n  assign c2 = pe2_out;\n  assign c3 = pe3_out;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] instr;\nwire [4:0] rd, rs1, rs2;\nwire [5:0] opcode;\nwire [31:0] rs1_val, rs2_val;\nwire [31:0] add_sub_out;\n\nreg [31:0] pc;\nreg [31:0] out_reg_file_reg;\n\nassign out_reg_file = out_reg_file_reg;\n\n// Fetch stage\nstagepipe3_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr)\n);\n\n// Execute stage\nstagepipe3_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .reg_file(reg_file),\n    .rs1_val(rs1_val),\n    .rs2_val(rs2_val),\n    .add_sub_out(add_sub_out)\n);\n\n// Writeback stage\nstagepipe3_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .add_sub_out(add_sub_out),\n    .rd(rd),\n    .out_reg_file(out_reg_file_reg)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pc <= 32'h00000000;\n    end else begin\n        case (instr[5:0])\n            6'b000000: pc <= pc + 1;\n            6'b001000: pc <= pc + 1;\n            default: pc <= pc + 1;\n        endcase\n    end\nend\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] pc,\n    input [31:0] instr_mem [0:31],\n    output [31:0] instr\n);\n\nreg [31:0] instr_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        instr_reg <= 32'h00000000;\n    end else begin\n        instr_reg <= instr_mem[pc[4:0]];\n    end\nend\n\nassign instr = instr_reg;\n\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] rs1_val,\n    output [31:0] rs2_val,\n    output [31:0] add_sub_out\n);\n\nwire [31:0] rs1_val_reg;\nwire [31:0] rs2_val_reg;\nwire [31:0] add_sub_out_reg;\n\nreg [5:0] opcode;\nreg [4:0] rd;\nreg [4:0] rs1;\nreg [4:0] rs2;\n\nassign rs1_val = rs1_val_reg;\nassign rs2_val = rs2_val_reg;\nassign add_sub_out = add_sub_out_reg;\n\nalways @(*) begin\n    opcode = instr[31:26];\n    rd = instr[20:16];\n    rs1 = instr[25:21];\n    rs2 = instr[15:11];\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        rs1_val_reg <= 32'h00000000;\n        rs2_val_reg <= 32'h00000000;\n        add_sub_out_reg <= 32'h00000000;\n    end else begin\n        case (opcode"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                count_done;\n\n    // Counter Module\n    reg          [2:0]   count;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 3'd0;\n        end else if (count_done) begin\n            count <= 3'd0;\n        end else if (valid_in) begin\n            count <= count + 1'b1;\n        end\n    end\n\n    assign count_done = (count == 3'd4);\n\n    // Data Accumulator Module\n    reg          [9:0]   data_accum;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accum <= 10'd0;\n        end else if (count_done) begin\n            data_accum <= data_in + data_accum;\n        end\n    end\n\n    // Valid Output Module\n    reg                valid_out_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out_reg <= 1'b0;\n        end else if (count_done) begin\n            valid_out_reg <= 1'b1;\n        end else begin\n            valid_out_reg <= 1'b0;\n        end\n    end\n\n    assign valid_out = valid_out_reg;\n    assign data_out = data_accum;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               count_en,\n    output reg          count_done\n);\n\n    reg          [2:0]   count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 3'd0;\n            count_done <= 1'b0;\n        end else if (count_en) begin\n            if (count == 3'd4) begin\n                count_done <= 1'b1;\n            end else begin\n                count <= count + 1'b1;\n            end\n        end else begin\n            count_done <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               count_done,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 10'd0;\n        end else if (count_done) begin\n            data_out <= data_in + data_out;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               count_done,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n        end else if (count_done) begin\n            valid_out <= 1'b1;\n        end else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    assign result = {remainder[7:0], quotient[7:0]};\n\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (opn_valid) begin\n            res_valid <= 1;\n            quotient <= 0;\n            remainder <= dividend;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end\n        if (sign) begin\n            quotient <= remainder[7] ? 0 : ~quotient;\n        end\n        quotient <= quotient << 1;\n        remainder <= remainder << 1;\n        if (remainder[15:8] == divisor) begin\n            quotient[7] <= 1;\n            remainder[7:0] <= remainder[15:8] - divisor;\n        end else begin\n            quotient[7] <= 0;\n        end\n    end\nendmodule\n\nmodule radix2_div_submodule_abs_dividend(\n    input wire [7:0] dividend,\n    input wire sign,\n    output wire [7:0] abs_dividend\n);\n    assign abs_dividend = (sign) ? -dividend : dividend;\nendmodule\n\nmodule radix2_div_submodule_neg_divisor_mod(\n    input wire [7:0] divisor,\n    input wire sign,\n    output wire [7:0] neg_divisor_mod\n);\n    assign neg_divisor_mod = (sign) ? ~divisor : divisor;\nendmodule\n\nmodule radix2_div_submodule_ctrl(\n    input wire clk,\n    input wire rst,\n    input wire [15:0] dividend,    \n    input wire [15:0] divisor,    \n    input wire sign,       \n    output wire opn_valid,   \n    output reg [7:0] count,    \n    output wire [15:0] shift_reg,    \n    output wire [7:0] abs_dividend,\n    output wire [7:0] neg_divisor_mod\n);\n    reg [15:0] shift_reg_temp;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n            shift_reg_temp <= 0;\n        end else if (count == 0) begin\n            count <= 1;\n            shift_reg_temp <= dividend;\n        end else begin\n            count <= count + 1;\n            shift_reg_temp <= {shift_reg_temp[14:0], 1'b0};\n        end\n    end\n\n    assign shift_reg = shift_reg_temp;\n    assign abs_dividend = shift_reg[15:8];\n    assign neg_divisor_mod = (sign) ? ~divisor : divisor;\n    assign opn_valid = (count == 0) ? 1'b1 : 1'b0;\nendmodule\n\nmodule radix2_div_submodule_res_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] count,    \n    input wire [15:0] result,    \n    input wire res_ready,   \n    output wire res_valid,   \n    output wire [15:0] res_mgmt\n);\n    reg [15:0] res_mgmt_temp;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            res_mgmt_temp <= 0;\n        end else if (res_ready) begin\n            res_mgmt_temp <= result;\n        end else if (count == 0) begin\n            res_mgmt_temp <= {res_mgmt_temp[14:0], 1'b0};\n        end\n    end\n\n    assign res_valid = (count == 0) ? 1'b1 : 1'b0;\n    assign res_mgmt"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// prep_dividend submodule\n// (A is 32-bit, B is 16-bit, result is 32-bit)\n\n// div_operation submodule\n// (A is 32-bit, B is 16-bit, result is 32-bit)\n\nendmodule\n\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n// Implement the control unit\nmodule control_unit (\n    input wire [15:0] A,     // 16-bit dividend\n    input wire [7:0] B,      // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nreg [15:0] dividend, divisor, quotient, remainder;\nreg [3:0] count;\nreg [3:0] shift;\n\n// Initialize dividend and divisor\ninitial begin\n    dividend = A;\n    divisor = B;\n    count = 0;\nend\n\n// Compare divisor with dividend\nalways @(*) begin\n    if (dividend[7:0] == divisor) begin\n        quotient[15:8] = 0;\n        quotient[7:0] = dividend[7:0];\n        remainder = dividend[15:8];\n        count = 1;\n    end else if (dividend[15:8] == divisor) begin\n        quotient[15:8] = 1;\n        quotient[7:0] = dividend[15:8];\n        remainder = dividend[7:0];\n        count = 1;\n    end\nend\n\n// Shift dividend left and compare with divisor\nalways @(*) begin\n    if (count == 0) begin\n        shift = 4'd0;\n        while (count < 16) begin\n            dividend = {dividend[15:0], 1'b0};\n            if (dividend[15:8] == divisor) begin\n                quotient[15:8] = count[3:0];\n                quotient[7:0] = dividend[7:0];\n                remainder = dividend[15:8];\n                count = count + 1;\n            end\n            shift = shift + 1;\n        end\n    end\nend\n\n// Calculate final quotient and remainder\nalways @(*) begin\n    odd = remainder;\nend\n\nendmodule\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\nwire [7:0] B_comp;\n\n//------------------------------------------------\n// 2's complement B\nassign B_comp[7] = ~B[7];\nassign B_comp[6] = ~B[6];\nassign B_comp[5] = ~B[5];\nassign B_comp[4] = ~B[4];\nassign B_comp[3] = ~B[3];\nassign B_comp[2] = ~B[2];\nassign B_comp[1] = ~B[1];\nassign B_comp[0] = ~B[0];\n\n//------------------------------------------------\n// Full adder\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] carry_out;\n\nassign sum[7] = A[7] ^ B_comp[7];\nassign sum[6] = A[6] ^ B_comp[6];\nassign sum[5] = A[5] ^ B_comp[5];\nassign sum[4] = A[4] ^ B_comp[4];\nassign sum[3] = A[3] ^ B_comp[3];\nassign sum[2] = A[2] ^ B_comp[2];\nassign sum[1] = A[1] ^ B_comp[1];\nassign sum[0] = A[0] ^ B_comp[0];\n\nassign carry[7] = (A[7] & B_comp[7]);\nassign carry[6] = (A[6] & B_comp[6]) | (A[6] & B_comp[6]) | (A[5] & B_comp[5]);\nassign carry[5] = (A[5] & B_comp[5]) | (A[4] & B_comp[4]) | (A[3] & B_comp[3]);\nassign carry[4] = (A[4] & B_comp[4]) | (A[3] & B_comp[3]) | (A[2] & B_comp[2]);\nassign carry[3] = (A[3] & B_comp[3]) | (A[2] & B_comp[2]) | (A[1] & B_comp[1]);\nassign carry[2] = (A[2] & B_comp[2]) | (A[1] & B_comp[1]) | (A[0] & B_comp[0]);\nassign carry[1] = (A[1] & B_comp[1]) | (A[0] & B_comp[0]);\nassign carry[0] = (A[0] & B_comp[0]);\n\nassign carry_out[7] = carry[7];\nassign carry_out[6] = carry[6];\nassign carry_out[5] = carry[5];\nassign carry_out[4] = carry[4];\nassign carry_out[3] = carry[3];\nassign carry_out[2] = carry[2];\nassign carry_out[1] = carry[1];\nassign carry_out[0] = carry[0];\n\n//------------------------------------------------\n// Subtractor\nassign D[7] = sum[7];\nassign D[6] = sum[6];\nassign D[5] = sum[5];\nassign D[4] = sum[4];\nassign D[3] = sum[3];\nassign D[2] = sum[2];\nassign D[1] = sum[1];\nassign D[0] = sum[0];\n\nassign B_out = carry_out[7];\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nreg [31:0] Diff;\nreg B_out;\n\nalways @(*) begin\n    Diff = A - B;\n    B_out = (A[31] == B[31]) ? 1 : 0;\nend\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1, D2, D3;\nwire [15:0] D4, D5;\nwire [7:0] D6, D7;\n\nwire B_out0, B_out1;\nwire B_out2, B_out3;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B_out0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B_out1);\nsub_16bit sub2(D0, D1, D2, B_out2);\nsub_16bit sub3(A[47:16], B[47:16], D3, B_out3);\n\nsub_8bit sub4(D2, D3, D4, B_out2);\nsub_8bit sub5(A[55:48], B[55:48], D5, B_out3);\nsub_8bit sub6(D4, D5, D6, B_out2);\nsub_8bit sub7(A[63:56], B[63:56], D7, B_out3);\n\nassign D = {D7, D6, D5, D4, D3, D2, D1, D0};\nassign B_out = B_out3 & B_out2 & B_out1 & B_out0;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire [7:0] D2, D3;\n\nwire B_out0, B_out1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B_out0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B_out1);\nsub_8bit sub2(D0, D1, D2, B_out0);\nsub_8bit sub3(A[23:8], B[23:8], D3, B_out1);\n\nsub_8bit sub4(D2, D3, D4, B_out0);\nsub_8bit sub5(A[31:24], B[31:24], D5, B_out1);\nsub_8bit sub6(D4, D5, D6, B_out0);\nsub_8bit sub7(A[31:24], B[31:24], D7, B_out1);\n\nassign D = {D7, D6, D5, D4, D3, D2, D1, D0};\nassign B_out = B_out1 & B_out0;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire [3:0] D2, D3;\n\nwire B_out0, B_out1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B_out0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B_out1);\nsub_4bit sub2(D0, D1, D2, B_out0);\nsub_4bit sub3(A[11:4], B[11:4], D3, B_out1);\n\nsub_4bit sub4(D2, D3, D4, B_out0);\nsub_4bit sub5(A[15:12], B[15:12], D5, B_out1);\nsub_4bit sub6(D4, D5, D6, B"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A0, A1, A2, A3, B0, B1, B2, B3;\nwire [2:1] D0, D1, D2, D3;\nwire B0_out, B1_out, B2_out, B3_out;\n\n// Borrow-Lookahead Subtractor Block\nwire B_in;\n\n// 4-bit full subtractor\nwire [3:1] B_in_s;\nwire [2:1] A_s, B_s, D_s, B_out_s;\n\nassign B_in_s = {B3, B2, B1, B0};\nassign A_s = {A3, A2, A1, A0};\nassign B_s = {B_in_s, B_in_s, B_in_s, B_in_s};\nassign D_s = A_s - B_s;\nassign B_out_s = B_in_s;\n\nassign D = D_s;\nassign B_out = B_out_s;\n\n// 4-bit full subtractor\nwire [3:1] B_in_s2;\nwire [2:1] A_s2, B_s2, D_s2, B_out_s2;\n\nassign B_in_s2 = {B3, B2, B1, B0};\nassign A_s2 = {A3, A2, A1, A0};\nassign B_s2 = {B_in_s2, B_in_s2, B_in_s2, B_in_s2};\nassign D_s2 = A_s2 - B_s2;\nassign B_out_s2 = B_in_s2;\n\nassign D = D_s2;\nassign B_out = B_out_s2;\n\n// 4-bit full subtractor\nwire [3:1] B_in_s3;\nwire [2:1] A_s3, B_s3, D_s3, B_out_s3;\n\nassign B_in_s3 = {B3, B2, B1, B0};\nassign A_s3 = {A3, A2, A1, A0};\nassign B_s3 = {B_in_s3, B_in_s3, B_in_s3, B_in_s3};\nassign D_s3 = A_s3 - B_s3;\nassign B_out_s3 = B_in_s3;\n\nassign D = D_s3;\nassign B_out = B_out_s3;\n\n// 4-bit full subtractor\nwire [3:1] B_in_s4;\nwire [2:1] A_s4, B_s4, D_s4, B_out_s4;\n\nassign B_in_s4 = {B3, B2, B1, B0};\nassign A_s4 = {A3, A2, A1, A0};\nassign B_s4 = {B_in_s4, B_in_s4, B_in_s4, B_in_s4};\nassign D_s4 = A_s4 - B_s4;\nassign B_out_s4 = B_in_s4;\n\nassign D = D_s4;\nassign B_out = B_out_s4;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtrahend;\nwire carry;\nwire [31:0] subtracted;\n\n// Subtractor with 32-bit input and carry-out\nsubtractor_32bit subtractor (\n    .A(A),\n    .B(B),\n    .subtrahend(subtrahend),\n    .carry(carry),\n    .subtracted(subtracted)\n);\n\nassign A_greater = (subtracted == 32'b0);\nassign A_equal = (subtracted == 32'b0 && carry == 1);\nassign A_less = (subtracted != 32'b0);\n\nendmodule\n\n// Subtractor with 32-bit input and carry-out\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtrahend,  // Output: subtrahend\n    output carry,             // Output: carry out\n    output [31:0] subtracted  // Output: subtracted value\n);\n\nassign subtrahend = A - B;\nassign carry = (A[31] == B[31]) ? 1'b0 : ((A[31] == 1'b1) ? 1'b1 : 1'b0);\nassign subtracted = A - B - carry;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1]= A[32:1]^B[32:1];\nassign C32= ^A[32:1]^B[32:1];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a;\ninput [15:0] b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] a0, a1, a2, a3;\nwire [3:0] b0, b1, b2, b3;\nwire [3:0] c0, c1, c2, c3;\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [3:0] c_out0, c_out1, c_out2, c_out3;\nwire [3:0] c_out;\n\nassign a0 = a[0];\nassign a1 = a[1];\nassign a2 = a[2];\nassign a3 = a[3];\nassign b0 = b[0];\nassign b1 = b[1];\nassign b2 = b[2];\nassign b3 = b[3];\n\nassign c0 = (a0 & b0) | (cin & (a0 | b0));\nassign c1 = (a1 & b1) | (c0 & (a1 | b1));\nassign c2 = (a2 & b2) | (c1 & (a2 | b2));\nassign c3 = (a3 & b3) | (c2 & (a3 | b3));\n\nassign c_out0 = (a0 & b1) | (a1 & b0);\nassign c_out1 = (a2 & b3) | (a3 & b2);\nassign c_out2 = (a4 & b5) | (a5 & b4);\nassign c_out3 = (a6 & b7) | (a7 & b6);\n\nassign c_out = (c_out0 & c_out1) | (c_out2 & c_out3);\n\nassign sum0 = (a0 ^ b0) ^ cin;\nassign sum1 = (a1 ^ b1) ^ c0;\nassign sum2 = (a2 ^ b2) ^ c1;\nassign sum3 = (a3 ^ b3) ^ c2;\n\nassign sum = {sum3, sum2, sum1, sum0};\n\nassign cout = c3;\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a;\ninput [15:0] b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] a0, a1, a2, a3;\nwire [3:0] b0, b1, b2, b3;\nwire [3:0] c0, c1, c2, c3;\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [3:0] c_out0, c_out1, c_out2, c_out3;\nwire [3:0] c_out;\n\nassign a0 = a[0];\nassign a1 = a[1];\nassign a2 = a[2];\nassign a3 = a[3];\nassign b0 = b[0];\nassign b1 = b[1];\nassign b2 = b[2];\nassign b3 = b[3];\n\nassign c0 = (a0 & b0) | (cin & (a0 | b0));\nassign c1 = (a1 & b1) | (c0 & (a1 | b1));\nassign c2 = (a2 & b2) | (c1 & (a2 | b2));\nassign c3 = (a3 & b3) | (c2 & (a3 | b3));\n\nassign c_out0 = (a0 & b1) | (a1 & b0);\nassign c_out1 = (a2 & b3) | (a3 & b2);\nassign c_out2 = (a4 & b5) | (a5 & b4);\nassign c_out3 = (a6 & b7) | (a7 & b6);\n\nassign c_out = (c_out0 & c_out1) | (c_out2 & c_out3);\n\nassign sum0 = (a0 ^ b0) ^ cin;\nassign sum1 = (a1"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire C1, C2, C3, C4, C5, C6, C7, C8;\n\n    // 8-bit adder implementation\n    wire [7:0] a0, b0, y0, C0;\n    assign {C0, y0} = a0 + b0 + C1;\n    assign {C1, a0} = a[7:0] + b[7:0] + C2;\n    assign {C2, b0} = a[15:8] + b[15:8] + C3;\n    assign {C3, a0} = a[7:0] + b[7:0] + C4;\n    assign {C4, b0} = a[15:8] + b[15:8] + C5;\n    assign {C5, a0} = a[7:0] + b[7:0] + C6;\n    assign {C6, b0} = a[15:8] + b[15:8] + C7;\n    assign {C7, y0} = a[7:0] + b[7:0] + C8;\n    assign {C8, y} = y0 + Cin;\n\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n\n    // First Bit Adder\n    full_adder fa0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum),\n        .cout(fa0_cout)\n    );\n\n    // Second Bit Adder\n    full_adder fa1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout),\n        .sum(fa1_sum),\n        .cout(fa1_cout)\n    );\n\n    // Third Bit Adder\n    full_adder fa2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout),\n        .sum(fa2_sum),\n        .cout(fa2_cout)\n    );\n\n    // Fourth Bit Adder\n    full_adder fa3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout),\n        .sum(fa3_sum),\n        .cout(fa3_cout)\n    );\n\n    // Fifth Bit Adder\n    full_adder fa4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout),\n        .sum(fa4_sum),\n        .cout(fa4_cout)\n    );\n\n    // Sixth Bit Adder\n    full_adder fa5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout),\n        .sum(fa5_sum),\n        .cout(fa5_cout)\n    );\n\n    // Seventh Bit Adder\n    full_adder fa6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout),\n        .sum(fa6_sum),\n        .cout(fa6_cout)\n    );\n\n    // Eighth Bit Adder\n    full_adder fa7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout),\n        .sum(fa7_sum),\n        .cout(fa7_cout)\n    );\n\n    // Carry-out\n    assign cout = fa7_cout;\n\n    // Sum\n    assign sum = {fa7_sum, fa6_sum, fa5_sum, fa4_sum, fa3_sum, fa2_sum, fa1_sum, fa0_sum};\nendmodule\n\n// Full Adder Implementation\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n//\n// Control Unit\n//\nreg [3:0] shift_count;\nreg [31:0] product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'd0;\n        product <= 32'd0;\n    end else if (start) begin\n        shift_count <= 4'd0;\n        product <= {16'd0, ain};\n    end else begin\n        shift_count <= shift_count + 4'd1;\n    end\nend\n\nassign done = shift_count == 4'd16;\n\n//\n// Register Unit\n//\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else if (start) begin\n        a_reg <= ain;\n        b_reg <= bin;\n    end\nend\n\n//\n// Multiplier Unit\n//\nreg [15:0] multiplier;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        multiplier <= 16'd0;\n    end else if (start) begin\n        multiplier <= b_reg;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n    end else if (start) begin\n        product <= {16'd0, a_reg};\n    end else if (shift_count < 16) begin\n        product <= product + (multiplier << shift_count);\n    end\nend\n\nassign yout = product;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] count_next;\n\n    // counter_logic\n    u_counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count_next(count_next)\n    );\n\n    // counter_register\n    u_counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count_next(count_next),\n        .count(count)\n    );\n\nendmodule\n\n// counter_logic\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count_next\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count_next = count_reg;\n\nendmodule\n\n// counter_register\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count_next,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0;\n        end else begin\n            count <= count_next;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    submodule init (\n        input wire clk,\n        input wire reset,\n        output wire [7:0] out\n    );\n\n        assign out = 8'b0000_0001;\n    endsubmodule\n\n    submodule transition (\n        input wire clk,\n        input wire reset,\n        output wire [7:0] out\n    );\n        reg [2:0] state = 3'b000;\n        assign out = 8'b0000_0001 << state;\n\n        always @(posedge clk) begin\n            if (reset) state <= 3'b000;\n            else state <= (state == 3'b111) ? 3'b000 : state + 1;\n        end\n    endsubmodule\n\n    assign init_out = init (clk, reset);\n    assign transition_out = transition (clk, reset);\n\n    assign out = reset ? 8'b0000_0001 : (init_out | transition_out);\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] u_counter_logic_out;\nwire [3:0] u_output_register_out;\n\n// Placeholder for submodules. Replace with actual implementations.\nu_counter_logic counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .out(u_counter_logic_out)\n);\n\nu_output_register output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .out(u_output_register_out)\n);\n\nassign out = u_output_register_out;\n\nendmodule\n\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= out + 1;\n        if (out == 4'd11) begin\n            out <= 4'b0000;\n        end\n    end\nend\n\nendmodule\n\nmodule u_output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 4'b0000;\n    end else if (valid_count) begin\n        out <= in;\n    end\nend\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Intermediate signals\nwire [63:0] next_Q;\n\n// Submodules\nJC_register reg_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(next_Q)\n);\n\nJC_logic logic_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(next_Q),\n    .next_Q(Q)\n);\n\nendmodule\n\n//------------------------------------------------\n// JC_register\n//------------------------------------------------\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q,\n    output reg [63:0]   next_Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        next_Q <= 64'd0;\n    else\n        next_Q <= Q;\nend\n\nendmodule\n\n//------------------------------------------------\n// JC_logic\n//------------------------------------------------\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]   next_Q\n);\n\nalways @(*) begin\n    next_Q = Q;\n    if (!rst_n)\n        next_Q = 64'd0;\n    else begin\n        if (Q[0])\n            next_Q = Q >> 1;\n        else\n            next_Q = Q | (1 << 63);\n    end\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n//\n// Submodule definitions\n//\n\n// clk_div_2\nreg [3:0] clk_div_2_cnt;\n\nassign CLK_50 = clk_div_2_cnt == 4'd0;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2_cnt <= 4'd0;\n    end else begin\n        clk_div_2_cnt <= clk_div_2_cnt + 1;\n    end\nend\n\n// clk_div_10\nreg [3:0] clk_div_10_cnt;\n\nassign CLK_10 = clk_div_10_cnt == 4'd4;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_10_cnt <= 4'd0;\n    end else begin\n        clk_div_10_cnt <= clk_div_10_cnt + 1;\n    end\nend\n\n// clk_div_100\nreg [6:0] clk_div_100_cnt;\n\nassign CLK_1 = clk_div_100_cnt == 7'd49;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_100_cnt <= 7'd0;\n    end else begin\n        clk_div_100_cnt <= clk_div_100_cnt + 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\n// Counter submodule\nreg [MUL2_DIV_CLK:0] cnt_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        cnt_reg <= {(MUL2_DIV_CLK+1){1'b0}};\n    end else begin\n        cnt_reg <= cnt_reg + 1'b1;\n    end\nend\nwire [MUL2_DIV_CLK:0] cnt = cnt_reg;\n\n// Clock average generator submodule\nreg [MUL2_DIV_CLK:0] clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        clk_div_reg <= {(MUL2_DIV_CLK+1){1'b0}};\n    end else if(cnt == {MUL2_DIV_CLK{1'b0}}) begin\n        clk_div_reg <= {2'b00, cnt[MUL2_DIV_CLK-1:1]};\n    end\nend\nwire [MUL2_DIV_CLK:0] clk_div_gen = clk_div_reg;\n\n// Clock adjustment submodule\nreg [MUL2_DIV_CLK:0] clk_div_neg_reg;\nalways @(negedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        clk_div_neg_reg <= {(MUL2_DIV_CLK+1){1'b0}};\n    end else if(cnt == {MUL2_DIV_CLK{1'b0}}) begin\n        clk_div_neg_reg <= {2'b00, cnt[MUL2_DIV_CLK-1:1]};\n    end\nend\nwire [MUL2_DIV_CLK:0] clk_div_neg = clk_div_neg_reg;\n\nassign clk_div = clk_div_gen | clk_div_neg;\n\nendmodule\n\nmodule counter (\n    input clk,\n    input rst_n,\n    output reg [MUL2_DIV_CLK:0] cnt\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK:0] cnt_next;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        cnt <= {(MUL2_DIV_CLK+1){1'b0}};\n    end else begin\n        cnt <= cnt_next;\n    end\nend\nalways @* begin\n    cnt_next = cnt + 1'b1;\nend\n\nendmodule\n\nmodule clk_average (\n    input clk,\n    input rst_n,\n    input [MUL2_DIV_CLK:0] cnt,\n    output reg clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK:0] clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        clk_div_reg <= {(MUL2_DIV_CLK+1){1'b0}};\n        clk_div <= 1'b0;\n    end else if(cnt == {MUL2_DIV_CLK{1'b0}}) begin\n        clk_div_reg <= {2'b00, cnt[MUL2_DIV_CLK-1:1]};\n        clk_div <= clk_div_reg[0];\n    end\nend\n\nendmodule\n\nmodule clk_adjustment (\n    input clk,\n    input rst_n,\n    input [MUL2_DIV_CLK:0] cnt,\n    output reg clk_div_neg\n);\n\nparameter MUL2_"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [NUM_DIV - 1:0] pos_counter;\nreg [NUM_DIV - 1:0] neg_counter;\nreg [NUM_DIV - 1:0] pos_counter_max;\nreg [NUM_DIV - 1:0] neg_counter_max;\n\nreg clk_div1;\nreg clk_div2;\n\nassign clk_div = clk_div1 | clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        neg_counter <= 0;\n        pos_counter_max <= NUM_DIV - 1;\n        neg_counter_max <= NUM_DIV - 1;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        neg_counter <= neg_counter + 1;\n        if (pos_counter == pos_counter_max) begin\n            pos_counter <= 0;\n            clk_div1 <= 1;\n        end else begin\n            clk_div1 <= 0;\n        end\n        if (neg_counter == neg_counter_max) begin\n            neg_counter <= 0;\n            clk_div2 <= 1;\n        end else begin\n            clk_div2 <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    wire [3:0] count_limit = (NUM_DIV / 2) - 1;\n\n    reg [3:0] count = 0;\n    reg clk_div_r = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div_r <= 0;\n        end else if (count == count_limit) begin\n            count <= 0;\n            clk_div_r <= ~clk_div_r;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    assign clk_div = clk_div_r;\nendmodule\n\nmodule u_counter (\n    input clk,\n    input rst_n,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (count == 7) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule u_clk_divider (\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg clk_div_r = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_r <= 0;\n        end else if (count == 0) begin\n            clk_div_r <= ~clk_div_r;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= clk_div_r;\n        end\n    end\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_r;\n    wire [31:0] sub_r;\n    wire [31:0] and_r;\n    wire [31:0] or_r;\n    wire [31:0] xor_r;\n    wire [31:0] nor_r;\n    wire [31:0] slt_r;\n    wire [31:0] sltu_r;\n    wire [31:0] sll_r;\n    wire [31:0] srl_r;\n    wire [31:0] sra_r;\n    wire [31:0] sllv_r;\n    wire [31:0] srlv_r;\n    wire [31:0] srav_r;\n    wire [31:0] lui_r;\n\n    wire add_zero, add_carry, add_neg, add_ovf, add_flag;\n    wire sub_zero, sub_carry, sub_neg, sub_ovf, sub_flag;\n    wire and_zero, and_carry, and_neg, and_ovf, and_flag;\n    wire or_zero, or_carry, or_neg, or_ovf, or_flag;\n    wire xor_zero, xor_carry, xor_neg, xor_ovf, xor_flag;\n    wire nor_zero, nor_carry, nor_neg, nor_ovf, nor_flag;\n    wire slt_zero, slt_carry, slt_neg, slt_ovf, slt_flag;\n    wire sltu_zero, sltu_carry, sltu_neg, sltu_ovf, sltu_flag;\n    wire sll_zero, sll_carry, sll_neg, sll_ovf, sll_flag;\n    wire srl_zero, srl_carry, srl_neg, srl_ovf, srl_flag;\n    wire sra_zero, sra_carry, sra_neg, sra_ovf, sra_flag;\n    wire sllv_zero, sllv_carry, sllv_neg, sllv_ovf, sllv_flag;\n    wire srlv_zero, srlv_carry, srlv_neg, srlv_ovf, srlv_flag;\n    wire srav_zero, srav_carry, srav_neg, srav_ovf, srav_flag;\n    wire lui_zero, lui_carry, lui_neg, lui_ovf, lui_flag;\n\n    // submodules\n    add add_submodule(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .neg(add_neg),\n        .ovf(add_ovf),\n        .flag(add_flag)\n    );\n\n    sub sub_submodule(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .neg(sub_neg),\n        .ovf(sub_ovf),\n        .flag(sub_flag)\n    );\n\n    and and_submodule(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .neg(and_neg),\n        .ovf(and_ovf),\n        .flag(and_flag)\n    );\n\n    or or_submodule(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .neg(or_neg),\n        .ovf(or_ovf),\n        .flag(or_flag)\n    );\n\n    xor xor_submodule(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [31:0] multiplication_result;\n    reg [31:0] current_value;\n\n    // multiplier submodule\n    assign multiplication_result = a * b;\n\n    // accumulator submodule\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + multiplication_result[31:0];\n    end\n\n    assign c = current_value;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    reg [7:0] ins_p1_r;\n    reg [7:0] ins_p2_r;\n\n    assign ins_p1 = ins_p1_r[7:5];\n    assign ins_p2 = ins_p2_r[7:0];\n\n    always @(posedge clk) begin\n        if (~rst) begin\n            ins_p1_r <= 8'b00000000;\n            ins_p2_r <= 8'b00000000;\n        end else begin\n            case (fetch)\n                2'b01: ins_p1_r <= data;\n                2'b10: ins_p2_r <= data;\n                default: ;\n            endcase\n        end\n    end\n\n    assign ins = ins_p1 | ins_p2;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n// Counter Module\n// Counter Operation: The counter module increments on each rising edge of clk.\n// When the count reaches (freq - 1), it resets to 0.\n// The count is enabled based on the frequency value.\n// Module Definition\nreg [7:0] count = 0;\nreg enable = 1;\n\n// Counter Functionality\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\n// Wave Generator Module\n// Functionality: Generates the square wave by toggling the wave_out signal.\n// Output frequency is inversely proportional to the input frequency value.\n// Module Definition\nreg wave_out = 0;\n\n// Wave Generator Functionality\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out <= ~wave_out;\n    end\nend\n\nendmodule\n\n```\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                default: wave_reg <= wave_reg;\n            endcase\n            if (wave_reg == 5'b00000 || wave_reg == 5'b11111)\n                state <= state + 1;\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else\n            state <= state + 1;\n    end\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'b00000;\n        else\n            wave <= wave + 1;\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q0, q1, q2, q3;\n\n    always @(posedge clk) begin\n        q0 <= d;\n        q1 <= q0;\n        q2 <= q1;\n        q3 <= q2;\n    end\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = q0;\n            2'b01: q = q1;\n            2'b10: q = q2;\n            2'b11: q = q3;\n            default: q = 8'b0;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = q;\n            2'b01: q = q;\n            2'b10: q = q;\n            2'b11: q = q;\n            default: q = 8'b0;\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n    end\n\n    assign q = q3;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] s1, s2, s3;\n\n    mux2X1 mux1 (.sel(ctrl[2]), .in1(in), .in2(s1), .out(s2));\n    mux2X1 mux2 (.sel(ctrl[1]), .in1(s2), .in2(s3), .out(s3));\n    mux2X1 mux3 (.sel(ctrl[0]), .in1(s3), .in2(in), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in1, in2, out);\n    input sel;\n    input in1, in2;\n    output out;\n\n    assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [31:0] b1;\n\n  assign b1 = (rst) ? 16'd0 : b0;\n\n  // pe0\n  reg [31:0] pe0_b;\n  reg [31:0] pe0_a0;\n  reg [31:0] pe0_a1;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe0_b <= 32'd0;\n      pe0_a0 <= 32'd0;\n      pe0_a1 <= 32'd0;\n    end else begin\n      pe0_b <= b0;\n      pe0_a0 <= a0;\n      pe0_a1 <= a1;\n    end\n  end\n\n  reg [31:0] pe0_c;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe0_c <= 32'd0;\n    end else begin\n      pe0_c <= pe0_b * pe0_a0;\n    end\n  end\n\n  assign c0 = pe0_c;\n\n  // pe1\n  reg [31:0] pe1_b;\n  reg [31:0] pe1_a0;\n  reg [31:0] pe1_a1;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe1_b <= 32'd0;\n      pe1_a0 <= 32'd0;\n      pe1_a1 <= 32'd0;\n    end else begin\n      pe1_b <= b1;\n      pe1_a0 <= a0;\n      pe1_a1 <= a1;\n    end\n  end\n\n  reg [31:0] pe1_c;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe1_c <= 32'd0;\n    end else begin\n      pe1_c <= pe1_b * pe1_a1;\n    end\n  end\n\n  assign c1 = pe1_c;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res_fetch [0:31];\n  wire [31:0] res_decode [0:31];\n  wire [31:0] res_execute [0:31];\n  wire [31:0] res_memory [0:31];\n  wire [31:0] res_writeback [0:31];\n  wire [5:0] pc;\n  \n  reg [5:0] pc_next;\n  \n  assign res_reg_file = res_writeback;\n  \n  stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_fetch),\n    .pc(pc),\n    .pc_next(pc_next)\n  );\n  \n  stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(res_fetch),\n    .res_reg_file(res_decode),\n    .pc(pc_next)\n  );\n  \n  stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(res_decode),\n    .res_reg_file(res_execute),\n    .pc(pc_next)\n  );\n  \n  stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(res_execute),\n    .res_reg_file(res_memory),\n    .pc(pc_next)\n  );\n  \n  stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(res_memory),\n    .res_reg_file(res_writeback),\n    .pc(pc_next)\n  );\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc_next;\n    end\n  end\nendmodule\nmodule stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31],\n  input [5:0] pc,\n  output [5:0] pc_next,\n  output [31:0] res_reg_file_next [0:31]\n);\n  wire [5:0] pc_next;\n  wire [31:0] res_fetch [0:31];\n  wire [31:0] res_decode [0:31];\n  wire [31:0] res_execute [0:31];\n  \n  assign res_reg_file = res_fetch;\n  assign res_reg_file_next = res_decode;\n  assign pc_next = pc + 1;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_fetch <= 0;\n      res_decode <= 0;\n      res_execute <= 0;\n    end else begin\n      res_fetch <= instr_mem[pc];\n      res_decode <= res_fetch;\n      res_execute <= res_fetch;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  \n  wire [15:0] b1 = b0_reg;\n  wire [15:0] b2 = b1_reg;\n  wire [15:0] b3 = b2_reg;\n\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 16'd0;\n      b1_reg <= 16'd0;\n      b2_reg <= 16'd0;\n      c0_reg <= 32'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n      c2_reg <= a2 * b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [4:0] rs1, rs2, rd;\n    wire [5:0] func3;\n    wire [6:0] op;\n    wire [31:0] rd_val;\n    reg [31:0] out_reg_file;\n    reg [31:0] pc_reg;\n    \n    wire [31:0] instr_mem_val;\n    assign instr_mem_val = instr_mem[pc_reg];\n    assign pc = pc_reg;\n    \n    assign rd_val = instr_mem_val[31:25];\n    assign rs1 = instr_mem_val[24:20];\n    assign rs2 = instr_mem_val[19:15];\n    assign rd = instr_mem_val[11:7];\n    assign func3 = instr_mem_val[14:12];\n    assign op = instr_mem_val[31:25];\n    \n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file <= reg_file[rd];\n    end\n    \n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            pc_reg <= 0;\n        else\n            pc_reg <= pc_reg + 1;\n    end\n    \nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//\n// Counter Module\n//\n\n// Counter register\nreg       [2:0]   cnt_reg;\n\n// Counter next state logic\nwire      [2:0]   cnt_next;\n\nassign cnt_next = (cnt_reg == 3'b111) ? 3'b000 : cnt_reg + 1;\n\n// Counter state update logic\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_reg <= 0;\n    else\n        cnt_reg <= cnt_next;\nend\n\n//\n// Data Accumulator Module\n//\n\n// Data accumulator register\nreg     [9:0]   data_acc_reg;\n\n// Data accumulator next state logic\nwire    [9:0]   data_acc_next;\n\nassign data_acc_next = data_acc_reg + data_in;\n\n// Data accumulator state update logic\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        data_acc_reg <= 0;\n    else if (cnt_reg == 3'b111)\n        data_acc_reg <= data_acc_next;\nend\n\n//\n// Valid Output Module\n//\n\n// Valid output register\nreg               valid_out_reg;\n\n// Valid output next state logic\nwire              valid_out_next;\n\nassign valid_out_next = (cnt_reg == 3'b111) ? 1'b1 : 1'b0;\n\n// Valid output state update logic\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        valid_out_reg <= 1'b0;\n    else if (valid_in)\n        valid_out_reg <= valid_out_next;\nend\n\n//\n// Output\n//\n\nassign valid_out = valid_out_reg;\nassign data_out = data_acc_reg;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    \n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    \n    wire [3:0] counter;\n    wire [7:0] abs_dividend;\n    wire [7:0] abs_divisor;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    \n    assign result = quotient + remainder;\n    \n    //////////////////////////////////////////////////////////////\n    // Submodule 9: Absolute Value Calculation\n    //////////////////////////////////////////////////////////////\n    \n    assign abs_dividend = sign ? -dividend : dividend;\n    \n    //////////////////////////////////////////////////////////////\n    // Submodule 10: Negative Divisor Calculation\n    //////////////////////////////////////////////////////////////\n    \n    assign abs_divisor = sign ? -divisor : divisor;\n    assign neg_divisor = sign ? -abs_divisor : abs_divisor;\n    \n    //////////////////////////////////////////////////////////////\n    // Submodule 11: Division Control Logic\n    //////////////////////////////////////////////////////////////\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n        end\n        else begin\n            counter <= counter + 1;\n            shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n        end\n    end\n    \n    //////////////////////////////////////////////////////////////\n    // Submodule 12: Result Management\n    //////////////////////////////////////////////////////////////\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n        end\n        else begin\n            res_valid <= (counter == 7) && !rst;\n        end\n    end\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            quotient <= 0;\n            remainder <= 0;\n        end\n        else if (res_ready && res_valid) begin\n            quotient <= shift_reg[7:0];\n            remainder <= shift_reg[15:8];\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Prepare the dividend and divisor\n// Output: dividend, divisor, and initial quotient\n// This submodule will be defined later.\n// Your code here\n//----------------------------------------------------------------------------------\n\n// Divide the dividend by the divisor\n// Output: quotient, remainder\n// This submodule will be defined later.\n// Your code here\n//----------------------------------------------------------------------------------\n\nendmodule\n\n//----------------------------------------------------------------------------------\n\n// Prepare the dividend and divisor\n// Output: dividend, divisor, and initial quotient\nmodule prep_dividend(\n    input wire [15:0] B, // 16-bit divisor\n    input wire [31:0] A, // 32-bit dividend\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor, // 16-bit divisor\n    output wire [31:0] quotient // 32-bit initial quotient\n);\n\nassign dividend = {A[31:16], A[15:0]};\nassign divisor = B;\nassign quotient = {32'b0, A[31:16]};\n\nendmodule\n\n//----------------------------------------------------------------------------------\n\n// Divide the dividend by the divisor\n// Output: quotient, remainder\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor, // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n);\n\ninteger i;\nreg [31:0] shifted_dividend;\nreg [15:0] shifted_divisor;\n\nalways @(*) begin\n    shifted_dividend = dividend;\n    shifted_divisor = divisor;\n\n    for (i = 0; i < 16; i = i + 1) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            shifted_divisor = shifted_divisor >> 1;\n        end else begin\n            shifted_divisor = shifted_divisor >> 1;\n        end\n    end\n\n    quotient = shifted_dividend;\n    remainder = shifted_divisor;\nend\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n// 16-bit dividend\n// 8-bit divisor\n// 16-bit quotient\n// 16-bit remainder\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\n\nassign B_comp = ~B + 1;\n\nwire [7:0] sum;\n\nassign sum = A + B_comp;\n\nalways @ (sum or B_comp)\nbegin\n    D = sum;\n    B_out = B_comp[7];\nend\n\nendmodule\n\nmodule adder_8bit(A, B, C, D);\ninput A, B, C;\noutput D;\n\nreg D;\n\nwire [7:0] sum;\n\nassign sum = A + B + C;\n\nalways @ (sum)\nbegin\n    D = sum;\nend\n\nendmodule\n\nmodule full_adder(A, B, C, D, sum, carry);\ninput A, B, C;\noutput D, sum, carry;\n\nwire carry;\n\nassign sum = A ^ B ^ C;\nassign D = (A & B) | (B & C) | (C & A);\nassign carry = (A & B) | (B & C) | (C & A);\n\nendmodule\n\nmodule submodule_instantiation (\n    input A,\n    input B,\n    output D,\n    output B_out\n);\n\nwire [7:0] B_comp;\n\nassign B_comp = ~B + 1;\n\nwire [7:0] sum;\n\nassign sum = A + B_comp;\n\nalways @ (sum or B_comp)\nbegin\n    D = sum;\n    B_out = B_comp[7];\nend\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit u0(A[15:0], B[15:0], Diff16, B_out16);\nsub_16bit u1(A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit u0(A[7:0], B[7:0], Diff8, B_out8);\nsub_8bit u1(A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit u0(A[3:0], B[3:0], Diff4, B_out4);\nsub_4bit u1(A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit u0(A[1:0], B[1:0], Diff2, B_out2);\nsub_2bit u1(A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nassign {B_out, Diff} = A < B ? 2'b10 : 2'b00;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_16, B_32, B_64;\nwire B_16_out, B_32_out, B_64_out;\n\nsub_16bit u0(A[15:0], B[15:0], D[15:0], B_16[15:0], B_16_out);\nsub_16bit u1(A[31:16], B[31:16], D[31:16], B_16[15:0], B_16_out);\nsub_16bit u2(A[47:32], B[47:32], D[47:32], B_16[15:0], B_16_out);\nsub_16bit u3(A[63:48], B[63:48], D[63:48], B_16[15:0], B_16_out);\n\nsub_8bit u4(D[7:0], B_16[7:0], D[7:0], B_8[3:0], B_8_out);\nsub_8bit u5(D[15:8], B_16[15:8], D[15:8], B_8[3:0], B_8_out);\nsub_8bit u6(D[23:16], B_16[23:16], D[23:16], B_8[3:0], B_8_out);\nsub_8bit u7(D[31:24], B_16[31:24], D[31:24], B_8[3:0], B_8_out);\nsub_8bit u8(D[39:32], B_16[39:32], D[39:32], B_8[3:0], B_8_out);\nsub_8bit u9(D[47:40], B_16[47:40], D[47:40], B_8[3:0], B_8_out);\nsub_8bit u10(D[55:48], B_16[55:48], D[55:48], B_8[3:0], B_8_out);\nsub_8bit u11(D[63:56], B_16[63:56], D[63:56], B_8[3:0], B_8_out);\n\nwire [3:0] B_8[3:0];\nwire B_8_out[3:0];\n\nassign B_out = B_64_out;\n\nassign B_64_out = B_32_out;\nassign B_32_out = B_16_out;\n\nassign B_8_out[3] = B_16_out;\nassign B_8_out[2] = B_16_out;\nassign B_8_out[1] = B_16_out;\nassign B_8_out[0] = B_16_out;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [15:0] B_8;\nwire B_8_out;\n\nsub_8bit u0(A[7:0], B[7:0], D[7:0], B_8[3:0], B_8_out);\nsub_8bit u1(A[15:8], B[15:8], D[15:8], B_8[3:0], B_8_out);\n\nwire [3:0] B_8[3:0];\nwire B_8_out[3:0];\n\nassign B_out = B_8_out;\n\nassign B_8_out = B_8[3] | B_8["}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nreg B_out;\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [4:1] D1, D2, D3, D4;\nwire [4:1] D1_B, D2_B, D3_B, D4_B;\nwire [4:1] D1_A, D2_A, D3_A, D4_A;\nwire [4:1] D1_AB, D2_AB, D3_AB, D4_AB;\nwire [4:1] D1_B_AB, D2_B_AB, D3_B_AB, D4_B_AB;\n\nassign D = D4_AB;\nassign B_out = (D4_AB[1]) | (D4_AB[2]) | (D4_AB[3]);\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign D1 = {A1, 1'b0} - {B1, 1'b0};\nassign D2 = {A2, 1'b0} - {B2, 1'b0};\nassign D3 = {A3, 1'b0} - {B3, 1'b0};\nassign D4 = {A4, 1'b0} - {B4, 1'b0};\n\nassign D1_B = {1'b0, D1[1:1]} - {D1[1], 1'b0};\nassign D2_B = {1'b0, D2[1:1]} - {D2[1], 1'b0};\nassign D3_B = {1'b0, D3[1:1]} - {D3[1], 1'b0};\nassign D4_B = {1'b0, D4[1:1]} - {D4[1], 1'b0};\n\nassign D1_A = {D1[2:2], 1'b0} - {D1[1], 1'b0};\nassign D2_A = {D2[2:2], 1'b0} - {D2[1], 1'b0};\nassign D3_A = {D3[2:2], 1'b0} - {D3[1], 1'b0};\nassign D4_A = {D4[2:2], 1'b0} - {D4[1], 1'b0};\n\nassign D1_AB = {D1_A[2:2], 1'b0} - {D1_A[1], 1'b0};\nassign D2_AB = {D2_A[2:2], 1'b0} - {D2_A[1], 1'b0};\nassign D3_AB = {D3_A[2:2], 1'b0} - {D3_A[1], 1'b0};\nassign D4_AB = {D4_A[2:2], 1'b0} - {D4_A[1], 1'b0};\n\nassign D1_B_AB = {1'b0, D1_B[1:1]} - {D1_B[1], 1'b0};\nassign D2_B_AB = {1'b0, D2_B[1:1]} - {D2_B[1], 1'b0};\nassign D3_B_AB = {1'b0, D3_B[1:1]} - {D3_B[1], 1'b0};\nassign D4_B_AB = {1'b0, D4_B[1:1]} - {D4_B[1], 1'b0};"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] A_minus_B;\n    wire borrow;\n\n    assign A_greater = (A_minus_B != 0);\n    assign A_equal = (A == B);\n    assign A_less = borrow;\n\n    assign A_minus_B = A - B;\n    assign borrow = (A_minus_B[31] == 1);\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32] = A[32] ^ B[32];\nassign C32 = A[32] & B[32];\n\ngenvar i;\ngenerate\n    for(i = 31; i > 0; i = i - 1) begin\n        assign S[i] = A[i] ^ B[i] ^ S[i+1];\n        assign C32 = C32 ^ (A[i] & B[i] & S[i+1]) ^ (A[i] & B[i] & ~S[i+1]);\n    end\nendgenerate\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\nwire [3:0] rca0_sum;\nwire [3:0] rca0_cout;\n\nwire [3:0] rca1_sum;\nwire [3:0] rca1_cout;\n\nwire [3:0] csa0_sum;\nwire [3:0] csa0_cout;\n\nwire [3:0] csa1_sum;\nwire [3:0] csa1_cout;\n\nwire [3:0] csa2_sum;\nwire [3:0] csa2_cout;\n\nwire [3:0] csa3_sum;\nwire [3:0] csa3_cout;\n\n// 4-bit ripple carry adder\nassign {rca0_cout[0], rca0_sum[0]} = a[0] + b[0] + cin;\nassign {rca0_cout[1], rca0_sum[1]} = a[1] + b[1] + rca0_cout[0];\nassign {rca0_cout[2], rca0_sum[2]} = a[2] + b[2] + rca0_cout[1];\nassign {rca0_cout[3], rca0_sum[3]} = a[3] + b[3] + rca0_cout[2];\n\n// 4-bit carry select adder\nassign {csa0_cout[0], csa0_sum[0]} = rca0_cout[0] ? rca0_sum[0] : a[0];\nassign {csa0_cout[1], csa0_sum[1]} = rca0_cout[1] ? rca0_sum[1] : a[1];\nassign {csa0_cout[2], csa0_sum[2]} = rca0_cout[2] ? rca0_sum[2] : a[2];\nassign {csa0_cout[3], csa0_sum[3]} = rca0_cout[3] ? rca0_sum[3] : a[3];\n\nassign {rca1_cout[0], rca1_sum[0]} = csa0_sum[0] + csa0_sum[1] + csa0_cout[0];\nassign {rca1_cout[1], rca1_sum[1]} = csa0_sum[2] + csa0_sum[3] + rca1_cout[0];\n\n// 4-bit carry select adder\nassign {csa1_cout[0], csa1_sum[0]} = rca1_cout[0] ? rca1_sum[0] : csa0_sum[0];\nassign {csa1_cout[1], csa1_sum[1]} = rca1_cout[1] ? rca1_sum[1] : csa0_sum[1];\nassign {csa1_cout[2], csa1_sum[2]} = rca1_cout[2] ? rca1_sum[2] : csa0_sum[2];\nassign {csa1_cout[3], csa1_sum[3]} = rca1_cout[3] ? rca1_sum[3] : csa0_sum[3];\n\nassign {rca1_cout[0], rca1_sum[0]} = csa1_sum[0] + csa1_sum[1] + csa1_cout[0];\nassign {rca1_cout[1], rca1_sum[1]} = csa1_sum[2] + csa1_sum[3] + rca1_cout[1];\n\n// 4-bit carry select adder\nassign {csa2_cout[0], csa2_sum[0]} = rca1_cout[0] ? rca1_sum[0] : csa1_sum[0];\nassign {csa2_cout[1], csa2_sum[1]} = rca1_cout[1] ? rca1_sum"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire C1, C2, C3;\n\n    // adder_8bit submodule instantiation\n    adder_8bit adder_8bit_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(C1)\n    );\n\n    adder_8bit adder_8bit_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(C1),\n        .y(y[15:8]),\n        .Co(C2)\n    );\n\n    assign Co = C2;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire C1, C2;\n\n    // 8-bit adder logic implementation\n    assign y[0] = a[0] ^ b[0] ^ Cin;\n    assign Co = (a[0] & b[0]) | (a[0] & Cin) | (b[0] & Cin);\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin : bit_adder\n            assign y[i] = a[i] ^ b[i] ^ Co;\n            assign Co = (a[i] & b[i]) | (a[i] & Co) | (b[i] & Co);\n        end\n    endgenerate\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa_sum;\n    wire [7:0] fa_cout;\n    \n    // First full adder\n    fa fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(fa_sum[0]), .cout(fa_cout[0]));\n    \n    // Second full adder\n    fa fa1(.a(a[1]), .b(b[1]), .cin(fa_cout[0]), .sum(fa_sum[1]), .cout(fa_cout[1]));\n    \n    // Third full adder\n    fa fa2(.a(a[2]), .b(b[2]), .cin(fa_cout[1]), .sum(fa_sum[2]), .cout(fa_cout[2]));\n    \n    // Fourth full adder\n    fa fa3(.a(a[3]), .b(b[3]), .cin(fa_cout[2]), .sum(fa_sum[3]), .cout(fa_cout[3]));\n    \n    // Fifth full adder\n    fa fa4(.a(a[4]), .b(b[4]), .cin(fa_cout[3]), .sum(fa_sum[4]), .cout(fa_cout[4]));\n    \n    // Sixth full adder\n    fa fa5(.a(a[5]), .b(b[5]), .cin(fa_cout[4]), .sum(fa_sum[5]), .cout(fa_cout[5]));\n    \n    // Seventh full adder\n    fa fa6(.a(a[6]), .b(b[6]), .cin(fa_cout[5]), .sum(fa_sum[6]), .cout(fa_cout[6]));\n    \n    // Eighth full adder\n    fa fa7(.a(a[7]), .b(b[7]), .cin(fa_cout[6]), .sum(fa_sum[7]), .cout(fa_cout[7]));\n    \n    assign sum = fa_sum;\n    assign cout = fa_cout[7];\nendmodule\n\nmodule fa(\n    input a, b, cin, \n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'd0;\n        product <= 32'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'd0;\n            product <= 32'd0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'd15) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 4'd1;\n                product <= product + (bin << shift_cnt);\n            end\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [31:0] temp_y;\nreg [3:0] i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        temp_y <= 32'd0;\n        i <= 4'd0;\n    end else begin\n        if (shift_cnt == i) begin\n            temp_y <= temp_y + (b_reg << i);\n        end\n        i <= i + 4'd1;\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n// submodules\nu_counter_logic u_counter_logic_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count),\n    .u_counter_logic_count_next(count)\n);\n\nu_counter_register u_counter_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count),\n    .u_counter_register_count_next(count)\n);\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output wire [15:0] u_counter_logic_count_next\n);\n\nreg [15:0] count_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_reg <= 16'd0;\n    end else begin\n        count_reg <= up_down ? (count + 16'd1) : (count - 16'd1);\n    end\nend\n\nassign u_counter_logic_count_next = count_reg;\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] count,\n    output wire [15:0] u_counter_register_count_next\n);\n\nreg [15:0] count_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_reg <= 16'd0;\n    end else begin\n        count_reg <= count;\n    end\nend\n\nassign u_counter_register_count_next = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // State Initialization Submodule\n    initial begin\n        out = 8'b0000_0001;\n    end\n\n    // State Transition Submodule\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule\n```\n\n### [Dual-Port RAM with Read-Write Ports](./dual-port-ram-with-read-write-ports.v)\n```verilog\n`timescale 1ns / 1ps\n`define PORT_A_WRITE 0\n`define PORT_A_READ  1\n`define PORT_B_WRITE 0\n`define PORT_B_READ  1\n`define PORT_A_DATA  2\n`define PORT_B_DATA  3\n`define PORT_A_ADDR  4\n`define PORT_B_ADDR  5\n`define PORT_A_MASK  6\n`define PORT_B_MASK  7\n`define DATA_WIDTH   8\n`define ADDR_WIDTH   3\n\nmodule dual_port_ram (\n    input wire clk,\n    input wire [`ADDR_WIDTH-1:0] addr_a,\n    input wire [`ADDR_WIDTH-1:0] addr_b,\n    input wire [7:0] write_data,\n    input wire [`DATA_WIDTH-1:0] write_mask,\n    output reg [7:0] read_data_a,\n    output reg [7:0] read_data_b\n);\n\n    reg [7:0] ram [0:(1 << `ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (write_mask[`PORT_A_WRITE]) begin\n            ram[addr_a] <= write_data;\n        end\n        if (write_mask[`PORT_B_WRITE]) begin\n            ram[addr_b] <= write_data;\n        end\n        read_data_a <= ram[addr_a];\n        read_data_b <= ram[addr_b];\n    end\nendmodule\n```\n\n### [Simple Register](./simple_register.v)\n```verilog\n`timescale 1ns / 1ps\n`define PORT_WRITE  0\n`define PORT_READ   1\n`define PORT_DATA   2\n`define PORT_ADDR   4\n\nmodule simple_register (\n    input wire clk,\n    input wire [3:0] write_mask,\n    input wire [7:0] write_data,\n    output reg [7:0] read_data\n);\n\n    always @(posedge clk) begin\n        if (write_mask[`PORT_WRITE]) begin\n            read_data <= write_data;\n        end\n    end\nendmodule\n```\n\n### [Simple Register with Write Mask](./simple_register_with_write_mask.v)\n```verilog\n`timescale 1ns / 1ps\n`define PORT_WRITE  0\n`define PORT_READ   1\n`define PORT_DATA   2\n`define PORT_ADDR   4\n\nmodule simple_register_with_write_mask (\n    input wire clk,\n    input wire [3:0] write_mask,\n    input wire [7:0] write_data,\n    output reg [7:0] read_data\n);\n\n    always @(posedge clk) begin\n        if (write_mask[`PORT_WRITE]) begin\n            read_data <= write_data;\n        end\n    end\nendmodule\n```\n\n### [Simple Register with Write Mask and Read Mask](./simple_register_with_write_mask_and_read_mask.v)\n```verilog\n`timescale 1ns / 1ps\n`define PORT_WRITE  0\n`define PORT_READ   1\n`define PORT_DATA   2\n`define PORT_ADDR   4\n`define PORT_MASK   6\n\nmodule simple_register_with_write_mask_and_read_mask (\n    input wire clk,\n   "}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count_out;\n\n// counter_logic\nreg [3:0] count;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        if (count == 4'd11)\n            count <= 4'b0000;\n            else\n                count <= count + 1;\nend\nassign count_out = count;\n\n// output_register\nreg [3:0] out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= count_out;\n    else\n        out_reg <= out_reg;\nend\nassign out = out_reg;\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count_out\n);\n\nreg [3:0] count;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        if (count == 4'd11)\n            count <= 4'b0000;\n            else\n                count <= count + 1;\nend\nassign count_out = count;\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_out,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= count_out;\n    else\n        out_reg <= out_reg;\nend\nassign out = out_reg;\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule implementation\n// Register submodule\nreg [63:0]    Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\n// Logic submodule\nwire [63:0]    Q_logic;\nassign Q_logic = {Q_reg[62:0], Q_reg[63]};\nassign Q = Q_logic;\n\nendmodule\n-------------------------------------------------\n-------------------------------------------------\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n// Submodule implementation\n// Register submodule\nreg [63:0]    Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\n// Logic submodule\nwire [63:0]    Q_logic;\nassign Q_logic = {Q_reg[62:0], Q_reg[63]};\nassign Q = Q_logic;\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_in_meta = CLK_in;\n    wire RST_meta = RST;\n    wire CLK_50_meta = CLK_50;\n    wire CLK_10_meta = CLK_10;\n    wire CLK_1_meta = CLK_1;\n\n    // Placeholder for submodules\n    wire clk_div_2_out;\n    wire clk_div_10_out;\n    wire clk_div_100_out;\n\n    assign CLK_50 = clk_div_2_out;\n    assign CLK_10 = clk_div_10_out;\n    assign CLK_1 = clk_div_100_out;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [1:0] div_clk = (clk_average & clk_adjustment) | (clk_average & clk_average);\n\nassign clk_div = div_clk[MUL2_DIV_CLK-1];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          count,\n    output              clk_div\n);\n\nparameter COUNT_MAX = 15;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (count == COUNT_MAX)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\nassign clk_div = (count == COUNT_MAX);\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg [1:0]    clk_average\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else if (clk_div)\n        clk_average <= 2'b01;\n    else\n        clk_average <= {clk_average[0], clk_div};\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output              clk_adjustment\n);\n\nassign clk_adjustment = ~clk_div;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nwire clk_div1;\nwire clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n    end else begin\n        pos_counter <= pos_counter + 1;\n    end\nend\n\nassign clk_div1 = (pos_counter == (NUM_DIV - 1)) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n    end else begin\n        neg_counter <= neg_counter + 1;\n    end\nend\n\nassign clk_div2 = (neg_counter == (NUM_DIV - 1)) ? 1'b1 : 1'b0;\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\nparameter NUM_DIV = 4;\n\nreg [3:0] counter;\nwire [3:0] half_div = NUM_DIV / 2 - 1;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == half_div)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nassign clk_div = counter == 0;\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_out, sub_out, sll_out, srl_out, sra_out, nor_out, and_out, or_out, xor_out;\nwire [31:0] slt_out, sltu_out, sllv_out, srlv_out, srav_out;\n\nassign r = (aluc == 6'b000000) ? sll_out :\n           (aluc == 6'b000010) ? srl_out :\n           (aluc == 6'b000011) ? sra_out :\n           (aluc == 6'b100000) ? add_out :\n           (aluc == 6'b100001) ? addu_out :\n           (aluc == 6'b100010) ? sub_out :\n           (aluc == 6'b100011) ? subu_out :\n           (aluc == 6'b100100) ? and_out :\n           (aluc == 6'b100101) ? or_out :\n           (aluc == 6'b100110) ? xor_out :\n           (aluc == 6'b100111) ? nor_out :\n           (aluc == 6'b101010) ? slt_out :\n           (aluc == 6'b101011) ? sltu_out :\n           (aluc == 6'b000100) ? sllv_out :\n           (aluc == 6'b000110) ? srlv_out :\n           (aluc == 6'b000111) ? srav_out :\n           32'b0;\n\nassign zero = (r == 0) ? 1'b1 : 1'b0;\nassign carry = (r[31] == 1) ? 1'b1 : 1'b0;\nassign negative = (r[31] == 1) ? 1'b1 : 1'b0;\nassign overflow = (r[31] == 1) ? 1'b1 : 1'b0;\nassign flag = (aluc == 6'b101010) ? slt_out[31] :\n              (aluc == 6'b101011) ? sltu_out[31] :\n              1'b0;\n\n// Addition module\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\nassign r = a + b;\nendmodule\n\n// Subtraction module\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\nassign r = a - b;\nendmodule\n\n// Logical module\nmodule logical(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\nassign r = a & b;\nendmodule\n\n// Shift Left Logical module\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\nassign r = a << b;\nendmodule\n\n// Shift Right Logical module\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\nassign r = a >> b;\nendmodule\n\n// Shift Right Arithmetic module\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\nassign r = $signed(a) >>> b;\nendmodule\n\n// Shift Left Logical variable module\nmodule sllv(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Implementing the multiplication submodule here.\n// This submodule should output multiplication_result.\n// You can implement this submodule or use an existing module.\n// The submodule should accept a and b as input ports.\n\n// Implementing the accumulator submodule here.\n// This submodule should take multiplication_result and current_value as input ports.\n// The submodule should also have a register to hold the accumulated value.\n// The submodule should reset the accumulated value to 0 when rst is high.\n// The submodule should add the multiplication result to the current value when rst is low.\n// The submodule should output the accumulated value as current_value.\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n\nwire clk_en;\n\nreg [2:0] ins_p1;\nreg [4:0] ad1_p1;\nreg [7:0] ad2_p1;\n\nreg [2:0] ins_p2;\nreg [4:0] ad1_p2;\nreg [7:0] ad2_p2;\n\nassign clk_en = 1;\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        ins_p1 <= 3'b0;\n        ad1_p1 <= 5'b0;\n        ad2_p1 <= 8'b0;\n        ins_p2 <= 3'b0;\n        ad1_p2 <= 5'b0;\n        ad2_p2 <= 8'b0;\n    end else if (clk_en) begin\n        case (fetch)\n            2'b01: begin\n                ins_p1 <= data[7:5];\n                ad1_p1 <= data[4:0];\n                ad2_p1 <= data;\n            end\n            2'b10: begin\n                ins_p2 <= data[7:5];\n                ad1_p2 <= data[4:0];\n                ad2_p2 <= data;\n            end\n            default: begin\n                ins_p1 <= ins_p1;\n                ad1_p1 <= ad1_p1;\n                ad2_p1 <= ad2_p1;\n                ins_p2 <= ins_p2;\n                ad1_p2 <= ad1_p2;\n                ad2_p2 <= ad2_p2;\n            end\n        endcase\n    end\nend\n\nassign ins = fetch[0] ? ins_p1 : ins_p2;\nassign ad1 = fetch[0] ? ad1_p1 : ad1_p2;\nassign ad2 = fetch[0] ? ad2_p1 : ad2_p2;\n\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n\n    wire enable = (freq != 0);\n\n    counter counter_inst (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wire [7:0] toggle_count = (freq == 0) ? 0 : count;\n    wire toggle = (toggle_count % 2) == 1;\n\n    wire [7:0] scaled_freq = (freq == 0) ? 0 : (freq - 1);\n    wire [7:0] inverse_freq = (scaled_freq == 0) ? 0 : (256 / scaled_freq);\n\n    wave_generator wave_generator_inst (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter (\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n    reg toggle;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            toggle <= ~toggle;\n        end\n    end\n\n    assign wave_out = toggle;\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state = 2'b00;\n    reg [4:0] wave_reg = 5'd0;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin // Incrementing\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end else begin\n                        wave_reg <= wave_reg + 5'd1;\n                    end\n                end\n                2'b01: begin // Decrementing\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end else begin\n                        wave_reg <= wave_reg - 5'd1;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 5'd0;\n                end\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    reg [7:0] shift_reg [0:2];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    my_dff8 u0 (.clk(clk), .d(d), .q(q[0]));\n    my_dff8 u1 (.clk(clk), .d(q[0]), .q(q[1]));\n    my_dff8 u2 (.clk(clk), .d(q[1]), .q(q[2]));\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire n1, n2, n3;\n\n    my_dff dff1 (n1, clk, d);\n    my_dff dff2 (n2, clk, n1);\n    my_dff dff3 (q, clk, n2);\n\nendmodule\n\nmodule my_dff (output q, input clk, input d);\n    reg q_reg;\n\n    always @(posedge clk)\n        q_reg <= d;\n\n    assign q = q_reg;\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] mux1_out, mux2_out, mux3_out, mux4_out;\nwire [2:0] sel;\n\nassign sel[2] = ctrl[2];\nassign sel[1] = ctrl[2] | ctrl[1];\nassign sel[0] = ctrl[2] | ctrl[1] | ctrl[0];\n\nmux2X1 mux1 (mux1_out, in, in >> 4, sel[2]);\nmux2X1 mux2 (mux2_out, mux1_out, mux1_out >> 2, sel[1]);\nmux2X1 mux3 (mux3_out, mux2_out, mux2_out >> 1, sel[0]);\nmux2X1 mux4 (mux4_out, mux3_out, mux3_out >> 1, sel[0]);\n\nassign out = mux4_out;\n\nendmodule\n\nmodule mux2X1 (out, in0, in1, sel);\ninput [7:0] in0, in1;\ninput sel;\noutput [7:0] out;\n\nassign out = sel ? in1 : in0;\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n\n  // PE0\n  wire [31:0] pe0_out;\n  assign pe0_out = {24'b0, a0} * {24'b0, b0};\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 32'd0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  // PE1\n  wire [31:0] pe1_out;\n  assign pe1_out = {24'b0, a1} * {24'b0, b1};\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch_out [0:31];\n  wire [31:0] decode_out [0:31];\n  wire [31:0] execute_out [0:31];\n  wire [31:0] memory_out [0:31];\n  wire [31:0] writeback_out [0:31];\n  reg [4:0] pc = 0;\n\n  stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetch_out(fetch_out)\n  );\n\n  stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .fetch_out(fetch_out),\n    .decode_out(decode_out)\n  );\n\n  stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .decode_out(decode_out),\n    .execute_out(execute_out)\n  );\n\n  stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .execute_out(execute_out),\n    .memory_out(memory_out)\n  );\n\n  stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .memory_out(memory_out),\n    .reg_file(reg_file),\n    .writeback_out(writeback_out)\n  );\n\n  assign res_reg_file[0] = writeback_out[0];\nendmodule\n\nmodule stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output [31:0] fetch_out [0:31]\n);\n  reg [4:0] pc_next;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_next <= 0;\n    end else begin\n      pc_next <= pc + 1;\n    end\n  end\n\n  assign fetch_out = instr_mem[pc_next];\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [15:0] r_b1, r_b2, r_b3;\n  reg [31:0] r_c0, r_c1, r_c2, r_c3;\n  \n  // Delayed signals\n  assign b1 = r_b1;\n  assign b2 = r_b2;\n  assign b3 = r_b3;\n  assign c0 = r_c0;\n  assign c1 = r_c1;\n  assign c2 = r_c2;\n  assign c3 = r_c3;\n  \n  // Processing Elements\n  pe pe0(\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .b0(b0),\n    .c0(r_c0)\n  );\n  \n  pe pe1(\n    .clk(clk),\n    .rst(rst),\n    .a0(a1),\n    .b0(b1),\n    .c0(r_c1)\n  );\n  \n  pe pe2(\n    .clk(clk),\n    .rst(rst),\n    .a0(a2),\n    .b0(b2),\n    .c0(r_c2)\n  );\n  \n  pe pe3(\n    .clk(clk),\n    .rst(rst),\n    .a0(a3),\n    .b0(b3),\n    .c0(r_c3)\n  );\n  \n  // Pipeline register\n  always @(posedge clk) begin\n    if (rst) begin\n      r_b1 <= 0;\n      r_b2 <= 0;\n      r_b3 <= 0;\n      r_c0 <= 0;\n      r_c1 <= 0;\n      r_c2 <= 0;\n      r_c3 <= 0;\n    end else begin\n      r_b1 <= b1;\n      r_b2 <= b2;\n      r_b3 <= b3;\n      r_c0 <= c0;\n      r_c1 <= c1;\n      r_c2 <= c2;\n      r_c3 <= c3;\n    end\n  end\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] b0,\n  output [31:0] c0\n);\n  reg [31:0] r_c0;\n  \n  // Pipeline register\n  always @(posedge clk) begin\n    if (rst) begin\n      r_c0 <= 0;\n    end else begin\n      r_c0 <= {a0, b0};\n    end\n  end\n  \n  assign c0 = r_c0;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] fetch;\nwire [31:0] execute;\nwire [31:0] writeback;\n\nstagepipe3_fetch fetch_stage(.clk(clk), .rst(rst), .instr_mem(instr_mem), .out_reg_file(fetch));\nstagepipe3_execute execute_stage(.clk(clk), .rst(rst), .reg_file(reg_file), .fetch(fetch), .out_reg_file(execute));\nstagepipe3_writeback writeback_stage(.clk(clk), .rst(rst), .reg_file(reg_file), .writeback(execute));\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] pc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 32'd0;\n            pc <= 6'd0;\n        end else begin\n            out_reg_file <= instr_mem[pc];\n            pc <= pc + 6'd1;\n        end\n    end\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    input [31:0] fetch,\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] rd;\n    reg [31:0] rs1_value;\n    reg [31:0] rs2_value;\n    reg [31:0] imm;\n    reg [5:0] opcode;\n    reg [5:0] funct;\n    reg [2:0] shamt;\n    reg [4:0] rt;\n    reg [4:0] rd_value;\n    reg [4:0] rs1_value_out;\n    reg [4:0] rs2_value_out;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rs1_value_out <= 5'd0;\n            rs2_value_out <= 5'd0;\n            out_reg_file <= 32'd0;\n            opcode <= 6'd0;\n            funct <= 6'd0;\n            shamt <= 3'd0;\n            rt <= 5'd0;\n            rd <= 5'd0;\n            result <= 32'd0;\n        end else begin\n            opcode <= fetch[31:26];\n            funct <= fetch[5:0];\n            shamt <= fetch[10:6];\n            rt <= fetch[15:11];\n            rd <= fetch[20:15];\n            rs1_value <= reg_file[fetch[20:15]];\n            rs2_value <= reg_file[fetch[25:21]];\n            case (opcode)\n                6'd0: begin // ADDI\n                    rs1_value_out <= rs1_value + imm;\n                end\n                6'd2: begin // ADD\n                    rs1_value_out <= rs1_value + rs2_value;\n                end\n                6'd4: begin // SUB\n                    rs1_value_out <= rs1_value - rs2_value;\n                end\n                default: begin\n                    rs1_value_out <= 5'd0;\n                    rs2_value_out <= 5'd0;\n                    out_reg_file <= 32'd0;\n                end\n            endcase\n            out_reg_file <= rs1_value_out;\n        end\n    end\nendmodule\n\nmodule stagepipe3_writeback (\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    input [31:0] writeback,\n    output reg [31:0]"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nparameter DATA_WIDTH = 8;\nparameter ADDER_DATA_WIDTH = 9;\n\nreg [DATA_WIDTH - 1:0] data_accumulator;\nreg [2:0] count;\nreg valid_out_i;\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nreg [1:0] counter_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_i <= 2'b0;\n    end else if (counter_i == 2'b11) begin\n        counter_i <= 2'b0;\n    end else if (valid_in) begin\n        counter_i <= counter_i + 1;\n    end\nend\n\nassign valid_out = valid_out_i;\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accumulator <= {ADDER_DATA_WIDTH{1'b0}};\n    end else begin\n        data_accumulator <= data_accumulator + data_in;\n    end\nend\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_i <= 1'b0;\n    end else if (counter_i == 2'b11) begin\n        valid_out_i <= 1'b1;\n    end else begin\n        valid_out_i <= 1'b0;\n    end\nend\n\nassign data_out = data_accumulator;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [1:0]   count\n);\n\nreg [1:0] count_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_i <= 2'b0;\n    end else if (count_i == 2'b11) begin\n        count_i <= 2'b0;\n    end else if (valid_in) begin\n        count_i <= count_i + 1;\n    end\nend\n\nassign valid_out = (count_i == 2'b11);\nassign count = count_i;\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nparameter DATA_WIDTH = 8;\nparameter ADDER_DATA_WIDTH = 9;\n\nreg [DATA_WIDTH - 1:0] data_accumulator;\nreg valid_out_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accumulator <= {ADDER_DATA_WIDTH{1'b0}};\n        valid_out_i <= 1'b0;\n    end else if (valid_in) begin\n        data_accumulator <= data_accumulator + data_in;\n    end else begin\n        valid_out_i <= 1'b0;\n    end\nend\n\nassign valid_out = valid_out_i;\n\nassign data_out = data_accumulator;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [1:0]   count\n);\n\nreg [1:0] count_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_i <= 2'b0;\n    end else if (count_i == 2'b11) begin\n        count_i <= 2'b0;\n    end else if"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend, neg_divisor;\n    wire [3:0] counter;\n    reg [15:0] shift_reg;\n\n    assign abs_dividend = (sign) ? ~dividend + 1 : dividend;\n    assign neg_divisor = (sign) ? ~divisor + 1 : divisor;\n\n    // FIXME: Submodule not defined\n    // ...\n\n    // FIXME: Submodule not defined\n    // ...\n\n    // FIXME: Submodule not defined\n    // ...\n\n    // FIXME: Submodule not defined\n    // ...\n\n    // FIXME: Submodule not defined\n    // ...\n\nendmodule\n"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Module prep_dividend\n    // Prepare dividend and divisor for division\n    // Inputs:\n    //      A: 32-bit dividend\n    //      B: 16-bit divisor\n    // Outputs:\n    //      result: 32-bit dividend\n    //      odd: 16-bit divisor\n    //\n    // Implementation:\n    // The dividend and divisor are shifted to the left by 16 bits each.\n    // The output is the original dividend.\n    wire [31:0] result_prep;\n    wire [15:0] odd_prep;\n    assign result_prep = A << 16;\n    assign odd_prep = B << 16;\n\n    // Module div_operation\n    // Perform division using prepared dividend and divisor\n    // Inputs:\n    //      result: 32-bit dividend\n    //      odd: 16-bit divisor\n    // Outputs:\n    //      result: 32-bit quotient\n    //      odd: 32-bit remainder\n    //\n    // Implementation:\n    // The divisor is shifted right by 16 bits and compared to the dividend.\n    // If the dividend is greater than the divisor, the dividend is subtracted from the divisor and the dividend is shifted right by 1 bit.\n    // The dividend is then shifted right by 1 bit and the loop continues.\n    // The result of the division is the quotient and remainder.\n    wire [31:0] result_div;\n    wire [31:0] odd_div;\n    assign result_div = result_prep << 1;\n    assign odd_div = {odd_prep, 1'b0} << 1;\n\n    // Main module\n    // Instantiate submodules\n    // Inputs:\n    //      A: 32-bit dividend\n    //      B: 16-bit divisor\n    // Outputs:\n    //      result: 32-bit quotient\n    //      odd: 32-bit remainder\n    //\n    // Implementation:\n    // Instantiate the submodules and connect their outputs to the outputs of the main module.\n    prep_dividend prep_dividend_inst (\n        .result(result_prep),\n        .odd(odd_prep),\n        .A(A),\n        .B(B)\n    );\n\n    div_operation div_operation_inst (\n        .result(result_div),\n        .odd(odd_div),\n        .result_prep(result_prep),\n        .odd_prep(odd_prep)\n    );\n\n    assign result = result_div;\n    assign odd = odd_div;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit dividend\n    output wire [15:0] odd      // 16-bit divisor\n);\n\n    assign result = A;\n    assign odd = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] result_prep, // 32-bit dividend\n    input wire [15:0] odd_prep,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    // Local signals\n    reg [31:0] result_div;\n    reg [31:0] odd_div;\n    reg [31:0] odd_temp;\n    reg [31:0] result_temp;\n    reg [5:0] i;\n\n    // Implementation\n    // The divisor is shifted right by 16 bits and compared to the dividend.\n    // If the dividend is greater than the divisor, the dividend is subtracted from the divisor and the dividend is shifted right by 1 bit.\n    // The dividend is then shifted right by 1 bit and the loop continues.\n   "}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_q;\n    wire [15:0] temp_r;\n    wire [7:0] temp_s;\n    wire [7:0] temp_t;\n    wire [15:0] temp_u;\n    wire [15:0] temp_v;\n    wire [15:0] temp_w;\n    wire [15:0] temp_x;\n    wire [15:0] temp_y;\n    wire [15:0] temp_z;\n\n    assign result = temp_q;\n    assign odd = temp_r;\n\n    // Control unit\n    control_unit control_unit_inst (\n        .A(A),\n        .B(B),\n        .temp_q(temp_q),\n        .temp_r(temp_r),\n        .temp_s(temp_s),\n        .temp_t(temp_t),\n        .temp_u(temp_u),\n        .temp_v(temp_v),\n        .temp_w(temp_w),\n        .temp_x(temp_x),\n        .temp_y(temp_y),\n        .temp_z(temp_z)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] temp_q, // 16-bit quotient\n    output wire [15:0] temp_r, // 16-bit remainder\n    output wire [7:0] temp_s,  // 8-bit divisor\n    output wire [7:0] temp_t,  // 8-bit divisor\n    output wire [15:0] temp_u, // 16-bit dividend\n    output wire [15:0] temp_v, // 16-bit dividend\n    output wire [15:0] temp_w, // 16-bit dividend\n    output wire [15:0] temp_x, // 16-bit dividend\n    output wire [15:0] temp_y, // 16-bit dividend\n    output wire [15:0] temp_z  // 16-bit dividend\n);\n\n    reg [15:0] temp_q_reg;\n    reg [15:0] temp_r_reg;\n    reg [7:0] temp_s_reg;\n    reg [7:0] temp_t_reg;\n    reg [15:0] temp_u_reg;\n    reg [15:0] temp_v_reg;\n    reg [15:0] temp_w_reg;\n    reg [15:0] temp_x_reg;\n    reg [15:0] temp_y_reg;\n    reg [15:0] temp_z_reg;\n\n    assign temp_q = temp_q_reg;\n    assign temp_r = temp_r_reg;\n    assign temp_s = temp_s_reg;\n    assign temp_t = temp_t_reg;\n    assign temp_u = temp_u_reg;\n    assign temp_v = temp_v_reg;\n    assign temp_w = temp_w_reg;\n    assign temp_x = temp_x_reg;\n    assign temp_y = temp_y_reg;\n    assign temp_z = temp_z_reg;\n\n    always @(*) begin\n        temp_q_reg = 16'b0;\n        temp_r_reg = 16'b0;\n        temp_s_reg = B;\n        temp_t_reg = B;\n        temp_u_reg = A;\n        temp_v_reg = A;\n        temp_w_reg = 16'b0;\n        temp_x_reg = 16'b0;\n        temp_y_reg = 16'b0;\n        temp_z_reg = 16'b0;\n\n        // Control unit implementation\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\nreg [7:0] B_comp;\nwire [7:0] carry;\nwire [7:0] sum;\ninteger i;\n\nassign B_comp = ~B + 1;\n\n// Generate carry chain\nassign carry[0] = 1;\nfor (i = 0; i < 7; i = i + 1) begin\n    assign carry[i+1] = carry[i] & carry[i+1];\nend\n\n// Generate sum\nassign sum[0] = A[0] ^ B_comp[0];\nfor (i = 1; i < 8; i = i + 1) begin\n    assign sum[i] = (A[i] ^ B_comp[i]) ^ carry[i-1];\nend\n\n// Assign outputs\nassign D = sum;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\ninput [7:0] A;\ninput [7:0] B;\ninput C_in;\noutput [7:0] D;\noutput C_out;\n\nreg [7:0] D;\nreg C_out;\nreg [7:0] carry;\nwire [7:0] sum;\ninteger i;\n\nassign sum[0] = A[0] ^ B[0] ^ C_in;\nfor (i = 1; i < 8; i = i + 1) begin\n    assign sum[i] = (A[i] ^ B[i]) ^ carry[i-1] ^ C_in;\nend\n\n// Assign outputs\nassign D = sum;\nassign C_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\ninput A;\ninput B;\ninput C_in;\noutput D;\noutput C_out;\n\nreg D;\nreg C_out;\n\nalways @(A or B or C_in) begin\n    D = A ^ B ^ C_in;\n    C_out = (A & B) | (B & C_in) | (A & C_in);\nend\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput wire [31:0] A, B;\noutput wire [31:0] Diff;\noutput wire B_out;\n\n// TODO: implement the subtractor module\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12;\nwire [31:0] D13, D14, D15, D16, D17, D18, D19, D20, D21, D22, D23, D24, D25, D26, D27, D28, D29, D30, D31, D32, D33, D34, D35, D36, D37, D38, D39, D40, D41, D42, D43, D44, D45, D46, D47, D48, D49, D50, D51, D52, D53, D54, D55, D56, D57, D58, D59, D60, D61, D62, D63;\nwire B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32, B33, B34, B35, B36, B37, B38, B39, B40, B41, B42, B43, B44, B45, B46, B47, B48, B49, B50, B51, B52, B53, B54, B55, B56, B57, B58, B59, B60, B61, B62, B63;\nwire B_out1, B_out2, B_out3, B_out4, B_out5, B_out6, B_out7, B_out8, B_out9, B_out10, B_out11, B_out12;\n\n// 32-bit subtractor\nsub_32bit u0(A[31:0], B[31:0], D13, B1);\nsub_32bit u1(D13, A[63:32], B[63:32], D14, B2);\nsub_32bit u2(D14, A[63:32], B[63:32], D15, B3);\nsub_32bit u3(D15, A[63:32], B[63:32], D16, B4);\nsub_32bit u4(D16, A[63:32], B[63:32], D17, B5);\nsub_32bit u5(D17, A[63:32], B[63:32], D18, B6);\nsub_32bit u6(D18, A[63:32], B[63:32], D19, B7);\nsub_32bit u7(D19, A[63:32], B[63:32], D20, B8);\nsub_32bit u8(D20, A[63:32], B[63:32], D21, B9);\nsub_32bit u9(D21, A[63:32], B[63:32], D22, B10);\nsub_32bit u10(D22, A[63:32], B[63:32], D23, B11);\nsub_32bit u11(D23, A[63:32], B"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\nwire [4:1] A1, A2, A3, A4;\nwire [4:1] B1, B2, B3, B4;\nwire [4:1] D1, D2, D3, D4;\nwire [1:1] B_out1, B_out2, B_out3, B_out4;\n\nassign A1 = A[4:1];\nassign A2 = A[8:5];\nassign A3 = A[12:9];\nassign A4 = A[16:13];\n\nassign B1 = B[4:1];\nassign B2 = B[8:5];\nassign B3 = B[12:9];\nassign B4 = B[16:13];\n\nsub_4bit_full_subtractor full_subtractor1 (.A(A1), .B(B1), .D(D1), .B_out(B_out1));\nsub_4bit_full_subtractor full_subtractor2 (.A(A2), .B(B2), .D(D2), .B_out(B_out2));\nsub_4bit_full_subtractor full_subtractor3 (.A(A3), .B(B3), .D(D3), .B_out(B_out3));\nsub_4bit_full_subtractor full_subtractor4 (.A(A4), .B(B4), .D(D4), .B_out(B_out4));\n\nassign D = {D1, D2, D3, D4};\nassign B_out = B_out1 & B_out2 & B_out3 & B_out4;\n\nendmodule\nmodule sub_4bit_full_subtractor(A, B, D, B_out);\ninput [4:1] A, B;\noutput [4:1] D;\noutput B_out;\n\nwire [3:1] B_out_3to1;\n\nassign D = A - B;\nassign B_out_3to1[1] = (~(A[1] ^ B[1]) & (A[2] ^ B[2])) | (A[1] & B[1]) | (A[2] & B[2]);\nassign B_out_3to1[2] = (~(A[2] ^ B[2]) & (A[3] ^ B[3])) | (A[2] & B[2]) | (A[3] & B[3]);\nassign B_out_3to1[3] = (~(A[3] ^ B[3]) & (A[4] ^ B[4])) | (A[3] & B[3]) | (A[4] & B[4]);\nassign B_out = B_out_3to1[1] & B_out_3to1[2] & B_out_3to1[3];\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] A_minus_B;\nwire carry;\n\n// Subtraction logic\nassign A_minus_B = A - B;\nassign carry = (A_minus_B[31] == 1);\n\n// Comparison logic\nassign A_greater = carry;\nassign A_equal = (A_minus_B == 0);\nassign A_less = (!carry && (A_minus_B != 0));\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] A_minus_B,\n    output carry\n);\n\nassign A_minus_B = A - B;\nassign carry = (A_minus_B[31] == 1);\n\nendmodule\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = |S[16:1] ^ |(A[16:1] ^ B[16:1]);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\nwire [15:0] carry;\n\nwire [3:0] a0, a1, a2, a3;\nwire [3:0] b0, b1, b2, b3;\nwire [3:0] c0, c1, c2, c3;\nwire [3:0] sum0, sum1, sum2, sum3;\n\n// Ripple carry adder\nwire [3:0] c00, c01, c02, c03;\nwire [3:0] sum00, sum01, sum02, sum03;\n\nassign a0 = a[3:0];\nassign b0 = b[3:0];\nassign c0 = {c0, 1'b0};\nassign sum0 = {sum0, a0 ^ b0 ^ c0};\n\nassign a1 = a[7:4];\nassign b1 = b[7:4];\nassign c1 = {c1, c0[3]};\nassign sum1 = {sum1, a1 ^ b1 ^ c1};\n\nassign a2 = a[11:8];\nassign b2 = b[11:8];\nassign c2 = {c2, c1[3]};\nassign sum2 = {sum2, a2 ^ b2 ^ c2};\n\nassign a3 = a[15:12];\nassign b3 = b[15:12];\nassign c3 = {c3, c2[3]};\nassign sum3 = {sum3, a3 ^ b3 ^ c3};\n\n// Carry-select adder\nwire [3:0] c4, c5, c6, c7;\nwire [3:0] sum4, sum5, sum6, sum7;\n\nassign c4[0] = c0[3];\nassign c5[0] = c1[3];\nassign c6[0] = c2[3];\nassign c7[0] = c3[3];\n\nassign sum4 = a0 + b0 + c4;\nassign sum5 = a1 + b1 + c5;\nassign sum6 = a2 + b2 + c6;\nassign sum7 = a3 + b3 + c7;\n\nassign carry = {c7, c6[3], c5[3], c4[3]};\nassign cout = carry[3];\nassign sum = {sum7, sum6, sum5, sum4};\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] carry;\n\nwire [3:0] a0, a1, a2, a3;\nwire [3:0] b0, b1, b2, b3;\nwire [3:0] c0, c1, c2, c3;\nwire [3:0] sum0, sum1, sum2, sum3;\n\nassign a0 = a[3:0];\nassign b0 = b[3:0];\nassign c0 = {1'b0, cin};\nassign sum0 = a0 ^ b0 ^ c0;\n\nassign a1 = a[7:4];\nassign b1 = b[7:4];\nassign c1 = {c0[3], c0[3]};\nassign sum1 = a1 ^ b1 ^ c1;\n\nassign a2 = a[11:8];\nassign b2 = b[11:8];\nassign c2 = {c1[3], c1[3]};\nassign sum2 = a2 ^ b2 ^ c2;\n\nassign a3 = a[15:12];\nassign b3 = b[15:12];\nassign c3 = {c2[3], c2[3]};\nassign sum3 = a3 ^ b3 ^ c3;\n\nassign carry = {c3[3], c2[3], c1[3], c0[3]};\nassign cout = carry[3];\nassign sum = {sum3, sum2, sum1, sum0"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co_temp;\n\n    // 8-bit adder\n    // TODO: Implement the adder logic\n    // ...\n\n    assign y = y_temp;\n    assign Co = Co_temp;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] a_xor_b;\n    wire [7:0] a_and_b;\n    wire [7:0] a_and_cin;\n    wire [7:0] b_and_cin;\n    wire [7:0] a_xor_b_xor_cin;\n    \n    assign a_xor_b = a ^ b;\n    assign a_and_b = a & b;\n    assign a_and_cin = a & cin;\n    assign b_and_cin = b & cin;\n    assign a_xor_b_xor_cin = a_xor_b ^ cin;\n    \n    assign {cout, sum} = a_xor_b_xor_cin + a_and_b + b_and_cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n//\n// Control Unit\n//\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg [15:0] a, b;\nreg [31:0] a_reg, b_reg;\nreg [3:0] shift_cnt_reg;\nreg [31:0] product_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 0;\n        a <= 0;\n        b <= 0;\n        product <= 0;\n        a_reg <= 0;\n        b_reg <= 0;\n        shift_cnt_reg <= 0;\n        product_reg <= 0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 1;\n            a <= ain;\n            b <= bin;\n            product <= 0;\n            a_reg <= ain;\n            b_reg <= bin;\n            shift_cnt_reg <= 1;\n            product_reg <= 0;\n        end else begin\n            if (shift_cnt < 16) begin\n                shift_cnt <= shift_cnt + 1;\n                shift_cnt_reg <= shift_cnt_reg + 1;\n            end\n            if (shift_cnt == 16) begin\n                shift_cnt <= 0;\n                shift_cnt_reg <= 0;\n            end\n            if (shift_cnt_reg == 16) begin\n                product <= product_reg;\n            end\n        end\n    end\nend\n\nassign yout = product;\nassign done = (shift_cnt_reg == 16);\n\n//\n// Register Unit\n//\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n//\n// Multiplier Unit\n//\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product_reg <= 0;\n    end else begin\n        if (shift_cnt_reg < 16) begin\n            if (a_reg[shift_cnt_reg] == 1) begin\n                product_reg <= product_reg + b_reg;\n            end\n            a_reg <= a_reg << 1;\n            b_reg <= b_reg << 1;\n        end else begin\n            if (shift_cnt_reg == 16) begin\n                product_reg <= product_reg;\n            end\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] count_logic;\n    wire [15:0] count_register;\n\n    submodule u_counter_logic (\n        input wire clk,\n        input wire reset,\n        input wire up_down,\n        output wire [15:0] count_logic\n    );\n\n        reg [15:0] count_reg;\n\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                count_reg <= 16'd0;\n            end else if (up_down) begin\n                count_reg <= count_reg + 16'd1;\n            end else begin\n                count_reg <= count_reg - 16'd1;\n            end\n        end\n\n        assign count_logic = count_reg;\n\n    endsubmodule\n\n    submodule u_counter_register (\n        input wire clk,\n        input wire reset,\n        input wire [15:0] count_logic,\n        output wire [15:0] count_register\n    );\n\n        reg [15:0] count_reg;\n\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                count_reg <= 16'd0;\n            end else begin\n                count_reg <= count_logic;\n            end\n        end\n\n        assign count_register = count_reg;\n\n    endsubmodule\n\n    assign count = count_register;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // 8-bit ring counter state\n    reg [7:0] ring_state;\n\n    // 8-bit ring counter initialization submodule\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            ring_state <= 8'b0000_0001;\n    end\n\n    // 8-bit ring counter transition submodule\n    always @(posedge clk) begin\n        ring_state <= {ring_state[6:0], ring_state[7]};\n    end\n\n    // 8-bit ring counter output\n    assign out = ring_state;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nassign out = (rst_n) ? 4'b0000 : ((valid_count) ? count : out);\n\nreg [3:0] count_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_reg <= 4'b0000;\n    else if (valid_count) begin\n        if (count_reg == 4'd11)\n            count_reg <= 4'b0000;\n        else\n            count_reg <= count_reg + 1;\n    end\nend\nassign count = count_reg;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_reg <= 4'b0000;\n    else if (valid_count) begin\n        if (count_reg == 4'd11)\n            count_reg <= 4'b0000;\n        else\n            count_reg <= count_reg + 1;\n    end\nend\nassign count = count_reg;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= count;\nend\nassign out = out_reg;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// JC_register submodule\n// Continuous assignment\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'd0;\n    else\n        Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\nend\nassign Q = Q_reg;\n\n// JC_logic submodule\n// Combinational assignment\nreg [63:0] next_Q;\nalways @(*) begin\n    next_Q[63] = Q[63];\n    next_Q[62:0] = Q[62:0];\nend\n\n// Integration\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'd0;\n    else\n        Q_reg <= next_Q;\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire CLK_in_pos;\nreg CLK_50_reg;\nreg CLK_10_reg;\nreg CLK_1_reg;\n\n// submodules\nclk_div_2 clk_div_2_inst (\n    .CLK_in(CLK_in_pos),\n    .RST(RST),\n    .CLK_out(CLK_50_reg)\n);\n\nclk_div_10 clk_div_10_inst (\n    .CLK_in(CLK_in_pos),\n    .RST(RST),\n    .CLK_out(CLK_10_reg)\n);\n\nclk_div_100 clk_div_100_inst (\n    .CLK_in(CLK_in_pos),\n    .RST(RST),\n    .CLK_out(CLK_1_reg)\n);\n\n// count on every positive edge of CLK_in\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        CLK_50_reg <= 1'b0;\n        CLK_10_reg <= 1'b0;\n        CLK_1_reg <= 1'b0;\n    end else begin\n        CLK_50_reg <= CLK_50_reg + 1;\n        CLK_10_reg <= CLK_10_reg + 1;\n        CLK_1_reg <= CLK_1_reg + 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_2 (CLK_in, RST, CLK_out);\ninput CLK_in;\ninput RST;\noutput CLK_out;\nreg CLK_out_reg;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_out_reg <= 1'b0;\n    end else begin\n        CLK_out_reg <= ~CLK_out_reg;\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_10 (CLK_in, RST, CLK_out);\ninput CLK_in;\ninput RST;\noutput CLK_out;\nreg [2:0] count_reg;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        count_reg <= 3'b000;\n    end else begin\n        if (count_reg == 3'b100) begin\n            count_reg <= 3'b000;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign CLK_out = count_reg[1];\n\nendmodule\n\nmodule clk_div_100 (CLK_in, RST, CLK_out);\ninput CLK_in;\ninput RST;\noutput CLK_out;\nreg [4:0] count_reg;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        count_reg <= 5'b00000;\n    end else begin\n        if (count_reg == 5'b11011) begin\n            count_reg <= 5'b00000;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign CLK_out = count_reg[3];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\n// Counter Submodule\nreg [15:0] counter_q;\nreg [15:0] counter_n;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_q <= 16'd0;\n    end else begin\n        counter_q <= counter_n;\n    end\nend\n\nalways @(negedge clk) begin\n    counter_n <= counter_q + 1;\nend\n\n// Clock Average Generator Submodule\nreg [7:0] clk_average_q;\nreg [7:0] clk_average_n;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average_q <= 8'd0;\n    end else begin\n        clk_average_q <= clk_average_n;\n    end\nend\n\nalways @(posedge clk) begin\n    clk_average_n <= {clk_average_q[6:0], counter_q[0]};\nend\n\n// Clock Adjustment Submodule\nreg [7:0] clk_adjustment_q;\nreg [7:0] clk_adjustment_n;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment_q <= 8'd0;\n    end else begin\n        clk_adjustment_q <= clk_adjustment_n;\n    end\nend\n\nalways @(negedge clk) begin\n    clk_adjustment_n <= {clk_adjustment_q[6:0], counter_q[1]};\nend\n\n// Output Logic\nassign clk_div = clk_average_q[4] | clk_adjustment_q[4];\n\nendmodule\n\n-------------------------------------------------\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg          q,\n    input [15:0]        limit\n);\n\nparameter DIV = 16;\n\nreg [15:0] counter_q;\nreg [15:0] counter_n;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_q <= 16'd0;\n        q <= 1'b0;\n    end else if (counter_q == limit) begin\n        counter_q <= 16'd0;\n        q <= 1'b1;\n    end else begin\n        counter_q <= counter_n;\n        q <= 1'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    counter_n <= counter_q + 1;\nend\n\nendmodule\n\n-------------------------------------------------\n\nmodule clk_average (\n    input               clk,\n    input               rst_n,\n    input [7:0]         clk_in,\n    output reg [7:0]    q\n);\n\nparameter DIV = 8;\n\nreg [7:0] counter_q;\nreg [7:0] counter_n;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_q <= 8'd0;\n        q <= 8'd0;\n    end else if (counter_q == DIV - 1) begin\n        counter_q <= 8'd0;\n        q <= q + 1'b1;\n    end else begin\n        counter_q <= counter_n;\n        q <= q;\n    end\nend\n\nalways @(posedge clk) begin\n    counter_n <= counter_q + 1;\nend\n\nalways @(posedge clk) begin\n    q <= q + clk_in;\nend\n\nendmodule\n\n-------------------------------------------------\n\nmodule clk_adjustment (\n    input               clk,\n    input               rst_n,\n    input [7:0]         clk_in,\n    output reg"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    \n    reg [$clog2(NUM_DIV)-1:0] u_pos_counter;\n    reg [$clog2(NUM_DIV)-1:0] u_neg_counter;\n    \n    reg clk_div1;\n    reg clk_div2;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            u_pos_counter <= 0;\n            u_neg_counter <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else if (u_pos_counter == NUM_DIV - 1) begin\n            u_pos_counter <= 0;\n            clk_div1 <= 1;\n        end else begin\n            u_pos_counter <= u_pos_counter + 1;\n            clk_div1 <= 0;\n        end\n    end\n    \n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            u_neg_counter <= 0;\n            clk_div2 <= 0;\n        end else if (u_neg_counter == NUM_DIV - 1) begin\n            u_neg_counter <= 0;\n            clk_div2 <= 1;\n        end else begin\n            u_neg_counter <= u_neg_counter + 1;\n            clk_div2 <= 0;\n        end\n    end\n    \n    assign clk_div = clk_div1 | clk_div2;\n    \nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 4;\n    \n    reg [3:0] counter;\n    reg div_clk;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0;\n            div_clk <= 1'b0;\n        end\n        else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 4'b0;\n                div_clk <= ~div_clk;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 4'b0;\n        end\n        else begin\n            if (q == (NUM_DIV / 2 - 1)) begin\n                q <= 4'b0;\n            end\n            else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0;\n            clk_div <= 1'b0;\n        end\n        else begin\n            if (counter == (NUM_DIV / 2 - 1)) begin\n                counter <= 4'b0;\n                clk_div <= ~clk_div;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n```"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out, sub_out, and_out, or_out, xor_out, nor_out;\n    wire [31:0] sll_out, srl_out, sra_out;\n    wire [31:0] slt_out, sltu_out;\n    wire [31:0] lui_out;\n    wire [31:0] sllv_out, srlv_out, srav_out;\n\n    // Submodule instantiations\n    add add_inst (\n        .a(a),\n        .b(b),\n        .r(add_out)\n    );\n    addu addu_inst (\n        .a(a),\n        .b(b),\n        .r(add_out)\n    );\n    sub sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    subu subu_inst (\n        .a(a),\n        .b(b),\n        .r(sub_out)\n    );\n    and and_inst (\n        .a(a),\n        .b(b),\n        .r(and_out)\n    );\n    or or_inst (\n        .a(a),\n        .b(b),\n        .r(or_out)\n    );\n    xor xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_out)\n    );\n    nor nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_out)\n    );\n    sll sll_inst (\n        .a(a),\n        .b(b),\n        .r(sll_out)\n    );\n    srl srl_inst (\n        .a(a),\n        .b(b),\n        .r(srl_out)\n    );\n    sra sra_inst (\n        .a(a),\n        .b(b),\n        .r(sra_out)\n    );\n    slt slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_out)\n    );\n    sltu sltu_inst (\n        .a(a),\n        .b(b),\n        .r(sltu_out)\n    );\n    sllv sllv_inst (\n        .a(a),\n        .b(b),\n        .r(sllv_out)\n    );\n    srlv srlv_inst (\n        .a(a),\n        .b(b),\n        .r(srlv_out)\n    );\n    srav srav_inst (\n        .a(a),\n        .b(b),\n        .r(srav_out)\n    );\n    lui lui_inst (\n        .a(a),\n        .r(lui_out)\n    );\n\n    // Control logic\n    assign r = (aluc == 6'b000000) ? sll_out :\n               (aluc == 6'b000010) ? srl_out :\n               (aluc == 6'b000011) ? sra_out :\n               (aluc == 6'b000100) ? and_out :\n               (aluc == 6'b000101) ? or_out :\n               (aluc == 6'b000110) ? xor_out :\n               (aluc == 6'b000111) ? nor_out :\n               (aluc == 6'b001010) ? slt_out :\n               (aluc == 6'b001011) ? sltu_out :\n               (aluc == 6'b001111) ? lui_out :\n               (aluc == 6'b100000) ? add_out :\n               (aluc == 6'b100001) ? addu_out :\n               (aluc == 6'b100010) ? sub_out :\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] accumulator_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_reg <= 0;\n        end else begin\n            accumulator_reg <= accumulator_reg + multiplication_result[31:0];\n        end\n    end\n    assign current_value = accumulator_reg;\n\n    // Connecting Multiplier and Accumulator Submodules\n    assign c = current_value;\nendmodule\n```\n\n### 1.2.2\n```verilog\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] accumulator_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_reg <= 0;\n        end else begin\n            accumulator_reg <= accumulator_reg + multiplication_result[31:0];\n        end\n    end\n    assign current_value = accumulator_reg;\n\n    // Connecting Multiplier and Accumulator Submodules\n    assign c = current_value;\nendmodule\n```\n\n### 1.2.3\n```verilog\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] accumulator_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_reg <= 0;\n        end else begin\n            accumulator_reg <= accumulator_reg + multiplication_result[31:0];\n        end\n    end\n    assign current_value = accumulator_reg;\n\n    // Connecting Multiplier and Accumulator Submodules\n    assign c = current_value;\nendmodule\n```\n\n## 1.3\n### 1.3.1\n```verilog\n`timescale 1ns / 1ps\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] accumulator_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_reg <= 0;\n        end else begin\n            accumulator_reg <= accumulator_reg + multiplication_result[31:0];\n        end\n    end\n    assign current_value = accumulator_reg;\n\n    // Connecting Multiplier and Accumulator Submodules\n    assign c = current_value;\nendmodule\n```\n\n### 1.3.2\n```verilog\n`timescale 1ns / 1ps\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multip"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Two submodules to store instruction data\n    ins_reg_p1 ins_p1_m (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    ins_reg_p2 ins_p2_m (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Mux to select the proper submodule\n    wire [2:0] ins_sel;\n    wire [4:0] ad1_sel;\n    wire [7:0] ad2_sel;\n    assign ins_sel = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1_sel = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2_sel = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\n    assign ins = ins_sel;\n    assign ad1 = ad1_sel;\n    assign ad2 = ad2_sel;\nendmodule\n\nmodule ins_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_r;\n    reg [4:0] ad1_r;\n    reg [7:0] ad2_r;\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_r <= 3'b0;\n            ad1_r <= 5'b0;\n            ad2_r <= 8'b0;\n        end else begin\n            ins_r <= data[7:5];\n            ad1_r <= data[4:0];\n            ad2_r <= data;\n        end\n    end\n\n    assign ins = ins_r;\n    assign ad1 = ad1_r;\n    assign ad2 = ad2_r;\nendmodule\n\nmodule ins_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_r;\n    reg [4:0] ad1_r;\n    reg [7:0] ad2_r;\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_r <= 3'b0;\n            ad1_r <= 5'b0;\n            ad2_r <= 8'b0;\n        end else begin\n            ins_r <= data[7:5];\n            ad1_r <= data[4:0];\n            ad2_r <= data;\n        end\n    end\n\n    assign ins = ins_r;\n    assign ad1 = ad1_r;\n    assign ad2 = ad2_r;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    \n    wire enable;\n    assign enable = 1;\n    \n    counter u_counter(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wire [7:0] div;\n    assign div = 8'd100 / freq;\n    \n    reg wave;\n    assign wave_out = wave;\n    \n    wave_generator u_wave_generator(\n        .clk(clk),\n        .count(count),\n        .freq(div),\n        .wave_out(wave)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count == (freq - 1)) ? 1 : 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule\nmodule wave_gen (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n    reg [4:0] wave_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            if (wave_reg == 5'd31) begin\n                wave_reg <= 5'd0;\n            end else begin\n                wave_reg <= wave_reg + 1;\n            end\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        case (sel)\n            2'b00: q <= q1;\n            2'b01: q <= q2;\n            2'b10: q <= q3;\n            2'b11: q <= d;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q1;\n            2'b01: q <= q2;\n            2'b10: q <= q3;\n            2'b11: q <= d;\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    // Instantiate D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output q\n);\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] mux1_out, mux2_out, mux3_out, mux4_out;\n    wire [1:0] sel;\n    \n    assign sel[0] = ctrl[2];\n    assign sel[1] = ctrl[1];\n    \n    assign mux1_out = (sel[0] == 1) ? in : 8'b0;\n    assign mux2_out = (sel[1] == 1) ? mux1_out : 8'b0;\n    assign mux3_out = (ctrl[0] == 1) ? mux2_out : in;\n    assign mux4_out = (ctrl[1] == 1) ? mux3_out : mux2_out;\n    assign out = (ctrl[2] == 1) ? mux4_out : mux3_out;\n\n    // 2-to-1 multiplexer\n    // Selects between two input values based on the sel signal.\n    // The output is determined by the value of sel[0] and sel[1].\n    //\n    // Example:\n    //   sel = 00, output is in\n    //   sel = 01, output is mux1_out\n    //   sel = 10, output is mux2_out\n    //   sel = 11, output is mux3_out\n    //\n    // Note: sel is a 2-bit vector, with each bit used to select between the two inputs.\n    //\n    // The input arguments are:\n    //   in0: Input 1.\n    //   in1: Input 2.\n    //   sel: 2-bit vector used to select between inputs.\n    //\n    // The output is:\n    //   out: Output selected based on sel.\n    function [7:0] mux2X1;\n        input [7:0] in0;\n        input [7:0] in1;\n        input [1:0] sel;\n        begin\n            case (sel)\n                2'b00: mux2X1 = in0;\n                2'b01: mux2X1 = in1;\n                2'b10: mux2X1 = in0;\n                2'b11: mux2X1 = in1;\n                default: mux2X1 = 8'b0;\n            endcase\n        end\n    endfunction\n\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // pe0\n  assign pe0_out = {24'b0, a0} * {24'b0, b0};\n\n  // pe1\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n  assign pe1_out = {24'b0, a1} * {24'b0, b1};\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetch_stage_res;\n  wire [31:0] decode_stage_res;\n  wire [31:0] execute_stage_res;\n  wire [31:0] memory_stage_res;\n  wire [31:0] writeback_stage_res;\n  reg [31:0] pc;\n\n  fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .fetch_stage_res(fetch_stage_res)\n  );\n\n  decode_stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .fetch_stage_res(fetch_stage_res),\n    .decode_stage_res(decode_stage_res)\n  );\n\n  execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .decode_stage_res(decode_stage_res),\n    .execute_stage_res(execute_stage_res)\n  );\n\n  memory_stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .execute_stage_res(execute_stage_res),\n    .memory_stage_res(memory_stage_res)\n  );\n\n  writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .memory_stage_res(memory_stage_res),\n    .writeback_stage_res(writeback_stage_res)\n  );\n\n  assign res_reg_file = writeback_stage_res;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule fetch_stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] fetch_stage_res\n);\n  reg [31:0] pc;\n  reg [31:0] instr;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\n\n  assign fetch_stage_res = instr;\nendmodule\n\nmodule decode_stage (\n  input clk,\n  input rst,\n  input [31:0] fetch_stage_res,\n  output [31:0] decode_stage_res\n);\n  reg [31:0] instr;\n  reg [4:0] rs1;\n  reg [4:0] rs2;\n  reg [4:0] rd;\n  reg [1:0] op;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      instr <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      instr <= fetch_stage_res;\n      rs1 <= instr[25:21];\n      rs2 <= instr[20:16];\n      rd <= instr[15:11];\n      op <= instr[30:26];\n    end\n  end\n\n  assign decode_stage_res = {rs1, rs2, rd, op};\nendmodule\n\nmodule execute_stage (\n  input clk,\n  input rst,\n  input [31:0] decode_stage_res,\n  output [31:0] execute_stage_res\n);\n  reg [31:0] instr;\n  reg [4:0] rs1;\n  reg [4:0] rs2;\n  reg [4:0] rd;\n  reg [1:0] op;\n  reg [31:0] rs1_val"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [15:0] b1 = b0_reg;\n  wire [15:0] b2 = b1_reg;\n  wire [15:0] b3 = b2_reg;\n\n  // Processing Element 0\n  always @(posedge clk) begin\n    if (rst) begin\n      c0_reg <= 0;\n      b0_reg <= 0;\n    end else begin\n      c0_reg <= a0 * b0;\n      b0_reg <= b0;\n    end\n  end\n\n  // Processing Element 1\n  always @(posedge clk) begin\n    if (rst) begin\n      c1_reg <= 0;\n      b1_reg <= 0;\n    end else begin\n      c1_reg <= a1 * b1;\n      b1_reg <= b1;\n    end\n  end\n\n  // Processing Element 2\n  always @(posedge clk) begin\n    if (rst) begin\n      c2_reg <= 0;\n      b2_reg <= 0;\n    end else begin\n      c2_reg <= a2 * b2;\n      b2_reg <= b2;\n    end\n  end\n\n  // Processing Element 3\n  always @(posedge clk) begin\n    if (rst) begin\n      c3_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      c3_reg <= a3 * b3;\n      b3_reg <= b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    \n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    reg [31:0] pc;\n    \n    // Define the modules\n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(fetched_instr)\n    );\n    \n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr(fetched_instr),\n        .reg_file(reg_file),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n    \n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n    \nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    // Define the module contents here.\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nreg       [2:0]   u_counter_cnt;\nwire      [2:0]   u_counter_max_cnt = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_counter_cnt <= 0;\n    end else if (valid_in) begin\n        u_counter_cnt <= u_counter_cnt + 1;\n    end\nend\n\nassign valid_out = (u_counter_cnt == u_counter_max_cnt);\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nreg       [9:0]   u_data_accumulator_sum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_data_accumulator_sum <= 0;\n    end else if (valid_in) begin\n        u_data_accumulator_sum <= u_data_accumulator_sum + data_in;\n    end\nend\n\nassign data_out = u_data_accumulator_sum;\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nreg               u_valid_output_valid_out;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_valid_output_valid_out <= 0;\n    end else if (valid_in) begin\n        u_valid_output_valid_out <= 1;\n    end else begin\n        u_valid_output_valid_out <= 0;\n    end\nend\n\nassign valid_out = u_valid_output_valid_out;\n\nendmodule\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg                   u_counter_cnt;\nreg                   u_counter_valid_out;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_counter_cnt <= 0;\n        u_counter_valid_out <= 0;\n    end else if (u_counter_cnt == 4) begin\n        u_counter_cnt <= 0;\n        u_counter_valid_out <= 1;\n    end else if (u_counter_valid_out) begin\n        u_counter_cnt <= u_counter_cnt + 1;\n        u_counter_valid_out <= 0;\n    end\nend\n\nassign valid_out = u_counter_valid_out;\nassign cnt = u_counter_cnt;\n\nendmodule\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg       [9:0]   u_data_accumulator_sum;\nreg               u_data_accumulator_valid_out;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_data_accumulator_sum <= 0;\n        u_data_accumulator_valid_out <= 0;\n    end else if (valid_in) begin\n        u_data_accumulator_sum <= u_data_accumulator_sum + data_in;\n        u_data_accumulator_valid_out <= 1;\n    end else begin\n        u_data_accumulator_valid_out <= 0;\n    end\nend\n\nassign valid_out = u_data_accumulator_valid_out;\nassign data_out = u_data_accumulator_sum;\n\nendmodule\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nmodule u_valid_output (\n    input               clk,\n    input               r"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Prepare the inputs\n    wire [63:0] dividend;\n    wire [31:0] divisor;\n\n    assign {dividend, odd} = {A, 16'b0};\n    assign divisor = B;\n\n// 32-bit divider\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    assign {quotient, remainder} = {1'b0, dividend} / {1'b0, divisor};\n\n    assign result = quotient;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [63:0] dividend, // 64-bit dividend\n    input wire [15:0] divisor, // 16-bit divisor\n    output wire [63:0] adjusted_dividend, // 64-bit adjusted dividend\n    output wire [15:0] adjusted_divisor // 16-bit adjusted divisor\n);\n\n// Prepare the inputs\n    assign adjusted_dividend = {dividend[31:0], 16'b0};\n    assign adjusted_divisor = divisor;\n\nendmodule\n\nmodule div_operation(\n    input wire [63:0] dividend, // 64-bit dividend\n    input wire [15:0] divisor, // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n);\n\n// Prepare the inputs\n    wire [63:0] shifted_dividend;\n    wire [31:0] shifted_divisor;\n\n    assign shifted_dividend = dividend;\n    assign shifted_divisor = divisor;\n\n// Shift the dividend and compare it with the divisor\n    wire [31:0] shifted_remainder;\n    wire [31:0] shifted_quotient;\n    wire [31:0] shifted_dividend_temp;\n    wire [15:0] shifted_divisor_temp;\n\n    assign {shifted_remainder, shifted_quotient} = {1'b0, shifted_dividend} / {1'b0, shifted_divisor};\n    assign shifted_dividend_temp = shifted_dividend - (shifted_divisor << 16);\n    assign shifted_divisor_temp = shifted_divisor >> 1;\n    assign {shifted_remainder, shifted_quotient} = {shifted_remainder, shifted_quotient} - {shifted_dividend_temp, shifted_divisor_temp};\n\n    assign quotient = shifted_quotient;\n    assign remainder = shifted_remainder;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Calculate quotient and remainder\n    wire [15:0] quotient, remainder;\n    assign result = quotient;\n    assign odd = remainder;\n\n    // Control unit\n    reg [15:0] dividend, divisor, quotient_reg, remainder_reg;\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        quotient_reg = 16'b0;\n        remainder_reg = 16'b0;\n        while (dividend >= divisor) begin\n            quotient_reg = quotient_reg << 1;\n            quotient_reg[0] = 1;\n            dividend = dividend - divisor;\n        end\n        quotient_reg = quotient_reg << 1;\n        remainder_reg = dividend;\n    end\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n    \nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {B_out, sum} = A + B_comp;\nassign D = sum;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\n\nsub_16bit sub16_inst1 (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Diff(S1_out),\n    .B_out()\n);\n\nsub_16bit sub16_inst2 (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Diff(S2_out),\n    .B_out()\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_16bit (\n    input [15:0] A,\n    input [15:0] B,\n    output [15:0] Diff,\n    output B_out\n);\n\nwire [8:0] S1_out, S2_out;\n\nsub_8bit sub8_inst1 (\n    .A(A[7:0]),\n    .B(B[7:0]),\n    .Diff(S1_out),\n    .B_out()\n);\n\nsub_8bit sub8_inst2 (\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .Diff(S2_out),\n    .B_out()\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] Diff,\n    output B_out\n);\n\nwire [4:0] S1_out, S2_out;\n\nsub_4bit sub4_inst1 (\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .Diff(S1_out),\n    .B_out()\n);\n\nsub_4bit sub4_inst2 (\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .Diff(S2_out),\n    .B_out()\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] Diff,\n    output B_out\n);\n\nwire [2:0] S1_out, S2_out;\n\nsub_2bit sub2_inst1 (\n    .A(A[1:0]),\n    .B(B[1:0]),\n    .Diff(S1_out),\n    .B_out()\n);\n\nsub_2bit sub2_inst2 (\n    .A(A[3:2]),\n    .B(B[3:2]),\n    .Diff(S2_out),\n    .B_out()\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_2bit (\n    input [1:0] A,\n    input [1:0] B,\n    output [1:0] Diff,\n    output B_out\n);\n\nwire [1:0] S1_out, S2_out;\n\nsub_1bit sub1_inst1 (\n    .A(A[0]),\n    .B(B[0]),\n    .Diff(S1_out),\n    .B_out()\n);\n\nsub_1bit sub1_inst2 (\n    .A(A[1]),\n    .B(B[1]),\n    .Diff(S2_out),\n    .B_out()\n);\n\nassign Diff = {S2_out, S1_out};\n\nendmodule\n\nmodule sub_1bit (\n    input A,\n    input B,\n    output Diff,\n    output B_out\n);\n\nwire B_out;\n\nassign Diff = A ^ B;\nassign B_out = (A & B) ? 1'b1 : 1'b0;"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_out;\n\nwire [31:0] A_1;\nwire [31:0] B_1;\nwire [31:0] D_1;\n\nwire [15:0] A_2;\nwire [15:0] B_2;\nwire [15:0] D_2;\n\nwire [7:0] A_3;\nwire [7:0] B_3;\nwire [7:0] D_3;\n\nwire [3:0] A_4;\nwire [3:0] B_4;\nwire [3:0] D_4;\n\nwire [1:0] A_5;\nwire [1:0] B_5;\nwire [1:0] D_5;\n\nwire [31:0] D;\n\n\nassign A_1 = A[63:32];\nassign B_1 = B[63:32];\nassign D_1 = A_1 - B_1;\n\nassign A_2 = D_1[63:32];\nassign B_2 = B[31:16];\nassign D_2 = A_2 - B_2;\n\nassign A_3 = D_2[63:32];\nassign B_3 = B[15:0];\nassign D_3 = A_3 - B_3;\n\nassign A_4 = D_3[63:32];\nassign B_4 = D_3[31:16];\nassign D_4 = A_4 - B_4;\n\nassign A_5 = D_4[63:32];\nassign B_5 = D_4[31:16];\nassign D_5 = A_5 - B_5;\n\nassign D = {D_5, D_4, D_3, D_2, D_1};\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [4:1] D0, D1, D2, D3;\nwire [2:1] B_out0, B_out1, B_out2, B_out3;\nwire [2:1] B0, B1, B2, B3;\n\nfull_subtractor_1bit u0(A[1:1], B[1:1], D0, B0);\nfull_subtractor_1bit u1(A[2:2], B[2:2], D1, B1);\nfull_subtractor_1bit u2(A[3:3], B[3:3], D2, B2);\nfull_subtractor_1bit u3(A[4:4], B[4:4], D3, B3);\n\nfull_subtractor_1bit u4(D0, B0, D[1:1], B_out0);\nfull_subtractor_1bit u5(D1, B1, D[2:2], B_out1);\nfull_subtractor_1bit u6(D2, B2, D[3:3], B_out2);\nfull_subtractor_1bit u7(D3, B3, D[4:4], B_out3);\n\nassign B_out = B_out3[1];\n\nendmodule\n\nmodule full_subtractor_1bit(A, B, D, B_out);\ninput [1:1] A, B;\noutput [1:1] D;\noutput B_out;\n\nwire [2:1] A_neg, B_neg, B_out0, B_out1;\n\nassign A_neg = ~A;\nassign B_neg = ~B;\n\nfull_adder_1bit u0(A_neg, B_neg, D, B_out0);\nfull_adder_1bit u1(A, B_neg, D, B_out1);\nfull_adder_1bit u2(D, B_out0, D, B_out);\n\nendmodule\n\nmodule full_adder_1bit(A, B, C_in, D, C_out);\ninput [1:1] A, B, C_in;\noutput [1:1] D, C_out;\n\nwire [2:1] A_neg, B_neg, C_in_neg;\n\nassign A_neg = ~A;\nassign B_neg = ~B;\nassign C_in_neg = ~C_in;\n\nassign D = A_neg ^ B_neg ^ C_in_neg;\nassign C_out = (A_neg & B_neg) | (A_neg & C_in_neg) | (B_neg & C_in_neg);\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Implement the subtractor\nsubtractor_32bit subtractor (\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .carry(carry)\n);\n\n// Comparison logic\nassign A_greater = (sub_result == 32'b0);\nassign A_equal = (carry == 0);\nassign A_less = (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,   // Result of subtraction\n    output carry        // Carry out of subtraction\n);\n\nassign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32] = A[32]^B[32];\nassign C32 = A[32]&B[32];\n\ngenvar i;\ngenerate\nfor (i = 1; i < 16; i = i + 1) begin : CLA\n    wire c[i-1:0];\n    assign c[i-1] = A[2*i]^B[2*i];\n    assign S[2*i] = A[2*i]^B[2*i]^c[i-1];\n    assign c[i] = A[2*i]&B[2*i] | A[2*i]&c[i-1] | B[2*i]&c[i-1];\nend\nendgenerate\n\ngenvar j;\ngenerate\nfor (j = 32; j > 16; j = j - 1) begin : CLA\n    wire c[j-16:0];\n    assign c[j-16] = A[j]^B[j];\n    assign S[j] = A[j]^B[j]^c[j-16];\n    assign c[j] = A[j]&B[j] | A[j]&c[j-16] | B[j]&c[j-16];\nend\nendgenerate\n\nassign S[1] = A[1]^B[1];\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] sum0;\nwire [15:0] sum1;\nwire [15:0] sum2;\nwire [15:0] sum3;\n\nwire [3:0] carry0;\nwire [3:0] carry1;\nwire [3:0] carry2;\nwire [3:0] carry3;\n\nwire [3:0] carry_out;\nwire [3:0] carry_in;\n\nwire [15:0] sum4;\nwire [15:0] sum5;\nwire [15:0] sum6;\nwire [15:0] sum7;\n\nwire [15:0] sum8;\nwire [15:0] sum9;\nwire [15:0] sum10;\nwire [15:0] sum11;\n\nwire [15:0] sum12;\nwire [15:0] sum13;\nwire [15:0] sum14;\nwire [15:0] sum15;\n\nwire [15:0] sum16;\nwire [15:0] sum17;\nwire [15:0] sum18;\nwire [15:0] sum19;\n\nassign carry_out[0] = 1;\nassign carry_in[0] = cin;\n\nassign carry_out[1] = carry_in[0];\nassign carry_in[1] = carry_out[0];\n\nassign carry_out[2] = carry_in[1];\nassign carry_in[2] = carry_out[1];\n\nassign carry_out[3] = carry_in[2];\nassign carry_in[3] = carry_out[2];\n\nassign {carry_out[3], carry_out} = a + b + carry_in;\nassign {carry_in[3], carry_in} = carry_out[3];\n\nassign sum0 = a[0 +: 4] + b[0 +: 4] + carry_in[0];\nassign sum1 = a[4 +: 4] + b[4 +: 4] + carry_in[1];\nassign sum2 = a[8 +: 4] + b[8 +: 4] + carry_in[2];\nassign sum3 = a[12 +: 4] + b[12 +: 4] + carry_in[3];\n\nassign sum4 = a[0 +: 4] + b[0 +: 4] + carry_in[0];\nassign sum5 = a[4 +: 4] + b[4 +: 4] + carry_in[1];\nassign sum6 = a[8 +: 4] + b[8 +: 4] + carry_in[2];\nassign sum7 = a[12 +: 4] + b[12 +: 4] + carry_in[3];\n\nassign sum8 = a[0 +: 4] + b[0 +: 4] + carry_in[0];\nassign sum9 = a[4 +: 4] + b[4 +: 4] + carry_in[1];\nassign sum10 = a[8 +: 4] + b[8 +: 4] + carry_in[2];\nassign sum11 = a[12 +: 4] + b[12 +: 4] + carry_in[3];\n\nassign sum12 = a[0 +: 4] + b[0 +: 4] + carry_in[0];\nassign sum13 = a[4 +: 4] + b[4 +: 4] + carry_in[1];\nassign sum14 = a[8 +: 4] + b[8 +: 4] + carry_in[2];\nassign sum15 = a[12 +: 4] + b[12 +: 4] + carry_in[3];\n\nassign sum16 = a[0 +: 4] + b[0 +: 4] + carry_in[0];\nassign sum17 = a[4 +: 4] + b[4 +:"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder implementation\n    // ...\n\n    // instantiate 8 times\n    // ...\n\n    // concatenate the outputs\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] c;\n    wire [7:0] s;\n    \n    // First adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(s[0]),\n        .cout(c[0])\n    );\n    \n    // Second adder\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(s[1]),\n        .cout(c[1])\n    );\n    \n    // Third adder\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(s[2]),\n        .cout(c[2])\n    );\n    \n    // Fourth adder\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(s[3]),\n        .cout(c[3])\n    );\n    \n    // Fifth adder\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c[3]),\n        .sum(s[4]),\n        .cout(c[4])\n    );\n    \n    // Sixth adder\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c[4]),\n        .sum(s[5]),\n        .cout(c[5])\n    );\n    \n    // Seventh adder\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c[5]),\n        .sum(s[6]),\n        .cout(c[6])\n    );\n    \n    // Eighth adder\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c[6]),\n        .sum(s[7]),\n        .cout(c[7])\n    );\n    \n    assign sum = s;\n    assign cout = c[7];\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_count;\nreg [15:0] mux_a, mux_b;\nreg start_d1, done_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'd0;\n        start_d1 <= 1'b0;\n    end else begin\n        start_d1 <= start;\n        if (start_d1 && !done_i) begin\n            shift_count <= shift_count + 4'd1;\n        end else if (start_d1) begin\n            shift_count <= 4'd0;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        done_i <= 1'b0;\n    end else begin\n        if (shift_count == 4'd16) begin\n            done_i <= 1'b1;\n        end else begin\n            done_i <= 1'b0;\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a, reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else begin\n        if (start && !done_i) begin\n            reg_a <= ain;\n            reg_b <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [31:0] product;\nreg [15:0] multiplicand, multiplier;\nreg [3:0] bit_cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n        multiplicand <= 16'd0;\n        multiplier <= 16'd0;\n        bit_cnt <= 4'd0;\n    end else begin\n        if (start && !done_i) begin\n            bit_cnt <= 4'd0;\n            multiplicand <= reg_a;\n            multiplier <= reg_b;\n        end else if (bit_cnt < 16) begin\n            multiplicand <= {multiplicand[14:0], 1'b0};\n            multiplier <= {multiplier[14:0], 1'b0};\n            bit_cnt <= bit_cnt + 4'd1;\n        end else if (bit_cnt == 16) begin\n            bit_cnt <= 4'd0;\n        end\n        if (bit_cnt < 16) begin\n            product <= product + {multiplier, 16'd0} & {16'd0, multiplicand};\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_i;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire u_counter_logic;\n    wire u_counter_register;\n\n    submodule (u_counter_logic) (\n        input wire clk,\n        input wire reset,\n        input wire up_down,\n        output wire u_counter_logic\n    );\n\n        // Counter logic implementation\n    endsubmodule\n\n    submodule (u_counter_register) (\n        input wire clk,\n        input wire reset,\n        input wire u_counter_logic,\n        output reg [15:0] count\n    );\n\n        // Counter register implementation\n    endsubmodule\n\n    assign u_counter_register = u_counter_logic;\n\nendmodule\n\n--------------------------------------------------------------------------------\nRules:\nThe Verilog code must compile and run on a standard Verilog simulator or\na Verilog-compliant synthesizer and FPGA.\n--------------------------------------------------------------------------------\n```\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\nwire [3:0] count;\n\nreg [3:0] count_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\nreg [3:0] count_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'b1111)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\nreg [3:0] out_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q_reg <= 64'h0000000000000000;\n    else Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_register(\n    input           clk,\n    input           rst_n,\n    input [63:0]    D,\n    output reg [63:0] Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 64'h0000000000000000;\n    else Q <= D;\nend\n\nendmodule\n\nmodule JC_logic(\n    input           clk,\n    input           rst_n,\n    input [63:0]    A,\n    output reg [63:0] Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 64'h0000000000000000;\n    else Q <= {Q[62:0], Q[63]};\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg clk_50, clk_10, clk_1;\n\n// clk_div_2\nreg [3:0] count_50;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count_50 <= 0;\n    else\n        count_50 <= count_50 + 1;\nend\n\nassign CLK_50 = count_50[3];\n\n// clk_div_10\nreg [3:0] count_10;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count_10 <= 0;\n    else if (count_50[3])\n        count_10 <= count_10 + 1;\nend\n\nassign CLK_10 = count_10[3];\n\n// clk_div_1\nreg [6:0] count_1;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        count_1 <= 0;\n    else if (count_10[3])\n        count_1 <= count_1 + 1;\nend\n\nassign CLK_1 = count_1[6];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [4:0] clk_4cycles;\nwire [3:0] clk_3cycles;\n\nreg [4:0] counter;\n\n\n\n\n\n\nassign clk_4cycles = counter[4] ? (counter - 5) : counter;\nassign clk_3cycles = counter[4] ? (counter - 6) : counter;\n\n\n\n\n\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 5'd1;\n    end\nend\n\n\n\n\n\n\nassign clk_div = clk_4cycles[2] | clk_3cycles[2];\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_edge_counter = 0;\nreg [3:0] neg_edge_counter = 0;\n\nreg clk_div1 = 0;\nreg clk_div2 = 0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        clk_div1 <= 0;\n    end else begin\n        if (pos_edge_counter == NUM_DIV - 1) begin\n            pos_edge_counter <= 0;\n            clk_div1 <= 1;\n        end else begin\n            pos_edge_counter <= pos_edge_counter + 1;\n            clk_div1 <= 0;\n        end\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_edge_counter <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (neg_edge_counter == NUM_DIV - 1) begin\n            neg_edge_counter <= 0;\n            clk_div2 <= 1;\n        end else begin\n            neg_edge_counter <= neg_edge_counter + 1;\n            clk_div2 <= 0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 12;\n\n// Submodules\nreg [3:0] u_counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_counter <= 0;\n    end else if (u_counter == NUM_DIV / 2 - 1) begin\n        u_counter <= 0;\n    end else begin\n        u_counter <= u_counter + 1;\n    end\nend\n\nreg u_clk_divider;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_clk_divider <= 0;\n    end else if (u_counter == NUM_DIV / 2 - 1) begin\n        u_clk_divider <= ~u_clk_divider;\n    end\nend\n\nassign clk_div = u_clk_divider;\n\nendmodule\n\nmodule submodule(\n    input clk,\n    input rst_n,\n    output submodule_out\n);\n\nreg [3:0] u_counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        u_counter <= 0;\n    end else if (u_counter == 9) begin\n        u_counter <= 0;\n    end else begin\n        u_counter <= u_counter + 1;\n    end\nend\n\nreg submodule_out;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        submodule_out <= 0;\n    end else if (u_counter == 9) begin\n        submodule_out <= ~submodule_out;\n    end\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] r_add, r_sub, r_and, r_or, r_xor, r_nor, r_slt, r_sltu, r_sll, r_srl, r_sra, r_lui;\n    wire [31:0] r_sllv, r_srlv, r_srav;\n    wire carry_add, carry_sub, carry_sll, carry_srl, carry_sra;\n    wire overflow_add, overflow_sub;\n    wire zero_add, zero_sub, zero_slt, zero_sltu;\n    wire zero_sllv, zero_srlv, zero_srav;\n    wire negative_add, negative_sub, negative_slt, negative_sltu;\n    wire negative_sllv, negative_srlv, negative_srav;\n\n    assign r = (aluc == 6'b100000) ? r_add :\n               (aluc == 6'b100001) ? r_add :\n               (aluc == 6'b100010) ? r_sub :\n               (aluc == 6'b100011) ? r_sub :\n               (aluc == 6'b100100) ? r_and :\n               (aluc == 6'b100101) ? r_or :\n               (aluc == 6'b100110) ? r_xor :\n               (aluc == 6'b100111) ? r_nor :\n               (aluc == 6'b101010) ? r_slt :\n               (aluc == 6'b101011) ? r_sltu :\n               (aluc == 6'b000000) ? r_sll :\n               (aluc == 6'b000010) ? r_srl :\n               (aluc == 6'b000011) ? r_sra :\n               (aluc == 6'b000100) ? r_sllv :\n               (aluc == 6'b000110) ? r_srlv :\n               (aluc == 6'b000111) ? r_srav :\n               (aluc == 6'b001111) ? r_lui : 32'b0;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign carry = (carry_add | carry_sub | carry_sll | carry_srl | carry_sra) ? 1'b1 : 1'b0;\n    assign negative = (r_add[31] | r_sub[31] | r_slt[31] | r_sltu[31] | r_sllv[31] | r_srlv[31] | r_srav[31] | r_lui[31]) ? 1'b1 : 1'b0;\n    assign overflow = (overflow_add | overflow_sub) ? 1'b1 : 1'b0;\n    assign flag = (aluc == 6'b101010) ? r_slt[31] :\n                  (aluc == 6'b101011) ? r_sltu[31] :\n                  1'b0;\n\n    add_sub add_sub_inst(\n        .a(a),\n        .b(b),\n        .carry_out(carry_add),\n        .overflow_out(overflow_add),\n        .r(r_add)\n    );\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .carry_out(carry_sub),\n        .overflow_out(overflow_sub),\n        .r(r_sub)\n    );\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(r_and)\n    );\n    or or_inst"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] mult_result;\n\n// Submodule: Multiplier\n// Takes two 32-bit inputs and produces a 64-bit result of their multiplication.\n// Inputs:\n//      a: Input operand A.\n//      b: Input operand B.\n// Output:\n//      mult_result: The result of the multiplication.\n\n// Submodule: Accumulator\n// Accumulates the lower 32 bits of the multiplication result into a register, current_value.\n// It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\n// Inputs:\n//      clk: Clock signal used for synchronous operations.\n//      rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n//      mult_result: The result of the multiplication.\n// Output:\n//      c: 32-bit output representing the accumulated result.\n\nreg [31:0] current_value;\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Instruction register 1\n    reg [2:0] ins_reg1;\n    reg [4:0] ad1_reg1;\n    reg [7:0] ad2_reg1;\n\n    // Instruction register 2\n    reg [2:0] ins_reg2;\n    reg [4:0] ad1_reg2;\n    reg [7:0] ad2_reg2;\n\n    // Submodule 1\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_reg1 <= 3'b000;\n            ad1_reg1 <= 5'b00000;\n            ad2_reg1 <= 8'b00000000;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data[7:5];\n                ad1_reg1 <= data[4:0];\n                ad2_reg1 <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_reg1;\n    assign ad1_p1 = ad1_reg1;\n    assign ad2_p1 = ad2_reg1;\n\n    // Submodule 2\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_reg2 <= 3'b000;\n            ad1_reg2 <= 5'b00000;\n            ad2_reg2 <= 8'b00000000;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_reg2 <= data[7:5];\n                ad1_reg2 <= data[4:0];\n                ad2_reg2 <= data;\n            end\n        end\n    end\n\n    assign ins_p2 = ins_reg2;\n    assign ad1_p2 = ad1_reg2;\n    assign ad2_p2 = ad2_reg2;\n\n    assign ins = {ins_p2[2], ins_p1[2], ins_p2[1], ins_p1[1], ins_p2[0], ins_p1[0]};\n    assign ad1 = {ad1_p2[4], ad1_p1[4], ad1_p2[3], ad1_p1[3], ad1_p2[2], ad1_p1[2], ad1_p2[1], ad1_p1[1], ad1_p2[0], ad1_p1[0]};\n    assign ad2 = {ad2_p2[7], ad2_p1[7], ad2_p2[6], ad2_p1[6], ad2_p2[5], ad2_p1[5], ad2_p2[4], ad2_p1[4], ad2_p2[3], ad2_p1[3], ad2_p2[2], ad2_p1[2], ad2_p2[1], ad2_p1[1], ad2_p2[0], ad2_p1[0]};\n\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire enable;\n    reg [7:0] count;\n    reg wave_out_reg;\n\n    assign enable = 1;\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n// 2-bit state register\nreg [1:0] state;\n\n// 5-bit waveform register\nreg [4:0] wave_reg;\n\n// State control module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        state <= 2'b00;\n    else begin\n        case (state)\n            2'b00: state <= 2'b01;\n            2'b01: state <= 2'b10;\n            2'b10: state <= 2'b00;\n            2'b11: state <= 2'b11;\n        endcase\n    end\nend\n\n// Waveform generation module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        wave_reg <= 5'd0;\n    else begin\n        case (state)\n            2'b00: wave_reg <= wave_reg + 1;\n            2'b01: wave_reg <= wave_reg - 1;\n            2'b10: wave_reg <= wave_reg + 1;\n            2'b11: wave_reg <= wave_reg - 1;\n        endcase\n    end\nend\n\nassign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q0, q1, q2;\n    wire [7:0] mux_out;\n\n    // Implement my_dff8 using a simple flip-flop.\n    always @(posedge clk) begin\n        q0 <= d;\n        q1 <= q0;\n        q2 <= q1;\n    end\n\n    assign mux_out = (sel == 2'b00) ? q0 :\n                     (sel == 2'b01) ? q1 :\n                     (sel == 2'b10) ? q2 :\n                                      d;\n\n    always @(posedge clk) begin\n        q <= mux_out;\n    end\n\nendmodule\n```\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Verilog HDL\u5b9e\u73b0\u5faa\u73af\u52a0\u6cd5\u5668\n\n### 4.4 \u4f7f\u7528Ver"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q_u0, q_u1, q_u2;\n\n    my_dff dff0 (\n        .clk(clk),\n        .d(d),\n        .q(q_u0)\n    );\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(q_u0),\n        .q(q_u1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q_u1),\n        .q(q_u2)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted;\n    wire [2:0] shift_amt;\n    wire [2:0] sel;\n\n    assign shift_amt = ctrl;\n    assign sel = ~shift_amt;\n\n    // Stage 1\n    assign shifted[7] = in[0];\n    assign shifted[6] = in[1] & sel[2];\n    assign shifted[5] = in[2] & sel[1];\n    assign shifted[4] = in[3] & sel[0];\n    assign shifted[3] = in[4] & sel[2];\n    assign shifted[2] = in[5] & sel[1];\n    assign shifted[1] = in[6] & sel[0];\n    assign shifted[0] = in[7] & sel[2];\n\n    // Stage 2\n    assign out[7] = shifted[7];\n    assign out[6] = shifted[6] | (shifted[5] & sel[2]);\n    assign out[5] = shifted[5] | (shifted[4] & sel[1]);\n    assign out[4] = shifted[4] | (shifted[3] & sel[0]);\n    assign out[3] = shifted[3] | (shifted[2] & sel[2]);\n    assign out[2] = shifted[2] | (shifted[1] & sel[1]);\n    assign out[1] = shifted[1] | (shifted[0] & sel[0]);\n    assign out[0] = shifted[0] | (in[7] & sel[2]);\n\nendmodule\n\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n  \n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  reg [31:0] pc;\n  wire [31:0] fetched_instr;\n  wire [31:0] decoded_instr;\n  wire [31:0] alu_result;\n  wire [31:0] writeback_result;\n\n  wire [31:0] fetch_stage_in;\n  wire [31:0] decode_stage_in;\n  wire [31:0] execute_stage_in;\n  wire [31:0] memory_stage_in;\n  wire [31:0] writeback_stage_in;\n\n  wire [31:0] fetch_stage_out;\n  wire [31:0] decode_stage_out;\n  wire [31:0] execute_stage_out;\n  wire [31:0] memory_stage_out;\n  wire [31:0] writeback_stage_out;\n\n  stagepipe5_fetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .pc(pc),\n    .fetched_instr(fetched_instr)\n  );\n\n  stagepipe5_decode_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .decoded_instr(decoded_instr)\n  );\n\n  stagepipe5_execute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .decoded_instr(decoded_instr),\n    .alu_result(alu_result)\n  );\n\n  stagepipe5_memory_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .memory_stage_in(memory_stage_in),\n    .memory_stage_out(memory_stage_out)\n  );\n\n  stagepipe5_writeback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .reg_file(reg_file),\n    .writeback_stage_in(writeback_stage_in),\n    .writeback_stage_out(writeback_stage_out),\n    .res_reg_file(res_reg_file)\n  );\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule stagepipe5_fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [31:0] pc,\n  output [31:0] fetched_instr\n);\n  reg [31:0] pc_reg;\n  reg [31:0] fetched_instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc_reg <= 0;\n      fetched_instr_reg <= 0;\n    end else begin\n      fetched_instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign fetched_instr = fetched_instr_reg;\nendmodule\n\nmodule stagepipe5_decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [31:0] decoded_instr\n);\n  reg [31:0] decoded_instr_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      decoded_instr_reg <= 0;\n    end else begin\n      decoded_instr_reg <= {26'h0, fetched_instr[5:0]};\n    end\n  end\n\n  assign"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 16'h0;\n      b1_reg <= 16'h0;\n      b2_reg <= 16'h0;\n      c0_reg <= 32'h0;\n      c1_reg <= 32'h0;\n      c2_reg <= 32'h0;\n      c3_reg <= 32'h0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b2_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    \n    reg [31:0] fetch_stage_out;\n    reg [31:0] execute_stage_out;\n    reg [31:0] writeback_stage_out;\n    reg [31:0] pc;\n\n    // Fetch stage\n    always @(posedge clk or posedge rst)\n        if (rst) fetch_stage_out <= 32'b0;\n        else fetch_stage_out <= instr_mem[pc];\n    assign out_reg_file = fetch_stage_out;\n    always @(posedge clk or posedge rst)\n        if (rst) pc <= 0;\n        else pc <= pc + 1;\n    \n    // Execute stage\n    always @(posedge clk or posedge rst)\n        if (rst) execute_stage_out <= 32'b0;\n        else begin\n            case (fetch_stage_out[5:0])\n                6'b000000: execute_stage_out <= reg_file[fetch_stage_out[15:10]] + reg_file[fetch_stage_out[25:20]];\n                6'b000001: execute_stage_out <= reg_file[fetch_stage_out[15:10]] - reg_file[fetch_stage_out[25:20]];\n                default: execute_stage_out <= reg_file[fetch_stage_out[15:10]];\n            endcase\n        end\n    \n    // Writeback stage\n    always @(posedge clk or posedge rst)\n        if (rst) writeback_stage_out <= 32'b0;\n        else writeback_stage_out <= execute_stage_out;\n    always @(posedge clk or posedge rst)\n        if (rst) reg_file[fetch_stage_out[15:10]] <= execute_stage_out;\n        else reg_file[fetch_stage_out[15:10]] <= writeback_stage_out;\n    \nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nparameter     COUNT_WIDTH = 3;\n\nlocalparam    COUNT_MAX = (1 << COUNT_WIDTH) - 1;\nlocalparam    COUNT_INIT = COUNT_MAX - 4;\n\nreg     [COUNT_WIDTH-1:0]   count_r;\nreg     [9:0]               data_accum_r;\nreg                         valid_out_r;\n\n//------------------------------------------------------------------------------\n// Counter Module\n//------------------------------------------------------------------------------\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_r <= COUNT_INIT;\n    end else if (count_r == COUNT_INIT) begin\n        count_r <= COUNT_MAX;\n    end else if (valid_in) begin\n        count_r <= count_r - 1;\n    end\nend\n\n//------------------------------------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------------------------------------\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum_r <= 0;\n    end else if (count_r == COUNT_MAX) begin\n        data_accum_r <= data_accum_r + data_in;\n    end\nend\n\n//------------------------------------------------------------------------------\n// Valid Output Module\n//------------------------------------------------------------------------------\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 0;\n    end else if (count_r == COUNT_INIT) begin\n        valid_out_r <= 1;\n    end else begin\n        valid_out_r <= 0;\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum_r;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n//------------------------------------------------\n// Local Parameters\n//------------------------------------------------\nlocalparam RES_WIDTH = 16;\nlocalparam RES_BITS = 8;\nlocalparam RES_HIGH = RES_WIDTH - 1;\n\n//------------------------------------------------\n// Local Wires\n//------------------------------------------------\nwire [7:0] abs_dividend;\nwire [7:0] abs_divisor;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [2:0] counter;\nwire [2:0] counter_next;\nwire done;\nwire [7:0] quotient;\nwire [7:0] remainder;\n\n//------------------------------------------------\n// Submodule Instantiations\n//------------------------------------------------\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .abs_value(abs_dividend)\n);\n\nabs_value abs_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .abs_value(abs_divisor)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(abs_divisor),\n    .neg_value(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .done(done),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .done(done),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .remainder(remainder),\n    .quotient(quotient)\n);\n\n//------------------------------------------------\n// Functional Module\n//------------------------------------------------\nassign result = {remainder, quotient};\n\n//------------------------------------------------\n// Internal Functional Module\n//------------------------------------------------\nassign quotient = shift_reg[7:0];\nassign remainder = dividend - (shift_reg[7:0] * neg_divisor);\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n// Submodule: prep_dividend\n// Prepares the dividend and divisor for division.\n// Inputs:\n//      A: 32-bit dividend.\n//      B: 16-bit divisor.\n// Outputs:\n//      result: 32-bit dividend.\n//      odd: 32-bit dividend.\n//      B: 16-bit divisor.\n\n// Submodule: div_operation\n// Performs the division operation.\n// Inputs:\n//      A: 32-bit dividend.\n//      B: 16-bit divisor.\n// Outputs:\n//      result: 32-bit quotient.\n//      odd: 32-bit remainder.\n\n// Instantiations\nprep_dividend prep_dividend_inst (\n    .A(A),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\ndiv_operation div_operation_inst (\n    .A(result),\n    .B(B),\n    .result(result),\n    .odd(odd)\n);\n\nendmodule\n\nmodule prep_dividend (\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit dividend\n    output wire [31:0] odd      // 32-bit dividend\n);\n\n// Prepare the dividend and divisor for division.\n// Inputs:\n//      A: 32-bit dividend.\n//      B: 16-bit divisor.\n// Outputs:\n//      result: 32-bit dividend.\n//      odd: 32-bit dividend.\n\n// Implementation\n\nendmodule\n\nmodule div_operation (\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Performs the division operation.\n// Inputs:\n//      A: 32-bit dividend.\n//      B: 16-bit divisor.\n// Outputs:\n//      result: 32-bit quotient.\n//      odd: 32-bit remainder.\n\n// Implementation\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result;\n    wire [7:0] temp_odd;\n    \n    // Control unit\n    div_control_unit div_control_unit_inst (\n        .A(A),\n        .B(B),\n        .result(temp_result),\n        .odd(temp_odd)\n    );\n    \n    assign result = temp_result;\n    assign odd = temp_odd;\n    \nendmodule\n\nmodule div_control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_dividend;\n    reg [15:0] temp_result;\n    reg [15:0] temp_odd;\n    \n    // Initialize\n    initial begin\n        temp_divisor = B;\n        temp_dividend = A;\n        temp_result = 16'b0;\n        temp_odd = 16'b0;\n    end\n    \n    // Division algorithm\n    always @(*) begin\n        if (temp_dividend[0] == 1'b0) begin\n            temp_result = temp_result + 1;\n            temp_dividend = temp_dividend >> 1;\n        end\n        if (temp_dividend == 16'b0) begin\n            temp_odd = temp_divisor;\n            temp_dividend = temp_divisor << 1;\n        end\n        temp_divisor = temp_divisor >> 1;\n    end\n    \n    assign result = temp_result;\n    assign odd = temp_odd;\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_not = ~B;\nwire [7:0] B_out_temp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : adder_8bit\n        full_adder fa(A[i], B_not[i], B_out_temp[i], D[i]);\n    end\nendgenerate\n\nassign B_out = B_out_temp[7];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff[31:0] = A[31:0] - B[31:0];\nassign B_out = (Diff[31:16] == 16'b0) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] sub0_D;\nwire sub0_B_out;\nwire [63:0] sub1_D;\nwire sub1_B_out;\n\nsub_32bit sub0 (\n    .A(A),\n    .B(B),\n    .D(sub0_D),\n    .B_out(sub0_B_out)\n);\n\nsub_32bit sub1 (\n    .A(sub0_D),\n    .B(B),\n    .D(sub1_D),\n    .B_out(sub1_B_out)\n);\n\nassign D = sub1_D;\nassign B_out = sub1_B_out;\n\nendmodule\n\nmodule sub_16bit (\n    input [63:0] A,\n    input [63:0] B,\n    output [63:0] D,\n    output B_out\n);\nwire [15:0] A1, B1, D1;\nwire B_out1;\n\nsub_8bit sub0 (\n    .A(A[63:48]),\n    .B(B[63:48]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_8bit sub1 (\n    .A(A[47:32]),\n    .B(B[47:32]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_8bit sub2 (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_8bit sub3 (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nassign D = D1;\nassign B_out = B_out1;\nendmodule\n\nmodule sub_8bit (\n    input [63:0] A,\n    input [63:0] B,\n    output [63:0] D,\n    output B_out\n);\nwire [7:0] A1, B1, D1;\nwire B_out1;\n\nsub_4bit sub0 (\n    .A(A[63:56]),\n    .B(B[63:56]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub1 (\n    .A(A[55:48]),\n    .B(B[55:48]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub2 (\n    .A(A[47:40]),\n    .B(B[47:40]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub3 (\n    .A(A[39:32]),\n    .B(B[39:32]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub4 (\n    .A(A[31:24]),\n    .B(B[31:24]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub5 (\n    .A(A[23:16]),\n    .B(B[23:16]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub6 (\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .D(D1),\n    .B_out(B_out1)\n);\n\nsub_4bit sub7 (\n    .A(A[7:0]),\n    .B(B[7:0"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [4:1] A1, B1, D1, B_out1;\nwire C1, G1, P1;\n\nfull_subtractor sub4 (A[4:1], B[4:1], D1, C1, G1, P1);\nfull_subtractor sub3 (A[8:5], B[8:5], D[8:5], C1, G1, P1);\nfull_subtractor sub2 (A[12:9], B[12:9], D[12:9], C1, G1, P1);\nfull_subtractor sub1 (A[16:13], B[16:13], D[16:13], C1, G1, P1);\n\nassign B_out = C1;\n\nendmodule\n\nmodule full_subtractor(A, B, D, C, G, P);\ninput A, B;\noutput D, C, G, P;\n\nassign D = A ^ B ^ P;\nassign G = (A & B) | (P & (A ^ B));\nassign C = G ^ B;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n// Carry Generator Logic\nwire [31:0] A_minus_B;\nassign A_minus_B = A - B;\nwire carry_out = (A_minus_B[31] == 1) ? 1'b1 : 1'b0;\n\n// Comparison Logic\nassign A_greater = (carry_out == 1'b0) ? 1'b0 : 1'b1;\nassign A_equal = (A_minus_B == 0) ? 1'b1 : 1'b0;\nassign A_less = (carry_out == 1'b1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] A_minus_B, \n    output carry_out    \n);\n\nassign A_minus_B = A - B;\nassign carry_out = (A_minus_B[31] == 1) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa0_sum, csa1_sum, csa2_sum, csa3_sum;\nwire [3:0] csa0_carry, csa1_carry, csa2_carry, csa3_carry;\nwire [3:0] csa0_cout, csa1_cout, csa2_cout, csa3_cout;\nwire [3:0] rca0_sum, rca1_sum, rca2_sum, rca3_sum;\nwire [3:0] rca0_carry, rca1_carry, rca2_carry, rca3_carry;\nwire [3:0] rca0_cout, rca1_cout, rca2_cout, rca3_cout;\nwire [3:0] csa_sum, csa_carry, csa_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] sum0, carry0;\nassign rca0_sum[0] = a[0] ^ b[0];\nassign rca0_sum[1] = a[1] ^ b[1];\nassign rca0_sum[2] = a[2] ^ b[2];\nassign rca0_sum[3] = a[3] ^ b[3];\n\nassign rca0_carry[0] = a[0] & b[0];\nassign rca0_carry[1] = a[1] & b[1];\nassign rca0_carry[2] = a[2] & b[2];\nassign rca0_carry[3] = a[3] & b[3];\n\nassign rca0_cout = rca0_carry[0] | (rca0_sum[0] & rca0_carry[1]) | (rca0_sum[1] & rca0_carry[2]) | (rca0_sum[2] & rca0_carry[3]);\n\n// 4-bit carry select adder\nwire [3:0] csa0_xor0, csa0_xor1, csa0_xor2, csa0_xor3;\nassign csa0_xor0 = csa0_carry[0] | (csa0_sum[0] & csa0_carry[1]);\nassign csa0_xor1 = csa0_carry[1] | (csa0_sum[1] & csa0_carry[2]);\nassign csa0_xor2 = csa0_carry[2] | (csa0_sum[2] & csa0_carry[3]);\nassign csa0_xor3 = csa0_sum[3];\n\nassign csa0_cout = csa0_xor0 | (csa0_xor1 & csa0_carry[0]) | (csa0_xor2 & csa0_carry[1]) | (csa0_xor3 & csa0_carry[2]);\n\n// 4-bit ripple carry adder\nassign rca1_sum[0] = rca0_sum[0] ^ rca0_sum[1];\nassign rca1_sum[1] = rca0_sum[2] ^ rca0_sum[3];\n\nassign rca1_carry[0] = rca0_carry[0] ^ rca0_sum[0];\nassign rca1_carry[1] = rca0_carry[1] ^ rca0_sum[1];\nassign rca1_carry[2] = rca0_carry[2] ^ rca0_sum[2];\nassign rca1_carry[3] = rca0_carry[3] ^ rca0_sum[3];\n\nassign rca1_cout = rca1_carry[0] | (rca1_sum[0] & rca1_carry[1]) | (rca1_sum[1] & rca1_carry[2]) |"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire c;\n\n    // First adder\n    wire [7:0] a_7;\n    wire [7:0] b_7;\n    wire [7:0] y_7;\n    assign a_7 = a[7:0];\n    assign b_7 = b[7:0];\n    assign {y_7, c} = a_7 + b_7 + Cin;\n    assign y[7:0] = y_7;\n\n    // Second adder\n    wire [7:0] a_15;\n    wire [7:0] b_15;\n    wire [7:0] y_15;\n    assign a_15 = a[15:8];\n    assign b_15 = b[15:8];\n    assign {y_15, c} = a_15 + b_15 + c;\n    assign y[15:8] = y_15;\n\n    // Third adder\n    wire [7:0] a_23;\n    wire [7:0] b_23;\n    wire [7:0] y_23;\n    assign a_23 = a[23:16];\n    assign b_23 = b[23:16];\n    assign {y_23, c} = a_23 + b_23 + c;\n    assign y[23:16] = y_23;\n\n    // Fourth adder\n    wire [7:0] a_31;\n    wire [7:0] b_31;\n    wire [7:0] y_31;\n    assign a_31 = a[31:24];\n    assign b_31 = b[31:24];\n    assign {y_31, Co} = a_31 + b_31 + c;\n    assign y[31:24] = y_31;\nendmodule\n```\n\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    \n    full_adder fa0(a[0], b[0], cin, sum[0], c1);\n    full_adder fa1(a[1], b[1], c1, sum[1], c2);\n    full_adder fa2(a[2], b[2], c2, sum[2], c3);\n    full_adder fa3(a[3], b[3], c3, sum[3], c4);\n    full_adder fa4(a[4], b[4], c4, sum[4], c5);\n    full_adder fa5(a[5], b[5], c5, sum[5], c6);\n    full_adder fa6(a[6], b[6], c6, sum[6], c7);\n    full_adder fa7(a[7], b[7], c7, sum[7], cout);\n    \nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n//------------------------------------------------\n// Control Unit\n//------------------------------------------------\nreg [1:0] shift_count;\nwire [1:0] next_shift_count;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 0;\n        done_reg <= 0;\n    end\n    else begin\n        shift_count <= next_shift_count;\n        done_reg <= 0;\n    end\nend\n\nassign next_shift_count = (start && !done_reg) ? 2 : 0;\n\nassign done = done_reg;\n\n//------------------------------------------------\n// Register Unit\n//------------------------------------------------\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end\n    else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n//------------------------------------------------\n// Multiplier Unit\n//------------------------------------------------\nreg [31:0] product;\nwire [31:0] next_product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0;\n    end\n    else begin\n        if (shift_count > 0) begin\n            product <= next_product;\n        end\n    end\nend\n\nassign next_product = product + (b_reg[shift_count] ? a_reg : 0);\n\n//------------------------------------------------\n// Output Assignment\n//------------------------------------------------\nassign yout = product;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire count_enable;\n    wire count_increment;\n    wire count_decrement;\n    wire [15:0] next_count;\n\n    // Counter logic\n    assign count_enable = up_down;\n    assign count_increment = count_enable & !up_down;\n    assign count_decrement = count_enable & up_down;\n    assign next_count = count_increment ? count + 1 : count - 1;\n\n    // Counter register\n    reg [15:0] current_count;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\n    assign count = current_count;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialize\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule: Transition\n    always @(posedge clk) begin\n        out <= (out >> 1) | (out << 7);\n    end\n\nendmodule\n\n========================================================================\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    // Submodule: Initialize\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule: Transition\n    always @(posedge clk) begin\n        out <= (out >> 1) | (out << 7);\n    end\n\nendmodule\n\n========================================================================\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\nreg [3:0] next_count;\n\nassign count = count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'd0;\n    else\n        count_r <= next_count;\nend\n\nalways @* begin\n    next_count = count_r;\n\n    if (valid_count) begin\n        if (count_r == 4'd11)\n            next_count = 4'd0;\n        else\n            next_count = count_r + 1;\n    end\nend\n\nendmodule\n\nmodule\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd0;\n    else if (valid_count)\n        count <= count + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'd0;\n    else if (valid_count)\n        out_r <= in;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_Q;\n\n// Submodule instantiation\nJC_register reg_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(next_Q)\n);\n\nJC_logic logic_inst (\n    .Q(Q),\n    .next_Q(next_Q)\n);\n\nendmodule\n\nmodule JC_register (\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q,\n    input [63:0]        next_Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'd0;\n    else\n        Q_reg <= next_Q;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic (\n    input [63:0]        Q,\n    input [63:0]        next_Q,\n    output [63:0]       next_Q\n);\n\nassign next_Q[0] = Q[63];\nassign next_Q[1] = Q[63] ^ Q[62];\nassign next_Q[62:2] = Q[61:1];\nassign next_Q[63] = Q[0];\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_div_2_out;\n    wire clk_div_10_out;\n    wire clk_div_100_out;\n\n    // clk_div_2\n    reg [1:0] counter_2 = 2'b00;\n    assign clk_div_2_out = ~counter_2[1];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter_2 <= 2'b00;\n        else\n            counter_2 <= counter_2 + 2'b01;\n    end\n\n    // clk_div_10\n    reg [1:0] counter_10 = 2'b00;\n    assign clk_div_10_out = ~counter_10[1];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter_10 <= 2'b00;\n        else if (counter_2[1])\n            counter_10 <= counter_10 + 2'b01;\n    end\n\n    // clk_div_100\n    reg [6:0] counter_100 = 7'b0000000;\n    assign clk_div_100_out = ~counter_100[6];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter_100 <= 7'b0000000;\n        else if (counter_10[1])\n            counter_100 <= counter_100 + 7'b0000001;\n    end\n\n    assign CLK_50 = clk_div_2_out;\n    assign CLK_10 = clk_div_10_out;\n    assign CLK_1 = clk_div_100_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg clk = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            clk <= 0;\n        else\n            clk <= ~clk;\n    end\n\n    assign CLK_out = clk;\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [1:0] counter = 2'b00;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 2'b00;\n        else if (counter[1])\n            counter <= counter + 2'b01;\n    end\n\n    assign CLK_out = ~counter[1];\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [6:0] counter = 7'b0000000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            counter <= 7'b0000000;\n        else if (counter[6])\n            counter <= counter + 7'b0000001;\n    end\n\n    assign CLK_out = ~counter[6];\nendmodule\n\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] cnt;\nwire [3:0] cnt_next;\nwire [1:0] cnt_avg;\nwire [1:0] cnt_avg_next;\nwire [1:0] cnt_adjusted;\n\nreg [3:0] cnt_reg;\nreg [3:0] cnt_next_reg;\nreg [1:0] cnt_avg_reg;\nreg [1:0] cnt_avg_next_reg;\nreg [1:0] cnt_adjusted_reg;\n\nreg [3:0] cnt_avg_2;\n\nreg [3:0] clk_div_reg;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_reg <= 4'b0;\n    else\n        cnt_reg <= cnt_next_reg;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_next_reg <= 4'b0;\n    else if (cnt_reg >= MUL2_DIV_CLK)\n        cnt_next_reg <= 4'b0;\n    else\n        cnt_next_reg <= cnt_reg + 1'b1;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_avg_reg <= 2'b0;\n    else if (cnt_avg_next_reg != cnt_avg_reg)\n        cnt_avg_reg <= cnt_avg_next_reg;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_avg_next_reg <= 2'b0;\n    else if (cnt_avg_reg != cnt_avg_next_reg)\n        cnt_avg_next_reg <= cnt_avg_reg + 1'b1;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_adjusted_reg <= 2'b0;\n    else\n        cnt_adjusted_reg <= {~cnt_avg_reg[1], cnt_avg_reg[0]};\nend\n\nassign cnt = cnt_reg;\nassign cnt_avg = cnt_avg_reg;\nassign cnt_avg_2 = {~cnt_avg_reg[1], cnt_avg_reg[0]};\n\nassign cnt_adjusted = cnt_adjusted_reg;\n\nassign clk_div = cnt_avg_2[0] | cnt_avg_2[1];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    input [3:0]         limit,\n    output reg [3:0]    cnt,\n    output reg          cnt_next\n);\n\nreg [3:0] cnt_reg;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_reg <= 4'b0;\n    else if (cnt_reg >= limit)\n        cnt_reg <= 4'b0;\n    else\n        cnt_reg <= cnt_reg + 1'b1;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt <= 4'b0;\n    else\n        cnt <= cnt_reg;\nend\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        cnt_next <= 1'b0;\n    else if (cnt_reg >= limit)\n        cnt_next <= 1'b0;\n    else\n        cnt_next <= 1'b1;\nend\n\nend"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    reg [$clog2(NUM_DIV)-1:0] cnt_pos;\n    reg [$clog2(NUM_DIV)-1:0] cnt_neg;\n    reg clk_div1, clk_div2;\n    assign clk_div = clk_div1 | clk_div2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            cnt_pos <= 0;\n            cnt_neg <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else begin\n            if (cnt_pos < NUM_DIV - 1) begin\n                cnt_pos <= cnt_pos + 1;\n            end else begin\n                cnt_pos <= 0;\n                clk_div1 <= 1;\n            end\n            if (cnt_neg < NUM_DIV - 1) begin\n                cnt_neg <= cnt_neg + 1;\n            end else begin\n                cnt_neg <= 0;\n                clk_div2 <= 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end else begin\n            if (counter == NUM_DIV / 2 - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n            if (counter == 0) begin\n                clk_div_reg <= ~clk_div_reg;\n            end\n        end\n    end\n\n    assign clk_div = clk_div_reg;\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output [3:0] q\n);\n    reg [3:0] q_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q_reg <= 0;\n        end else begin\n            if (q_reg == NUM_DIV / 2 - 1) begin\n                q_reg <= 0;\n            end else begin\n                q_reg <= q_reg + 1;\n            end\n        end\n    end\n\n    assign q = q_reg;\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    reg clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_reg <= 0;\n        end else begin\n            clk_div_reg <= ~clk_div_reg;\n        end\n    end\n\n    assign clk_div = clk_div_reg;\nendmodule\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] alu_add, alu_sub, alu_and, alu_or, alu_xor, alu_nor, alu_slt, alu_sltu, alu_sll, alu_srl, alu_sra, alu_sllv, alu_srlv, alu_srav;\nwire [31:0] alu_lui;\nwire [31:0] alu_sllv_result, alu_srlv_result, alu_srav_result;\nwire [31:0] alu_sub_result, alu_slt_result, alu_sltu_result;\n\n// Addition\nsubmodule alu_add_submodule alu_add_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_add)\n);\n\nassign alu_add = a + b;\n\n// Subtraction\nsubmodule alu_sub_submodule alu_sub_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_sub)\n);\n\nassign alu_sub = a - b;\n\n// AND\nsubmodule alu_and_submodule alu_and_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_and)\n);\n\nassign alu_and = a & b;\n\n// OR\nsubmodule alu_or_submodule alu_or_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_or)\n);\n\nassign alu_or = a | b;\n\n// XOR\nsubmodule alu_xor_submodule alu_xor_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_xor)\n);\n\nassign alu_xor = a ^ b;\n\n// NOR\nsubmodule alu_nor_submodule alu_nor_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_nor)\n);\n\nassign alu_nor = ~(a | b);\n\n// SLT\nsubmodule alu_slt_submodule alu_slt_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_slt)\n);\n\nassign alu_slt = a < b;\n\n// SLTU\nsubmodule alu_sltu_submodule alu_sltu_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_sltu)\n);\n\nassign alu_sltu = a < b;\n\n// SLL\nsubmodule alu_sll_submodule alu_sll_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_sll)\n);\n\nassign alu_sll = a << b;\n\n// SRL\nsubmodule alu_srl_submodule alu_srl_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_srl)\n);\n\nassign alu_srl = a >> b;\n\n// SRA\nsubmodule alu_sra_submodule alu_sra_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_sra)\n);\n\nassign alu_sra = $signed(a) >>> b;\n\n// SLLV\nsubmodule alu_sllv_submodule alu_sllv_submodule_inst(\n    .a(a),\n    .b(b),\n    .r(alu_sllv_result)\n);\n\nassign alu_sllv_result = a << b[4:0];\nsubmodule alu_sllv_submodule alu_sllv_submodule_inst(\n    .a(alu_sllv_result),\n    .b(b),\n    .r(alu_sllv)\n);\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] u_multiplier;\nwire [31:0] u_accumulator;\n\n// Implement u_multiplier submodule\nassign u_multiplier = a * b;\n\n// Implement u_accumulator submodule\nreg [31:0] current_value = 0;\nalways @(posedge clk) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + u_multiplier;\n    end\nend\nassign u_accumulator = current_value;\n\nassign c = u_accumulator;\n\nendmodule\n\nmodule pe_submodule_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] c\n);\n\nassign c = a * b;\n\nendmodule\n\nmodule pe_submodule_accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    output [31:0] c\n);\n\nreg [31:0] current_value = 0;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + a;\n    end\nend\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    reg [2:0] ins_p1;\n    reg [4:0] ad1_p1;\n    reg [7:0] ad2_p1;\n\n    reg [2:0] ins_p2;\n    reg [4:0] ad1_p2;\n    reg [7:0] ad2_p2;\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1 <= 3'd0;\n            ad1_p1 <= 5'd0;\n            ad2_p1 <= 8'd0;\n            ins_p2 <= 3'd0;\n            ad1_p2 <= 5'd0;\n            ad2_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1 <= data[7:5];\n                ad1_p1 <= data[4:0];\n                ad2_p1 <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2 <= data[7:5];\n                ad1_p2 <= data[4:0];\n                ad2_p2 <= data;\n            end\n        end\n    end\n\n    assign ins = {ins_p2, ins_p1};\n    assign ad1 = {ad1_p2, ad1_p1};\n    assign ad2 = {ad2_p2, ad2_p1};\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable = 1;\nwire [7:0] count;\n\nwire [7:0] freq_counter;\n\nassign freq_counter = (enable) ? freq : 8'h00;\n\n\ncounter counter_instance(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq_counter),\n    .count(count)\n);\n\nwire [7:0] freq_counter_output;\n\nassign freq_counter_output = (count == (freq - 1)) ? 8'h00 : 8'h01;\n\n\nwave_generator wave_generator_instance(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 8'h00;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= 0;\n    end else begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n/* State Control Module */\nreg [1:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= 2'b00;\n    end else begin\n        case (state)\n            2'b00: state <= 2'b01;\n            2'b01: state <= 2'b10;\n            2'b10: state <= 2'b00;\n            default: state <= 2'b00;\n        endcase\n    end\nend\n\n/* Waveform Generation Module */\nreg [4:0] wave_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wave_reg <= 5'd0;\n    end else begin\n        case (state)\n            2'b00: wave_reg <= wave_reg + 1;\n            2'b01: wave_reg <= wave_reg - 1;\n            default: wave_reg <= 5'd0;\n        endcase\n    end\nend\n\nassign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\nwire q1, q2, q3;\n\n// Replace my_dff with an actual flip-flop implementation\n// You will need to define the module or include an existing implementation.\n// Using a simple D flip-flop implementation as an example.\n\n// Simple D flip-flop implementation\nreg q_reg;\nalways @(posedge clk) begin\n    q_reg <= d;\nend\nassign q = q_reg;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n\n    assign shifted_in[7] = in[ctrl[2]];\n    assign shifted_in[6] = in[ctrl[2] ^ 1];\n    assign shifted_in[5] = in[ctrl[2] ^ 2];\n    assign shifted_in[4] = in[ctrl[2] ^ 3];\n    assign shifted_in[3] = in[ctrl[2] ^ 4];\n    assign shifted_in[2] = in[ctrl[2] ^ 5];\n    assign shifted_in[1] = in[ctrl[2] ^ 6];\n    assign shifted_in[0] = in[ctrl[2] ^ 7];\n\n    assign out = shifted_in;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  assign b1 = b1_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1_reg <= 16'b0;\n    end else begin\n      b1_reg <= b0;\n    end\n  end\n\n  // pe0\n  wire [31:0] pe0_c;\n  assign pe0_c = {16'b0, a0} * {16'b0, b0};\n\n  // pe1\n  wire [31:0] pe1_c;\n  assign pe1_c = {16'b0, a1} * {16'b0, b1};\n\n  assign c0 = pe0_c;\n  assign c1 = pe1_c;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  wire [31:0] next_instr;\n  wire [31:0] pc_reg;\n  wire [31:0] next_pc;\n  wire [31:0] alu_out;\n  wire [31:0] write_data;\n  wire [31:0] write_reg;\n  wire [31:0] write_en;\n  wire [31:0] write_addr;\n  reg [31:0] res_reg_file_reg [0:31];\n\n  assign res_reg_file = res_reg_file_reg;\n\n  // Pipeline stages\n  stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc_reg(pc_reg),\n    .next_instr(next_instr)\n  );\n\n  stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc_reg(pc_reg),\n    .next_instr(next_instr),\n    .alu_out(alu_out),\n    .write_data(write_data),\n    .write_reg(write_reg),\n    .write_en(write_en),\n    .write_addr(write_addr)\n  );\n\n  stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .reg_file(reg_file),\n    .write_data(write_data),\n    .write_reg(write_reg),\n    .write_en(write_en),\n    .write_addr(write_addr),\n    .alu_out_reg(alu_out)\n  );\n\n  stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .reg_file(reg_file),\n    .write_data(write_data),\n    .write_reg(write_reg),\n    .write_en(write_en),\n    .write_addr(write_addr),\n    .alu_out_reg(alu_out)\n  );\n\n  stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .reg_file(reg_file),\n    .write_data(write_data),\n    .write_reg(write_reg),\n    .write_en(write_en),\n    .write_addr(write_addr),\n    .alu_out_reg(alu_out)\n  );\n\n  // Pipeline registers\n  always @(posedge clk) begin\n    if (rst) begin\n      res_reg_file_reg <= 0;\n      pc_reg <= 0;\n      next_instr <= 0;\n    end else begin\n      res_reg_file_reg <= alu_out;\n      pc_reg <= next_pc;\n      next_instr <= fetch_stage.next_instr;\n    end\n  end\n\nendmodule\n\nmodule stage (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc_reg,\n  input [31:0] next_instr,\n  output [31:0] alu_out,\n  output [31:0] write_data,\n  output [31:0] write_reg,\n  output [31:0] write_en,\n  output [31:0] write_addr,\n  output [31:0] next_pc\n);\n\n  wire [31:0] rs1;\n  wire [31:0] rs2;\n  wire [31:0] rd;\n  wire [31:0] op;\n  wire [31:0] rd_reg;\n  wire [31:0] rs1_reg;\n  wire [31:0] rs2_reg;\n\n  // Registers\n  reg [31:0] rd_reg_reg;\n  reg [31:0] rs1_reg"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [31:0] b0_dly = 0;\n  reg [31:0] b1_dly = 0;\n  reg [31:0] b2_dly = 0;\n  reg [31:0] b3_dly = 0;\n  \n  wire [31:0] pe0 = a0*b0;\n  wire [31:0] pe1 = a1*b1_dly;\n  wire [31:0] pe2 = a2*b2_dly;\n  wire [31:0] pe3 = a3*b3_dly;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_dly <= 0;\n      b1_dly <= 0;\n      b2_dly <= 0;\n      b3_dly <= 0;\n    end else begin\n      b0_dly <= b0;\n      b1_dly <= b0_dly;\n      b2_dly <= b1_dly;\n      b3_dly <= b2_dly;\n    end\n  end\n  \n  assign c0 = pe0;\n  assign c1 = pe1;\n  assign c2 = pe2;\n  assign c3 = pe3;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] instr;\nwire [31:0] alu_out;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nparameter ADDR_COUNTER = 0;\nparameter ADDR_DATA_ACCUMULATOR = 1;\nparameter ADDR_VALID_OUTPUT = 2;\n\n// Submodule definitions\n// Counter Module\nreg [1:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 2'd0;\n    end else if (valid_in && cnt < 2'd3) begin\n        cnt <= cnt + 2'd1;\n    end else if (cnt == 2'd3) begin\n        cnt <= 2'd0;\n    end\nend\nassign valid_out = (cnt == 2'd3);\n\n// Data Accumulator Module\nreg [9:0] data_accumulator;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accumulator <= 10'd0;\n    end else if (valid_in) begin\n        data_accumulator <= data_accumulator + data_in;\n    end\nend\nassign data_out = data_accumulator;\n\n// Valid Output Module\nreg valid_out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n    end else if (valid_in && cnt == 2'd3) begin\n        valid_out_reg <= 1'b1;\n    end else if (cnt < 2'd3) begin\n        valid_out_reg <= 1'b0;\n    end\nend\nassign valid_out = valid_out_reg;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .result(dividend),\n        .odd(divisor)\n    );\n\n    // Divide dividend by divisor\n    div_operation div_operation_inst(\n        .A(dividend),\n        .B(divisor),\n        .result(quotient),\n        .odd(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit dividend\n    output wire [31:0] odd      // 32-bit divisor\n);\n\n    // Prepare dividend\n    assign result = A;\n\n    // Prepare divisor\n    assign odd = {B, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [31:0] B,   // 32-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    // Divide dividend by divisor\n    assign result = A >> B;\n    assign odd = A - (B << (32-1));\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [7:0] A_16;\n    wire [7:0] B_16;\n    wire [15:0] odd_16;\n    wire [15:0] result_16;\n    wire [15:0] tmp_16;\n\n    // 16-bit submodule\n    div_8bit div8 (\n        .A(A_16),\n        .B(B_16),\n        .odd(odd_16),\n        .result(result_16)\n    );\n\n    // 8-bit submodule\n    div_8bit div8_2 (\n        .A(A[7:0]),\n        .B(B),\n        .odd(odd[7:0]),\n        .result(tmp_16)\n    );\n\n    // Control unit\n    always @(*) begin\n        A_16 = A;\n        B_16 = B;\n        odd_16 = 8'b0;\n        result_16 = 16'b0;\n        tmp_16 = 16'b0;\n\n        while (A_16 >= B_16) begin\n            A_16 = A_16 - B_16;\n            result_16 = result_16 + 1;\n        end\n        odd_16 = A_16;\n    end\n\nendmodule\n\nmodule div_8bit (\n    input wire [7:0] A,       // 8-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [7:0] odd,    // 8-bit remainder\n    output wire [7:0] result  // 8-bit quotient\n);\n\n    // Prepare tmp and odd\n    reg [15:0] tmp;\n    reg [15:0] odd_16;\n    reg [15:0] result_16;\n\n    // Shift A and B left by one bit to ensure correct comparison\n    reg [15:0] A_16;\n    reg [15:0] B_16;\n\n    // Calculate the result\n    always @(*) begin\n        A_16 = {A, 1'b0};\n        B_16 = {B, 1'b0};\n        odd_16 = 16'b0;\n        result_16 = 16'b0;\n        tmp = 16'b0;\n\n        while (A_16 >= B_16) begin\n            A_16 = A_16 - B_16;\n            result_16 = result_16 + 1;\n        end\n        odd_16 = A_16;\n    end\n\n    assign result = result_16[7:0];\n    assign odd = odd_16[7:0];\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_inv;\nwire [7:0] B_inv_carry;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_inv = ~B;\n\nassign {B_out_temp, carry} = A + B_inv;\nassign {sum, B_inv_carry} = carry + B_inv_carry;\nassign D = sum;\nassign B_out = B_out_temp;\n\nendmodule\n\nmodule adder_8bit(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] B_inv;\nwire [7:0] B_inv_carry;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_inv = ~B;\n\nassign {B_out_temp, carry} = A + B_inv;\nassign {sum, B_inv_carry} = carry_in + B_inv_carry;\nassign D = sum;\nassign carry_out = B_out_temp;\n\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\ninput A, B, carry_in;\noutput sum, carry_out;\n\nassign {carry_out, sum} = A + B + carry_in;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] A1, B1, D1;\nwire B_out1;\n\nsubmodule sub0(A[63:32], B[63:32], D[63:32], B_out);\n\nsubmodule sub1(A[31:16], B[31:16], D[31:16], B_out);\n\nsubmodule sub2(A[15:8], B[15:8], D[15:8], B_out);\n\nsubmodule sub3(A[7:0], B[7:0], D[7:0], B_out);\n\nendmodule\n"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] B_out;\nwire [15:1] B_out;\nwire [15:1] D;\n\nwire [3:0] A1, A2, A3, A4, B1, B2, B3, B4, C1, C2, C3, C4, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13, D14, D15, D16;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign C1 = A1^B1;\nassign C2 = A2^B2;\nassign C3 = A3^B3;\nassign C4 = A4^B4;\n\nassign D1 = (~A1) & B1;\nassign D2 = (~A2) & B2;\nassign D3 = (~A3) & B3;\nassign D4 = (~A4) & B4;\nassign D5 = (~C1) & C2;\nassign D6 = (~C3) & C4;\nassign D7 = (~D1) & D2;\nassign D8 = (~D3) & D4;\nassign D9 = (~D5) & D6;\nassign D10 = (~D7) & D8;\nassign D11 = (~D9) & D10;\nassign D12 = (~D7) & D9;\nassign D13 = (~D9) & D11;\nassign D14 = (~D11) & D13;\nassign D15 = (~D13) & D15;\nassign D16 = (~D15) & D16;\n\nassign B_out = D16;\nassign D = {D16, D15, D14, D13, D12, D11, D10, D9, D8, D7, D6, D5, D4, D3, D2, D1};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtract A and B\nassign sub_result = A - B;\nassign carry = (sub_result == 0);\n\n// Determine if greater\nassign A_greater = (sub_result < 0);\n\n// Determine if equal\nassign A_equal = (sub_result == 0) && carry;\n\n// Determine if less\nassign A_less = (sub_result > 0) && !carry;\n\nendmodule\n\"\"\"\n\n\ndef test_case_1():\n    code = \"\"\"\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtract A and B\nassign sub_result = A - B;\nassign carry = (sub_result == 0);\n\n// Determine if greater\nassign A_greater = (sub_result < 0);\n\n// Determine if equal\nassign A_equal = (sub_result == 0) && carry;\n\n// Determine if less\nassign A_less = (sub_result > 0) && !carry;\n\nendmodule\n\"\"\"\n    assert_equivalent(code, comparator_32bit)\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n\ninput  [32:1] A;\ninput  [32:1] B;\noutput [32:1] S;\noutput        C32;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa0_sum, csa1_sum, csa2_sum, csa3_sum;\nwire [3:0] csa0_carry, csa1_carry, csa2_carry, csa3_carry;\nwire [3:0] rca0_sum, rca1_sum;\nwire [1:0] mux0_out, mux1_out;\nwire [3:0] csa0_cout, csa1_cout, csa2_cout, csa3_cout;\nwire [1:0] mux2_out, mux3_out;\nwire [3:0] rca0_cout, rca1_cout;\n\n// ripple carry adder\nwire [15:0] rca0_b, rca1_b;\n\nassign rca0_b = {b[15], b[15:1]};\nassign rca1_b = {b[14:0], 1'b0};\n\nassign rca0_sum = rca0_b[15:12] ^ a[15:12] ^ {4{rca0_b[12]}};\nassign rca0_cout = (rca0_b[12] & a[15]) | (rca0_b[12] & rca0_b[11]) | (a[15] & rca0_b[11]);\n\nassign rca1_sum = rca1_b[15:12] ^ a[15:12] ^ {4{rca1_b[12]}};\nassign rca1_cout = (rca1_b[12] & a[15]) | (rca1_b[12] & rca1_b[11]) | (a[15] & rca1_b[11]);\n\n// carry select adder\nwire [15:0] csa0_a, csa1_a, csa2_a, csa3_a;\n\nassign csa0_a = {csa0_sum, csa0_cout};\nassign csa1_a = {csa1_sum, csa1_cout};\nassign csa2_a = {csa2_sum, csa2_cout};\nassign csa3_a = {csa3_sum, csa3_cout};\n\nassign csa0_sum = rca0_sum;\nassign csa0_carry = rca0_cout;\nassign csa1_sum = {csa1_carry, 4'b0};\nassign csa1_carry = rca0_cout;\nassign csa2_sum = {csa2_carry, 4'b0};\nassign csa2_carry = rca1_cout;\nassign csa3_sum = {csa3_carry, 4'b0};\nassign csa3_carry = rca1_cout;\n\n// multiplexer\nassign mux0_out = cin ? csa0_carry : csa0_sum;\nassign mux1_out = cin ? csa1_carry : csa1_sum;\nassign mux2_out = cin ? csa2_carry : csa2_sum;\nassign mux3_out = cin ? csa3_carry : csa3_sum;\n\nassign sum = {mux3_out, mux2_out, mux1_out, mux0_out};\nassign cout = csa3_carry;\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n    wire [15:0] y0, y1, y2, y3, y4, y5, y6, y7;\n\n    // 8-bit full adder instantiation\n    adder_8bit adder_8bit0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_8bit adder_8bit1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // concatenate the outputs\n    assign y = {y1, y0};\n    assign Co = Co1;\n\nendmodule\n\n// adder_8bit\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    assign {Co7, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_out, fa1_out, fa2_out, fa3_out, fa4_out, fa5_out, fa6_out, fa7_out;\n    wire [6:0] fa_cout;\n    \n    // First FA\n    fa fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_out),\n        .cout(fa_cout[0]));\n    \n    // Second FA\n    fa fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa_cout[0]),\n        .sum(fa1_out),\n        .cout(fa_cout[1]));\n    \n    // Third FA\n    fa fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa_cout[1]),\n        .sum(fa2_out),\n        .cout(fa_cout[2]));\n    \n    // Fourth FA\n    fa fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa_cout[2]),\n        .sum(fa3_out),\n        .cout(fa_cout[3]));\n    \n    // Fifth FA\n    fa fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa_cout[3]),\n        .sum(fa4_out),\n        .cout(fa_cout[4]));\n    \n    // Sixth FA\n    fa fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa_cout[4]),\n        .sum(fa5_out),\n        .cout(fa_cout[5]));\n    \n    // Seventh FA\n    fa fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa_cout[5]),\n        .sum(fa6_out),\n        .cout(fa_cout[6]));\n    \n    // Eighth FA\n    fa fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa_cout[6]),\n        .sum(fa7_out),\n        .cout(fa_cout[7]));\n    \n    assign sum = fa0_out + fa1_out + fa2_out + fa3_out + fa4_out + fa5_out + fa6_out + fa7_out;\n    assign cout = fa_cout[7];\n    \nendmodule\n\nmodule fa(\n    input a, b, cin, \n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_count; // Shift count register.\nreg [15:0] product;    // Product register.\nreg [15:0] reg_a;      // Register a.\nreg [15:0] reg_b;      // Register b.\nreg done_flag;         // Done flag.\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'd0;\n        product <= 16'd0;\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'd0;\n            reg_a <= ain;\n            reg_b <= bin;\n            product <= 16'd0;\n            done_flag <= 1'b0;\n        end else if (shift_count < 4'd15) begin\n            shift_count <= shift_count + 4'd1;\n            done_flag <= 1'b0;\n        end else begin\n            done_flag <= 1'b1;\n        end\n    end\nend\n\n// Register Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else begin\n        if (start) begin\n            reg_a <= ain;\n            reg_b <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [31:0] temp_product;\nreg [15:0] temp_a;\nreg [15:0] temp_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        temp_product <= 32'd0;\n        temp_a <= 16'd0;\n        temp_b <= 16'd0;\n    end else begin\n        if (shift_count == 4'd0) begin\n            temp_product <= 32'd0;\n            temp_a <= reg_a;\n            temp_b <= reg_b;\n        end else if (shift_count < 4'd15) begin\n            temp_a <= {temp_a[14:0], 1'b0};\n            temp_product <= temp_product + (temp_b & temp_a);\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n    submodule u_counter_logic = counter_logic(clk, reset, up_down, count);\n    submodule u_counter_register = counter_register(clk, reset, up_down, count);\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= count;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Define submodules here\n    // ...\n\n    // ...\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_next;\n\nassign out = count_next;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        count_next <= 4'b0000;\n    else if (valid_count)\n        count_next <= count + 1;\nend\n\nassign count = (count_next == 4'd11) ? 4'b0000 : count_next;\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_reg;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        count_reg <= 4'b0000;\n    else if (valid_count)\n        count_reg <= count_reg + 1;\nend\n\nassign count = (count_reg == 4'd11) ? 4'b0000 : count_reg;\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= count;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Implement the Johnson Counter here\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\nalways @(*) begin\n    Q_next = Q & 64'b1;\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_r;\nreg CLK_10_r;\nreg CLK_1_r;\nreg [2:0] cnt_50;\nreg [2:0] cnt_10;\nreg [2:0] cnt_1;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        CLK_50_r <= 1'b0;\n        CLK_10_r <= 1'b0;\n        CLK_1_r <= 1'b0;\n        cnt_50 <= 3'b0;\n        cnt_10 <= 3'b0;\n        cnt_1 <= 3'b0;\n    end else begin\n        CLK_50_r <= ~CLK_50_r;\n        CLK_10_r <= ~CLK_10_r;\n        CLK_1_r <= ~CLK_1_r;\n        if (cnt_50 == 3'b111) begin\n            cnt_50 <= 3'b0;\n        end else begin\n            cnt_50 <= cnt_50 + 1'b1;\n        end\n        if (cnt_10 == 3'b111) begin\n            cnt_10 <= 3'b0;\n        end else begin\n            cnt_10 <= cnt_10 + 1'b1;\n        end\n        if (cnt_1 == 3'b111) begin\n            cnt_1 <= 3'b0;\n        end else begin\n            cnt_1 <= cnt_1 + 1'b1;\n        end\n    end\nend\n\nassign CLK_50 = CLK_50_r;\nassign CLK_10 = CLK_10_r;\nassign CLK_1 = CLK_1_r;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg CLK_out_r;\nreg [1:0] cnt;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        CLK_out_r <= 1'b0;\n        cnt <= 2'b0;\n    end else begin\n        CLK_out_r <= ~CLK_out_r;\n        if (cnt == 2'b11) begin\n            cnt <= 2'b0;\n        end else begin\n            cnt <= cnt + 1'b1;\n        end\n    end\nend\n\nassign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg CLK_out_r;\nreg [2:0] cnt;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        CLK_out_r <= 1'b0;\n        cnt <= 3'b0;\n    end else begin\n        CLK_out_r <= ~CLK_out_r;\n        if (cnt == 3'b111) begin\n            cnt <= 3'b0;\n        end else begin\n            cnt <= cnt + 1'b1;\n        end\n    end\nend\n\nassign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg CLK_out_r;\nreg [4:0] cnt;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        CLK_out_r <= 1'b0;\n        cnt <= 5'b0;\n    end else begin\n        CLK_out_r <= ~CLK_out_r;\n        if (cnt == 5'b11111) begin\n            cnt <= 5'b0;\n        end else begin\n            cnt <= cnt + 1"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nlocalparam COUNT_WIDTH = $clog2(MUL2_DIV_CLK);\n\nreg [COUNT_WIDTH-1:0] counter;\nwire clk_div_1;\nwire clk_div_2;\n\n\n// Counter Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div_1 = counter == 4 ? 1'b0 : 1'b1;\n\n\n// Clock Average Generator Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div_2 = counter == 3 ? 1'b0 : 1'b1;\n\n\n// Clock Adjustment Submodule\nassign clk_div = clk_div_1 | clk_div_2;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n`define NUM_DIV 5\n`define WIDTH ($clog2(`define NUM_DIV) + 1)\n`define POS_EDGE 0\n`define NEG_EDGE 1\n\nreg [`WIDTH - 1:0] clk_div1, clk_div2;\nreg [`WIDTH - 1:0] u_pos_counter, u_neg_counter;\n\nalways @(posedge clk or negedge rst_n)\nbegin\n    if (!rst_n)\n    begin\n        u_pos_counter <= 0;\n        u_neg_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end\n    else\n    begin\n        u_pos_counter <= (u_pos_counter == (`define NUM_DIV - 1)) ? 0 : u_pos_counter + 1;\n        u_neg_counter <= (u_neg_counter == (`define NUM_DIV - 1)) ? 0 : u_neg_counter + 1;\n        clk_div1 <= (u_pos_counter == (`define NUM_DIV - 1)) ? 1 : 0;\n        clk_div2 <= (u_neg_counter == (`define NUM_DIV - 1)) ? 1 : 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    localparam NUM_DIV = 8;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    assign clk_div = clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end\n        else begin\n            if (counter == NUM_DIV/2 - 1) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 0;\n        end\n        else begin\n            if (q == NUM_DIV/2 - 1) begin\n                q <= 0;\n            end\n            else begin\n                q <= q + 1;\n            end\n        end\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div_reg\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end\n        else begin\n            if (counter == NUM_DIV/2 - 1) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule freq_divbyeven_sub(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    localparam NUM_DIV = 8;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    assign clk_div = clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div_reg <= 0;\n        end\n        else begin\n            if (counter == NUM_DIV/2 - 1) begin\n                counter <= 0;\n                clk_div_reg <= ~clk_div_reg;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] result;\n    \n    // Define the submodules for each operation\n    // ADD\n    wire [31:0] add_result;\n    wire [31:0] add_carry;\n    wire [31:0] add_negative;\n    wire [31:0] add_overflow;\n    wire add_flag;\n    \n    // SUB\n    wire [31:0] sub_result;\n    wire [31:0] sub_carry;\n    wire [31:0] sub_negative;\n    wire [31:0] sub_overflow;\n    wire sub_flag;\n    \n    // AND\n    wire [31:0] and_result;\n    wire and_flag;\n    \n    // OR\n    wire [31:0] or_result;\n    wire or_flag;\n    \n    // XOR\n    wire [31:0] xor_result;\n    wire xor_flag;\n    \n    // NOR\n    wire [31:0] nor_result;\n    wire nor_flag;\n    \n    // SLT\n    wire [31:0] slt_result;\n    wire slt_flag;\n    \n    // SLTU\n    wire [31:0] sltu_result;\n    wire sltu_flag;\n    \n    // SLL\n    wire [31:0] sll_result;\n    wire sll_flag;\n    \n    // SRL\n    wire [31:0] srl_result;\n    wire srl_flag;\n    \n    // SRA\n    wire [31:0] sra_result;\n    wire sra_flag;\n    \n    // SLLV\n    wire [31:0] sllv_result;\n    wire sllv_flag;\n    \n    // SRLV\n    wire [31:0] srlv_result;\n    wire srlv_flag;\n    \n    // SRAV\n    wire [31:0] srav_result;\n    wire srav_flag;\n    \n    // LUI\n    wire [31:0] lui_result;\n    wire lui_flag;\n    \n    // Implement the submodules\n    // ADD\n    assign {add_carry, add_result} = a + b;\n    assign {add_negative, add_overflow} = {1'b0, add_result[31] ^ add_result[31] ^ add_result[30]};\n    assign add_flag = add_result[31];\n    \n    // SUB\n    assign {sub_carry, sub_result} = a - b;\n    assign {sub_negative, sub_overflow} = {1'b0, sub_result[31] ^ sub_result[31] ^ sub_result[30]};\n    assign sub_flag = sub_result[31];\n    \n    // AND\n    assign and_result = a & b;\n    assign and_flag = and_result[31];\n    \n    // OR\n    assign or_result = a | b;\n    assign or_flag = or_result[31];\n    \n    // XOR\n    assign xor_result = a ^ b;\n    assign xor_flag = xor_result[31];\n    \n    // NOR\n    assign nor_result = ~(a | b);\n    assign nor_flag = nor_result[31];\n    \n    // SLT\n    assign slt_result = $signed(a) < $signed(b);\n    assign slt_flag = slt_result[31];\n    \n    // SLTU\n    assign sltu_result = a < b;\n    assign sltu_flag = sltu_result[31];\n    \n    // SLL\n    assign sll_result = a << b[4:0];\n    assign sll_flag = sll_result[31];\n    \n    // SRL\n    assign srl_result = $signed(a) >>> b[4:0];\n    assign srl_flag = srl_result[31];\n    \n    // SRA\n    assign sra_result = a >>> b[4:0];\n    assign sra_flag"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [31:0] multiplier_out;\n    wire [31:0] accumulator_out;\n    \n    // Multiplier submodule implementation\n    // This module is missing\n    // You can implement the missing parts as a separate Verilog module\n    // or define the multiplier operation here.\n    \n    // Accumulator submodule implementation\n    // This module is missing\n    // You can implement the missing parts as a separate Verilog module\n    // or define the accumulator operation here.\n    \n    // Connect submodules\n    // Connect the multiplier and accumulator submodules here\n    \n    // Output result\n    assign c = accumulator_out;\nendmodule\n\n/**\n * Your task is to implement the multiplier submodule, which should take two 32-bit inputs, a and b, and produce a 64-bit result of their multiplication.\n * \n * The input and output ports of the multiplier submodule are already defined.\n * \n * Your implementation should define a wire to hold the 64-bit result of multiplication.\n * \n * The wire should be assigned the product of the two inputs in the always block.\n */\nmodule pe_multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] out\n);\n    reg [63:0] result;\n    \n    // Implement the multiplication operation\n    always @(*) begin\n        result = a * b;\n    end\n    \n    assign out = result;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // 1st instruction port\n    reg [2:0] ins_p1_reg = 3'b0;\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n        end\n    end\n    assign ins_p1 = ins_p1_reg;\n\n    // 2nd instruction port\n    reg [7:0] ins_p2_reg = 8'b0;\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data;\n        end\n    end\n    assign ins_p2 = ins_p2_reg;\n\n    // Outputs\n    assign ins = {ins_p1_reg, ins_p2_reg};\n    assign ad1 = {ins_p1_reg, ins_p2_reg[4:0]};\n    assign ad2 = ins_p2_reg;\nendmodule\n\n-------------------------------------------------\n\nmodule submodule (\n    input [7:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ad1 = ins[4:0];\n    assign ad2 = ins;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n// Counter Module\nreg [7:0] count;\nreg enable;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\n// Functional Module\nalways @(posedge clk) begin\n    enable <= 1;\n    if (freq == 0) begin\n        enable <= 0;\n    end\nend\n\n// Wave Generator Module\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            wave_out <= 1;\n        end else begin\n            wave_out <= 0;\n        end\n    end else begin\n        wave_out <= 0;\n    end\nend\n\nendmodule\n\n```\n\n---\n\n\n\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule (\n    input clk,\n    input rst_n,\n    output wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            wave_reg <= wave_reg + 1;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] q0, q1, q2, q3;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n    my_dff8 u3 (.clk(clk), .d(q2), .q(q3));\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q0;\n            2'b01: q <= q1;\n            2'b10: q <= q2;\n            2'b11: q <= q3;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // D flip-flop module\n    reg q0;\n    always @(posedge clk) begin\n        q0 <= d;\n    end\n\n    assign q1 = q0;\n    assign q2 = q1;\n    assign q3 = q2;\n\n    assign q = q3;\n\nendmodule\n\"\"\"\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\n\ndef get_nodes(connectivity: List[List[int]]) -> List[int]:\n    \"\"\"\n    Get all nodes in the connectivity graph.\n\n    Args:\n        connectivity: The connectivity graph.\n\n    Returns:\n        A list of all nodes in the connectivity graph.\n    \"\"\"\n    nodes = set()\n    for edge in connectivity:\n        for node in edge:\n            nodes.add(node)\n    return list(nodes)\n\n\ndef get_edges(connectivity: List[List[int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Get all edges in the connectivity graph.\n\n    Args:\n        connectivity: The connectivity graph.\n\n    Returns:\n        A list of all edges in the connectivity graph.\n    \"\"\"\n    edges = defaultdict(list)\n    for edge in connectivity:\n        for i in range(0, len(edge), 2):\n            edges[edge[i]].append(edge[i + 1])\n    return [(node, edges[node][0]) for node in edges]\n\n\ndef get_edge_attrs(connectivity: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Get all edge attributes in the connectivity graph.\n\n    Args:\n        connectivity: The connectivity graph.\n\n    Returns:\n        A list of all edge attributes in the connectivity graph.\n    \"\"\"\n    return connectivity[1]\n\n\ndef get_node_attrs(nodes: List[int], node_attrs: List[List[int]]) -> List[str]:\n    \"\"\"\n    Get all node attributes in the submodules.\n\n    Args:\n        nodes: The nodes in the submodules.\n        node_attrs: The node attributes in the submodules.\n\n    Returns:\n        A list of all node attributes in the submodules.\n    \"\"\"\n    return [node_attrs[node][1] for node in nodes]\n\n\ndef get_submodules(nodes: List[int], node_attrs: List[List[int]]) -> List[str]:\n    \"\"\"\n    Get all submodules in the connectivity graph.\n\n    Args:\n        nodes: The nodes in the submodules.\n        node_attrs: The node attributes in the submodules.\n\n    Returns:\n        A list of all submodules in the connectivity graph.\n    \"\"\"\n    return [node_attrs[node][1] for node in nodes]\n\n\ndef run(connectivity: List[List[int]]) -> str:\n    \"\"\"\n    Generate the code for the shift register module.\n\n    Args:\n        connectivity: The connectivity graph.\n\n    Returns:\n        The code for the shift register module.\n    \"\"\"\n    nodes = get_nodes(connectivity)\n    edges = get_edges(connectivity)\n    edge_attrs = get_edge_attrs(connectivity)\n    node_attrs = get_node_attrs(nodes, edge_attrs)\n    submodules = get_submodules(nodes, edge_attrs)\n\n    code = f\"\"\"module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q1, q2, q3;\n\n    // D flip-flop module\n    reg q0;\n    always @(posedge clk) begin\n        q0 <= d;\n    end\n\n    assign q1 = q0;\n    assign q2 = q1;\n    assign q3 = q2;\n\n    assign q = q3;\n\nendmodule\n\"\"\"\n    return code\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput [7:0] out;\n\nwire [7:0] shifted;\nwire [2:0] ctrl2;\n\nmux2X1 mux1 (shifted[0], shifted[1], in[0], in[1], ctrl[2]);\nmux2X1 mux2 (shifted[1], shifted[2], shifted[0], shifted[1], ctrl[1]);\nmux2X1 mux3 (shifted[2], shifted[3], shifted[1], shifted[2], ctrl[0]);\nmux2X1 mux4 (shifted[3], shifted[4], shifted[2], shifted[3], ctrl[2]);\nmux2X1 mux5 (shifted[4], shifted[5], shifted[3], shifted[4], ctrl[1]);\nmux2X1 mux6 (shifted[5], shifted[6], shifted[4], shifted[5], ctrl[0]);\nmux2X1 mux7 (shifted[6], shifted[7], shifted[5], shifted[6], ctrl[2]);\nmux2X1 mux8 (shifted[7], out, shifted[6], shifted[7], ctrl[1]);\nmux2X1 mux9 (out, out, shifted[7], shifted[7], ctrl[0]);\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\ninput sel;\ninput in0, in1;\noutput out;\n\nassign out = sel ? in1 : in0;\n\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) b1 <= 0;\n    else b1 <= b0;\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .b0(b0),\n    .c0(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a0(a1),\n    .b0(b1),\n    .c0(c1)\n  );\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] b0,\n  output [31:0] c0\n);\n  reg [31:0] c0_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) c0_reg <= 0;\n    else c0_reg <= a0 * b0;\n  end\n\n  assign c0 = c0_reg;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res;\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] rs1;\n  wire [31:0] rs2;\n  wire [31:0] rd;\n  wire [31:0] op;\n  wire [31:0] alu_out;\n  wire [31:0] mem_out;\n  \n  stagepipe5_submodule fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .next_pc(next_pc),\n    .instr_mem(instr_mem),\n    .res(res)\n  );\n  \n  stagepipe5_submodule decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .next_pc(next_pc),\n    .instr_mem(instr_mem),\n    .res(res),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n  \n  stagepipe5_submodule execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .res(alu_out)\n  );\n  \n  stagepipe5_submodule memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_out(alu_out),\n    .res(mem_out)\n  );\n  \n  stagepipe5_submodule writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .mem_out(mem_out),\n    .res_reg_file(res_reg_file)\n  );\n  \n  reg [31:0] pipeline_reg [0:4];\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      pipeline_reg[0] <= 32'b0;\n      pipeline_reg[1] <= 32'b0;\n      pipeline_reg[2] <= 32'b0;\n      pipeline_reg[3] <= 32'b0;\n      pipeline_reg[4] <= 32'b0;\n    end else begin\n      pipeline_reg[0] <= pc;\n      pipeline_reg[1] <= res;\n      pipeline_reg[2] <= alu_out;\n      pipeline_reg[3] <= mem_out;\n      pipeline_reg[4] <= res_reg_file;\n    end\n  end\n  \n  assign pc = pipeline_reg[0];\n  assign res = pipeline_reg[1];\n  assign alu_out = pipeline_reg[2];\n  assign mem_out = pipeline_reg[3];\n  assign res_reg_file = pipeline_reg[4];\n  \n  assign next_pc = pc + 1;\n  \n  assign rs1 = res[31:28] ? reg_file[res[7:0]] : 0;\n  assign rs2 = res[31:28] ? reg_file[res[15:12]] : 0;\n  assign rd = res[31:28] ? res[27:22] : 0;\n  assign op = res[5:0];\n  \nendmodule\n\nmodule stagepipe5_submodule (\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] next_pc,\n  input [31:0] instr_mem [0:31],\n  input [31:0] res,\n  output [31:0] rs1,\n  output [31:0] rs2,\n  output [31:0] r"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [31:0] pe0_out_reg, pe1_out_reg, pe2_out_reg, pe3_out_reg;\n  wire [31:0] pe0_out, pe1_out, pe2_out, pe3_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n      pe0_out_reg <= 0;\n      pe1_out_reg <= 0;\n      pe2_out_reg <= 0;\n      pe3_out_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      pe0_out_reg <= a0 * b0_reg;\n      pe1_out_reg <= a1 * b1_reg;\n      pe2_out_reg <= a2 * b2_reg;\n      pe3_out_reg <= a3 * b3_reg;\n      c0_reg <= pe0_out_reg;\n      c1_reg <= pe1_out_reg + pe0_out_reg;\n      c2_reg <= pe2_out_reg + pe1_out_reg;\n      c3_reg <= pe3_out_reg + pe2_out_reg;\n    end\n  end\n\n  assign pe0_out = a0 * b0;\n  assign pe1_out = a1 * b1_reg;\n  assign pe2_out = a2 * b2_reg;\n  assign pe3_out = a3 * b3_reg;\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetched_instr;\n    wire [5:0] pc;\n    wire [4:0] rd;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    reg [31:0] reg_file_next;\n\n    assign pc = reg_file[0];\n    assign fetched_instr = instr_mem[pc];\n    assign rd = fetched_instr[11:7];\n    assign op1 = reg_file[fetched_instr[20:16]];\n    assign op2 = reg_file[fetched_instr[31:25]];\n\n    assign result = (fetched_instr[15:0] == 16'b000000_0000011) ? op1 + op2 : op1 - op2;\n\n    always @(posedge clk)\n    begin\n        if (rst) reg_file_next <= 32'b0;\n        else reg_file_next <= result;\n    end\n    \n    assign out_reg_file = reg_file_next;\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    // Counter Module\n    reg [2:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else if (valid_in) begin\n            cnt <= cnt + 1;\n        end else begin\n            cnt <= 0;\n        end\n    end\n\n    // Data Accumulator Module\n    reg [9:0] accu_data;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accu_data <= 0;\n        end else if (valid_in) begin\n            accu_data <= accu_data + data_in;\n        end else begin\n            accu_data <= 0;\n        end\n    end\n\n    // Valid Output Module\n    reg valid_out_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out_reg <= 0;\n        end else if (cnt == 4) begin\n            valid_out_reg <= 1;\n        end else begin\n            valid_out_reg <= 0;\n        end\n    end\n\n    assign valid_out = valid_out_reg;\n    assign data_out = accu_data;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n// Submodules\nabs_dividend abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(result[15:8])\n);\n\nneg_divisor_mod neg_divisor_mod_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .divisor(divisor),\n    .result(result[7:0])\n);\n\ndivider_control divider_control_inst (\n    .clk(clk),\n    .rst(rst),\n    .dividend(dividend),\n    .divisor(result[7:0]),\n    .opn_valid(opn_valid),\n    .res_valid(res_valid),\n    .res_ready(res_ready)\n);\n\nresult_management result_management_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .result(result)\n);\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // prep_dividend\n    wire [31:0] P;\n    wire [15:0] Q;\n    prep_dividend prep_dividend(\n        .A(A),\n        .B(B),\n        .P(P),\n        .Q(Q)\n    );\n\n    // div_operation\n    wire [31:0] Q1;\n    wire [31:0] Q2;\n    wire [31:0] R;\n    div_operation div_operation(\n        .P(P),\n        .Q(Q),\n        .Q1(Q1),\n        .Q2(Q2),\n        .R(R)\n    );\n\n    assign result = Q1;\n    assign odd = R;\n\nendmodule\n\n// prep_dividend\nmodule prep_dividend(\n    input wire [31:0] A, // 32-bit dividend\n    input wire [15:0] B, // 16-bit divisor\n    output wire [31:0] P, // 32-bit dividend\n    output wire [15:0] Q  // 16-bit divisor\n);\n    assign P = {A[31:16], A[31:16]};\n    assign Q = {B, B};\nendmodule\n\n// div_operation\nmodule div_operation(\n    input wire [31:0] P, // 32-bit dividend\n    input wire [15:0] Q, // 16-bit divisor\n    output wire [31:0] Q1, // 32-bit quotient\n    output wire [31:0] Q2, // 32-bit remainder\n    output wire [31:0] R  // 32-bit remainder\n);\n    reg [31:0] Q1_reg;\n    reg [31:0] Q2_reg;\n    reg [31:0] R_reg;\n\n    integer i;\n\n    always @(*) begin\n        Q1_reg = 0;\n        Q2_reg = 0;\n        R_reg = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (Q2_reg[15:0] == Q) begin\n                Q1_reg[i] = 1'b1;\n                Q2_reg[15:0] = Q2_reg[31:16];\n            end else begin\n                Q1_reg[i] = Q1_reg[i-1];\n                Q2_reg[15:0] = Q2_reg[31:16];\n            end\n        end\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (Q2_reg[15:0] == Q) begin\n                Q2_reg[i] = 1'b0;\n                Q2_reg[15:0] = Q2_reg[31:16];\n            end else begin\n                Q2_reg[i] = Q2_reg[i-1];\n                Q2_reg[15:0] = Q2_reg[31:16];\n            end\n        end\n\n        R_reg = Q2_reg;\n    end\n\n    assign Q1 = Q1_reg;\n    assign Q2 = Q2_reg;\n    assign R = R_reg;\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Shift dividend by 1 bit\n    wire [15:0] shifted_dividend = {A[14:0], 1'b0};\n\n    // Compare with divisor\n    wire [15:0] compare_result = shifted_dividend - B;\n\n    // Update quotient and remainder\n    always @(*) begin\n        if (compare_result[15]) begin\n            quotient = quotient << 1;\n            quotient[0] = 1'b1;\n        end else begin\n            quotient = quotient << 1;\n            quotient[0] = 1'b0;\n        end\n\n        remainder = compare_result;\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = (A[7] == B[7]) ? 0 : (A[7] ? 0 : 1);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [31:0] S1, S2;\nwire C_out;\n\nsub_16bit sub16_1(A[31:16], B[31:16], S1);\nsub_16bit sub16_2(A[15:0], B[15:0], S2);\n\nassign {C_out, Diff[31:16]} = S1 + S2 + ~B;\nassign Diff[15:0] = {C_out, S1[15:0] + S2[15:0] + ~B[15:0]};\nassign B_out = C_out;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff);\ninput [15:0] A, B;\noutput [15:0] Diff;\n\nwire C_out;\n\nsub_8bit sub8_1(A[15:8], B[15:8], Diff[15:8]);\nsub_8bit sub8_2(A[7:0], B[7:0], Diff[7:0]);\n\nassign {C_out, Diff[7:0]} = Diff[7:0] + ~B[7:0];\n\nendmodule\n\nmodule sub_8bit(A, B, Diff);\ninput [7:0] A, B;\noutput [7:0] Diff;\n\nwire C_out;\n\nsub_4bit sub4_1(A[7:4], B[7:4], Diff[7:4]);\nsub_4bit sub4_2(A[3:0], B[3:0], Diff[3:0]);\n\nassign {C_out, Diff[3:0]} = Diff[3:0] + ~B[3:0];\n\nendmodule\n\nmodule sub_4bit(A, B, Diff);\ninput [3:0] A, B;\noutput [3:0] Diff;\n\nwire C_out;\n\nsub_2bit sub2_1(A[3:2], B[3:2], Diff[3:2]);\nsub_2bit sub2_2(A[1:0], B[1:0], Diff[1:0]);\n\nassign {C_out, Diff[1:0]} = Diff[1:0] + ~B[1:0];\n\nendmodule\n\nmodule sub_2bit(A, B, Diff);\ninput [1:0] A, B;\noutput [1:0] Diff;\n\nwire C_out;\n\nsub_1bit sub1_1(A[1], B[1], Diff[1]);\nsub_1bit sub1_2(A[0], B[0], Diff[0]);\n\nassign {C_out, Diff[0]} = Diff[0] + ~B[0];\n\nendmodule\n\nmodule sub_1bit(A, B, Diff);\ninput A, B;\noutput Diff;\n\nassign Diff = A ^ B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] A0, A1, B0, B1, D0, D1, B_out0, B_out1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B_out0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B_out1);\n\nassign D = {D1, D0};\nassign B_out = {B_out1, B_out0};\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] A0, A1, B0, B1, D0, D1, B_out0, B_out1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B_out0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B_out1);\n\nassign D = {D1, D0};\nassign B_out = {B_out1, B_out0};\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] A0, A1, B0, B1, D0, D1, B_out0, B_out1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B_out0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B_out1);\n\nassign D = {D1, D0};\nassign B_out = {B_out1, B_out0};\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nassign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] a1, a2, a3, a4;\nwire [3:1] b1, b2, b3, b4;\nwire [4:1] d1, d2, d3, d4;\nwire [3:1] b_out1, b_out2, b_out3, b_out4;\nwire b_out;\n\nassign a1 = A[3:1];\nassign a2 = A[7:4];\nassign a3 = A[11:8];\nassign a4 = A[15:12];\n\nassign b1 = B[3:1];\nassign b2 = B[7:4];\nassign b3 = B[11:8];\nassign b4 = B[15:12];\n\nassign {b_out1, d1} = 4'b0000 - {a1, b1};\nassign {b_out2, d2} = 4'b0000 - {a2, b2};\nassign {b_out3, d3} = 4'b0000 - {a3, b3};\nassign {b_out4, d4} = 4'b0000 - {a4, b4};\n\nassign D = {d1, d2, d3, d4};\nassign B_out = b_out4[3];\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output carry\n);\n\nassign {carry, diff} = A - B;\n\nendmodule\n\n// Comparator module\nsubtractor_32bit sub_inst(A, B, diff, carry);\n\nassign A_greater = (diff != 0);\nassign A_equal = (A == B);\nassign A_less = (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[1:32] = A[1:32] ^ B[1:32];\nassign C32 = |(A[32:1] & B[32:1]);\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry_out;\n\n    assign {carry_out[3], sum[15:12]} = a[15:12] + b[15:12] + cin;\n    assign {carry_out[2], sum[11:8]} = a[11:8] + b[11:8] + carry_out[3];\n    assign {carry_out[1], sum[7:4]} = a[7:4] + b[7:4] + carry_out[2];\n    assign {carry_out[0], sum[3:0]} = a[3:0] + b[3:0] + carry_out[1];\n    assign cout = carry_out[0];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry_out;\n\n    assign {carry_out[3], sum[15:12]} = a[15:12] + b[15:12] + cin;\n    assign {carry_out[2], sum[11:8]} = a[11:8] + b[11:8] + carry_out[3];\n    assign {carry_out[1], sum[7:4]} = a[7:4] + b[7:4] + carry_out[2];\n    assign {carry_out[0], sum[3:0]} = a[3:0] + b[3:0] + carry_out[1];\n    assign cout = carry_out[0];\n\nendmodule\n"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co2;\n    \n    // 8-bit adder implementation\n    // Replace the placeholder with the proper implementation of the adder module.\n    // Note: The adder module should be defined before the adder_16bit module.\n    // Please refer to the sample code for the implementation.\n    // If the adder module is not defined, please define it accordingly.\n    // adder is a placeholder. Please define the correct module or replace it with the proper implementation.\n    // Placeholder code\n    assign y = 0;\n    assign Co = 0;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] carry;\n    wire [6:0] s;\n    \n    // 8-bit adder\n    assign {cout, s} = a + b + cin;\n    assign sum = s[6:0];\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nwire ctrl_en;\nreg [3:0] shift_cnt;\nreg [31:0] prod_reg;\nreg [31:0] a_reg;\nreg [31:0] b_reg;\n\nassign ctrl_en = start | (shift_cnt != 4'b0);\nassign yout = prod_reg;\nassign done = shift_cnt == 4'b1000;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0;\n        prod_reg <= 32'b0;\n        a_reg <= 32'b0;\n        b_reg <= 32'b0;\n    end else if (ctrl_en) begin\n        shift_cnt <= shift_cnt + 1'b1;\n        prod_reg <= prod_reg + (a_reg & b_reg);\n        if (shift_cnt == 4'b1000) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end else begin\n            a_reg <= {a_reg[30:0], 1'b0};\n            b_reg <= {b_reg[30:0], b_reg[31]};\n        end\n    end\nend\n\n// Register Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 32'b0;\n        b_reg <= 32'b0;\n    end else if (ctrl_en) begin\n        a_reg <= ain;\n        b_reg <= bin;\n    end\nend\n\n// Multiplier Unit.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        prod_reg <= 32'b0;\n    end else if (ctrl_en) begin\n        prod_reg <= prod_reg + (a_reg & b_reg);\n    end\nend\n\nendmodule\n"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] count_next;\nwire [15:0] count_reg;\n\nassign count = count_reg;\n\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count_next)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count_next),\n    .count_out(count_reg)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\nreg [15:0] count_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_reg <= 16'd0;\n    end else begin\n        if (up_down) begin\n            count_reg <= count_reg + 16'd1;\n        end else begin\n            count_reg <= count_reg - 16'd1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_out <= 16'd0;\n    end else begin\n        count_out <= count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] init_state;\n    wire [7:0] transition_state;\n\n    // Implement the submodules\n    // ...\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] counter_logic_out;\nwire [3:0] output_register_out;\n\ncounter_logic counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .out(counter_logic_out)\n);\n\noutput_register output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .out(counter_logic_out),\n    .out_r(output_register_out)\n);\n\nassign out = output_register_out;\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        count <= count + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] out,\n    output [3:0] out_r\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= out;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    // Submodule instances\n    wire [63:0] Q_reg;\n    wire [63:0] Q_logic;\n\n    // Register instance\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_reg)\n    );\n\n    // Logic instance\n    JC_logic logic_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q_reg(Q_reg),\n        .Q_logic(Q_logic)\n    );\n\n    // Output\n    assign Q = Q_logic;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q,\n    input [63:0]        Q_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= Q_reg;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q_reg,\n    output [63:0]       Q_logic,\n    output [63:0]       Q\n);\n\n    assign Q_logic = Q_reg ^ {Q_reg[63], Q_reg[62:0]};\n    assign Q = Q_logic[0];\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_div_2_out, clk_div_10_out, clk_div_100_out;\n\n    clk_div_2 clk_div_2_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div_2_out)\n    );\n\n    clk_div_10 clk_div_10_inst (\n        .CLK_in(clk_div_2_out),\n        .RST(RST),\n        .CLK_out(clk_div_10_out)\n    );\n\n    clk_div_100 clk_div_100_inst (\n        .CLK_in(clk_div_10_out),\n        .RST(RST),\n        .CLK_out(clk_div_100_out)\n    );\n\n    assign CLK_50 = clk_div_2_out;\n    assign CLK_10 = clk_div_10_out;\n    assign CLK_1 = clk_div_100_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 0;\n        else if (count == 1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\n\n    assign CLK_out = (count == 1) ? 1'b0 : 1'b1;\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 4'b0000;\n        else if (count == 4'b1001)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\n\n    assign CLK_out = (count == 4'b0001) ? 1'b0 : 1'b1;\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            count <= 7'b1000000;\n        else if (count == 7'b1100011)\n            count <= 7'b1000000;\n        else\n            count <= count + 1;\n    end\n\n    assign CLK_out = (count == 7'b1100010) ? 1'b0 : 1'b1;\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter\n    MUL2_DIV_CLK = 7;  // Divide clock frequency by 3.5\n\n// Counter submodule\nreg [15:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == MUL2_DIV_CLK)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Clock average generator submodule\nreg [2:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else begin\n        clk_average[0] <= counter[0];\n        clk_average[1] <= clk_average[0];\n        clk_average[2] <= clk_average[1];\n    end\nend\n\n// Clock adjustment submodule\nreg [2:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= 0;\n    else begin\n        clk_adjustment[0] <= counter[0];\n        clk_adjustment[1] <= clk_adjustment[0];\n        clk_adjustment[2] <= clk_adjustment[1];\n    end\nend\n\n// Final clock output\nreg clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div_reg <= 0;\n    else\n        clk_div_reg <= clk_average[0] | clk_adjustment[1];\nend\n\nassign clk_div = clk_div_reg;\n\nendmodule\n\n\n\n\n\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] count_pos;\nreg [3:0] count_neg;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_pos <= 0;\n        count_neg <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else if (count_pos == NUM_DIV - 1) begin\n        count_pos <= 0;\n        clk_div1 <= 1;\n    end else begin\n        count_pos <= count_pos + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_neg <= 0;\n        clk_div2 <= 0;\n    end else if (count_neg == NUM_DIV - 1) begin\n        count_neg <= 0;\n        clk_div2 <= 1;\n    end else begin\n        count_neg <= count_neg + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div = counter[3] ^ counter[2];\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r;\nwire [31:0] sllv_r, srlv_r, srav_r, srau_r;\nwire [31:0] l_r;\n\nwire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero;\nwire [31:0] sllv_zero, srlv_zero, srav_zero, srau_zero, l_zero;\nwire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry;\nwire [31:0] sllv_carry, srlv_carry, srav_carry, srau_carry, l_carry;\nwire [31:0] add_neg, sub_neg, and_neg, or_neg, xor_neg, nor_neg, slt_neg, sltu_neg, sll_neg, srl_neg, sra_neg;\nwire [31:0] sllv_neg, srlv_neg, srav_neg, srau_neg, l_neg;\nwire [31:0] add_ov, sub_ov, and_ov, or_ov, xor_ov, nor_ov, slt_ov, sltu_ov, sll_ov, srl_ov, sra_ov;\nwire [31:0] sllv_ov, srlv_ov, srav_ov, srau_ov, l_ov;\nwire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag;\nwire [31:0] sllv_flag, srlv_flag, srav_flag, srau_flag, l_flag;\n\nwire [31:0] l_lui_r;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [31:0] u_multiplier_out;\n    wire [31:0] u_accumulator_out;\n\n    // Implementing the multiplier submodule here\n    // ...\n\n    // Implementing the accumulator submodule here\n    // ...\n\n    // Connecting the submodules\n    assign c = u_accumulator_out;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n    wire [1:0] fetch1, fetch2;\n\n    assign fetch1 = fetch;\n    assign fetch2 = 2'b0;\n\n    // submodules\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch1),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch2),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // output\n    assign ins = {ins1[2], ins2[2], ins2[1]};\n    assign ad1 = {ad11[4], ad12[4], ad12[3:2]};\n    assign ad2 = {ad21, ad22};\nendmodule\n\n// submodule\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            case (fetch)\n                2'b01: begin\n                    ins_reg <= data[7:5];\n                    ad1_reg <= data[4:0];\n                    ad2_reg <= data;\n                end\n                2'b10: begin\n                    ins_reg <= data[7:5];\n                    ad1_reg <= data[4:0];\n                    ad2_reg <= data;\n                end\n                default: begin\n                    ins_reg <= ins_reg;\n                    ad1_reg <= ad1_reg;\n                    ad2_reg <= ad2_reg;\n                end\n            endcase\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n// Counter Module\nwire [7:0] count;\nreg [7:0] count_next;\nreg enable;\n\nalways @(posedge clk)\nbegin\n    if (count == (freq - 1))\n        count_next <= 0;\n    else\n        count_next <= count + 1;\nend\n\nassign count = enable ? count_next : 0;\n\n// Wave Generator Module\nreg wave_out_next;\n\nalways @(posedge clk)\nbegin\n    wave_out_next <= ~(count == (freq - 1));\nend\n\nassign wave_out = wave_out_next;\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state_reg, state_next;\n    reg [4:0] wave_reg, wave_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            state_reg <= state_next;\n            wave_reg <= wave_next;\n        end\n    end\n\n    always @(*) begin\n        state_next = state_reg;\n        wave_next = wave_reg;\n\n        case (state_reg)\n            2'b00: begin\n                if (wave_reg == 5'b00000) begin\n                    state_next = 2'b01;\n                end else begin\n                    wave_next = wave_reg + 1;\n                end\n            end\n            2'b01: begin\n                if (wave_reg == 5'b11111) begin\n                    state_next = 2'b10;\n                end else begin\n                    wave_next = wave_reg - 1;\n                end\n            end\n            2'b10: begin\n                if (wave_reg == 5'b00000) begin\n                    state_next = 2'b00;\n                end else begin\n                    wave_next = wave_reg + 1;\n                end\n            end\n        endcase\n    end\n\n    assign wave = wave_reg;\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [0:2];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= (sel[1]) ?\n                (sel[0]) ? shift_reg[2] : shift_reg[1] :\n                shift_reg[2];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    my_dff8 u0 (.clk(clk), .d(d), .q(q));\n    my_dff8 u1 (.clk(clk), .d(q), .q(q));\n    my_dff8 u2 (.clk(clk), .d(q), .q(q));\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    reg q0, q1, q2;\n\n    always @(posedge clk) begin\n        q0 <= d;\n        q1 <= q0;\n        q2 <= q1;\n    end\n\n    assign q = q2;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\ninput [7:0] in;\ninput [2:0] ctrl;\noutput reg [7:0] out;\n\nwire [7:0] stage1, stage2, stage3;\n\n// Stage 1\nmux2X1 mux11 (stage1, in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0], ctrl[2], ctrl[1], ctrl[0]);\nassign stage2 = stage1 >> ctrl[2];\nassign stage3 = stage1 >> ctrl[1];\n\n// Stage 2\nmux2X1 mux21 (stage1, stage2[7], stage2[6], stage2[5], stage2[4], stage2[3], stage2[2], stage2[1], stage2[0], ctrl[2], ctrl[1], ctrl[0]);\nassign stage2 = stage1 >> ctrl[2];\nassign stage3 = stage1 >> ctrl[1];\n\n// Stage 3\nmux2X1 mux31 (stage1, stage2[7], stage2[6], stage2[5], stage2[4], stage2[3], stage2[2], stage2[1], stage2[0], ctrl[2], ctrl[1], ctrl[0]);\nassign stage2 = stage1 >> ctrl[2];\nassign stage3 = stage1 >> ctrl[1];\n\nassign out = stage3;\n\nendmodule\n\nmodule mux2X1 (out, in0, in1, sel);\ninput in0, in1, sel;\noutput reg out;\nalways @(*) begin\n    if (sel)\n        out = in1;\n    else\n        out = in0;\nend\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] c0_reg, c1_reg;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n    end else begin\n      b1 <= b0;\n      c0_reg <= a0 + b0;\n      c1_reg <= a1 + b1;\n    end\n  end\n  \n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  reg [31:0] next_pc;\n  reg [31:0] res;\n\n  stagepipe5_fetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n\n  stagepipe5_decode_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem[pc]),\n    .reg_file(reg_file),\n    .rs1(decode_stage.rs1),\n    .rs2(decode_stage.rs2),\n    .rd(decode_stage.rd),\n    .op(decode_stage.op)\n  );\n\n  stagepipe5_execute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .op(decode_stage.op),\n    .rs1(reg_file[decode_stage.rs1]),\n    .rs2(reg_file[decode_stage.rs2]),\n    .res(res)\n  );\n\n  stagepipe5_memory_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .res(res),\n    .next_pc(next_pc)\n  );\n\n  stagepipe5_writeback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .res(res),\n    .rd(decode_stage.rd),\n    .res_reg_file(res_reg_file)\n  );\nendmodule\n\nmodule stagepipe5_fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc\n);\n  reg [31:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 32'd0;\n    else\n      pc_reg <= next_pc;\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = pc_reg + 32'd4;\nendmodule\n\nmodule stagepipe5_decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem,\n  input [31:0] reg_file [0:31],\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      instr_reg <= 32'd0;\n    else\n      instr_reg <= instr_mem;\n  end\n\n  assign {op, rs2, rs1, rd} = instr_reg;\nendmodule\n\nmodule stagepipe5_execute_stage(\n  input clk,\n  input rst,\n  input [5:0] op,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  output [31:0] res\n);\n  reg [31:0] res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      res_reg <= 32'd0;\n    else\n      res_reg <= op == 6'b000000 ? rs1 + rs2 : rs1 - rs2;\n  end\n\n  assign res = res_reg;\nendmodule\n\nmodule stagepipe5_memory_stage(\n  input clk,\n  input rst,\n  input [31:0] res,\n  output [31:0] next_pc\n);\n  reg [31:0] next_pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if ("}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [3:0] delay;\n  \n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 16'd0;\n      b2 <= 16'd0;\n      b3 <= 16'd0;\n      c0_reg <= 32'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n      delay <= 4'd0;\n    end else begin\n      delay <= delay + 1;\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      if(delay == 4'd1) begin\n        c0_reg <= {a0, 16'd0} * b0;\n        c1_reg <= {a1, 16'd0} * b1;\n        c2_reg <= {a2, 16'd0} * b2;\n        c3_reg <= {a3, 16'd0} * b3;\n      end\n    end\n  end\n  \n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n  \nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] pc = 32'b0;\n\n    wire [31:0] instr = instr_mem[pc];\n    wire [5:0] opcode = instr[31:26];\n    wire [5:0] rs = instr[25:21];\n    wire [5:0] rt = instr[20:16];\n    wire [5:0] rd = instr[15:11];\n    wire [5:0] sa = instr[10:6];\n    wire [5:0] sb = instr[5:1];\n    wire [31:0] imm = instr[5:0];\n    wire [31:0] a = reg_file[rs];\n    wire [31:0] b = reg_file[rt];\n    wire [31:0] add_sub_out;\n\n    assign out_reg_file = reg_file[rd];\n\n    assign add_sub_out = opcode == 6'b000000 ? a + b : a - b;\n\n    assign reg_file[rd] = add_sub_out;\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//------------------------------------------------\n// Serial input data accumulator\n//------------------------------------------------\n\n// Counter Module\nreg [2:0] cnt_reg, cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt_reg <= 0;\n    else cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        0: cnt_next = valid_in ? 1 : 0;\n        1: cnt_next = valid_in ? 2 : 0;\n        2: cnt_next = valid_in ? 3 : 0;\n        3: cnt_next = valid_in ? 4 : 0;\n        4: cnt_next = 0;\n        default: cnt_next = 0;\n    endcase\nend\n\n// Data Accumulator Module\nreg [9:0] data_acc_reg, data_acc_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) data_acc_reg <= 0;\n    else data_acc_reg <= data_acc_next;\nend\n\nalways @(*) begin\n    data_acc_next = (cnt_reg == 0) ? data_in : data_acc_reg + data_in;\nend\n\n// Valid Output Module\nreg valid_out_reg, valid_out_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) valid_out_reg <= 1'b0;\n    else valid_out_reg <= valid_out_next;\nend\n\nalways @(*) begin\n    valid_out_next = (cnt_reg == 4) ? 1'b1 : 1'b0;\nend\n\nendmodule\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output              count_out\n);\n\nreg [2:0] cnt_reg, cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) cnt_reg <= 0;\n    else cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        0: cnt_next = valid_in ? 1 : 0;\n        1: cnt_next = valid_in ? 2 : 0;\n        2: cnt_next = valid_in ? 3 : 0;\n        3: cnt_next = valid_in ? 4 : 0;\n        4: cnt_next = 0;\n        default: cnt_next = 0;\n    endcase\nend\n\nassign count_out = cnt_reg;\nassign valid_out = (cnt_reg == 4) ? 1'b1 : 1'b0;\n\nendmodule\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg [9:0] data_acc_reg, data_acc_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) data_acc_reg <= 0;\n    else data_acc_reg <= data_acc_next;\nend\n\nalways @(*) begin\n    data_acc_next = (cnt_reg == 0) ? data_in : data_acc_reg + data_in;\nend\n\nassign data_out = data_acc_reg;\nassign valid_out = (cnt_reg == 4) ? 1'b1 : 1'b0;\n\nendmodule\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\n\nmodule u_valid_output (\n    input               clk,\n   "}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [15:0] abs_dividend;\nwire [15:0] neg_divisor;\nwire [15:0] remainder;\nwire [3:0] counter;\nwire [3:0] shift_reg;\nwire [3:0] shift_reg_next;\nwire [3:0] counter_next;\nwire [3:0] quotient;\nwire [3:0] quotient_next;\n\nassign abs_dividend = (sign) ? {8'b0, dividend} : dividend;\nassign neg_divisor = (sign) ? {8'b0, divisor} : {8'b11111111, ~divisor};\n\nassign result = remainder;\n\n// abs_dividend submodule\nwire [15:0] abs_dividend_result;\n\nassign abs_dividend_result = (sign) ? {8'b0, dividend} : dividend;\n\n// neg_divisor_mod submodule\nwire [15:0] neg_divisor_result;\n\nassign neg_divisor_result = (sign) ? {8'b0, divisor} : {8'b11111111, ~divisor};\n\n// ctrl submodule\nwire [15:0] ctrl_result;\n\nassign ctrl_result = {8'b0, abs_dividend_result} + {8'b0, neg_divisor_result};\n\n// res_mgmt submodule\nwire [15:0] res_mgmt_result;\n\nassign res_mgmt_result = ctrl_result;\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend_prep;\n    wire [31:0] divisor_prep;\n\n    // Prepare dividend and divisor for division\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .result(dividend_prep),\n        .odd(divisor_prep)\n    );\n\n    // Divide dividend by divisor\n    div_op div_op (\n        .A(dividend_prep),\n        .B(divisor_prep),\n        .result(result),\n        .odd(odd)\n    );\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Prepare dividend and divisor for division\n    assign result = {32'b0, A[31:16]} / {32'b0, B};\n    assign odd = {32'b0, A[31:16]} % {32'b0, B};\nendmodule\n\nmodule div_op(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Divide dividend by divisor\n    assign result = {32'b0, A[31:16]} / {32'b0, B};\n    assign odd = {32'b0, A[31:16]} % {32'b0, B};\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Divide A by B\n    reg [15:0] dividend = A;\n    reg [7:0] divisor = B;\n    reg [15:0] quotient = 0;\n    reg [15:0] remainder = 0;\n    reg [15:0] tmp;\n    reg [3:0] count = 0;\n\n    always @(*) begin\n        // Shift dividend\n        tmp = dividend >> 1;\n        dividend = {dividend[14:0], 1'b0};\n\n        // Check divisibility\n        if (dividend >= divisor) begin\n            // Add divisor to quotient\n            quotient = quotient + {1'b0, divisor};\n\n            // Subtract divisor from dividend\n            dividend = dividend - divisor;\n\n            // Shift remainder\n            remainder = remainder >> 1;\n            remainder = {remainder[14:0], 1'b0};\n\n            // Shift tmp\n            tmp = tmp >> 1;\n            tmp = {tmp[14:0], 1'b0};\n        end\n\n        // Count loop\n        count = count + 1;\n        if (count == 15) begin\n            // Final count\n            remainder = dividend;\n        end\n    end\n\n    // Outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A;\ninput [7:0] B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire carry;\n\nassign B_comp = ~B + 1;\n\nassign {carry, sum} = A + B_comp;\nassign D = sum;\nassign B_out = carry;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff[31:16] = B[31:16] - A[31:16];\nassign B_out = (B[31:16] < A[31:16]);\n\nassign Diff[15:0] = B[15:0] - A[15:0] - B_out;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] D1;\nwire [63:0] D2;\nwire [63:0] D3;\nwire [63:0] D4;\nwire [63:0] D5;\nwire [63:0] D6;\nwire [63:0] D7;\nwire [63:0] D8;\nwire B1;\nwire B2;\nwire B3;\nwire B4;\nwire B5;\nwire B6;\nwire B7;\nwire B8;\nwire B_out;\n\nsub_32bit u1(A[63:32], B[63:32], D1, B1);\nsub_32bit u2(A[31:0], B[31:0], D2, B2);\nsub_16bit u3(D1[63:48], D2[63:48], D3, B3);\nsub_16bit u4(D1[47:32], D2[47:32], D4, B4);\nsub_8bit u5(D3[63:48], D4[63:48], D5, B5);\nsub_8bit u6(D3[47:32], D4[47:32], D6, B6);\nsub_8bit u7(D5[63:48], D6[63:48], D7, B7);\nsub_8bit u8(D5[47:32], D6[47:32], D8, B8);\n\nassign D = {D7[31:0], D8[31:0]};\nassign B_out = B7;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A;\ninput [31:0] B;\noutput [31:0] D;\noutput B_out;\n\nwire [31:0] D1;\nwire [31:0] D2;\nwire [31:0] D3;\nwire [31:0] D4;\nwire [31:0] D5;\nwire B1;\nwire B2;\nwire B3;\nwire B4;\nwire B_out;\n\nsub_16bit u1(A[31:16], B[31:16], D1, B1);\nsub_16bit u2(A[15:0], B[15:0], D2, B2);\nsub_8bit u3(D1[31:16], D2[31:16], D3, B3);\nsub_8bit u4(D1[15:0], D2[15:0], D4, B4);\nsub_8bit u5(D3[31:16], D4[31:16], D5, B5);\n\nassign D = D5;\nassign B_out = B5;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A;\ninput [15:0] B;\noutput [15:0] D;\noutput B_out;\n\nwire [15:0] D1;\nwire [15:0] D2;\nwire [15:0] D3;\nwire [15:0] D4;\nwire [15:0] D5;\nwire B1;\nwire B2;\nwire B3;\nwire B4;\nwire B_out;\n\nsub_8bit u1(A[15:8], B[15:8], D1, B1);\nsub_8bit u2(A[7:0], B[7:0], D2, B2);\nsub_8bit u3(D1[15:8], D2[15:8], D3, B3);\nsub_8bit u4(D1[7:0], D2[7:0], D4, B4"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [4:1] A_s, B_s, D_s;\nwire B_out_s;\n\n// 4-bit full subtractor\nsub_4bit sub4_0(.A(A[4:1]), .B(B[4:1]), .D(D_s[4:1]), .B_out(B_out_s));\nsub_4bit sub4_1(.A(A[8:5]), .B(B[8:5]), .D(D_s[8:5]), .B_out(B_out_s));\nsub_4bit sub4_2(.A(A[12:9]), .B(B[12:9]), .D(D_s[12:9]), .B_out(B_out_s));\nsub_4bit sub4_3(.A(A[16:13]), .B(B[16:13]), .D(D_s[16:13]), .B_out(B_out_s));\n\nassign D[16:1] = {D_s[16:13], D_s[8:5], D_s[4:1]};\nassign B_out = B_out_s;\n\nendmodule\n\n// sub_4bit\nmodule sub_4bit(A, B, D, B_out);\ninput [4:1] A, B;\noutput [4:1] D;\noutput B_out;\n\nwire [2:1] A_s, B_s, D_s;\nwire B_out_s;\n\n// 2-bit full subtractor\nsub_2bit sub2_0(.A(A[2:1]), .B(B[2:1]), .D(D_s[2:1]), .B_out(B_out_s));\nsub_2bit sub2_1(.A(A[4:3]), .B(B[4:3]), .D(D_s[4:3]), .B_out(B_out_s));\n\nassign D[4:1] = {D_s[4:3], D_s[2:1]};\nassign B_out = B_out_s;\n\nendmodule\n\n// sub_2bit\nmodule sub_2bit(A, B, D, B_out);\ninput [2:1] A, B;\noutput [2:1] D;\noutput B_out;\n\nwire [1:1] A_s, B_s, D_s;\nwire B_out_s;\n\n// 1-bit full subtractor\nsub_1bit sub1_0(.A(A[1:1]), .B(B[1:1]), .D(D_s[1:1]), .B_out(B_out_s));\n\nassign D[2:1] = {D_s[1:1], D_s[1:1]};\nassign B_out = B_out_s;\n\nendmodule\n\n// sub_1bit\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] subtraction_result;\n    wire borrow;\n\n    assign {borrow, subtraction_result} = A - B;\n    assign A_greater = ~borrow & subtraction_result;\n    assign A_equal = ~borrow & ~subtraction_result;\n    assign A_less = borrow;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    \n    wire [16:1] C16;\n    \n    CLA16 CLA1(.A(A[16:1]), .B(B[16:1]), .S(S[16:1]), .C32(C16[1]));\n    CLA16 CLA2(.A(A[32:17]), .B(B[32:17]), .S(S[32:17]), .C32(C16[2]));\n    \n    assign C32 = C16[1] | C16[2];\nendmodule\n\nmodule CLA16(A,B,S,C32);\n    input [16:1] A,B;\n    output [16:1] S;\n    output C32;\n    \n    wire [8:1] C8;\n    \n    CLA8 CLA1(.A(A[8:1]), .B(B[8:1]), .S(S[8:1]), .C32(C8[1]));\n    CLA8 CLA2(.A(A[16:9]), .B(B[16:9]), .S(S[16:9]), .C32(C8[2]));\n    \n    assign C32 = C8[1] | C8[2];\nendmodule\n\nmodule CLA8(A,B,S,C32);\n    input [8:1] A,B;\n    output [8:1] S;\n    output C32;\n    \n    wire [4:1] C4;\n    \n    CLA4 CLA1(.A(A[4:1]), .B(B[4:1]), .S(S[4:1]), .C32(C4[1]));\n    CLA4 CLA2(.A(A[8:5]), .B(B[8:5]), .S(S[8:5]), .C32(C4[2]));\n    \n    assign C32 = C4[1] | C4[2];\nendmodule\n\nmodule CLA4(A,B,S,C32);\n    input [4:1] A,B;\n    output [4:1] S;\n    output C32;\n    \n    wire [2:1] C2;\n    \n    CLA2 CLA1(.A(A[2:1]), .B(B[2:1]), .S(S[2:1]), .C32(C2[1]));\n    CLA2 CLA2(.A(A[4:3]), .B(B[4:3]), .S(S[4:3]), .C32(C2[2]));\n    \n    assign C32 = C2[1] | C2[2];\nendmodule\n\nmodule CLA2(A,B,S,C32);\n    input [2:1] A,B;\n    output [2:1] S;\n    output C32;\n    \n    wire [1:1] C1;\n    \n    CLA1 CLA1(.A(A[1:1]), .B(B[1:1]), .S(S[1:1]), .C32(C1[1]));\n    CLA1 CLA2(.A(A[2:2]), .B(B[2:2]), .S(S[2:2]), .C32(C1[2]));\n    \n    assign C32 = C1[1] | C1[2];\nendmodule\n\nmodule CLA1(A,B,S,C32);\n    input [1:1] A,B;\n    output [1:1] S;\n    output C32;\n    \n    assign S = A ^ B;\n    assign C32 = A & B;\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [15:0] sum1, sum2;\n    wire [3:0] cout1, cout2;\n\n    // Ripple carry adder for the first 4 bits\n    assign {cout1[0], sum1[0]} = a[0] + b[0] + cin;\n    assign {cout1[1], sum1[1]} = a[1] + b[1] + cout1[0];\n    assign {cout1[2], sum1[2]} = a[2] + b[2] + cout1[1];\n    assign {cout1[3], sum1[3]} = a[3] + b[3] + cout1[2];\n\n    // Ripple carry adder for the second 4 bits\n    assign {cout2[0], sum2[0]} = a[4] + b[4] + cout1[3];\n    assign {cout2[1], sum2[1]} = a[5] + b[5] + cout2[0];\n    assign {cout2[2], sum2[2]} = a[6] + b[6] + cout2[1];\n    assign {cout2[3], sum2[3]} = a[7] + b[7] + cout2[2];\n\n    // Carry select adder for the next 4 bits\n    assign {cout1[0], sum1[4]} = a[4] + b[4] + cout1[3];\n    assign {cout1[1], sum1[5]} = a[5] + b[5] + cout1[0];\n    assign {cout1[2], sum1[6]} = a[6] + b[6] + cout1[1];\n    assign {cout1[3], sum1[7]} = a[7] + b[7] + cout1[2];\n\n    // Carry select adder for the last 4 bits\n    assign {cout2[0], sum2[4]} = a[8] + b[8] + cout1[3];\n    assign {cout2[1], sum2[5]} = a[9] + b[9] + cout2[0];\n    assign {cout2[2], sum2[6]} = a[10] + b[10] + cout2[1];\n    assign {cout2[3], sum2[7]} = a[11] + b[11] + cout2[2];\n\n    // Carry select adder for the last 4 bits\n    assign {cout1[0], sum1[8]} = a[12] + b[12] + cout1[3];\n    assign {cout1[1], sum1[9]} = a[13] + b[13] + cout1[0];\n    assign {cout1[2], sum1[10]} = a[14] + b[14] + cout1[1];\n    assign {cout1[3], sum1[11]} = a[15] + b[15] + cout1[2];\n\n    // Carry select adder for the last 4 bits\n    assign {cout2[0], sum2[8]} = a[12] + b[12] + cout1[3];\n    assign {cout2[1], sum2[9]} = a[13] + b[13] + cout2[0];\n    assign {cout2[2], sum2[10]} = a[14] + b[14] + cout2[1];\n    assign {cout2[3], sum2[11]} = a[15] + b[15] + cout2[2];\n\n    // Carry select adder for the last 4 bits\n    assign {cout1[0], sum1[12]} = a[12] + b[12] + cout1[3];\n    assign {cout1[1], sum1[13]} = a[13] + b[13] + cout1[0];\n    assign {cout1[2], sum1[14]} = a[14] + b[14] + cout1[1];\n    assign {cout1[3], sum1[1"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire Co1, Co2, Co3, Co4, Co5, Co6, Co7, Co8;\n\n    // 8-bit adder implementation\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n    // Replace the instantiation with the adder module definition\n\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire c1, c2, c3;\n    \n    assign {c1, sum[0]} = a[0] + b[0] + cin;\n    assign {c2, sum[1]} = a[1] + b[1] + c1;\n    assign {c3, sum[2]} = a[2] + b[2] + c2;\n    assign {sum[3], c1} = a[3] + b[3] + c3;\n    assign {sum[4], c2} = a[4] + b[4] + c1;\n    assign {sum[5], c3} = a[5] + b[5] + c2;\n    assign {sum[6], c1} = a[6] + b[6] + c3;\n    assign {sum[7], cout} = a[7] + b[7] + c1;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [15:0] shift_cnt;\nreg [31:0] product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 16'd0;\n        product <= 32'd0;\n    end else if (start) begin\n        shift_cnt <= 16'd16;\n        product <= 32'd0;\n    end else if (shift_cnt != 16'd0) begin\n        shift_cnt <= shift_cnt - 16'd1;\n    end\nend\n\n// Register Unit\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Multiplier Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n    end else if (shift_cnt != 16'd0) begin\n        product <= product + (reg_b << (shift_cnt - 1));\n    end else begin\n        product <= reg_a * reg_b;\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = (shift_cnt == 16'd0) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n// Submodules\nu_counter_logic u_counter_logic_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\nu_counter_register u_counter_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0000000000000000;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0000000000000000;\n    end else begin\n        count <= count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    reg [7:0] out_reg;\n    reg [2:0] state_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n            state_reg <= 3'b000;\n        end else begin\n            case (state_reg)\n                3'b000: begin\n                    out_reg <= 8'b0000_0001;\n                    state_reg <= 3'b001;\n                end\n                3'b001: begin\n                    out_reg <= 8'b0000_0010;\n                    state_reg <= 3'b010;\n                end\n                3'b010: begin\n                    out_reg <= 8'b0000_0100;\n                    state_reg <= 3'b011;\n                end\n                3'b011: begin\n                    out_reg <= 8'b0000_1000;\n                    state_reg <= 3'b100;\n                end\n                3'b100: begin\n                    out_reg <= 8'b0001_0000;\n                    state_reg <= 3'b101;\n                end\n                3'b101: begin\n                    out_reg <= 8'b0010_0000;\n                    state_reg <= 3'b110;\n                end\n                3'b110: begin\n                    out_reg <= 8'b0100_0000;\n                    state_reg <= 3'b111;\n                end\n                3'b111: begin\n                    out_reg <= 8'b1000_0000;\n                    state_reg <= 3'b000;\n                end\n                default: begin\n                    out_reg <= 8'b0000_0000;\n                    state_reg <= 3'b000;\n                end\n            endcase\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule submodule_init (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out_reg,\n    output wire [7:0] out\n);\n\n    reg [7:0] out_reg_init;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg_init <= 8'b0000_0001;\n        end else begin\n            out_reg_init <= out_reg;\n        end\n    end\n\n    assign out = out_reg_init;\n\nendmodule\n\nmodule submodule_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out_reg,\n    output wire [7:0] out\n);\n\n    reg [7:0] out_reg_transition;\n    reg [2:0] state_reg_transition;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg_transition <= 8'b0000_0001;\n            state_reg_transition <= 3'b000;\n        end else begin\n            case (state_reg_transition)\n                3'b000: begin\n                    out_reg_transition <= 8'b0000_0001;\n                    state_reg_transition <= 3'b001;\n                end\n                3'b001: begin\n                    out_reg_transition <= 8'b0000_0010;\n                    state_reg_transition <= 3'b010;\n                end\n                3'b010: begin\n                    out_reg_transition <= 8'b0000_0100;\n                    state_reg_transition <= 3'b011;\n                end\n                3'b011: begin\n                    out"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    reg [3:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= count + 1;\n    end\n    \n    assign out = count;\nendmodule\n\nmodule\nmodule counter_logic (\n    input clk,\n    input rst_n,\n    input valid_count,\n    output [3:0] out\n);\n    reg [3:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= count + 1;\n    end\n    \n    assign out = count;\nendmodule\n\nmodule\nmodule output_register (\n    input clk,\n    input rst_n,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= in;\n    end\nendmodule\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule declaration\nJC_register  reg_inst  (.clk(clk), .rst_n(rst_n), .Q(Q));\nJC_logic     logic_inst  (.Q(Q), .next_Q(Q));\n\nendmodule\n\nmodule JC_register (\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'h0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule\n\nmodule JC_logic (\n    input [63:0]       Q,\n    output [63:0]      next_Q\n);\n\nreg [63:0]   next_Q;\n\nalways @(*) begin\n    next_Q[63] = Q[0];\n    next_Q[62:0] = Q[62:0];\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg clk_div_2 = 0;\nreg clk_div_10 = 0;\nreg clk_div_100 = 0;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2 <= 0;\n        clk_div_10 <= 0;\n        clk_div_100 <= 0;\n    end else begin\n        clk_div_2 <= ~clk_div_2;\n        clk_div_10 <= ~clk_div_10;\n        clk_div_100 <= ~clk_div_100;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [1:0] clk_div_counter;\nreg  [3:0] clk_div_counter_r;\n\nwire clk_div_counter_zero;\nwire clk_div_counter_one;\nwire clk_div_counter_two;\nwire clk_div_counter_three;\nwire clk_div_counter_four;\n\nwire clk_div_counter_five;\nwire clk_div_counter_six;\nwire clk_div_counter_seven;\nwire clk_div_counter_eight;\n\nwire clk_div_counter_nine;\nwire clk_div_counter_ten;\nwire clk_div_counter_eleven;\nwire clk_div_counter_twelve;\n\nwire clk_div_counter_thirteen;\nwire clk_div_counter_fourteen;\nwire clk_div_counter_fifteen;\nwire clk_div_counter_sixteen;\n\nwire [1:0] clk_div_counter_shifted;\n\nwire clk_div_counter_zero_xor;\nwire clk_div_counter_one_xor;\nwire clk_div_counter_two_xor;\nwire clk_div_counter_three_xor;\nwire clk_div_counter_four_xor;\n\nwire clk_div_counter_five_xor;\nwire clk_div_counter_six_xor;\nwire clk_div_counter_seven_xor;\nwire clk_div_counter_eight_xor;\n\nwire clk_div_counter_nine_xor;\nwire clk_div_counter_ten_xor;\nwire clk_div_counter_eleven_xor;\nwire clk_div_counter_twelve_xor;\n\nwire clk_div_counter_thirteen_xor;\nwire clk_div_counter_fourteen_xor;\nwire clk_div_counter_fifteen_xor;\nwire clk_div_counter_sixteen_xor;\n\nwire [1:0] clk_div_counter_xor;\n\nreg [1:0] clk_div_counter_xor_r;\n\nwire clk_div_counter_xor_zero;\nwire clk_div_counter_xor_one;\n\nwire clk_div_counter_xor_two;\nwire clk_div_counter_xor_three;\nwire clk_div_counter_xor_four;\n\nwire clk_div_counter_xor_five;\nwire clk_div_counter_xor_six;\nwire clk_div_counter_xor_seven;\nwire clk_div_counter_xor_eight;\n\nwire clk_div_counter_xor_nine;\nwire clk_div_counter_xor_ten;\nwire clk_div_counter_xor_eleven;\nwire clk_div_counter_xor_twelve;\n\nwire clk_div_counter_xor_thirteen;\nwire clk_div_counter_xor_fourteen;\nwire clk_div_counter_xor_fifteen;\nwire clk_div_counter_xor_sixteen;\n\nwire clk_div_counter_xor_rst_n;\n\nreg clk_div;\n\n// Counter Submodule\n\nassign clk_div_counter_zero = clk_div_counter == 4'd0;\nassign clk_div_counter_one = clk_div_counter == 4'd1;\nassign clk_div_counter_two = clk_div_counter == 4'd2;\nassign clk_div_counter_three = clk_div_counter == 4'd3;\nassign clk_div_counter_four = clk_div_counter == 4'd4;\n\nassign clk_div_counter_five = clk_div_counter == 4'd5;\nassign clk_div_counter_six = clk_div_counter == 4'd6;\nassign clk_div_counter_seven"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\n// Frequency divider by odd numbers\nreg [3:0] pos_edge_counter = 0;\nreg [3:0] neg_edge_counter = 0;\n\nreg clk_div1 = 0;\nreg clk_div2 = 0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        neg_edge_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (pos_edge_counter < NUM_DIV - 1)\n            pos_edge_counter <= pos_edge_counter + 1;\n        else\n            pos_edge_counter <= 0;\n\n        if (neg_edge_counter < NUM_DIV - 1)\n            neg_edge_counter <= neg_edge_counter + 1;\n        else\n            neg_edge_counter <= 0;\n\n        clk_div1 <= (pos_edge_counter == NUM_DIV - 1);\n        clk_div2 <= (neg_edge_counter == NUM_DIV - 1);\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n`define NUM_DIV 4\n`define COUNTER_MAX (2*`NUM_DIV - 1)\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == `COUNTER_MAX) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Divider Submodule\nreg clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_reg <= 0;\n    end else if (counter == `COUNTER_MAX) begin\n        clk_div_reg <= ~clk_div_reg;\n    end\nend\nassign clk_div = clk_div_reg;\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    assign r = aluc == 6'b100000 ? a + b :\n              aluc == 6'b100001 ? a + b :\n              aluc == 6'b100010 ? a - b :\n              aluc == 6'b100011 ? a - b :\n              aluc == 6'b100100 ? a & b :\n              aluc == 6'b100101 ? a | b :\n              aluc == 6'b100110 ? a ^ b :\n              aluc == 6'b100111 ? ~(a | b) :\n              aluc == 6'b101010 ? $signed(a) < $signed(b) :\n              aluc == 6'b101011 ? $unsigned(a) < $unsigned(b) :\n              aluc == 6'b000000 ? a << b[4:0] :\n              aluc == 6'b000010 ? $signed(a) >>> b[4:0] :\n              aluc == 6'b000011 ? a >>> b[4:0] :\n              aluc == 6'b000100 ? a << b[4:0] :\n              aluc == 6'b000110 ? $signed(a) >>> b[4:0] :\n              aluc == 6'b000111 ? a >>> b[4:0] :\n              aluc == 6'b001111 ? {24'b0, b[15:0]} : 0;\n    \n    assign zero = r == 0;\n    assign carry = r[32];\n    assign negative = r[31];\n    assign overflow = r[32] ^ a[31] ^ b[31];\n    assign flag = aluc == 6'b101010 || aluc == 6'b101011;\nendmodule\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n// Submodule for multiplication\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Submodule for accumulation\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule\n\n// Main module\nwire [63:0] mult_result;\n\n// Multiplier submodule\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Accumulator submodule\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [4:0] ad1_p1;\n    wire [4:0] ad2_p1;\n    wire [4:0] ad1_p2;\n    wire [4:0] ad2_p2;\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n\n    // Instruction register submodules\n    // ins_p1: Instruction from the first port\n    // ad1_p1: Low 5 bits of the instruction from the first port\n    // ad2_p1: Full 8 bits of the instruction from the first port\n    // ins_p2: Instruction from the second port\n    // ad1_p2: Low 5 bits of the instruction from the second port\n    // ad2_p2: Full 8 bits of the instruction from the second port\n\n    // ...\n    // Implementation of the submodules\n    // ...\n\n    // Assign outputs\n    assign ins = {ins_p2, ins_p1};\n    assign ad1 = {ad2_p2, ad1_p2};\n    assign ad2 = {data, ad2_p1};\n\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable = 1;\n\nwire [7:0] count;\nwire [7:0] freq_adjusted = 8'h100 / freq;\n\ncounter u_counter(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq_adjusted),\n    .count(count)\n);\n\nassign wave_out = (count == (freq_adjusted - 1)) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] reg_count = 0;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (reg_count == (freq - 1)) begin\n            reg_count <= 0;\n        end else begin\n            reg_count <= reg_count + 1;\n        end\n    end\nend\n\nassign count = reg_count;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state_reg;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'd31) begin\n                        state_reg <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'd0) begin\n                        state_reg <= 2'b00;\n                    end\n                end\n                default: begin\n                    state_reg <= 2'b00;\n                    wave_reg <= 5'd0;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    state <= 2'b00;\n                end\n                2'b01: begin\n                    state <= 2'b00;\n                end\n                default: begin\n                    state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave <= wave + 1;\n                    if (wave == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave <= wave - 1;\n                    if (wave == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    wave <= 5'd0;\n                    state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] dff1, dff2, dff3;\n    wire [7:0] mux_out;\n\n    // D flip-flops\n    always @(posedge clk) begin\n        dff1 <= d;\n        dff2 <= dff1;\n        dff3 <= dff2;\n    end\n\n    // Multiplexer\n    assign mux_out = (sel == 2'b00) ? dff1 :\n                     (sel == 2'b01) ? dff2 :\n                     (sel == 2'b10) ? dff3 :\n                     d;\n\n    // Shift register\n    always @(posedge clk) begin\n        q <= {mux_out, q[7:1]};\n    end\n\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\nwire q0, q1, q2;\n\n// Instantiate D flip-flop module\nmy_dff f0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff f1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff f2 (\n    .clk(clk),\n    .d(q1),\n    .q(q2)\n);\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q_reg;\n\nalways @(posedge clk) begin\n    q_reg <= d;\nend\n\nassign q = q_reg;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    mux2X1 mux1 (stage1_out, in[3:0], in[7:4], ctrl[2]);\n    mux2X1 mux2 (stage2_out, stage1_out[1:0], stage1_out[3:2], ctrl[1]);\n    mux2X1 mux3 (stage3_out, stage2_out[1:0], stage2_out[3:2], ctrl[0]);\n\n    mux2X1 mux4 (out[3:0], stage3_out[1:0], stage3_out[3:2], ctrl[2]);\n    mux2X1 mux5 (out[7:4], stage3_out[3:2], stage3_out[7:6], ctrl[1]);\n    mux2X1 mux6 (out[7:6], stage3_out[7:6], stage3_out[7:6], ctrl[0]);\n\nendmodule\n\nmodule mux2X1 (out, in1, in2, sel);\n    input [1:0] sel;\n    input [1:0] in1;\n    input [1:0] in2;\n    output [1:0] out;\n\n    assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n  wire [31:0] pe0, pe1;\n\n  assign pe0 = a0 * b0;\n  assign pe1 = a1 * b1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 32'b0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  assign c0 = pe0;\n  assign c1 = pe1;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  reg [31:0] pipeline_reg [0:4];\n  reg [4:0] pc;\n\n  // Fetch stage\n  stage fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] instr,\n    output reg [4:0] next_pc\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      instr <= 0;\n      next_pc <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n      next_pc <= pc + 1;\n    end\n  end\n\n  // Decode stage\n  stage decode_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output reg [4:0] op,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [4:0] rd,\n    output reg [31:0] imm\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      imm <= 0;\n    end else begin\n      op <= instr[31:28];\n      rs1 <= instr[24:20];\n      rs2 <= instr[20:16];\n      rd <= instr[15:11];\n      imm <= {{(20 - instr[31]){instr[31]}}, instr[31:20]};\n    end\n  end\n\n  // Execute stage\n  stage execute_stage(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    input [4:0] op,\n    input [4:0] rs1,\n    input [4:0] rs2,\n    input [31:0] imm,\n    output reg [31:0] alu_out\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_out <= 0;\n    end else begin\n      case (op)\n        4'b0000: alu_out <= reg_file[rs1] + reg_file[rs2];\n        4'b0001: alu_out <= reg_file[rs1] - reg_file[rs2];\n        default: alu_out <= 0;\n      endcase\n    end\n  end\n\n  // Memory stage\n  stage memory_stage(\n    input clk,\n    input rst,\n    input [31:0] alu_out,\n    output reg [31:0] mem_out\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      mem_out <= 0;\n    end else begin\n      mem_out <= alu_out;\n    end\n  end\n\n  // Writeback stage\n  stage writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] mem_out,\n    output reg [31:0] res_reg_file [0:31]\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[pc[4:0]] <= mem_out;\n    end\n  end\n\n  // Pipeline register\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pipeline_reg <= 0;\n    end else begin\n      pipeline_reg[0] <= fetch_stage.instr;\n      pipeline_reg[1] <= decode_stage.op;\n      pipeline_reg[2] <= execute_stage.alu_out;\n     "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [31:0] pe0, pe1, pe2, pe3;\n  reg [15:0] b1, b2, b3;\n  reg [31:0] d1, d2, d3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pe0 <= 32'b0;\n      pe1 <= 32'b0;\n      pe2 <= 32'b0;\n      pe3 <= 32'b0;\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      d1 <= 32'b0;\n      d2 <= 32'b0;\n      d3 <= 32'b0;\n    end else begin\n      pe0 <= a0 * b0;\n      pe1 <= a1 * b1;\n      pe2 <= a2 * b2;\n      pe3 <= a3 * b3;\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      d1 <= pe1 + pe0;\n      d2 <= pe2 + pe1;\n      d3 <= pe3 + pe2;\n    end\n  end\n\n  assign c0 = pe0;\n  assign c1 = d1;\n  assign c2 = d2;\n  assign c3 = d3;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] instr;\n    reg [31:0] out_reg_file_reg;\n\n    // Fetch stage\n    wire [4:0] pc;\n    assign pc = instr_mem[0];\n    assign instr = instr_mem[pc];\n    assign out_reg_file_reg = instr_mem[pc];\n\n    // Execute stage\n    wire [31:0] op1, op2;\n    wire [31:0] add_sub;\n    assign op1 = reg_file[instr[25:21]];\n    assign op2 = reg_file[instr[15:11]];\n    assign add_sub = op1 + op2;\n    assign out_reg_file_reg = add_sub;\n\n    // Writeback stage\n    assign reg_file[instr[15:11]] = out_reg_file_reg;\n    assign out_reg_file = out_reg_file_reg;\n\nendmodule\n\n\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                valid_out;\n    wire        [9:0]   data_out;\n\n    //\n    // Counter Module\n    //\n    reg          [2:0]   cnt_reg;\n    reg                cnt_en;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_reg <= 0;\n            cnt_en <= 0;\n        end else begin\n            cnt_en <= valid_in;\n            if (cnt_en) begin\n                if (cnt_reg == 3) begin\n                    cnt_reg <= 0;\n                end else begin\n                    cnt_reg <= cnt_reg + 1;\n                end\n            end\n        end\n    end\n\n    assign valid_out = cnt_en && (cnt_reg == 3);\n\n    //\n    // Data Accumulator Module\n    //\n    reg          [9:0]   data_acc_reg;\n    reg                data_acc_en;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_acc_reg <= 0;\n            data_acc_en <= 0;\n        end else begin\n            data_acc_en <= valid_in;\n            if (data_acc_en) begin\n                data_acc_reg <= data_acc_reg + data_in;\n            end\n        end\n    end\n\n    assign data_out = data_acc_reg;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output              count_out\n);\n\n    wire                valid_out;\n    reg          [2:0]   count_reg;\n    reg                count_en;\n    reg                count_reset;\n\n    //\n    // Counter Module\n    //\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_reg <= 0;\n            count_en <= 0;\n            count_reset <= 0;\n        end else begin\n            if (count_reset) begin\n                count_reg <= 0;\n                count_en <= 0;\n            end else begin\n                count_en <= valid_in;\n                if (count_en) begin\n                    if (count_reg == 3) begin\n                        count_reg <= 0;\n                        count_reset <= 1;\n                    end else begin\n                        count_reg <= count_reg + 1;\n                    end\n                end\n            end\n        end\n    end\n\n    assign valid_out = count_en && (count_reg == 3);\n    assign count_out = valid_in;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire                valid_out;\n    reg          [9:0]   data_acc_reg;\n    reg                data_acc_en;\n    reg                data_acc_reset;\n\n    //\n    // Data Accumulator Module\n    //\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_acc_reg <= 0;\n            data_acc_en <= 0;\n            data_acc_reset <= 0;\n        end else begin\n            if (data_acc_reset) begin\n                data_acc_reg <= 0;\n                data_acc_en <= 0;\n                data_acc_reset <= 0;\n            end else begin\n                data_acc_en <= valid_in;\n                if (data_acc_en) begin\n                    data_acc_reg <= data_acc_reg + data_in;\n                end\n            end\n        end\n    end\n\n    assign valid_out = data_acc_en && (data_acc_reg == "}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [15:0] abs_dividend;\n    wire [15:0] neg_divisor_mod;\n\n    // submodules\n    abs_dividend abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_divisor_mod neg_divisor_mod_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .divisor(divisor),\n        .result(neg_divisor_mod)\n    );\n\n    // submodules\n    divider_control divider_control_inst(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .result_ready(res_valid)\n    );\n\n    // submodules\n    result_management result_management_inst(\n        .clk(clk),\n        .rst(rst),\n        .res_valid(res_valid),\n        .result(result)\n    );\nendmodule\n\nmodule abs_dividend(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,    \n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= {dividend, 8'b0};\n            end else begin\n                result <= {{8{dividend[7]}}, dividend};\n            end\n        end\n    end\nendmodule\n\nmodule neg_divisor_mod(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,    \n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= {divisor, 8'b0};\n            end else begin\n                result <= {{8{divisor[7]}}, divisor};\n            end\n        end\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg result_ready\n);\n    reg [15:0] shift_reg;\n    reg [3:0] count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n            count <= 0;\n        end else begin\n            if (opn_valid) begin\n                shift_reg <= shift_reg >> 1;\n                count <= count + 1;\n            end else if (count != 0) begin\n                shift_reg <= shift_reg >> 1;\n                count <= count - 1;\n            end\n            if (count == 0) begin\n                result_ready <= 0;\n            end else if (res_ready) begin\n                result_ready <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [15:0] abs_dividend,    \n    input wire [15:0] neg_divisor_mod,    \n    input wire [15:0] shift_reg,    \n    output reg res_valid,   \n    output reg [15:0] result\n);\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end else if (opn_valid) begin\n            remainder <= abs_dividend -"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // 32-bit dividend, 16-bit divisor\n    // 32-bit result, 32-bit remainder\n\n    // Your submodule implementation goes here\n    // Use a simple division algorithm for demonstration\n    // You can modify this algorithm to meet your specific requirements\n\n    // For example, we can use a simple loop to perform the division\n    // by shifting the dividend and comparing it with the divisor\n    // to compute the quotient and remainder\n\n    // The dividend and divisor are 32-bit\n    // The result and remainder are 32-bit\n\n    // Prepare the dividend and divisor\n    // For example, we can pad the dividend with 16 zeros\n    // If the dividend is 32-bit, we can simply pass it as it is\n    // We can also pad the divisor with 16 zeros\n    // If the divisor is 16-bit, we can pad it with 16 zeros\n    wire [31:0] prep_dividend;\n    wire [15:0] prep_divisor;\n\n    // Implement the division algorithm\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    assign quotient = 0;\n    assign remainder = 0;\n    genvar i;\n    always @(*) begin\n        // Loop to divide the dividend by the divisor\n        for (i = 0; i < 32; i = i + 1) begin\n            if (prep_dividend > prep_divisor) begin\n                prep_dividend = prep_dividend - prep_divisor;\n                quotient = quotient << 1;\n            end\n            prep_divisor = prep_divisor << 1;\n        end\n        remainder = prep_dividend;\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Example submodule implementation for prep_dividend\n// It takes in the original dividend and outputs the prepared dividend\nmodule prep_dividend(\n    input wire [31:0] A,\n    output wire [31:0] prep_dividend\n);\n    assign prep_dividend = A;\nendmodule\n\n// Example submodule implementation for div_operation\n// It takes in the prepared dividend and divisor\n// and outputs the result and remainder\nmodule div_operation(\n    input wire [31:0] prep_dividend,\n    input wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    assign result = 0;\n    assign odd = 0;\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    //\n    // The control unit is responsible for performing the division operation.\n    //\n    // In this example, we'll implement a simple division algorithm.\n    //\n    // Implementation:\n    // 1. Initialize variables for quotient and remainder.\n    // 2. Shift the dividend to the right by one bit.\n    // 3. Compare the shifted dividend with the divisor.\n    // 4. If the shifted dividend is greater than or equal to the divisor,\n    //    subtract the divisor from the shifted dividend and set the\n    //    least significant bit of the quotient to 1.\n    // 5. If the shifted dividend is less than the divisor, set the\n    //    least significant bit of the quotient to 0.\n    // 6. Shift the shifted dividend to the left by one bit.\n    // 7. Compare the shifted dividend with the divisor.\n    // 8. Repeat steps 3-7 until the shifted dividend is less than the divisor.\n    // 9. Set the quotient and remainder.\n    //\n    // This implementation is for demonstration purposes only and should not be used in production.\n    //\n    // Submodule port declarations\n    output wire [15:0] quotient;\n    output wire [15:0] remainder;\n\n    // Implementation\n    reg [15:0] q;\n    reg [15:0] r;\n    integer i;\n\n    always @(*) begin\n        // Initialize quotient and remainder\n        q = 0;\n        r = A;\n\n        // Shift dividend to the right by one bit\n        for (i = 15; i >= 0; i = i - 1) begin\n            // Compare shifted dividend with divisor\n            if (r >= B) begin\n                // If shifted dividend is greater than or equal to divisor\n                r = r - B;\n                q[i] = 1;\n            end else begin\n                // If shifted dividend is less than divisor\n                q[i] = 0;\n            end\n\n            // Shift shifted dividend to the left by one bit\n            r = r << 1;\n        end\n\n        // Set quotient and remainder\n        quotient = q;\n        remainder = r;\n    end\n\nendmodule\n"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_not, B_out_temp;\n\nnot (B_not, B);\n\n// Replace adder_8bit with an instantiation of full_adder\nfull_adder fa0 (.A(A[0]), .B(B_not[0]), .Cin(1'b0), .Sum(D[0]), .Cout(B_out_temp[0]));\nfull_adder fa1 (.A(A[1]), .B(B_not[1]), .Cin(B_out_temp[0]), .Sum(D[1]), .Cout(B_out_temp[1]));\nfull_adder fa2 (.A(A[2]), .B(B_not[2]), .Cin(B_out_temp[1]), .Sum(D[2]), .Cout(B_out_temp[2]));\nfull_adder fa3 (.A(A[3]), .B(B_not[3]), .Cin(B_out_temp[2]), .Sum(D[3]), .Cout(B_out_temp[3]));\nfull_adder fa4 (.A(A[4]), .B(B_not[4]), .Cin(B_out_temp[3]), .Sum(D[4]), .Cout(B_out_temp[4]));\nfull_adder fa5 (.A(A[5]), .B(B_not[5]), .Cin(B_out_temp[4]), .Sum(D[5]), .Cout(B_out_temp[5]));\nfull_adder fa6 (.A(A[6]), .B(B_not[6]), .Cin(B_out_temp[5]), .Sum(D[6]), .Cout(B_out_temp[6]));\nfull_adder fa7 (.A(A[7]), .B(B_not[7]), .Cin(B_out_temp[6]), .Sum(D[7]), .Cout(B_out_temp[7]));\n\nassign B_out = B_out_temp[7];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (B & Cin) | (A & Cin);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput wire [31:0] A, B;\noutput wire [31:0] Diff;\noutput wire B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_out_s1;\nwire [63:0] B_out_s2;\nwire [63:0] B_out_s3;\nwire [63:0] B_out_s4;\nwire [63:0] B_out_s5;\n\nwire [63:0] D_s1;\nwire [63:0] D_s2;\nwire [63:0] D_s3;\n\nwire [63:0] B_out_s1_s2;\nwire [63:0] B_out_s3_s4;\nwire [63:0] B_out_s5;\n\nsub_32bit u_sub_32bit1(\n    .A(A),\n    .B(B),\n    .D(D_s1),\n    .B_out(B_out_s1)\n);\n\nsub_32bit u_sub_32bit2(\n    .A(A),\n    .B(B),\n    .D(D_s2),\n    .B_out(B_out_s2)\n);\n\nsub_32bit u_sub_32bit3(\n    .A(A),\n    .B(B),\n    .D(D_s3),\n    .B_out(B_out_s3)\n);\n\nsub_16bit u_sub_16bit1(\n    .A(D_s1),\n    .B(D_s2),\n    .D(B_out_s1_s2),\n    .B_out(B_out_s1_s2)\n);\n\nsub_16bit u_sub_16bit2(\n    .A(D_s3),\n    .B(D_s2),\n    .D(B_out_s3_s4),\n    .B_out(B_out_s3_s4)\n);\n\nsub_8bit u_sub_8bit1(\n    .A(B_out_s1_s2),\n    .B(B_out_s3_s4),\n    .D(B_out_s5),\n    .B_out(B_out_s5)\n);\n\nassign B_out = B_out_s1;\nassign D = B_out_s5;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_out_s1;\nwire [63:0] B_out_s2;\n\nsub_4bit u_sub_4bit1(\n    .A(A),\n    .B(B),\n    .D(B_out_s1),\n    .B_out(B_out_s1)\n);\n\nsub_4bit u_sub_4bit2(\n    .A(A),\n    .B(B),\n    .D(B_out_s2),\n    .B_out(B_out_s2)\n);\n\nsub_4bit u_sub_4bit3(\n    .A(B_out_s1),\n    .B(B_out_s2),\n    .D(B_out),\n    .B_out(B_out)\n);\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [63:0] A;\ninput [63:0] B;\noutput [63:0] D;\noutput B_out;\n\nwire [63:0] B_out_s1;\nwire [63:0] B_out_s2;\n\nsub_2bit u_sub_2bit1(\n    .A(A),\n    .B(B),\n    .D(B_out_s1),\n    .B_out(B_out_s1)\n);\n\nsub_2bit u_sub"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] b_out;\nwire [3:1] d_out;\nwire [7:1] sub1, sub2, sub3, sub4;\n\n// Instantiate the full subtractor block for 4-bit\nsub4_bit full_sub4_1(A[4:1], B[4:1], sub1[4:1], sub2[4:1], b_out[1], d_out[1]);\nsub4_bit full_sub4_2(sub1[4:1], B[4:1], sub2[4:1], sub3[4:1], b_out[2], d_out[2]);\nsub4_bit full_sub4_3(sub2[4:1], B[4:1], sub3[4:1], sub4[4:1], b_out[3], d_out[3]);\n\nassign D[16:1] = {d_out[1], d_out[2], d_out[3], sub4[4:1]};\nassign B_out = b_out[3];\n\nendmodule\n\nmodule sub4_bit (A, B, B_out, D);\ninput [3:1] A, B;\noutput B_out;\noutput [3:1] D;\n\nwire [7:1] sub1, sub2;\nwire [3:1] b_out;\n\nsub2_bit full_sub2_1(A[2:1], B[2:1], sub1[2:1], b_out[1], D[1]);\nsub2_bit full_sub2_2(sub1[2:1], B[2:1], sub2[2:1], b_out[2], D[2]);\n\nassign D[3] = sub2[3];\nassign B_out = b_out[2];\n\nendmodule\n\nmodule sub2_bit (A, B, B_out, D);\ninput [2:1] A, B;\noutput B_out;\noutput [2:1] D;\n\nwire [5:1] sub1;\nwire [2:1] b_out;\n\nsub1_bit full_sub1_1(A[1:1], B[1:1], sub1[1:1], b_out[1], D[1]);\nsub1_bit full_sub1_2(sub1[2:1], B[2:1], sub1[2:1], b_out[2], D[2]);\n\nassign D[2] = sub1[2];\nassign B_out = b_out[2];\n\nendmodule\n\nmodule sub1_bit (A, B, B_out, D);\ninput [1:1] A, B;\noutput B_out;\noutput D;\n\nwire [3:1] sub1;\nwire [1:1] b_out;\n\nsub2_bit full_sub2_3(A[1:1], B[1:1], sub1[1:1], b_out[1], D);\n\nassign D = sub1[1];\nassign B_out = b_out[1];\n\nendmodule\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtrahend;\nwire borrow;\n\nassign subtrahend = B;\n\nsubtractor_32bit subtractor (\n    .A(A),\n    .B(subtrahend),\n    .borrow(borrow),\n    .A_greater(A_greater),\n    .A_equal(A_equal),\n    .A_less(A_less)\n);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output borrow,\n    output [31:0] A_greater,\n    output A_equal,\n    output A_less\n);\n\nassign {borrow, A_greater} = A - B;\nassign A_equal = ~|(A_greater);\nassign A_less = ~borrow;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] carry;\nwire [3:0] carry_select;\nwire [3:0] sum_select;\n\nassign carry[0] = 1'b0;\nassign carry_select[0] = 4'b0000;\nassign sum_select[0] = 4'b0000;\n\ngenvar i;\ngenerate\nfor (i = 0; i < 4; i = i + 1) begin\n    assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n    assign sum_select[i+1] = {4{carry_select[i]}} & {4{sum_select[i]}} | {4{a[i]}} & {4{b[i]}} | {4{a[i]}} & {4{carry[i]}} | {4{b[i]}} & {4{carry[i]}};\n    assign carry_select[i+1] = {4{carry_select[i]}} & {4{carry[i]}} | {4{a[i]}} & {4{b[i]}} | {4{a[i]}} & {4{carry[i]}} | {4{b[i]}} & {4{carry[i]}};\nend\nendgenerate\n\nassign sum = {sum_select[3:0], a[3:0]} ^ {sum_select[3:0], b[3:0]};\nassign cout = carry_select[3] | (a[3] & b[3]) | (a[3] & carry[3]) | (b[3] & carry[3]);\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] rca1_sum, rca1_cout;\nwire [3:0] csa1_sum, csa1_cout;\nwire [3:0] csa2_sum, csa2_cout;\nwire [3:0] csa3_sum, csa3_cout;\n\nassign rca1_sum = a ^ b;\nassign rca1_cout = (a & b) | (a & cin) | (b & cin);\n\nassign csa1_sum = {rca1_cout[3:0], rca1_sum[3:0]} ^ {rca1_cout[3:0], a[3:0]} ^ {rca1_cout[3:0], b[3:0]};\nassign csa1_cout = {rca1_cout[3:0], rca1_cout[3:0]} & {rca1_cout[3:0], rca1_cout[3:0]} | {rca1_cout[3:0], rca1_cout[3:0]} & {rca1_cout[3:0], rca1_sum[3:0]} | {rca1_cout[3:0], rca1_cout[3:0]} & {rca1_cout[3:0], a[3:0]} | {rca1_cout[3:0], rca1_cout[3:0]} & {rca1_cout[3:0], b[3:0]};\n\nassign csa2_sum = {csa1_cout[3:0], csa1_sum[3:0]} ^ {csa1_cout[3:0], a[7:4]} ^ {csa1_cout[3:0], b[7:4]};\nassign csa2_cout = {csa1_cout[3:0], csa1_cout[3:0]} & {csa1_cout[3:0], csa1_cout[3:0]} | {csa1_cout[3:0], csa1_cout[3:0]} & {csa1_cout[3:0], csa1_sum"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire [7:0] Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    assign {Co7, y7} = a7 + b7 + Co6;\n    assign {Co6, y6} = a6 + b6 + Co5;\n    assign {Co5, y5} = a5 + b5 + Co4;\n    assign {Co4, y4} = a4 + b4 + Co3;\n    assign {Co3, y3} = a3 + b3 + Co2;\n    assign {Co2, y2} = a2 + b2 + Co1;\n    assign {Co1, y1} = a1 + b1 + Co0;\n    assign {Co0, y0} = a0 + b0 + Cin;\n\nendmodule\n\n\n\n\n\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    assign {c1, sum[0]} = a[0] + b[0] + cin;\n    assign {c2, sum[1]} = a[1] + b[1] + c1;\n    assign {c3, sum[2]} = a[2] + b[2] + c2;\n    assign {c4, sum[3]} = a[3] + b[3] + c3;\n    assign {c5, sum[4]} = a[4] + b[4] + c4;\n    assign {c6, sum[5]} = a[5] + b[5] + c5;\n    assign {c7, sum[6]} = a[6] + b[6] + c6;\n    assign {cout, sum[7]} = a[7] + b[7] + c7;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_cnt;   // Shift counter.\nreg [31:0] product;    // Product register.\nreg [31:0] reg_unit;   // Register unit.\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000; // Reset the shift counter.\n        product <= 32'b0;     // Reset the product register.\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000; // Reset the shift counter.\n            reg_unit <= {16'b0, ain}; // Load the multiplicand.\n        end\n    end\nend\n\n// Register Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset the register unit.\n    end else begin\n        if (start) begin\n            reg_unit <= {16'b0, bin}; // Load the multiplier.\n        end\n    end\nend\n\n// Multiplier Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset the multiplier unit.\n    end else begin\n        if (start) begin\n            // Shift the multiplier.\n            product <= {product[30:0], reg_unit[15:0]};\n            reg_unit <= {reg_unit[14:0], 1'b0};\n            shift_cnt <= shift_cnt + 1;\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product; // Assign the product to the output.\nassign done = shift_cnt[3]; // Assign the done flag.\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n// Modules\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count),\n    .next_count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\nreg [15:0] count_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count_reg <= 16'b0000000000000000;\n    else if (up_down)\n        count_reg <= count_reg + 1;\n    else\n        count_reg <= count_reg - 1;\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        next_count <= 16'b0000000000000000;\n    else\n        next_count <= count;\nend\n\nendmodule\n\n\"\"\"\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    reg [7:0] out_reg;\n    reg [2:0] state;\n\n    // State Initialization\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n            state <= 0;\n        end else begin\n            out_reg <= 8'b0000_0001;\n            state <= 0;\n        end\n    end\n\n    // State Transition\n    always @(posedge clk) begin\n        if (state == 2'd7) begin\n            state <= 0;\n        end else begin\n            state <= state + 1;\n        end\n    end\n\n    // Output\n    always @(*) begin\n        out = out_reg << state;\n    end\n\nendmodule\n\n// This is a submodule used in the ring_counter design.\n// The submodule initializes the counter to its starting state when reset is high.\nmodule submodule_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\n// This is a submodule used in the ring_counter design.\n// The submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal.\nmodule submodule_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0000;\n        end else begin\n            out <= out << 1;\n            if (out == 8'b1000_0000) begin\n                out <= 8'b0000_0001;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        count <= count + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= count;\nend\n\nendmodule\n\nmodule\nu_counter_logic\n    (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= out + 1;\n    else\n        out <= 4'b0000;\nend\n\nendmodule\n\nmodule\nu_output_register\n    (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= count;\n    else\n        out <= out;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule instantiation\nJC_register reg_inst();\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_inst.Q <= 64'b0;\n    end else begin\n        reg_inst.Q <= reg_inst.Q + 1'b1;\n    end\nend\n\n// Submodule definition\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1'b1;\n    end\nend\nendmodule\n\n// Submodule definition\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]   Q_next\n);\n\nalways @(*) begin\n    Q_next = Q;\n    Q_next[0] = Q[63];\nend\nendmodule\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg CLK_50_tmp, CLK_10_tmp, CLK_1_tmp;\n\n    // clk_div_2\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_50_tmp <= 1'b0;\n        end else begin\n            CLK_50_tmp <= ~CLK_50_tmp;\n        end\n    end\n\n    assign CLK_50 = CLK_50_tmp;\n\n    // clk_div_10\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_10_tmp <= 1'b0;\n        end else begin\n            if (CLK_10_tmp == 1'b1) begin\n                CLK_10_tmp <= 1'b0;\n            end else begin\n                CLK_10_tmp <= 1'b1;\n            end\n        end\n    end\n\n    assign CLK_10 = CLK_10_tmp;\n\n    // clk_div_100\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_1_tmp <= 1'b0;\n        end else begin\n            if (CLK_1_tmp == 1'b1) begin\n                CLK_1_tmp <= 1'b0;\n            end else begin\n                CLK_1_tmp <= 1'b1;\n            end\n        end\n    end\n\n    assign CLK_1 = CLK_1_tmp;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK - 1 : 0] cnt;\nreg [MUL2_DIV_CLK - 1 : 0] cnt2;\n\nwire [MUL2_DIV_CLK - 1 : 0] cnt_max = (1 << MUL2_DIV_CLK) - 1;\nwire clk_div2 = (cnt2 == cnt_max);\n\nreg [MUL2_DIV_CLK - 1 : 0] cnt_div2;\nreg [MUL2_DIV_CLK - 1 : 0] cnt_div3;\nwire [MUL2_DIV_CLK - 1 : 0] cnt_div2_max = (1 << MUL2_DIV_CLK) - 1;\nwire [MUL2_DIV_CLK - 1 : 0] cnt_div3_max = (1 << MUL2_DIV_CLK) - 1;\nwire clk_div23 = (cnt_div2 == cnt_div2_max) & (cnt_div3 == cnt_div3_max);\n\nreg clk_div_r;\nreg clk_div2_r;\nreg clk_div3_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_r <= 1'b0;\n        clk_div2_r <= 1'b0;\n        clk_div3_r <= 1'b0;\n    end else begin\n        clk_div_r <= clk_div23;\n        clk_div2_r <= clk_div2;\n        clk_div3_r <= clk_div3;\n    end\nend\n\nassign clk_div = clk_div_r;\n\n// Counter\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= {MUL2_DIV_CLK{1'b0}};\n        cnt2 <= {MUL2_DIV_CLK{1'b0}};\n    end else begin\n        if (cnt == cnt_max) begin\n            cnt <= {MUL2_DIV_CLK{1'b0}};\n            cnt2 <= cnt2 + 1'b1;\n        end else begin\n            cnt <= cnt + 1'b1;\n        end\n    end\nend\n\n// Clock Average Generator\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_div2 <= {MUL2_DIV_CLK{1'b0}};\n        cnt_div3 <= {MUL2_DIV_CLK{1'b0}};\n    end else begin\n        if (cnt_div2 == cnt_div2_max) begin\n            cnt_div2 <= {MUL2_DIV_CLK{1'b0}};\n            cnt_div3 <= cnt_div3 + 1'b1;\n        end else begin\n            cnt_div2 <= cnt_div2 + 1'b1;\n        end\n    end\nend\n\n// Clock Adjustment\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_div2 <= {MUL2_DIV_CLK{1'b0}};\n        cnt_div3 <= {MUL2_DIV_CLK{1'b0}};\n    end else begin\n        if (cnt_div2 == cnt_div2_max) begin\n            cnt_div2 <= {MUL2_DIV_CLK{1'b0}};\n            cnt_div3 <= cnt_div3 + 1'b1;\n        end else begin\n            cnt_div2 <= cnt_div2 + 1'b1;\n        end\n    end\nend\n\nendmodule\n\nmodule counter (\n    input               clk,\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n`define NUM_DIV 5\n\nreg [(`define NUM_DIV)-1:0] cnt;\nreg clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        cnt <= cnt + 1;\n        if (cnt == (`define NUM_DIV)-1) begin\n            cnt <= 0;\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (cnt == (`define NUM_DIV)-1) begin\n            clk_div1 <= 1;\n        end else begin\n            clk_div1 <= 0;\n        end\n        if (cnt == 0) begin\n            clk_div2 <= 1;\n        end else begin\n            clk_div2 <= 0;\n        end\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    wire clk_div_en;\n    reg [3:0] counter;\n\n    assign clk_div_en = (counter == (NUM_DIV / 2 - 1)) ? 1'b1 : 1'b0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (clk_div_en) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign clk_div = counter[0];\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] sllv_out;\nwire [31:0] srlv_out;\nwire [31:0] srav_out;\nwire [31:0] add_out;\nwire [31:0] addu_out;\nwire [31:0] sub_out;\nwire [31:0] subu_out;\nwire [31:0] and_out;\nwire [31:0] or_out;\nwire [31:0] xor_out;\nwire [31:0] nor_out;\nwire [31:0] sll_out;\nwire [31:0] srl_out;\nwire [31:0] sra_out;\nwire [31:0] slt_out;\nwire [31:0] sltu_out;\n\n// add submodule\nwire [31:0] add_a;\nwire [31:0] add_b;\nwire [31:0] add_c;\n\n// addu submodule\nwire [31:0] addu_a;\nwire [31:0] addu_b;\nwire [31:0] addu_c;\n\n// sub submodule\nwire [31:0] sub_a;\nwire [31:0] sub_b;\nwire [31:0] sub_c;\n\n// subu submodule\nwire [31:0] subu_a;\nwire [31:0] subu_b;\nwire [31:0] subu_c;\n\n// sll submodule\nwire [31:0] sll_a;\nwire [31:0] sll_b;\n\n// srl submodule\nwire [31:0] srl_a;\nwire [31:0] srl_b;\n\n// sra submodule\nwire [31:0] sra_a;\nwire [31:0] sra_b;\n\n// sllv submodule\nwire [31:0] sllv_a;\nwire [31:0] sllv_b;\n\n// srlv submodule\nwire [31:0] srlv_a;\nwire [31:0] srlv_b;\n\n// srav submodule\nwire [31:0] srav_a;\nwire [31:0] srav_b;\n\n// and submodule\nwire [31:0] and_a;\nwire [31:0] and_b;\n\n// or submodule\nwire [31:0] or_a;\nwire [31:0] or_b;\n\n// xor submodule\nwire [31:0] xor_a;\nwire [31:0] xor_b;\n\n// nor submodule\nwire [31:0] nor_a;\nwire [31:0] nor_b;\n\n// slt submodule\nwire [31:0] slt_a;\nwire [31:0] slt_b;\n\n// sltu submodule\nwire [31:0] sltu_a;\nwire [31:0] sltu_b;\n\n// lui submodule\nwire [31:0] lui_out;\n\nassign add_a = a;\nassign add_b = b;\nassign add_c = 0;\n\nassign addu_a = a;\nassign addu_b = b;\nassign addu_c = 0;\n\nassign sub_a = a;\nassign sub_b = b;\nassign sub_c = 0;\n\nassign subu_a = a;\nassign subu_b = b;\nassign subu_c = 0;\n\nassign sll_a = a;\nassign sll_b = b;\n\nassign srl_a = a;\nassign srl_b = b;\n\nassign sra_a = a;\nassign sra_b = b;\n\nassign sllv_a = a;\nassign sllv_b = b;\n\nassign srlv_a = a;\nassign srlv_b = b;\n\nassign srav_a = a;\nassign srav_b ="}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiply_result;\n\n// Multiplier submodule\nwire [63:0] multiply_result;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        multiply_result <= 0;\n    end else begin\n        multiply_result <= a * b;\n    end\nend\n\n// Accumulator submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + multiply_result[31:0];\n    end\nend\n\n// Connect multiplier and accumulator submodules\nassign c = current_value;\n\nendmodule\n\n'''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n\nwire [2:0] ins_p1;\nwire [4:0] ad1_p1;\n\nwire [2:0] ins_p2;\nwire [4:0] ad1_p2;\n\nwire [7:0] ad2_p2;\n\nassign ins = ins_p1 | ins_p2;\nassign ad1 = ad1_p1 | ad1_p2;\nassign ad2 = ad2_p2;\n\nsubmodule ins_p1 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n        end else if (fetch == 2'b01) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n        end\n    end\nendmodule\n\nsubmodule ins_p2 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins <= 3'b0;\n            ad2 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins <= data[7:5];\n            ad2 <= data;\n        end\n    end\nendmodule\n\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n// Counter Module\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n    reg [7:0] count_reg;\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count_reg == (freq - 1)) begin\n                count_reg <= 0;\n            end else begin\n                count_reg <= count_reg + 1;\n            end\n        end\n    end\n    assign count = count_reg;\nendmodule\n\n// Wave Generator Module\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n    reg wave_out_reg;\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n    assign wave_out = wave_out_reg;\nendmodule\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            if (state == 2'b00) begin\n                if (wave_reg == 5'b00000) begin\n                    state <= 2'b01;\n                end\n            end else begin\n                if (wave_reg == 5'b11111) begin\n                    state <= 2'b00;\n                end\n            end\n\n            if (state == 2'b00) begin\n                wave_reg <= wave_reg + 1;\n            end else begin\n                wave_reg <= wave_reg - 1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            if (wave_reg == 5'b11111) begin\n                wave_reg <= 5'b00000;\n            end else begin\n                wave_reg <= wave_reg + 1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    my_dff8 dff0 (\n        .clk(clk),\n        .d(d),\n        .q(u0_q)\n    );\n\n    my_dff8 dff1 (\n        .clk(clk),\n        .d(u0_q),\n        .q(u1_q)\n    );\n\n    my_dff8 dff2 (\n        .clk(clk),\n        .d(u1_q),\n        .q(u2_q)\n    );\n\n    assign q = u2_q;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n    end\n\n    assign q = q3;\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    assign stage1_out[0] = in[ctrl[2]];\n    assign stage1_out[1] = in[ctrl[2]^1];\n    assign stage1_out[2] = in[ctrl[2]^2];\n    assign stage1_out[3] = in[ctrl[2]^3];\n    assign stage1_out[4] = in[ctrl[2]^4];\n    assign stage1_out[5] = in[ctrl[2]^5];\n    assign stage1_out[6] = in[ctrl[2]^6];\n    assign stage1_out[7] = in[ctrl[2]^7];\n\n    // Stage 2\n    assign stage2_out[0] = stage1_out[ctrl[1]];\n    assign stage2_out[1] = stage1_out[ctrl[1]^1];\n    assign stage2_out[2] = stage1_out[ctrl[1]^2];\n    assign stage2_out[3] = stage1_out[ctrl[1]^3];\n    assign stage2_out[4] = stage1_out[ctrl[1]^4];\n    assign stage2_out[5] = stage1_out[ctrl[1]^5];\n    assign stage2_out[6] = stage1_out[ctrl[1]^6];\n    assign stage2_out[7] = stage1_out[ctrl[1]^7];\n\n    // Stage 3\n    assign stage3_out[0] = stage2_out[ctrl[0]];\n    assign stage3_out[1] = stage2_out[ctrl[0]^1];\n    assign stage3_out[2] = stage2_out[ctrl[0]^2];\n    assign stage3_out[3] = stage2_out[ctrl[0]^3];\n    assign stage3_out[4] = stage2_out[ctrl[0]^4];\n    assign stage3_out[5] = stage2_out[ctrl[0]^5];\n    assign stage3_out[6] = stage2_out[ctrl[0]^6];\n    assign stage3_out[7] = stage2_out[ctrl[0]^7];\n\n    // Output\n    assign out = stage3_out;\nendmodule\n\nmodule mux2X1(sel, in0, in1, out);\n    input sel;\n    input in0, in1;\n    output reg out;\n\n    always @(*) begin\n        if (sel)\n            out = in1;\n        else\n            out = in0;\n    end\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  reg [31:0] next_pc;\n  reg [31:0] alu_result;\n  reg [31:0] reg_file_result;\n  wire [31:0] pc_plus_4;\n  wire [31:0] pc_plus_8;\n  wire [31:0] pc_plus_12;\n  wire [31:0] pc_plus_16;\n  wire [31:0] instr;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  wire [31:0] rs1_val;\n  wire [31:0] rs2_val;\n  wire [31:0] alu_in1;\n  wire [31:0] alu_in2;\n  wire [31:0] alu_out;\n\n  wire [31:0] reg_file_in;\n  wire [31:0] reg_file_out;\n\n  wire [31:0] pc_plus_4_in;\n  wire [31:0] pc_plus_8_in;\n  wire [31:0] pc_plus_12_in;\n  wire [31:0] pc_plus_16_in;\n\n  wire [31:0] instr_mem_in;\n  wire [31:0] instr_mem_out;\n\n  assign pc = next_pc;\n\n  assign instr = instr_mem[pc];\n\n  assign rs1 = instr[31:27];\n  assign rs2 = instr[26:22];\n  assign rd = instr[21:17];\n  assign op = instr[16:12];\n\n  assign rs1_val = reg_file[rs1];\n  assign rs2_val = reg_file[rs2];\n\n  assign alu_in1 = rs1_val;\n  assign alu_in2 = rs2_val;\n\n  assign alu_out = (op == 6'b000000) ? alu_in1 + alu_in2 : alu_in1 - alu_in2;\n\n  assign reg_file_in = alu_out;\n  assign reg_file_out = reg_file_in;\n\n  assign pc_plus_4_in = pc + 4;\n  assign pc_plus_8_in = pc + 8;\n  assign pc_plus_12_in = pc + 12;\n  assign pc_plus_16_in = pc + 16;\n\n  assign instr_mem_in = instr_mem[pc_plus_4_in];\n  assign instr_mem_out = instr_mem[pc_plus_8_in];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n    end else begin\n      next_pc <= pc_plus_4_in;\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      alu_result <= alu_out;\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file_result <= 0;\n    end else begin\n      reg_file_result <= reg_file_out;\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[rd] <= reg_file_result;\n    end\n  end\n\n  assign pc_plus_4 = pc_plus_4_in;\n  assign pc_plus_8 = pc_plus_8_in;\n  assign pc_plus_12 = pc_plus_12_in;\n  assign pc_plus_16 = pc_plus"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  wire [15:0] b1 = b0_reg;\n  wire [15:0] b2 = b1_reg;\n  wire [15:0] b3 = b2_reg;\n  \n  reg [31:0] pe0, pe1, pe2, pe3;\n  wire [31:0] c0 = pe0;\n  wire [31:0] c1 = pe1;\n  wire [31:0] c2 = pe2;\n  wire [31:0] c3 = pe3;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      pe0 <= 0;\n      pe1 <= 0;\n      pe2 <= 0;\n      pe3 <= 0;\n    end else begin\n      b0_reg <= b0;\n      pe0 <= {a0, 16'b0} * {b0, 16'b0};\n      pe1 <= {a1, 16'b0} * {b1, 16'b0};\n      pe2 <= {a2, 16'b0} * {b2, 16'b0};\n      pe3 <= {a3, 16'b0} * {b3, 16'b0};\n    end\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2;\n    wire [5:0] opcode;\n    wire [4:0] rs, rt;\n    wire [11:0] imm;\n    wire [31:0] result;\n\n    assign out_reg_file = result;\n\n    // Fetch stage\n    // Fetch the instruction from the instruction memory\n    // and output it to the next stage\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .fetched_instr(fetched_instr)\n    );\n\n    // Execute stage\n    // Decode the instruction, perform the operation\n    // and output the result to the next stage\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .opcode(fetched_instr[31:26]),\n        .rs(fetched_instr[25:21]),\n        .rt(fetched_instr[20:16]),\n        .op1(reg_file[rs]),\n        .op2(reg_file[rt]),\n        .imm(fetched_instr[15:0]),\n        .result(result)\n    );\n\n    // Writeback stage\n    // Write the result back into the register file\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file)\n    );\nendmodule\n\n// Fetch stage\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] fetched_instr\n);\n\n    reg [5:0] pc;\n    reg [31:0] instr;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc <= 0;\n            instr <= 0;\n        end else begin\n            instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\n\n    assign fetched_instr = instr;\nendmodule\n\n// Execute stage\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [5:0] opcode,\n    input [4:0] rs,\n    input [4:0] rt,\n    input [31:0] op1,\n    input [31:0] op2,\n    input [11:0] imm,\n    output [31:0] result\n);\n\n    reg [31:0] add_result;\n    reg [31:0] sub_result;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            add_result <= 0;\n            sub_result <= 0;\n        end else begin\n            case (opcode)\n                6'b100000: add_result <= op1 + op2; // add\n                6'b101000: sub_result <= op1 - op2; // sub\n                default: add_result <= 0;\n            endcase\n        end\n    end\n\n    assign result = add_result + sub_result + imm; // add immediate\nendmodule\n\n// Writeback stage\nmodule stagepipe3_writeback (\n    input clk,\n    input rst,\n    input [31:0] result,\n    inout [31:0] reg_file [0:31]\n);\n\n    reg [31:0] op1;\n    reg [31:0] op2;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n        end else begin\n            op1 <= result;\n            op2 <= reg_file[31]; // write back\n        end\n    end\n\n    assign reg_file[31] = op2;\nendmodule\n\n// Implementation of the processor\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg       [2:0]   cnt;\nreg       [2:0]   next_cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n    end else begin\n        cnt <= next_cnt;\n    end\nend\n\nalways @* begin\n    next_cnt = cnt + 3'd1;\n    if (valid_in) begin\n        next_cnt = 3'd0;\n    end\nend\n\n// Data Accumulator Module\nreg [9:0] data_accumulator;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accumulator <= 10'd0;\n    end else begin\n        data_accumulator <= data_accumulator + data_in;\n    end\nend\n\n// Valid Output Module\nreg               valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n    end else if (cnt == 3'd4) begin\n        valid_out_reg <= 1'b1;\n    end else begin\n        valid_out_reg <= 1'b0;\n    end\nend\n\nassign data_out = data_accumulator;\nassign valid_out = valid_out_reg;\n\nendmodule\n\n\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend;\n    wire [7:0] abs_divisor;\n    wire [7:0] neg_divisor;\n    wire [7:0] neg_abs_dividend;\n\n    wire [3:0] counter;\n    reg [15:0] shift_reg;\n\n    assign res_valid = shift_reg[15];\n    assign abs_dividend = (sign == 1) ? -dividend : dividend;\n    assign abs_divisor = (sign == 1) ? -divisor : divisor;\n    assign neg_divisor = (sign == 1) ? -divisor : dividend;\n    assign neg_abs_dividend = (sign == 1) ? -abs_dividend : abs_dividend;\n\n    // 4-bit counter\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n        end else if (opn_valid) begin\n            counter <= counter + 1;\n        end\n    end\n\n    // 16-bit shift register\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 0;\n        end else if (opn_valid) begin\n            shift_reg <= {shift_reg[13:0], abs_dividend};\n        end\n    end\n\n    // Output result\n    assign result = {shift_reg[15:8], shift_reg[7:0]} ^ {neg_divisor, 8'b0};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // div_prep_dividend\n    wire [31:0] prep_dividend;\n    wire [15:0] prep_divisor;\n    wire [31:0] prep_dividend_16;\n    wire [15:0] prep_divisor_16;\n    wire [31:0] prep_dividend_32;\n    wire [15:0] prep_divisor_32;\n    \n    // div_operation\n    wire [31:0] div_result;\n    wire [31:0] div_remainder;\n    wire [31:0] div_prep_dividend_32;\n    wire [15:0] div_prep_divisor_32;\n    \n    // Submodules instantiation\n    prep_dividend prep_div (\n        .A(A),\n        .B(B),\n        .prep_dividend(prep_dividend),\n        .prep_divisor(prep_divisor),\n        .prep_dividend_16(prep_dividend_16),\n        .prep_divisor_16(prep_divisor_16),\n        .prep_dividend_32(prep_dividend_32),\n        .prep_divisor_32(prep_divisor_32)\n    );\n    \n    div_operation div (\n        .prep_dividend_32(prep_dividend_32),\n        .prep_divisor_32(prep_divisor_32),\n        .div_result(div_result),\n        .div_remainder(div_remainder),\n        .div_prep_dividend_32(div_prep_dividend_32),\n        .div_prep_divisor_32(div_prep_divisor_32)\n    );\n    \n    // Assign outputs\n    assign result = div_result;\n    assign odd = div_remainder;\n    \nendmodule\n\nmodule prep_dividend (\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] prep_dividend,\n    output wire [15:0] prep_divisor,\n    output wire [31:0] prep_dividend_16,\n    output wire [15:0] prep_divisor_16,\n    output wire [31:0] prep_dividend_32,\n    output wire [15:0] prep_divisor_32\n);\n    \n    assign prep_dividend = A;\n    assign prep_divisor = B;\n    assign prep_dividend_16 = {16'h0000, A[31:16]};\n    assign prep_divisor_16 = {16'h0000, B[15:0]};\n    assign prep_dividend_32 = {16'h0000, A[31:16], 16'h0000, A[31:16]};\n    assign prep_divisor_32 = {16'h0000, B[15:0], 16'h0000, B[15:0]};\n    \nendmodule\n\nmodule div_operation (\n    input wire [31:0] prep_dividend_32,\n    input wire [15:0] prep_divisor_32,\n    output wire [31:0] div_result,\n    output wire [31:0] div_remainder,\n    output wire [31:0] div_prep_dividend_32,\n    output wire [15:0] div_prep_divisor_32\n);\n    \n    wire [31:0] shift_dividend;\n    wire [31:0] shift_dividend_1;\n    wire [31:0] shift_dividend_2;\n    wire [31:0] shift_dividend_3;\n    wire [31:"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    reg [15:0] q;\n    reg [15:0] r;\n    reg [7:0] d;\n    reg [3:0] i;\n\n    always @(*) begin\n        // Initialize\n        q = 16'b0;\n        r = 16'b0;\n        d = B;\n        i = 4'b0;\n\n        // Division algorithm\n        while (r < A) begin\n            r = r << 1;\n            r[0] = q[0];\n            q = q << 1;\n            q[0] = 1'b0;\n            i = i + 1;\n        end\n\n        // Final results\n        odd = r;\n        result = {q, {8{1'b0}}};\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_inv, sum;\nwire [6:0] i;\n\nassign B_inv = ~B;\nassign D = sum;\nassign B_out = 0;\n\nassign sum = {1'b0, A} + B_inv;\nendmodule\n\nmodule adder_8bit(A, B, C, D);\ninput [7:0] A, B, C;\noutput [7:0] D;\n\nwire [7:0] sum;\n\nassign sum = A + B + C;\nassign D = {D[7], sum};\n\nendmodule\n\nmodule full_adder(A, B, C, D, P, G);\ninput A, B, C;\noutput D, P, G;\n\nassign P = A ^ B ^ C;\nassign D = A ^ P;\nassign G = A & B | B & C | C & P;\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] S1_out, S2_out;\nwire B1_out, B2_out;\n\nsub_16bit sub_16bit_inst1(A[15:0], B[15:0], S1_out, B1_out);\nsub_16bit sub_16bit_inst2(A[31:16], B[31:16], S2_out, B2_out);\n\nassign Diff[15:0] = S1_out;\nassign Diff[31:16] = S2_out;\nassign B_out = B1_out | B2_out;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] S1_out, S2_out;\nwire B1_out, B2_out;\n\nsub_8bit sub_8bit_inst1(A[7:0], B[7:0], S1_out, B1_out);\nsub_8bit sub_8bit_inst2(A[15:8], B[15:8], S2_out, B2_out);\n\nassign Diff[7:0] = S1_out;\nassign Diff[15:8] = S2_out;\nassign B_out = B1_out | B2_out;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nreg [7:0] Diff;\nreg B_out;\n\nalways @(A, B) begin\n    Diff = A - B;\n    B_out = (A[7] & B[7]) | (A[7] & ~B[7]) | (~A[7] & B[7]);\nend\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire B0, B1;\n\nassign D = A - B;\nassign B_out = B1;\n\nendmodule\n"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [15:0] xor_out;\nwire [15:0] nor_out;\nwire [14:0] bls_out;\n\nxor x1(xor_out, A[16:1], B[16:1]);\nnor n1(nor_out, xor_out);\n\nbls bls0(bls_out, nor_out);\n\nassign D = {nor_out[14:0], B_out};\nassign B_out = A[16];\n\nendmodule\nmodule bls(out, a);\ninput [14:0] a;\noutput [15:0] out;\n\nwire [14:0] s1;\nwire [14:0] s2;\n\nand a1(s1, a[14], a[13]);\nand a2(s2, a[12], a[11]);\nand a3(s1, s1, a[10]);\nand a4(s2, s2, a[9]);\nand a5(s1, s1, a[8]);\nand a6(s2, s2, a[7]);\nand a7(s1, s1, a[6]);\nand a8(s2, s2, a[5]);\nand a9(s1, s1, a[4]);\nand a10(s2, s2, a[3]);\nand a11(s1, s1, a[2]);\nand a12(s2, s2, a[1]);\nand a13(s1, s1, a[0]);\n\nor o1(out[15], s1, s2);\n\nendmodule\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff;\n    wire borrow;\n\n    assign diff = A - B;\n    assign borrow = diff[31];\n\n    assign A_greater = ~borrow & (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Result of subtraction\n    output borrow  // Borrow bit\n);\n    assign {borrow, diff} = A - B;\nendmodule\n"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] rc1, rc2, rc3, rc4;\n    wire [3:0] c1, c2, c3, c4;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, rc1, c1);\n    ripple_carry_adder rca2(a[7:4], b[7:4], c1[0], rc2, c2);\n    ripple_carry_adder rca3(a[11:8], b[11:8], c2[0], rc3, c3);\n    ripple_carry_adder rca4(a[15:12], b[15:12], c3[0], rc4, c4);\n\n    // 4-bit carry select adder\n    wire [3:0] sum1, sum2, sum3, sum4;\n    wire [3:0] csa1, csa2, csa3;\n    assign sum = {sum4, sum3, sum2, sum1};\n    assign cout = rc4[0];\n\n    assign csa1 = (rc1[0] | (c1[0] & rc2[0])) & (rc1[1] | (c1[1] & rc2[1])) & (rc1[2] | (c1[2] & rc2[2])) & (rc1[3] | (c1[3] & rc2[3]));\n    assign csa2 = (rc2[0] | (c2[0] & rc3[0])) & (rc2[1] | (c2[1] & rc3[1])) & (rc2[2] | (c2[2] & rc3[2])) & (rc2[3] | (c2[3] & rc3[3]));\n    assign csa3 = (rc3[0] | (c3[0] & rc4[0])) & (rc3[1] | (c3[1] & rc4[1])) & (rc3[2] | (c3[2] & rc4[2])) & (rc3[3] | (c3[3] & rc4[3]));\n\n    assign sum1 = (a[3:0] ^ b[3:0]) | (a[3:0] & b[3:0] & c1[0]);\n    assign sum2 = (a[7:4] ^ b[7:4]) | (a[7:4] & b[7:4] & c2[0]);\n    assign sum3 = (a[11:8] ^ b[11:8]) | (a[11:8] & b[11:8] & c3[0]);\n    assign sum4 = (a[15:12] ^ b[15:12]) | (a[15:12] & b[15:12] & c4[0]);\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, rc, c);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] rc;\n    output [3:0] c;\n\n    assign {c[0], rc[0]} = a[0] + b[0] + cin;\n    assign {c[1], rc[1]} = a[1] + b[1] + c[0];\n    assign {c[2], rc[2]} = a[2] + b[2] + c[1];\n    assign {c[3], rc[3]} = a[3] + b[3] + c[2];\nendmodule\n"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] Co_i;\n    wire [7:0] y_i;\n    \n    // 8-bit adder instantiation\n    add8_inst1 add8_inst1_0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_i[0]),\n        .Co(Co_i[0])\n    );\n    add8_inst1 add8_inst1_1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_i[0]),\n        .y(y_i[1]),\n        .Co(Co_i[1])\n    );\n    \n    assign y = {y_i[1:0], y_i[1:0]};\n    assign Co = Co_i[1];\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] Co_i;\n    wire [3:0] y_i;\n    \n    // 4-bit adder instantiation\n    add4_inst1 add4_inst1_0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y_i[0]),\n        .Co(Co_i[0])\n    );\n    add4_inst1 add4_inst1_1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_i[0]),\n        .y(y_i[1]),\n        .Co(Co_i[1])\n    );\n    \n    assign y = {y_i[1:0], y_i[1:0]};\n    assign Co = Co_i[1];\nendmodule\n\nmodule add4_inst1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [1:0] Co_i;\n    wire [1:0] y_i;\n    \n    // 2-bit adder instantiation\n    add2_inst1 add2_inst1_0 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y_i[0]),\n        .Co(Co_i[0])\n    );\n    add2_inst1 add2_inst1_1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_i[0]),\n        .y(y_i[1]),\n        .Co(Co_i[1])\n    );\n    \n    assign y = {y_i[1:0], y_i[1:0]};\n    assign Co = Co_i[1];\nendmodule\n\nmodule add2_inst1 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[0] & b[0]) | (a[0] & Co) | (b[0] & Co);\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] cin_list = {1'b1, cin};\n    \n    assign sum = a ^ b ^ cin_list;\n    assign cout = (a & b) | (cin_list & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [31:0] ctrl_reg;\nwire [4:0] shift_count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl_reg <= 32'd0;\n    end else if (start) begin\n        ctrl_reg <= 32'd0;\n    end else begin\n        ctrl_reg <= {ctrl_reg[30:0], 1'b0};\n    end\nend\n\nassign shift_count = ctrl_reg[4:0];\n\n// Register Unit.\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Multiplier Unit.\nreg [31:0] product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n    end else if (start) begin\n        product <= {16'd0, reg_a};\n    end else begin\n        if (shift_count[4]) begin\n            product <= {product[30:0], reg_b[15]};\n        end else begin\n            product <= product + ({32{reg_b[shift_count]}} & product);\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = start & !rst_n;\n\nendmodule"}
