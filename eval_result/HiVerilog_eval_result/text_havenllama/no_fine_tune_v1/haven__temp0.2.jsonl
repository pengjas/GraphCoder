{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // counter_logic module\n    // ...\n\n    // counter_register module\n    // ...\n\nendmodule\n\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] u_counter_logic_out\n);\n\n    // ...\n\nendmodule\n\nmodule u_counter_register (\n    input wire [15:0] u_counter_logic_out,\n    input wire clk,\n    input wire reset,\n    output wire [15:0] u_counter_register_out\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            count_reg <= u_counter_logic_out;\n        end\n    end\n\n    assign u_counter_register_out = count_reg;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // State Initialization Submodule\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end else begin\n            init_out <= out;\n        end\n    end\n\n    // State Transition Submodule\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule instantiation\nJC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\nJC_logic logic_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'b0;\n    else\n        Q_reg <= Q_reg + 1;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'b0;\n    else\n        Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\nassign Q = Q_reg;\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_reg <= 0;\n    end else begin\n        CLK_50_reg <= ~CLK_50_reg;\n    end\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_reg <= 0;\n    end else begin\n        CLK_10_reg <= (CLK_10_reg == 3) ? 0 : CLK_10_reg + 1;\n    end\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_reg <= 0;\n    end else begin\n        CLK_1_reg <= (CLK_1_reg == 49) ? 0 : CLK_1_reg + 1;\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [MUL2_DIV_CLK:0] counter_out;\nwire clk_div_int1;\nwire clk_div_int2;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\nassign counter_out = counter;\n\n// Clock Average Generator Submodule\nreg [MUL2_DIV_CLK:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= counter_out;\n    end\nend\nassign clk_div_int1 = (clk_average[MUL2_DIV_CLK] & clk_average[MUL2_DIV_CLK-1]) |\n                      (clk_average[MUL2_DIV_CLK-1] & clk_average[MUL2_DIV_CLK-2]);\n\n// Clock Adjustment Submodule\nreg [MUL2_DIV_CLK:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= counter_out;\n    end\nend\nassign clk_div_int2 = (clk_adjustment[MUL2_DIV_CLK] & clk_adjustment[MUL2_DIV_CLK-1]) |\n                      (clk_adjustment[MUL2_DIV_CLK-1] & clk_adjustment[MUL2_DIV_CLK-2]);\n\n// Output\nassign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_edge_counter;\nreg [3:0] neg_edge_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_edge_counter == NUM_DIV - 1) begin\n        pos_edge_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_edge_counter <= pos_edge_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_edge_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_edge_counter == NUM_DIV - 1) begin\n        neg_edge_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_edge_counter <= neg_edge_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n\nparameter NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        clk_div <= ~clk_div;\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\nwire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\nwire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n\n// Addition\nadd add_inst(\n    .a(a),\n    .b(b),\n    .r(add_result),\n    .carry(add_carry),\n    .zero(add_zero)\n);\n\n// Subtraction\nsub sub_inst(\n    .a(a),\n    .b(b),\n    .r(sub_result),\n    .carry(sub_carry),\n    .zero(sub_zero)\n);\n\n// AND\nand and_inst(\n    .a(a),\n    .b(b),\n    .r(and_result),\n    .carry(and_carry),\n    .zero(and_zero)\n);\n\n// OR\nor or_inst(\n    .a(a),\n    .b(b),\n    .r(or_result),\n    .carry(or_carry),\n    .zero(or_zero)\n);\n\n// XOR\nxor xor_inst(\n    .a(a),\n    .b(b),\n    .r(xor_result),\n    .carry(xor_carry),\n    .zero(xor_zero)\n);\n\n// NOR\nnor nor_inst(\n    .a(a),\n    .b(b),\n    .r(nor_result),\n    .carry(nor_carry),\n    .zero(nor_zero)\n);\n\n// SLT\nslt slt_inst(\n    .a(a),\n    .b(b),\n    .r(slt_result),\n    .carry(slt_carry),\n    .zero(slt_zero)\n);\n\n// SLTU\nsltu sltu_inst(\n    .a(a),\n    .b(b),\n    .r(sltu_result),\n    .carry(sltu_carry),\n    .zero(sltu_zero)\n);\n\n// SLL\nsll sll_inst(\n    .a(a),\n    .b(b),\n    .r(sll_result),\n    .carry(sll_carry),\n    .zero(sll_zero)\n);\n\n// SRL\nsrl srl_inst(\n    .a(a),\n    .b(b),\n    .r(srl_result),\n    .carry(srl_carry),\n    .zero(srl_zero)\n);\n\n// SRA\nsra sra_inst(\n    .a(a),\n    .b(b),\n    .r(sra_result),\n    .carry(sra_carry),\n    .zero(sra_zero)\n);\n\n// SLLV\nsllv sllv_inst(\n    .a(a),\n    .b(b),\n    .r(sllv_result),\n    .carry(sllv_carry),\n    .zero(sllv_zero)\n);\n\n// SRLV\nsrlv srlv_inst(\n    .a(a),\n    .b(b),\n    .r(srlv_result),\n    .carry(srlv"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] m;\nwire [31:0] u_multiplier;\nwire [31:0] u_accumulator;\nreg [31:0] current_value;\n\n// Multiplier Submodule\nassign m = a * b;\nassign u_multiplier = m;\n\n// Accumulator Submodule\nassign u_accumulator = current_value + m;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= u_accumulator;\n    end\nend\n\nassign c = u_accumulator;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nassign c = a * b;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nreg [31:0] current_value;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + a;\n    end\nend\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for register source\n    reg [7:0] ins_p1_reg;\n    reg [7:0] ins_p2_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_p1_ram;\n    reg [7:0] ins_p2_ram;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 8'b0;\n            ins_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_ram <= 8'b0;\n            ins_p2_ram <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_ram <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_ram <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[7:0], ins_p2[7:0]};\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] freq_inv = (freq == 0) ? 0 : (8'd255 / freq);\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(count),\n    .freq(freq_inv),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    if (wave == 5'b00000) begin\n                        state_reg <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave == 5'b11111) begin\n                        state_reg <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    input [4:0] wave_inst,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state_inst)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        wave_reg <= wave_reg + 1;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        wave_reg <= wave_reg - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        q <= (sel == 2'b00) ? q1 :\n             (sel == 2'b01) ? q2 :\n             (sel == 2'b10) ? q3 :\n             d;\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    always @(posedge clk) begin\n        q <= (sel == 2'b00) ? q1 :\n             (sel == 2'b01) ? q2 :\n             (sel == 2'b10) ? q3 :\n             d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    my_dff dff1 (clk, d, q1);\n    my_dff dff2 (clk, q1, q2);\n    my_dff dff3 (clk, q2, q3);\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] shifted_in;\n    wire [2:0] sel;\n\n    assign sel = ctrl;\n\n    // Stage 1\n    assign mux_out[0] = in[0];\n    assign mux_out[1] = in[1];\n    assign mux_out[2] = in[2];\n    assign mux_out[3] = in[3];\n    assign mux_out[4] = in[4];\n    assign mux_out[5] = in[5];\n    assign mux_out[6] = in[6];\n    assign mux_out[7] = in[7];\n\n    assign shifted_in[0] = mux_out[0];\n    assign shifted_in[1] = mux_out[1];\n    assign shifted_in[2] = mux_out[2];\n    assign shifted_in[3] = mux_out[3];\n    assign shifted_in[4] = mux_out[4];\n    assign shifted_in[5] = mux_out[5];\n    assign shifted_in[6] = mux_out[6];\n    assign shifted_in[7] = mux_out[7];\n\n    // Stage 2\n    assign mux_out[0] = shifted_in[0];\n    assign mux_out[1] = shifted_in[1];\n    assign mux_out[2] = shifted_in[2];\n    assign mux_out[3] = shifted_in[3];\n    assign mux_out[4] = shifted_in[4];\n    assign mux_out[5] = shifted_in[5];\n    assign mux_out[6] = shifted_in[6];\n    assign mux_out[7] = shifted_in[7];\n\n    assign shifted_in[0] = mux_out[0];\n    assign shifted_in[1] = mux_out[1];\n    assign shifted_in[2] = mux_out[2];\n    assign shifted_in[3] = mux_out[3];\n    assign shifted_in[4] = mux_out[4];\n    assign shifted_in[5] = mux_out[5];\n    assign shifted_in[6] = mux_out[6];\n    assign shifted_in[7] = mux_out[7];\n\n    // Stage 3\n    assign mux_out[0] = shifted_in[0];\n    assign mux_out[1] = shifted_in[1];\n    assign mux_out[2] = shifted_in[2];\n    assign mux_out[3] = shifted_in[3];\n    assign mux_out[4] = shifted_in[4];\n    assign mux_out[5] = shifted_in[5];\n    assign mux_out[6] = shifted_in[6];\n    assign mux_out[7] = shifted_in[7];\n\n    assign shifted_in[0] = mux_out[0];\n    assign shifted_in[1] = mux_out[1];\n    assign shifted_in[2] = mux_out[2];\n    assign shifted_in[3] = mux_out[3];\n    assign shifted_in[4] = mux_out[4];\n    assign shifted_in[5] = mux_out[5];\n    assign shifted_in[6] = mux_out[6];\n    assign shifted_in[7] = mux_out[7];\n\n    // Stage 4\n    assign mux_out[0] = shifted_in[0];\n    assign mux_out[1] = shifted_in[1];\n    assign mux_out[2] = shifted_in[2];\n    assign mux_out[3] = shifted_in[3];\n    assign m"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rd;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [5:0] op;\n  wire [31:0] res_reg_file [0:31];\n\n  // Fetch stage\n  wire [31:0] fetch_stage_instr;\n  assign fetch_stage_instr = instr_mem[pc];\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= next_pc;\n    end\n  end\n  assign next_pc = pc + 1;\n\n  // Decode stage\n  wire [31:0] decode_stage_instr;\n  assign decode_stage_instr = fetch_stage_instr;\n  assign op = decode_stage_instr[31:26];\n  assign rs1 = decode_stage_instr[25:20];\n  assign rs2 = decode_stage_instr[19:14];\n  assign rd = decode_stage_instr[13:8];\n\n  // Execute stage\n  wire [31:0] execute_stage_instr;\n  assign execute_stage_instr = decode_stage_instr;\n  assign alu_res = (execute_stage_instr[31:26] == 6'b001000) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\n\n  // Memory stage\n  wire [31:0] memory_stage_instr;\n  assign memory_stage_instr = execute_stage_instr;\n  assign res_reg_file[rd] = alu_res;\n\n  // Writeback stage\n  wire [31:0] writeback_stage_instr;\n  assign writeback_stage_instr = memory_stage_instr;\n  assign res_reg_file[rd] = alu_res;\n\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch;\n    wire [31:0] execute;\n    wire [31:0] writeback;\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] reg_file_write_data;\n    wire [31:0] reg_file_write_addr;\n    wire [31:0] pc_write_data;\n    wire [31:0] pc_write_addr;\n    wire [31:0] pc_write_enable;\n    wire [31:0] pc_write_enable_writeback;\n    wire [31:0] pc_write_enable_fetch;\n    wire [31:0] pc_write_enable_execute;\n    wire [31:0] pc_write_enable_writeback_writeback;\n    wire [31:0] pc_write_enable_writeback_fetch;\n    wire [31:0] pc_write_enable_writeback_execute;\n\n    assign out_reg_file = reg_file_write_data;\n\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr(fetch)\n    );\n\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(fetch),\n        .op1(op1),\n        .op2(op2),\n        .result(execute)\n    );\n\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(execute),\n        .op1(op1),\n        .op2(op2),\n        .result(writeback),\n        .reg_file_write_data(reg_file_write_data),\n        .reg_file_write_addr(reg_file_write_addr)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n        end\n    end\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetch\n);\n\n    reg [31:0] pc_reg;\n    reg [31:0] instr_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc_reg <= 0;\n            instr_reg <= 0;\n        end else begin\n            pc_reg <= pc;\n            instr_reg <= instr_mem[pc_reg];\n        end\n    end\n\n    assign fetch = instr_reg;\n\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n\n    reg [31:0] op1_reg;\n    reg [31:0] op2_reg;\n    reg [31:0] result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1_reg <= 0;\n            op2_reg <= 0;\n            result_reg <= 0;\n        end else begin\n            op1_reg <= instr[25:20];\n            op2_reg <= instr[15:10];\n            result_reg <= 0;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result_reg <= 0;\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt == 3'd4) begin\n                cnt <= 3'd0;\n                valid_out_r <= 1'b1;\n            end else begin\n                cnt <= cnt + 1;\n                valid_out_r <= 1'b0;\n            end\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out_r <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_out_r <= data_out_r + data_in;\n        end\n    end\nend\n\n// Valid Output Module\nassign valid_out = valid_out_r;\nassign data_out = data_out_r;\n\nendmodule\n\n// Counter Module\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt_r == 3'd4) begin\n                cnt_r <= 3'd0;\n                valid_out_r <= 1'b1;\n            end else begin\n                cnt_r <= cnt_r + 1;\n                valid_out_r <= 1'b0;\n            end\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign cnt = cnt_r;\n\nendmodule\n\n// Data Accumulator Module\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_out_r;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out_r <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_out_r <= data_out_r + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_out_r;\n\nendmodule\n\n// Valid Output Module\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt_r == 3'd4) begin\n                cnt_r <= 3'd0"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg [0:7];\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg[0] <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (opn_valid && !res_ready) begin\n            counter <= 0;\n            shift_reg[0] <= abs_dividend;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (counter < 8) begin\n            counter <= counter + 1;\n            shift_reg[counter] <= shift_reg[counter-1] >> 1;\n            quotient <= quotient << 1;\n            remainder <= remainder << 1;\n            if (shift_reg[counter] >= neg_divisor) begin\n                shift_reg[counter] <= shift_reg[counter] - neg_divisor;\n                quotient <= quotient + 1;\n            end\n        end else begin\n            res_valid <= 1;\n            if (sign) begin\n                result <= -remainder;\n            end else begin\n                result <= remainder;\n            end\n        end\n    end\n\n    // Result Management\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (opn_valid && !res_ready) begin\n            res_valid <= 0;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [15:0] divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    // Perform division\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [4:0] counter;\n\n    // Shift dividend and divisor\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient_reg = 32'b0;\n        remainder_reg = 32'b0;\n        counter = 5'b0;\n    end\n\n    // Perform division\n    always @(*) begin\n        while (counter < 32) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                quotient_reg = quotient_reg << 1;\n                quotient_reg = quotient_reg | 1'b1;\n            end else begin\n                shifted_dividend = shifted_dividend;\n                quotient_reg = quotient_reg << 1;\n                quotient_reg = quotient_reg | 1'b0;\n            end\n            shifted_divisor = shifted_divisor << 1;\n            counter = counter + 1;\n        end\n        remainder_reg = shifted_dividend;\n    end\n\n    // Assign outputs\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [7:0] divisor;\n    reg [7:0] shifted_dividend;\n    reg [15:0] temp_dividend;\n    reg [15:0] temp_remainder;\n    reg [3:0] counter;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_odd;\n\n    // Control unit logic\n    always @(*) begin\n        divisor = B;\n        shifted_dividend = {8'b0, A[7:0]};\n        temp_dividend = A;\n        temp_remainder = 16'b0;\n        counter = 4'b0;\n        temp_quotient = 16'b0;\n        temp_odd = 16'b0;\n\n        while (counter < 16) begin\n            if (shifted_dividend[15:8] >= divisor) begin\n                temp_quotient[counter] = 1'b1;\n                temp_remainder = temp_remainder + divisor;\n            end\n            shifted_dividend = shifted_dividend - divisor;\n            counter = counter + 1;\n        end\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\nassign {B_out_temp, sum} = A + B_comp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : full_adder_loop\n        full_adder fa (\n            .A(A[i]),\n            .B(B_comp[i]),\n            .Cin(carry[i]),\n            .Sum(sum[i]),\n            .Cout(carry[i+1])\n        );\n    end\nendgenerate\n\nassign D = sum;\nassign B_out = B_out_temp;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\nassign {B_out_temp, sum} = A + B_comp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : full_adder_loop\n        full_adder fa (\n            .A(A[i]),\n            .B(B_comp[i]),\n            .Cin(carry[i]),\n            .Sum(sum[i]),\n            .Cout(carry[i+1])\n        );\n    end\nendgenerate\n\nassign D = sum;\nassign B_out = B_out_temp;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\nsub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[31:16]), .B_out(B_out));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff8), .B_out(B_out8));\nsub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[15:8]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff4), .B_out(B_out4));\nsub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff2), .B_out(B_out2));\nsub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(.A(A[0:0]), .B(B[0:0]), .Diff(Diff1), .B_out(B_out1));\nsub_1bit sub1_1(.A(A[1:1]), .B(B[1:1]), .Diff(Diff[1:1]), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput [0:0] A, B;\noutput [0:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A < B) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D_out;\n\nwire [1:1] B_out_1, B_out_2, B_out_3, B_out_4;\nwire [1:1] D_out_1, D_out_2, D_out_3, D_out_4;\n\nwire [1:1] B_out_1_1, B_out_2_1, B_out_3_1, B_out_4_1;\nwire [1:1] D_out_1_1, D_out_2_1, D_out_3_1, D_out_4_1;\n\nwire [1:1] B_out_1_2, B_out_2_2, B_out_3_2, B_out_4_2;\nwire [1:1] D_out_1_2, D_out_2_2, D_out_3_2, D_out_4_2;\n\nwire [1:1] B_out_1_3, B_out_2_3, B_out_3_3, B_out_4_3;\nwire [1:1] D_out_1_3, D_out_2_3, D_out_3_3, D_out_4_3;\n\nwire [1:1] B_out_1_4, B_out_2_4, B_out_3_4, B_out_4_4;\nwire [1:1] D_out_1_4, D_out_2_4, D_out_3_4, D_out_4_4;\n\nwire [1:1] B_out_1_5, B_out_2_5, B_out_3_5, B_out_4_5;\nwire [1:1] D_out_1_5, D_out_2_5, D_out_3_5, D_out_4_5;\n\nwire [1:1] B_out_1_6, B_out_2_6, B_out_3_6, B_out_4_6;\nwire [1:1] D_out_1_6, D_out_2_6, D_out_3_6, D_out_4_6;\n\nwire [1:1] B_out_1_7, B_out_2_7, B_out_3_7, B_out_4_7;\nwire [1:1] D_out_1_7, D_out_2_7, D_out_3_7, D_out_4_7;\n\nwire [1:1] B_out_1_8, B_out_2_8, B_out_3_8, B_out_4_8;\nwire [1:1] D_out_1_8, D_out_2_8, D_out_3_8, D_out_4_8;\n\nwire [1:1] B_out_1_9, B_out_2_9, B_out_3_9, B_out_4_9;\nwire [1:1] D_out_1_9, D_out_2_9, D_out_3_9, D_out_4_9;\n\nwire [1:1] B_out_1_10, B_out_2_10, B_out_3_10, B_out_4_10;\nwire [1:1] D_out_1_10, D_out_2_10, D_out_3_10, D_out_4_10;\n\nwire [1:1] B_out_1_11, B_out_2_11, B_out_3_11, B_out_4_11;\nwire [1:1] D_out_1_11, D_out_2_11, D_out_3_11, D_out_4_11;\n\nwire [1:1] B_out_1_12, B_out_2_12"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtraction operation\nassign sub_result = A - B;\nassign carry = (sub_result[31] == 1);\n\n// Carry generation\nassign A_greater = (sub_result != 0) && (carry == 0);\nassign A_equal = (sub_result == 0);\nassign A_less = (sub_result == 0) && (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum;\nwire [3:0] csa_slice2_sum;\nwire [3:0] csa_slice3_sum;\nwire [3:0] csa_slice1_cout;\nwire [3:0] csa_slice2_cout;\nwire [3:0] csa_slice3_cout;\nwire [3:0] rca1_sum;\nwire [3:0] rca2_sum;\nwire [3:0] rca3_sum;\nwire [3:0] rca1_cout;\nwire [3:0] rca2_cout;\nwire [3:0] rca3_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_carry;\nwire [3:0] rca2_carry;\nwire [3:0] rca3_carry;\n\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_carry = {rca1_sum[3], rca1_sum[2], rca1_sum[1], rca1_sum[0]};\nassign rca2_sum = a[7:4] + b[7:4] + rca1_carry[3];\nassign rca2_carry = {rca2_sum[3], rca2_sum[2], rca2_sum[1], rca2_sum[0]};\nassign rca3_sum = a[11:8] + b[11:8] + rca2_carry[3];\nassign rca3_carry = {rca3_sum[3], rca3_sum[2], rca3_sum[1], rca3_sum[0]};\n\n// 4-bit carry select adder slice\nwire [3:0] csa_slice1_carry;\nwire [3:0] csa_slice2_carry;\nwire [3:0] csa_slice3_carry;\n\nassign csa_slice1_carry[0] = rca1_carry[0];\nassign csa_slice1_carry[1] = rca1_carry[1];\nassign csa_slice1_carry[2] = rca1_carry[2];\nassign csa_slice1_carry[3] = rca1_carry[3];\n\nassign csa_slice2_carry[0] = rca2_carry[0];\nassign csa_slice2_carry[1] = rca2_carry[1];\nassign csa_slice2_carry[2] = rca2_carry[2];\nassign csa_slice2_carry[3] = rca2_carry[3];\n\nassign csa_slice3_carry[0] = rca3_carry[0];\nassign csa_slice3_carry[1] = rca3_carry[1];\nassign csa_slice3_carry[2] = rca3_carry[2];\nassign csa_slice3_carry[3] = rca3_carry[3];\n\nassign csa_slice1_sum = (cin == 1) ? a[3:0] : b[3:0];\nassign csa_slice2_sum = (cin == 1) ? a[7:4] : b[7:4];\nassign csa_slice3_sum = (cin == 1) ? a[11:8] : b[11:8];\n\nassign csa_slice1_cout = csa_slice1_carry[3];\nassign csa_slice2_cout = csa_slice2_carry[3];\nassign csa_slice3_cout = csa_slice3_carry[3];\n\nassign sum = {csa_slice3_sum, csa_slice2_sum, csa_slice1_sum};\nassign cout = csa_slice3_cout;\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder\n    // Replace the missing module with a simple 8-bit adder implementation\n    assign {Co7, y7} = a[7] + b[7] + Cin;\n    assign {Co6, y6} = a[6] + b[6] + Co7;\n    assign {Co5, y5} = a[5] + b[5] + Co6;\n    assign {Co4, y4} = a[4] + b[4] + Co5;\n    assign {Co3, y3} = a[3] + b[3] + Co4;\n    assign {Co2, y2} = a[2] + b[2] + Co3;\n    assign {Co1, y1} = a[1] + b[1] + Co2;\n    assign {Co0, y0} = a[0] + b[0] + Co1;\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co0;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n    \n    // FA0\n    assign {FA0_cout, FA0_sum} = a[0] + b[0] + cin;\n    \n    // FA1\n    assign {FA1_cout, FA1_sum} = a[1] + b[1] + FA0_cout;\n    \n    // FA2\n    assign {FA2_cout, FA2_sum} = a[2] + b[2] + FA1_cout;\n    \n    // FA3\n    assign {FA3_cout, FA3_sum} = a[3] + b[3] + FA2_cout;\n    \n    // FA4\n    assign {FA4_cout, FA4_sum} = a[4] + b[4] + FA3_cout;\n    \n    // FA5\n    assign {FA5_cout, FA5_sum} = a[5] + b[5] + FA4_cout;\n    \n    // FA6\n    assign {FA6_cout, FA6_sum} = a[6] + b[6] + FA5_cout;\n    \n    // FA7\n    assign {FA7_cout, FA7_sum} = a[7] + b[7] + FA6_cout;\n    \n    // sum\n    assign sum = FA7_sum;\n    \n    // cout\n    assign cout = FA7_cout;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_count == 4'b1111) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_count <= shift_count + 1'b1;\n                product <= product + (bin << shift_count);\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'b0;\n    end else begin\n        if (shift_count == 4'b0000) begin\n            m_reg <= b_reg;\n        end else begin\n            m_reg <= m_reg << 1;\n            if (a_reg[shift_count]) begin\n                m_reg <= m_reg + b_reg;\n            end\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_register_count)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule for state transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output logic\n    assign out = reset ? init_out : transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\n    else\n        count_r <= 4'b0000;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\n    else\n        out_r <= out_r;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\nend\n\n// Logic submodule\nwire [63:0] next_Q;\nassign next_Q = {Q_reg[62:0], ~Q_reg[63]};\nalways @(*) begin\n    Q = next_Q;\nend\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= D;\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         A,\n    output [63:0]        Q\n);\n\nassign Q = {A[62:0], ~A[63]};\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_reg <= 0;\n    end else begin\n        CLK_50_reg <= ~CLK_50_reg;\n    end\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_reg <= 0;\n    end else begin\n        CLK_10_reg <= (CLK_10_reg == 4) ? 0 : CLK_10_reg + 1;\n    end\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_reg <= 0;\n    end else begin\n        CLK_1_reg <= (CLK_1_reg == 49) ? 0 : CLK_1_reg + 1;\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [MUL2_DIV_CLK-1:0] clk_div_int;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK-1:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= {(MUL2_DIV_CLK){1'b0}};\n    else if (counter == {(MUL2_DIV_CLK){1'b1}})\n        counter <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        counter <= counter + 1'b1;\nend\n\n// Clock Average Generator Submodule\nreg [MUL2_DIV_CLK-1:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        clk_average <= {clk_average[MUL2_DIV_CLK-2:0], clk_average[MUL2_DIV_CLK-1]};\nend\n\n// Clock Adjustment Submodule\nreg [MUL2_DIV_CLK-1:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        clk_adjustment <= {clk_adjustment[MUL2_DIV_CLK-2:0], clk_adjustment[MUL2_DIV_CLK-1]};\nend\n\n// Clock Divider Submodule\nassign clk_div_int = counter[MUL2_DIV_CLK-1:0] + clk_average[MUL2_DIV_CLK-1:0] + clk_adjustment[MUL2_DIV_CLK-1:0];\nassign clk_div = |clk_div_int;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_cnt <= 0;\n        clk_div1 <= 0;\n    end else if (pos_cnt < NUM_DIV - 1) begin\n        pos_cnt <= pos_cnt + 1;\n        clk_div1 <= 0;\n    end else begin\n        pos_cnt <= 0;\n        clk_div1 <= 1;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_cnt <= 0;\n        clk_div2 <= 0;\n    end else if (neg_cnt < NUM_DIV - 1) begin\n        neg_cnt <= neg_cnt + 1;\n        clk_div2 <= 0;\n    end else begin\n        neg_cnt <= 0;\n        clk_div2 <= 1;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nwire [3:0] counter_out;\nwire clk_div_out;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 4'b0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        counter <= 4'b0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\nassign counter_out = counter;\n\n// Clock Divider Submodule\nreg clk_div_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_reg <= 1'b0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        clk_div_reg <= ~clk_div_reg;\n    end\nend\nassign clk_div_out = clk_div_reg;\n\nassign clk_div = clk_div_out;\n\nendmodule\n\n\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    wire [31:0] nor_result;\n    wire [31:0] slt_result;\n    wire [31:0] sltu_result;\n    wire [31:0] sll_result;\n    wire [31:0] srl_result;\n    wire [31:0] sra_result;\n    wire [31:0] sllv_result;\n    wire [31:0] srlv_result;\n    wire [31:0] srav_result;\n    wire [31:0] lui_result;\n\n    // Addition\n    assign add_result = a + b;\n    assign carry = add_result[32];\n    assign zero = (add_result == 0);\n    assign negative = add_result[31];\n    assign overflow = (a[31] == b[31] && add_result[31] != a[31]);\n\n    // Subtraction\n    assign sub_result = a - b;\n    assign carry = sub_result[32];\n    assign zero = (sub_result == 0);\n    assign negative = sub_result[31];\n    assign overflow = (a[31] != b[31] && sub_result[31] != a[31]);\n\n    // Logical operations\n    assign and_result = a & b;\n    assign or_result = a | b;\n    assign xor_result = a ^ b;\n    assign nor_result = ~(a | b);\n\n    // Bitwise operations\n    assign sll_result = a << b[4:0];\n    assign srl_result = a >> b[4:0];\n    assign sra_result = $signed(a) >>> b[4:0];\n    assign sllv_result = a << b;\n    assign srlv_result = a >> b;\n    assign srav_result = $signed(a) >>> b;\n\n    // Shift operations\n    assign lui_result = {b[15:0], 16'b0};\n\n    // Select the operation\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result :\n               32'b0;\n\n    // Set the flag\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? s"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] multiplication_result;\nassign multiplication_result = a * b;\n\n// Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + multiplication_result[31:0];\n    end\nend\n\n// Connecting the submodules\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Submodule 1\n    reg [7:0] ins_p1_reg;\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data;\n        end\n    end\n    assign ins_p1 = ins_p1_reg;\n\n    // Submodule 2\n    reg [7:0] ins_p2_reg;\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data;\n        end\n    end\n    assign ins_p2 = ins_p2_reg;\n\n    // Output\n    assign ins = {ins_p1[7:5], ins_p2[7:5]};\n    assign ad1 = {ins_p1[4:0], ins_p2[4:0]};\n    assign ad2 = {ins_p1[3:0], ins_p2[3:0]};\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] freq_inv = 8'hFF / freq;\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(count),\n    .freq(freq_inv),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    always @(posedge clk) begin\n        q <= dff_out[sel];\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] shifted_in;\n    wire [2:0] sel;\n\n    assign sel = ctrl;\n\n    // Stage 1\n    assign mux_out[7:4] = (sel[2]) ? in[7:4] : in[3:0];\n    assign mux_out[3:0] = (sel[2]) ? in[3:0] : in[7:4];\n    assign shifted_in = mux_out;\n\n    // Stage 2\n    assign mux_out[7:4] = (sel[1]) ? shifted_in[7:4] : shifted_in[3:0];\n    assign mux_out[3:0] = (sel[1]) ? shifted_in[3:0] : shifted_in[7:4];\n    assign shifted_in = mux_out;\n\n    // Stage 3\n    assign mux_out[7:4] = (sel[0]) ? shifted_in[7:4] : shifted_in[3:0];\n    assign mux_out[3:0] = (sel[0]) ? shifted_in[3:0] : shifted_in[7:4];\n    assign out = mux_out;\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  reg [31:0] pc;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_res(alu_res),\n    .pc(pc)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_res(alu_res),\n    .pc(pc)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_res(alu_res),\n    .pc(pc)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_res(alu_res),\n    .pc(pc)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_res(alu_res),\n    .pc(pc)\n  );\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31],\n  output [31:0] alu_res,\n  output [31:0] pc\n);\n  reg [31:0] pc_reg;\n  reg [31:0] alu_res_reg;\n  reg [31:0] res_reg_file_reg [0:31];\n  reg [31:0] instr_reg;\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc_reg <= 32'h00000000;\n      alu_res_reg <= 32'h00000000;\n      res_reg_file_reg <= 32'h00000000;\n      instr_reg <= 32'h00000000;\n      rs1_reg <= 5'h00;\n      rs2_reg <= 5'h00;\n      rd_reg <= 5'h00;\n      op_reg <= 6'h00;\n    end else begin\n      pc_reg <= pc_reg + 32'h00000004;\n      instr_reg <= instr_mem[pc_reg];\n      rs1_reg <= instr_reg[31:27];\n      rs2_reg <= instr_reg[26:22];\n      rd_reg <= instr_reg[21:17];\n      op_reg <= instr_reg[16:12];\n      if (op_reg == 6'b000000) begin\n        alu_res_reg <= reg_file[rs1_reg] + reg_file[rs2_reg];\n      end else if (op_reg == 6'b010000) begin\n        alu_res_reg <= reg"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 16'd0;\n      b1_reg <= 16'd0;\n      b2_reg <= 16'd0;\n      b3_reg <= 16'd0;\n      c0_reg <= 32'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [4:0] rs;\n    wire [4:0] rt;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] operand1;\n    wire [31:0] operand2;\n    wire [31:0] result;\n\n    assign pc = 0;\n    assign instr = instr_mem[pc];\n    assign opcode = instr[31:26];\n    assign funct = instr[5:0];\n    assign rs = instr[25:21];\n    assign rt = instr[20:16];\n    assign rd = instr[15:11];\n    assign operand1 = reg_file[rs];\n    assign operand2 = reg_file[rt];\n    assign result = (opcode == 6'b000000) ? operand1 + operand2 : operand1 - operand2;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file <= result;\n        end\n    end\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt == 3'd3) begin\n                cnt <= 3'd0;\n                valid_out_r <= 1'b1;\n            end else begin\n                cnt <= cnt + 1'b1;\n                valid_out_r <= 1'b0;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\nend\n\n// Valid Output Module\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (cnt_r == 3'd3) begin\n            cnt_r <= 3'd0;\n            valid_out_r <= 1'b1;\n        end else begin\n            cnt_r <= cnt_r + 1'b1;\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign cnt = cnt_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [2:0]   cnt,\n\n    output              valid_out\n);\n\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 1'b0;\n    end else begin\n        if (cnt == 3'd3) begin\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [3:0] counter;\n    reg [15:0] shift_reg;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Calculate absolute value of dividend\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            abs_dividend <= 8'd0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Calculate negative value of divisor\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            neg_divisor <= 8'd0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Divide dividend by divisor\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 16'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid && !res_ready) begin\n            counter <= counter + 4'd1;\n            shift_reg <= {shift_reg[14:0], abs_dividend[7:0]};\n            quotient <= quotient + (shift_reg[15] ? 16'd1 : 16'd0);\n            remainder <= shift_reg[15:8];\n        end\n    end\n\n    // Output result\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end else if (opn_valid && res_ready) begin\n            res_valid <= 1'b1;\n            result <= {remainder, quotient};\n        end else begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [31:0] divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A, 16'b0};\n    assign divisor = {B, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    // Perform division\n    assign quotient = dividend >> divisor;\n    assign remainder = dividend % divisor;\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [7:0] divisor;\n    reg [7:0] dividend;\n    reg [3:0] counter;\n    reg [3:0] shift;\n    reg [3:0] i;\n\n    // Control logic\n    always @(*) begin\n        divisor = B;\n        dividend = A;\n        counter = 0;\n        shift = 0;\n        quotient = 0;\n        remainder = 0;\n\n        // Shift dividend\n        for (i = 0; i < 16; i = i + 1) begin\n            if (counter == 0) begin\n                shift = shift + 1;\n                counter = 1;\n            end else begin\n                counter = counter - 1;\n            end\n\n            if (shift == 0) begin\n                remainder = {dividend[15], dividend[15:1]};\n                dividend = remainder;\n            end else begin\n                remainder = {dividend[15], dividend[15:1]};\n                dividend = {remainder[15], remainder[15:1]};\n            end\n\n            if (remainder[7:0] >= divisor) begin\n                quotient = quotient + (1 << (15 - i));\n                remainder = remainder - divisor;\n            end\n        end\n    end\n\n    // Output\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {B_out, sum} = A + B_comp;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_1(A[31:16], B[31:16], Diff16, B_out16);\nsub_16bit sub16_2(A[15:0], B[15:0], Diff[15:0], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_1(A[15:8], B[15:8], Diff8, B_out8);\nsub_8bit sub8_2(A[7:0], B[7:0], Diff[7:0], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_1(A[7:4], B[7:4], Diff4, B_out4);\nsub_4bit sub4_2(A[3:0], B[3:0], Diff[3:0], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_1(A[3:2], B[3:2], Diff2, B_out2);\nsub_2bit sub2_2(A[1:0], B[1:0], Diff[1:0], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_1(A[1:1], B[1:1], Diff1, B_out1);\nsub_1bit sub1_2(A[0:0], B[0:0], Diff[0:0], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A < B) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D_out;\nwire [3:1] A_out;\nwire [3:1] B_out_out;\nwire [3:1] D_out_out;\nwire [3:1] A_out_out;\n\n// BLS_4bit_subtractor\nsub_4bit sub1 (.A(A[16:1]), .B(B[16:1]), .D(D_out), .B_out(B_out));\nsub_4bit sub2 (.A(A[12:4]), .B(B[12:4]), .D(D_out), .B_out(B_out));\nsub_4bit sub3 (.A(A[8:8]), .B(B[8:8]), .D(D_out), .B_out(B_out));\nsub_4bit sub4 (.A(A[4:4]), .B(B[4:4]), .D(D_out), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [4:1] A, B;\noutput [4:1] D;\noutput B_out;\n\nwire [2:1] B_out;\nwire [2:1] D_out;\nwire [2:1] A_out;\nwire [2:1] B_out_out;\nwire [2:1] D_out_out;\nwire [2:1] A_out_out;\n\n// BLS_2bit_subtractor\nsub_2bit sub1 (.A(A[4:2]), .B(B[4:2]), .D(D_out), .B_out(B_out));\nsub_2bit sub2 (.A(A[2:2]), .B(B[2:2]), .D(D_out), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [2:1] A, B;\noutput [2:1] D;\noutput B_out;\n\nwire [1:1] B_out;\nwire [1:1] D_out;\nwire [1:1] A_out;\nwire [1:1] B_out_out;\nwire [1:1] D_out_out;\nwire [1:1] A_out_out;\n\n// BLS_1bit_subtractor\nsub_1bit sub1 (.A(A[2:1]), .B(B[2:1]), .D(D_out), .B_out(B_out));\nsub_1bit sub2 (.A(A[1:1]), .B(B[1:1]), .D(D_out), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput [1:1] A, B;\noutput [1:1] D;\noutput B_out;\n\nwire B_out;\nwire D_out;\nwire A_out;\nwire B_out_out;\nwire D_out_out;\nwire A_out_out;\n\n// BLS_1bit_subtractor\nassign D_out = A ^ B;\nassign B_out = (A & B) | (~A & ~B);\n\nendmodule\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire borrow;\n\n// Subtraction operation\nassign subtraction_result = A - B;\nassign borrow = (A[31] == B[31]) && (A[31] == subtraction_result[31]);\n\n// Carry generation\nassign A_greater = (subtraction_result != 0) && (borrow == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (subtraction_result == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtraction_result, \n    output borrow     \n);\n\nassign subtraction_result = A - B;\nassign borrow = (A[31] == B[31]) && (A[31] == subtraction_result[31]);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[32] ^ B[32]) | (A[31] & B[31]) | (A[30] & B[30]) | (A[29] & B[29]) | (A[28] & B[28]) | (A[27] & B[27]) | (A[26] & B[26]) | (A[25] & B[25]) | (A[24] & B[24]) | (A[23] & B[23]) | (A[22] & B[22]) | (A[21] & B[21]) | (A[20] & B[20]) | (A[19] & B[19]) | (A[18] & B[18]) | (A[17] & B[17]) | (A[16] & B[16]);\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit ripple carry adder\nwire [3:0] a_slices, b_slices, carry_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign carry_slices[0] = cin;\nassign carry_slices[1] = a_slices[0] & b_slices[0];\nassign carry_slices[2] = a_slices[1] & b_slices[1];\nassign carry_slices[3] = a_slices[2] & b_slices[2];\nassign sum_slices[0] = a_slices[0] ^ b_slices[0];\nassign sum_slices[1] = a_slices[1] ^ b_slices[1];\nassign sum_slices[2] = a_slices[2] ^ b_slices[2];\nassign sum_slices[3] = a_slices[3] ^ b_slices[3];\nassign carry[0] = carry_slices[0];\nassign carry[1] = carry_slices[1] | (a_slices[0] & b_slices[0]) | (a_slices[1] & b_slices[1]);\nassign carry[2] = carry_slices[2] | (a_slices[2] & b_slices[2]) | (a_slices[1] & b_slices[1]) | (a_slices[0] & b_slices[0]);\nassign carry[3] = carry_slices[3] | (a_slices[3] & b_slices[3]) | (a_slices[2] & b_slices[2]) | (a_slices[1] & b_slices[1]) | (a_slices[0] & b_slices[0]);\nassign sum = {sum_slices[3], sum_slices[2], sum_slices[1], sum_slices[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit carry select adder slice\nwire [3:0] a_slices, b_slices, carry_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign carry_slices[0] = cin;\nassign carry_slices[1] = a_slices[0] & b_slices[0];\nassign carry_slices[2] = a_slices[1] & b_slices[1];\nassign carry_slices[3] = a_slices[2] & b_slices[2];\nassign sum_slices[0] = a_slices[0] ^ b_slices[0];\nassign sum_slices[1] = a_slices[1] ^ b_slices[1];\nassign sum_slices[2] = a_slices[2] ^ b_slices[2];\nassign sum_slices[3] = a_slices[3] ^ b_slices[3];\nassign carry[0] = carry_slices[0];\nassign carry[1] = carry_slices[1] | (a_slices[0] & b_slices[0]) | (a_slices[1] & b_slices[1]);\nassign carry[2] = carry_slices[2] | (a_slices[2] & b_slices[2]) | (a_slices[1] & b_slices[1]) | (a_slices[0] & b_slices[0]);\nassign carry[3] = carry_slices[3] | (a_s"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_8bit;\n    wire [7:0] y_8bit;\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8bit),\n        .Co(Co_8bit)\n    );\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    assign y = {y_8bit, y[15:8]};\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] Co_4bit;\n    wire [3:0] y_4bit;\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y_4bit),\n        .Co(Co_4bit)\n    );\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_4bit),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\n    assign y = {y_4bit, y[7:4]};\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    \n    // FA0\n    assign FA0 = a[0] ^ b[0] ^ cin;\n    assign sum[0] = FA0;\n    assign cout = a[0] & b[0] | a[0] & cin | b[0] & cin;\n    \n    // FA1\n    assign FA1 = a[1] ^ b[1] ^ FA0;\n    assign sum[1] = FA1;\n    assign cout = a[1] & b[1] | a[1] & FA0 | b[1] & FA0;\n    \n    // FA2\n    assign FA2 = a[2] ^ b[2] ^ FA1;\n    assign sum[2] = FA2;\n    assign cout = a[2] & b[2] | a[2] & FA1 | b[2] & FA1;\n    \n    // FA3\n    assign FA3 = a[3] ^ b[3] ^ FA2;\n    assign sum[3] = FA3;\n    assign cout = a[3] & b[3] | a[3] & FA2 | b[3] & FA2;\n    \n    // FA4\n    assign FA4 = a[4] ^ b[4] ^ FA3;\n    assign sum[4] = FA4;\n    assign cout = a[4] & b[4] | a[4] & FA3 | b[4] & FA3;\n    \n    // FA5\n    assign FA5 = a[5] ^ b[5] ^ FA4;\n    assign sum[5] = FA5;\n    assign cout = a[5] & b[5] | a[5] & FA4 | b[5] & FA4;\n    \n    // FA6\n    assign FA6 = a[6] ^ b[6] ^ FA5;\n    assign sum[6] = FA6;\n    assign cout = a[6] & b[6] | a[6] & FA5 | b[6] & FA5;\n    \n    // FA7\n    assign FA7 = a[7] ^ b[7] ^ FA6;\n    assign sum[7] = FA7;\n    assign cout = a[7] & b[7] | a[7] & FA6 | b[7] & FA6;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1;\n                product <= product + (bin << shift_cnt);\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            m_reg <= b_reg;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // counter_logic module\n    // ...\n\n    // counter_register module\n    // ...\n\n    assign count = u_counter_register_out;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    // Initializes the counter to its starting state.\n    // The counter starts with the least significant bit (LSB) set to 1.\n    //\n    // Ports:\n    //   clk: Clock signal that drives the state transitions of the ring counter.\n    //   reset: Reset signal to initialize the counter to its starting state.\n    //\n    // Output:\n    //   out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //   out[0] = 1;\n    //\n    // Initialization:\n    //   out = 8'b0000_0001;\n\n    // Submodule: Transition\n    // Handles the cyclic behavior of the ring counter.\n    //\n    // Ports:\n    //   clk: Clock signal that drives the state transitions of the ring counter.\n    //   reset: Reset signal to initialize the counter to its starting state.\n    //\n    // Output:\n    //   out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //   out[0] = 1;\n    //\n    // State Transition:\n    //   out[0] = out[0] ^ out[1];\n    //   out[1] = out[1] ^ out[2];\n    //   out[2] = out[2] ^ out[3];\n    //   out[3] = out[3] ^ out[4];\n    //   out[4] = out[4] ^ out[5];\n    //   out[5] = out[5] ^ out[6];\n    //   out[6] = out[6] ^ out[7];\n    //   out[7] = out[7] ^ out[0];\n\n    // Submodule: Ring Counter\n    // Implements the ring counter functionality.\n    //\n    // Ports:\n    //   clk: Clock signal that drives the state transitions of the ring counter.\n    //   reset: Reset signal to initialize the counter to its starting state.\n    //\n    // Output:\n    //   out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //   out[0] = 1;\n    //\n    // Initialization:\n    //   out = 8'b0000_0001;\n    //\n    // State Transition:\n    //   out[0] = out[0] ^ out[1];\n    //   out[1] = out[1] ^ out[2];\n    //   out[2] = out[2] ^ out[3];\n    //   out[3] = out[3] ^ out[4];\n    //   out[4] = out[4] ^ out[5];\n    //   out[5] = out[5] ^ out[6];\n    //   out[6] = out[6] ^ out[7];\n    //   out[7] = out[7] ^ out[0];\n\nendmodule\n\nmodule submodule_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\nmodule submodule_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out[0] <= out[0] ^ out[1];\n            out[1] <= out[1] ^ out[2];\n            out[2] <= out[2] ^ out[3];\n            out[3] <= out[3] ^ out[4];\n            out[4] <= out[4] ^ out[5];\n            out[5] <= out[5] ^ out[6];\n            out[6] <= out[6] ^ out[7];\n            out[7] <= out["}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_next;\n\nassign count = count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_next <= 4'b0000;\n    else if (valid_count)\n        count_next <= count + 1;\nend\n\nendmodule\n\nmodule\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'b0000;\n    else if (valid_count)\n        count <= count + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= in;\nend\n\nassign out = out_reg;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] reg_inst;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) reg_inst <= 64'b0;\n    else reg_inst <= {reg_inst[62:0], reg_inst[63]};\nend\n\n// Logic submodule\nwire [63:0] logic_inst;\nassign logic_inst = {reg_inst[62:0], reg_inst[63]};\n\n// Output\nassign Q = logic_inst;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= D;\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         A,\n    output [63:0]        B\n);\n\nassign B = {A[62:0], A[63]};\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_reg <= 0;\n    end else begin\n        CLK_50_reg <= ~CLK_50_reg;\n    end\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_reg <= 0;\n    end else begin\n        CLK_10_reg <= (CLK_10_reg == 3) ? 0 : CLK_10_reg + 1;\n    end\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_reg <= 0;\n    end else begin\n        CLK_1_reg <= (CLK_1_reg == 49) ? 0 : CLK_1_reg + 1;\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == MUL2_DIV_CLK - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= {clk_average[2:0], counter[0]};\n    end\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= {clk_adjustment[2:0], counter[0]};\n    end\nend\n\n// Final Clock Output\nassign clk_div_int = clk_average | clk_adjustment;\nassign clk_div = |clk_div_int;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   counter\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == MUL2_DIV_CLK - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [3:0]         clk_div,\n    output reg  [3:0]   clk_average\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= {clk_average[2:0], clk_div[0]};\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [3:0]         clk_div,\n    output reg  [3:0]   clk_adjustment\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= {clk_adjustment[2:0], clk_div[0]};\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nwire clk_div_divider;\nreg [3:0] counter;\n\nassign clk_div = clk_div_divider;\n\n// Counter Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == (NUM_DIV / 2 - 1))\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Clock Divider Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div_divider <= 0;\n    else if (counter == (NUM_DIV / 2 - 1))\n        clk_div_divider <= ~clk_div_divider;\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\nwire [31:0] add_result_zero, sub_result_zero, and_result_zero, or_result_zero, xor_result_zero, nor_result_zero, slt_result_zero, sltu_result_zero, sll_result_zero, srl_result_zero, sra_result_zero, sllv_result_zero, srlv_result_zero, srav_result_zero, lui_result_zero;\nwire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\nwire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\nwire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\nwire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\nassign r = aluc[5:0] == 6'b000000 ? sllv_result :\n           aluc[5:0] == 6'b000010 ? srlv_result :\n           aluc[5:0] == 6'b000011 ? srav_result :\n           aluc[5:0] == 6'b000100 ? sll_result :\n           aluc[5:0] == 6'b000110 ? srl_result :\n           aluc[5:0] == 6'b000111 ? sra_result :\n           aluc[5:0] == 6'b001000 ? add_result :\n           aluc[5:0] == 6'b001001 ? sub_result :\n           aluc[5:0] == 6'b001010 ? and_result :\n           aluc[5:0] == 6'b001011 ? or_result :\n           aluc[5:0] == 6'b001100 ? xor_result :\n           aluc[5:0] == 6'b001101 ? nor_result :\n           aluc[5:0] == 6'b001110 ? slt_result :\n           aluc[5:0] == 6'b001111 ? sltu_result :\n           aluc[5:0] == 6'b010000 ? lui_result : 32'b0;\n\nassign zero = aluc[5:0] == 6'b000000 ? sllv_result_zero :\n              aluc[5:0] == 6'b000010 ? srlv_result_zero :\n              aluc[5:0] == 6'b000011 ? srav_result_zero :\n              aluc[5:0] == 6'b000100 ? sll_result_zero :\n              aluc[5"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [31:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] accumulator_value;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_value <= 0;\n        end else begin\n            accumulator_value <= accumulator_value + multiplication_result;\n        end\n    end\n    assign current_value = accumulator_value;\n\n    // Connecting the submodules\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] multiplication_result\n);\n\n    reg [31:0] a_reg;\n    reg [31:0] b_reg;\n    reg [63:0] multiplication_result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            a_reg <= 0;\n            b_reg <= 0;\n            multiplication_result_reg <= 0;\n        end else begin\n            a_reg <= a;\n            b_reg <= b;\n            multiplication_result_reg <= a_reg * b_reg;\n        end\n    end\n\n    assign multiplication_result = multiplication_result_reg;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [31:0] multiplication_result,\n    output [31:0] current_value\n);\n\n    reg [31:0] current_value_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value_reg <= 0;\n        end else begin\n            current_value_reg <= current_value_reg + multiplication_result;\n        end\n    end\n\n    assign current_value = current_value_reg;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Submodule for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n            ad1_p1_reg <= data[4:0];\n            ad2_p1_reg <= data;\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n\n    // Submodule for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data[7:5];\n            ad1_p2_reg <= data[4:0];\n            ad2_p2_reg <= data;\n        end\n    end\n\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = fetch == 2'b01 ? ins_p1 : ins_p2;\n    assign ad1 = fetch == 2'b01 ? ad1_p1 : ad1_p2;\n    assign ad2 = fetch == 2'b01 ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\nwire [7:0] next_count;\nassign next_count = (count + 1) % freq;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nend\n\nassign wave_out = (count == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                end\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    assign q = (sel == 2'b00) ? d : (sel == 2'b01) ? dff_out[0] : (sel == 2'b10) ? dff_out[1] : dff_out[2];\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    // Instantiate D flip-flop module\n    my_dff dff0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3 = (ctrl[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n\n    assign out = stage3;\n\n    // MUX2X1\n    module mux2X1 (sel, in1, in2, out);\n        input sel;\n        input in1, in2;\n        output out;\n\n        assign out = sel ? in2 : in1;\n    endmodule\nendmodule\n\n```\n\n### 2.2.2. 8-bit Barrel Shifter with 3-bit Control Signal\n\n```verilog\n`timescale 1ns / 1ps\n\nmodule barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3 = (ctrl[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n\n    assign out = stage3;\n\n    // MUX2X1\n    module mux2X1 (sel, in1, in2, out);\n        input sel;\n        input in1, in2;\n        output out;\n\n        assign out = sel ? in2 : in1;\n    endmodule\nendmodule\n\n```\n\n### 2.2.3. 8-bit Barrel Shifter with 4-bit Control Signal\n\n```verilog\n`timescale 1ns / 1ps\n\nmodule barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [3:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3, stage4;\n\n    // Stage 1\n    assign stage1 = (ctrl[3]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[2]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3 = (ctrl[1]) ? {stage2[3:0], stage2[7:4]} : stage2;\n    assign stage4 = (ctrl[0]) ? {stage3[3:0], stage3[7:4]} : stage3;\n\n    assign out = stage4;\n\n    // MUX2X1\n    module mux2X1 (sel, in1, in2, out);\n        input sel;\n        input in1, in2;\n        output out;\n\n        assign out = sel ? in2 : in1;\n    endmodule\nendmodule\n\n```\n\n## 2.3. 8-bit Barrel Shifter with 5-bit Control Signal\n\n```verilog\n`timescale 1ns / 1ps\n\nmodule barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [4:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3, stage4, stage5;\n\n    // Stage 1\n    assign stage1 = (ctrl[4]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[3]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rd;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [5:0] op;\n  wire [31:0] alu_in1;\n  wire [31:0] alu_in2;\n  wire [31:0] alu_in3;\n  wire [31:0] alu_in4;\n  wire [31:0] alu_in5;\n  wire [31:0] alu_in6;\n  wire [31:0] alu_in7;\n  wire [31:0] alu_in8;\n  wire [31:0] alu_in9;\n  wire [31:0] alu_in10;\n  wire [31:0] alu_in11;\n  wire [31:0] alu_in12;\n  wire [31:0] alu_in13;\n  wire [31:0] alu_in14;\n  wire [31:0] alu_in15;\n  wire [31:0] alu_in16;\n  wire [31:0] alu_in17;\n  wire [31:0] alu_in18;\n  wire [31:0] alu_in19;\n  wire [31:0] alu_in20;\n  wire [31:0] alu_in21;\n  wire [31:0] alu_in22;\n  wire [31:0] alu_in23;\n  wire [31:0] alu_in24;\n  wire [31:0] alu_in25;\n  wire [31:0] alu_in26;\n  wire [31:0] alu_in27;\n  wire [31:0] alu_in28;\n  wire [31:0] alu_in29;\n  wire [31:0] alu_in30;\n  wire [31:0] alu_in31;\n  wire [31:0] alu_in32;\n  wire [31:0] alu_in33;\n  wire [31:0] alu_in34;\n  wire [31:0] alu_in35;\n  wire [31:0] alu_in36;\n  wire [31:0] alu_in37;\n  wire [31:0] alu_in38;\n  wire [31:0] alu_in39;\n  wire [31:0] alu_in40;\n  wire [31:0] alu_in41;\n  wire [31:0] alu_in42;\n  wire [31:0] alu_in43;\n  wire [31:0] alu_in44;\n  wire [31:0] alu_in45;\n  wire [31:0] alu_in46;\n  wire [31:0] alu_in47;\n  wire [31:0] alu_in48;\n  wire [31:0] alu_in49;\n  wire [31:0] alu_in50;\n  wire [31:0] alu_in51;\n  wire [31:0] alu_in52;\n  wire [31:0] alu_in53;\n  wire [31:0] alu_in54;\n  wire [31:0] alu_in55;\n  wire [31:0] alu_in56;\n  wire [31:0] alu_in57;\n  wire [31:0] alu_in58;\n  wire [31:0] alu_in59;\n  wire [31:0] al"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 16'b0;\n      b1_reg <= 16'b0;\n      b2_reg <= 16'b0;\n      b3_reg <= 16'b0;\n      c0_reg <= 32'b0;\n      c1_reg <= 32'b0;\n      c2_reg <= 32'b0;\n      c3_reg <= 32'b0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] op;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n    wire [31:0] reg_file_out;\n\n    assign out_reg_file = writeback_out;\n\n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out(fetch_out)\n    );\n\n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out(execute_out)\n    );\n\n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out(writeback_out)\n    );\n\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out\n);\n\n    reg [31:0] out_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg <= 0;\n        end else begin\n            out_reg <= instr_mem[pc];\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out\n);\n\n    reg [31:0] out_reg;\n    reg [4:0] pc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n            out_reg <= 0;\n        end else begin\n            pc <= pc + 1;\n            out_reg <= instr_mem[pc];\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out\n);\n\n    reg [31:0] out_reg;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [5:0] op;\n    reg [31:0] imm;\n    reg [31:0] alu_out;\n    reg [31:0] reg_file_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            op <= 0;\n            imm <= 0;\n            alu_out <= 0;\n            reg_file_out <= 0;\n            out_reg <= 0;\n        end else begin\n            {rd, rs1, rs2, op, imm} = out;\n            reg_file_out = reg_file[rs1];\n            case (op)\n                6'b000000: alu_out = reg_file_out + imm;\n                6'b000010: alu_out = reg_file_out - imm;\n                default:"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n/*----------------------------------------------------------------------------\nModule references\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\nParameter declarations\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\nLocal signal declarations\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\nCounter Module\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\nData Accumulator Module\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\nValid Output Module\n----------------------------------------------------------------------------*/\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [15:0] abs_dividend;\n    wire [15:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n\n    assign abs_dividend = (sign) ? -dividend : dividend;\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    // Implement submodules here\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [15:0] divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = {B, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    // Perform division operation\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n    reg [15:0] quotient_bit;\n    reg [15:0] remainder_bit;\n    reg [15:0] i;\n\n    always @(*) begin\n        // Initialize quotient and remainder\n        quotient_reg = 32'b0;\n        remainder_reg = 32'b0;\n\n        // Shift dividend and divisor\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n\n        // Perform division\n        for (i = 0; i < 16; i = i + 1) begin\n            // Shift dividend and divisor\n            shifted_dividend = shifted_dividend << 1;\n            shifted_divisor = shifted_divisor << 1;\n\n            // Compare dividend and divisor\n            if (shifted_dividend >= shifted_divisor) begin\n                // Set quotient bit\n                quotient_bit = 16'b1;\n\n                // Subtract divisor from dividend\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                // Set quotient bit\n                quotient_bit = 16'b0;\n            end\n\n            // Set quotient and remainder\n            quotient_reg[i] = quotient_bit;\n            remainder_reg[i] = remainder_bit;\n        end\n    end\n\n    // Assign outputs\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [7:0] divisor;\n    reg [15:0] dividend;\n    reg [3:0] counter;\n\n    always @(*) begin\n        // Initialize variables\n        quotient = 16'b0;\n        remainder = 16'b0;\n        divisor = B;\n        dividend = A;\n        counter = 4'b0;\n\n        // Perform division\n        while (counter < 16) begin\n            if (dividend[15:8] >= divisor) begin\n                quotient[counter] = 1'b1;\n                dividend = dividend - divisor;\n            end\n            else begin\n                quotient[counter] = 1'b0;\n            end\n            dividend = dividend << 1;\n            counter = counter + 1;\n        end\n\n        // Update remainder\n        remainder = dividend;\n    end\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {carry[0], sum[0]} = A[0] + B_comp[0];\nassign {carry[1], sum[1]} = A[1] + B_comp[1] + carry[0];\nassign {carry[2], sum[2]} = A[2] + B_comp[2] + carry[1];\nassign {carry[3], sum[3]} = A[3] + B_comp[3] + carry[2];\nassign {carry[4], sum[4]} = A[4] + B_comp[4] + carry[3];\nassign {carry[5], sum[5]} = A[5] + B_comp[5] + carry[4];\nassign {carry[6], sum[6]} = A[6] + B_comp[6] + carry[5];\nassign {carry[7], sum[7]} = A[7] + B_comp[7] + carry[6];\n\nassign D = sum;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\ninput [7:0] A, B;\ninput C_in;\noutput [7:0] D;\noutput C_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign {carry[0], sum[0]} = A[0] + B[0] + C_in;\nassign {carry[1], sum[1]} = A[1] + B[1] + carry[0];\nassign {carry[2], sum[2]} = A[2] + B[2] + carry[1];\nassign {carry[3], sum[3]} = A[3] + B[3] + carry[2];\nassign {carry[4], sum[4]} = A[4] + B[4] + carry[3];\nassign {carry[5], sum[5]} = A[5] + B[5] + carry[4];\nassign {carry[6], sum[6]} = A[6] + B[6] + carry[5];\nassign {carry[7], sum[7]} = A[7] + B[7] + carry[6];\n\nassign D = sum;\nassign C_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\ninput A, B, C_in;\noutput D, C_out;\n\nassign D = A ^ B ^ C_in;\nassign C_out = (A & B) | (B & C_in) | (C_in & A);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_1(A[15:0], B[15:0], Diff16, B_out16);\nsub_16bit sub16_2(A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_1(A[7:0], B[7:0], Diff8, B_out8);\nsub_8bit sub8_2(A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_1(A[3:0], B[3:0], Diff4, B_out4);\nsub_4bit sub4_2(A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_1(A[1:0], B[1:0], Diff2, B_out2);\nsub_2bit sub2_2(A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_1(A[0], B[0], Diff1, B_out1);\nsub_1bit sub1_2(A[1], B[1], Diff[1], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D[15:0];\nwire [3:1] A_out[15:0];\nwire [3:1] B_out_temp[15:0];\n\ngenvar i;\ngenerate\n    for (i = 0; i < 16; i = i + 1) begin\n        full_subtractor_4bit fsub4 (\n            .A(A[i+1]),\n            .B(B[i+1]),\n            .D(D[i]),\n            .B_out(B_out_temp[i])\n        );\n    end\nendgenerate\n\nassign B_out = B_out_temp[15];\n\nendmodule\n\nmodule full_subtractor_4bit(A, B, D, B_out);\ninput A, B;\noutput D, B_out;\n\nwire C_out;\n\nassign D = A ^ B ^ C_out;\nassign B_out = (A & B) | (B & C_out) | (C_out & A);\nassign C_out = ~(A ^ B);\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire borrow;\n\n// Subtraction operation\nassign subtraction_result = A - B;\nassign borrow = (subtraction_result[31] == 1);\n\n// Carry generation\nassign A_greater = (subtraction_result != 0) && (borrow == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (subtraction_result == 0) && (borrow == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16[1:2];\nwire [15:1] S16[1:2];\n\nCLA1 CLA1_inst(\n    .A(A[16:1]),\n    .B(B[16:1]),\n    .Cin(1'b0),\n    .S(S16[1]),\n    .Cout(C16[1])\n);\n\nCLA2 CLA2_inst(\n    .A(A[32:17]),\n    .B(B[32:17]),\n    .Cin(C16[1]),\n    .S(S16[2]),\n    .Cout(C16[2])\n);\n\nassign S[16:1] = S16[1];\nassign S[32:17] = S16[2];\nassign C32 = C16[2];\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\n\nwire [14:1] C;\n\nassign C[14:1] = A[14:1] ^ B[14:1] ^ Cin;\nassign S[14:1] = A[14:1] ^ B[14:1] ^ Cin;\nassign Cout = C[14];\n\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\n\nwire [14:1] C;\n\nassign C[14:1] = A[14:1] ^ B[14:1] ^ Cin;\nassign S[14:1] = A[14:1] ^ B[14:1] ^ Cin;\nassign Cout = C[14];\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa1_sum, csa2_sum, csa3_sum;\nwire [3:0] csa1_cout, csa2_cout, csa3_cout;\nwire [3:0] rca1_sum, rca2_sum;\nwire [3:0] rca1_cout, rca2_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_xor;\nwire [3:0] rca2_cout_xor;\n\nassign rca1_cout_xor = rca1_cout ^ rca2_cout;\n\n// 4-bit carry select adder\nwire [3:0] csa1_cout_xor;\nwire [3:0] csa2_cout_xor;\n\nassign csa1_cout_xor = csa1_cout ^ csa2_cout;\n\n// 4-bit ripple carry adder\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_cout = (rca1_sum[3] & rca1_sum[2]) | (rca1_sum[3] & rca1_sum[1]) | (rca1_sum[2] & rca1_sum[1]);\n\nassign rca2_sum = a[7:4] + b[7:4] + rca1_cout_xor[3];\nassign rca2_cout = (rca2_sum[3] & rca2_sum[2]) | (rca2_sum[3] & rca2_sum[1]) | (rca2_sum[2] & rca2_sum[1]);\n\n// 4-bit carry select adder\nassign csa1_sum = (cin & rca1_sum[3]) ? rca1_sum[3:0] : rca1_sum[2:0];\nassign csa1_cout = (cin & rca1_sum[3]) ? rca1_cout : 1'b0;\n\nassign csa2_sum = (cin & rca2_sum[3]) ? rca2_sum[3:0] : rca2_sum[2:0];\nassign csa2_cout = (cin & rca2_sum[3]) ? rca2_cout : 1'b0;\n\n// 4-bit carry select adder\nassign csa3_sum = (cin & csa1_sum[3]) ? csa1_sum[3:0] : csa1_sum[2:0];\nassign csa3_cout = (cin & csa1_sum[3]) ? csa1_cout : 1'b0;\n\nassign sum = {csa3_sum, csa2_sum, csa1_sum};\nassign cout = csa3_cout;\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_8bit;\n    wire [7:0] y_8bit;\n\n    // 8-bit adder implementation\n    // ...\n\n    // 16-bit adder implementation\n    // ...\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n    \n    // FA0\n    full_adder FA0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(FA0_sum[0]),\n        .cout(FA0_cout)\n    );\n    \n    // FA1\n    full_adder FA1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(FA0_cout),\n        .sum(FA1_sum[1]),\n        .cout(FA1_cout)\n    );\n    \n    // FA2\n    full_adder FA2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(FA1_cout),\n        .sum(FA2_sum[2]),\n        .cout(FA2_cout)\n    );\n    \n    // FA3\n    full_adder FA3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(FA2_cout),\n        .sum(FA3_sum[3]),\n        .cout(FA3_cout)\n    );\n    \n    // FA4\n    full_adder FA4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(FA3_cout),\n        .sum(FA4_sum[4]),\n        .cout(FA4_cout)\n    );\n    \n    // FA5\n    full_adder FA5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(FA4_cout),\n        .sum(FA5_sum[5]),\n        .cout(FA5_cout)\n    );\n    \n    // FA6\n    full_adder FA6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(FA5_cout),\n        .sum(FA6_sum[6]),\n        .cout(FA6_cout)\n    );\n    \n    // FA7\n    full_adder FA7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(FA6_cout),\n        .sum(FA7_sum[7]),\n        .cout(FA7_cout)\n    );\n    \n    assign sum = FA7_sum;\n    assign cout = FA7_cout;\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                shift_cnt <= 4'b0000;\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            m_reg <= b_reg;\n        end else begin\n            m_reg <= {m_reg[14:0], 1'b0};\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\n// Shift-and-Accumulate Logic.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            product <= {a_reg, 16'b0};\n        end else begin\n            if (m_reg[shift_cnt]) begin\n                product <= product + {16'b0, a_reg};\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // counter_logic\n    assign u_counter_logic_out = up_down ? count + 1 : count - 1;\n\n    // counter_register\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= u_counter_register_out;\n        end\n    end\n    assign u_counter_register_out = count_reg;\n\n    assign count = u_counter_register_out;\n\nendmodule\n\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] out\n);\n    assign out = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule u_counter_register (\n    input wire [15:0] count,\n    input wire clk,\n    input wire reset,\n    output wire [15:0] out\n);\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count;\n        end\n    end\n    assign out = count_reg;\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end else begin\n            init_out <= init_out;\n        end\n    end\n\n    // Submodule: Transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\n    else\n        count_r <= 4'b0000;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\n    else\n        out_r <= out_r;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule JC_register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) Q <= 64'b0;\n    end\nendmodule\n\n// Submodule JC_logic\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n    always @(*) begin\n        Q_next = Q;\n        Q_next[0] = Q[63];\n    end\nendmodule\n\n// Instantiate the submodules\nJC_register reg_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(Q)\n);\n\nJC_logic logic_inst (\n    .Q(Q),\n    .Q_next(Q)\n);\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg CLK_50_r;\n    reg CLK_10_r;\n    reg CLK_1_r;\n    reg [2:0] count_50;\n    reg [2:0] count_10;\n    reg [5:0] count_1;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_50_r <= 0;\n            CLK_10_r <= 0;\n            CLK_1_r <= 0;\n            count_50 <= 0;\n            count_10 <= 0;\n            count_1 <= 0;\n        end else begin\n            if (count_50 == 2'b11) begin\n                CLK_50_r <= ~CLK_50_r;\n                count_50 <= 0;\n            end else begin\n                count_50 <= count_50 + 1;\n            end\n\n            if (count_10 == 3'b111) begin\n                CLK_10_r <= ~CLK_10_r;\n                count_10 <= 0;\n            end else begin\n                count_10 <= count_10 + 1;\n            end\n\n            if (count_1 == 6'b111111) begin\n                CLK_1_r <= ~CLK_1_r;\n                count_1 <= 0;\n            end else begin\n                count_1 <= count_1 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = CLK_50_r;\n    assign CLK_10 = CLK_10_r;\n    assign CLK_1 = CLK_1_r;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            if (count == 2'b11) begin\n                CLK_out_r <= ~CLK_out_r;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [2:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            if (count == 3'b111) begin\n                CLK_out_r <= ~CLK_out_r;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [5:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            if (count == 6'b111111) begin\n                CLK_out_r <= ~CLK_out_r;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_r;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == MUL2_DIV_CLK - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= {clk_average[2:0], clk};\n    end\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= {clk_adjustment[2:0], clk};\n    end\nend\n\n// Output Clock Signal\nassign clk_div = clk_div_int[3] | clk_div_int[2];\n\n// Clock Divider\nassign clk_div_int[0] = counter[0] & counter[1] & counter[2] & counter[3];\nassign clk_div_int[1] = counter[0] & counter[1] & counter[2] & ~counter[3];\nassign clk_div_int[2] = counter[0] & counter[1] & ~counter[2] & counter[3];\nassign clk_div_int[3] = counter[0] & ~counter[1] & counter[2] & counter[3];\n\nendmodule\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nwire clk_div_en;\nreg [3:0] counter;\n\nassign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (clk_div_en) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div = clk_div_en;\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nparameter NUM_DIV = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else if (q == (NUM_DIV / 2 - 1)) begin\n        q <= 0;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 4;\n\nwire clk_div_en;\nreg [3:0] counter;\n\nassign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        clk_div <= 0;\n    end else if (clk_div_en) begin\n        counter <= 0;\n        clk_div <= ~clk_div;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n    \n    // add\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n    \n    // sub\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n    \n    // and\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n    \n    // or\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n    \n    // xor\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n    \n    // nor\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n    \n    // slt\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_r),\n        .zero(slt_zero),\n        .carry(slt_carry),\n        .negative(slt_negative),\n        .overflow(slt_overflow)\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] u_multiplier_out;\nwire [31:0] u_accumulator_out;\n\n// Multiplier Submodule\n// Implement the multiplication logic here\n// The output of the multiplier should be u_multiplier_out\n\n// Accumulator Submodule\n// Implement the accumulation logic here\n// The output of the accumulator should be u_accumulator_out\n\n// Connect the multiplier and accumulator submodules\n// Implement the connections between the submodules\n\n// Output the accumulated result\nassign c = u_accumulator_out;\n\nendmodule\n\n\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nwire [7:0] freq_inv = 256 - freq;\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq_inv),\n    .count(count)\n);\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nassign enable = (freq != 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state_reg;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave_reg;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    always @(posedge clk) begin\n        q <= dff_out[sel];\n    end\n\nendmodule\n"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n\n    // Stage 2\n    assign stage2 = (ctrl[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n\n    // Stage 3\n    assign stage3 = (ctrl[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n\n    assign out = stage3;\n\n    // Multiplexer\n    // Selects between two input values based on the sel signal\n    // Outputs the selected value\n    module mux2X1 (sel, in0, in1, out);\n        input sel;\n        input in0;\n        input in1;\n        output out;\n\n        assign out = sel ? in1 : in0;\n    endmodule\nendmodule\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  reg [31:0] pc_next;\n  wire [31:0] instr;\n  reg [31:0] instr_next;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  reg [31:0] alu_out;\n  reg [31:0] res_reg_file_next [0:31];\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr),\n    .pc_next(pc_next),\n    .instr_next(instr_next)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res_reg_file_next(res_reg_file_next)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file_next(res_reg_file_next),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign pc = 0;\n  assign res_reg_file = reg_file;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_next <= 0;\n      instr_next <= 0;\n      res_reg_file_next <= 0;\n    end else begin\n      pc_next <= pc_next + 1;\n      instr_next <= instr_mem[pc_next];\n      res_reg_file_next <= res_reg_file_next;\n    end\n  end\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output [31:0] pc_next,\n  output [31:0] instr_next\n);\n  reg [31:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      pc_reg <= pc;\n      instr_reg <= instr;\n    end\n  end\n\n  assign pc_next = pc_reg + 1;\n  assign instr_next = instr_reg;\nendmodule\n\nmodule stage pipe5(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] alu_out,\n  output [31:0] res_reg_file_next [0:31]\n);\n  wire [31:0] rs1_val;\n  wire [31:0] rs2_val;\n  reg [31:0] alu_out_reg;\n  reg [31:0] res_reg_file_next_reg [0:31];\n\n  assign rs1_val = reg_file[rs1];\n  assign rs2_val = reg_file[rs2];\n\n  always @(posedge clk or posedge rst) begin\n    if ("}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n      c0_reg <= a0_reg * b0_reg;\n      c1_reg <= a1_reg * b1_reg;\n      c2_reg <= a2_reg * b2_reg;\n      c3_reg <= a3_reg * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] write_data;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] funct;\n    wire [5:0] opcode;\n    wire [5:0] alu_op;\n    wire [5:0] alu_funct;\n    wire [31:0] alu_in1;\n    wire [31:0] alu_in2;\n    wire [31:0] alu_out;\n    wire [31:0] mem_in;\n    wire [31:0] mem_out;\n    wire [31:0] mem_addr;\n    wire [31:0] mem_data;\n    wire [31:0] mem_wr_data;\n    wire [31:0] mem_rd_data;\n    wire [31:0] alu_result;\n    wire [31:0] write_reg;\n    wire [31:0] write_reg_data;\n    wire [31:0] write_reg_addr;\n\n    assign pc = 32'd0;\n    assign instr = instr_mem[pc];\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n    assign alu_in1 = op1;\n    assign alu_in2 = op2;\n    assign alu_op = instr[5:0];\n    assign alu_funct = instr[31:26];\n    assign alu_result = alu_in1 + alu_in2;\n    assign write_reg = instr[11:7];\n    assign write_reg_data = alu_result;\n    assign write_reg_addr = pc;\n\n    assign out_reg_file = mem_out;\n\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(mem_out)\n    );\n\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(mem_out)\n    );\n\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(mem_out)\n    );\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] write_data;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] funct;\n    wire [5:0] opcode;\n    wire [5:0] alu_op;\n    wire [5:0] alu_funct;\n    wire [31:0] alu_in1;\n    wire [31:0] alu_in2;\n    wire [31:0] alu_out;\n    wire [31:0] mem_in;\n    wire [31:0]"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg [2:0] cnt_reg;\nreg [2:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 3'b000;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        3'b000: cnt_next = valid_in ? 3'b001 : 3'b000;\n        3'b001: cnt_next = valid_in ? 3'b010 : 3'b000;\n        3'b010: cnt_next = valid_in ? 3'b011 : 3'b000;\n        3'b011: cnt_next = valid_in ? 3'b100 : 3'b000;\n        3'b100: cnt_next = valid_in ? 3'b101 : 3'b000;\n        3'b101: cnt_next = valid_in ? 3'b110 : 3'b000;\n        3'b110: cnt_next = valid_in ? 3'b111 : 3'b000;\n        3'b111: cnt_next = valid_in ? 3'b000 : 3'b000;\n        default: cnt_next = 3'b000;\n    endcase\nend\n\n// Data Accumulator Module\nreg [9:0] data_acc_reg;\nreg [9:0] data_acc_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_acc_reg <= 10'b0000000000;\n    else\n        data_acc_reg <= data_acc_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        3'b000: data_acc_next = data_in;\n        3'b001: data_acc_next = data_acc_reg + data_in;\n        3'b010: data_acc_next = data_acc_reg + data_in;\n        3'b011: data_acc_next = data_acc_reg + data_in;\n        3'b100: data_acc_next = data_acc_reg + data_in;\n        3'b101: data_acc_next = data_acc_reg + data_in;\n        3'b110: data_acc_next = data_acc_reg + data_in;\n        3'b111: data_acc_next = data_acc_reg + data_in;\n        default: data_acc_next = data_acc_reg;\n    endcase\nend\n\n// Valid Output Module\nreg valid_out_reg;\nreg valid_out_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out_reg <= 1'b0;\n    else\n        valid_out_reg <= valid_out_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        3'b000: valid_out_next = 1'b0;\n        3'b001: valid_out_next = 1'b0;\n        3'b010: valid_out_next = 1'b0;\n        3'b011: valid_out_next = 1'b1;\n        3'b100: valid_out_next = 1'b0;\n        3'b101: valid_out_next = 1'b0;\n        3'b110: valid_out_next = 1'b0;\n        3'b111: valid_out_next = 1'b0;\n        default: valid_out_next = valid_out_reg;\n    endcase\nend\n\nendmodule\n\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg;\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Calculate absolute value of dividend\n    assign abs_dividend = (sign) ? -dividend : dividend;\n\n    // Calculate negative value of divisor\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    // Initialize shift register and counter\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'b0;\n            counter <= 3'b0;\n            quotient <= 16'b0;\n            remainder <= 16'b0;\n            res_valid <= 1'b0;\n        end else begin\n            if (opn_valid) begin\n                shift_reg <= {1'b0, abs_dividend[7:1]};\n                counter <= 3'b0;\n                quotient <= 16'b0;\n                remainder <= 16'b0;\n                res_valid <= 1'b0;\n            end else if (res_ready) begin\n                res_valid <= 1'b1;\n            end else begin\n                res_valid <= 1'b0;\n            end\n        end\n    end\n\n    // Divide dividend by divisor\n    always @(posedge clk) begin\n        if (counter < 3'b100) begin\n            shift_reg <= {shift_reg[0], abs_dividend[0]};\n            counter <= counter + 1'b1;\n        end else begin\n            quotient <= quotient + {1'b0, shift_reg[0]};\n            remainder <= remainder + {1'b0, shift_reg[0]};\n            shift_reg <= {1'b0, shift_reg[7:1]};\n            counter <= counter + 1'b1;\n        end\n    end\n\n    // Calculate remainder\n    always @(posedge clk) begin\n        if (counter < 3'b100) begin\n            remainder <= remainder + {1'b0, shift_reg[0]};\n        end else begin\n            remainder <= remainder + {1'b0, shift_reg[0]};\n        end\n    end\n\n    // Calculate quotient\n    always @(posedge clk) begin\n        if (counter < 3'b100) begin\n            quotient <= quotient + {1'b0, shift_reg[0]};\n        end else begin\n            quotient <= quotient + {1'b0, shift_reg[0]};\n        end\n    end\n\n    // Calculate result\n    assign result = (sign) ? {remainder, quotient} : {quotient, remainder};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor  // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n);\n\n    // Perform division operation\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] dividend_reg;\n    reg [15:0] divisor_reg;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_dividend_reg;\n    reg [31:0] shifted_dividend_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [31:0] shifted_dividend_reg_reg_reg_reg_reg_reg_reg"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [7:0] temp_odd;\n    wire [7:0] temp_even;\n    wire [7:0] temp_remainder;\n    wire [7:0] temp_quotient;\n    wire [7:0] temp_divisor;\n    wire [7:0] temp_dividend;\n    wire [7:0] temp_dividend_shift;\n    wire [7:0] temp_dividend_shift_2;\n    wire [7:0] temp_dividend_shift_3;\n    wire [7:0] temp_dividend_shift_4;\n    wire [7:0] temp_dividend_shift_5;\n    wire [7:0] temp_dividend_shift_6;\n    wire [7:0] temp_dividend_shift_7;\n    wire [7:0] temp_dividend_shift_8;\n    wire [7:0] temp_dividend_shift_9;\n    wire [7:0] temp_dividend_shift_10;\n    wire [7:0] temp_dividend_shift_11;\n    wire [7:0] temp_dividend_shift_12;\n    wire [7:0] temp_dividend_shift_13;\n    wire [7:0] temp_dividend_shift_14;\n    wire [7:0] temp_dividend_shift_15;\n    wire [7:0] temp_dividend_shift_16;\n    wire [7:0] temp_dividend_shift_17;\n    wire [7:0] temp_dividend_shift_18;\n    wire [7:0] temp_dividend_shift_19;\n    wire [7:0] temp_dividend_shift_20;\n    wire [7:0] temp_dividend_shift_21;\n    wire [7:0] temp_dividend_shift_22;\n    wire [7:0] temp_dividend_shift_23;\n    wire [7:0] temp_dividend_shift_24;\n    wire [7:0] temp_dividend_shift_25;\n    wire [7:0] temp_dividend_shift_26;\n    wire [7:0] temp_dividend_shift_27;\n    wire [7:0] temp_dividend_shift_28;\n    wire [7:0] temp_dividend_shift_29;\n    wire [7:0] temp_dividend_shift_30;\n    wire [7:0] temp_dividend_shift_31;\n    wire [7:0] temp_dividend_shift_32;\n    wire [7:0] temp_dividend_shift_33;\n    wire [7:0] temp_dividend_shift_34;\n    wire [7:0] temp_dividend_shift_35;\n    wire [7:0] temp_dividend_shift_36;\n    wire [7:0] temp_dividend_shift_37;\n    wire [7:0] temp_dividend_shift_38;\n    wire [7:0] temp_dividend_shift_39;\n    wire [7:0] temp_dividend_shift_40;\n    wire [7:0] temp_dividend_shift_41;\n    wire [7:0] temp_dividend_shift_42;\n    wire [7:0] temp_dividend_shift_43;\n    wire [7:0] temp_dividend_shift_44;\n    wire [7:0] temp_dividend_shift_45;\n    wire [7:0] temp_dividend_shift_46;\n    wire [7:0] temp_dividend_shift_47;\n    wire [7:0] temp_dividend_shift_48;\n    wire [7:0] temp_dividend_shift_49;\n    wire [7:0] temp_dividend"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {carry[0], sum[0]} = A[0] + B_comp[0];\ngenvar i;\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin\n        assign {carry[i], sum[i]} = carry[i-1] ^ A[i] ^ B_comp[i];\n    end\nendgenerate\n\nassign D = sum;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, carry, sum);\ninput [7:0] A, B;\ninput carry;\noutput [7:0] sum;\n\nwire [7:0] carry_out;\n\nassign {carry_out, sum[0]} = A[0] + B[0] + carry;\ngenvar i;\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin\n        assign {carry_out, sum[i]} = carry_out[i-1] ^ A[i] ^ B[i];\n    end\nendgenerate\n\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\ninput A, B, carry_in;\noutput sum, carry_out;\n\nassign {carry_out, sum} = carry_in ^ A ^ B;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\nsub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[31:16]), .B_out(B_out));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff8), .B_out(B_out8));\nsub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[15:8]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff4), .B_out(B_out4));\nsub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff2), .B_out(B_out2));\nsub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(.A(A[0]), .B(B[0]), .Diff(Diff1), .B_out(B_out1));\nsub_1bit sub1_1(.A(A[1]), .B(B[1]), .Diff(Diff[1]), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = (A & B) | (~A & ~B);\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire [7:0] D2, D3, D4, D5;\nwire B0, B1, B2, B3, B4, B5;\n\nsub_32bit sub0(A[63:32], B[63:32], D0, B0);\nsub_32bit sub1(A[31:0], B[31:0], D1, B1);\n\nsub_16bit sub2(D0, B0, D2, B2);\nsub_16bit sub3(D1, B1, D3, B3);\n\nsub_8bit sub4(D2, B2, D4, B4);\nsub_8bit sub5(D3, B3, D5, B5);\n\nsub_8bit sub6(D4, B4, D[31:24], B_out);\nsub_8bit sub7(D5, B5, D[23:16], B_out);\n\nsub_8bit sub8(D[15:8], B_out, D[7:0], B_out);\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [7:0] D0, D1, D2, D3;\nwire B0, B1, B2, B3;\n\nsub_16bit sub0(A[31:16], B[31:16], D0, B0);\nsub_16bit sub1(A[15:0], B[15:0], D1, B1);\n\nsub_8bit sub2(D0, B0, D2, B2);\nsub_8bit sub3(D1, B1, D3, B3);\n\nsub_8bit sub4(D2, B2, D[15:8], B_out);\nsub_8bit sub5(D3, B3, D[7:0], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1, D2, D3;\nwire B0, B1, B2, B3;\n\nsub_8bit sub0(A[15:8], B[15:8], D0, B0);\nsub_8bit sub1(A[7:0], B[7:0], D1, B1);\n\nsub_8bit sub2(D0, B0, D2, B2);\nsub_8bit sub3(D1, B1, D3, B3);\n\nsub_8bit sub4(D2, B2, D[7:0], B_out);\nsub_8bit sub5(D3, B3, D[7:0], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1, D2, D3;\nwire B0, B1, B2, B3;\n\nsub_4bit sub0(A[7:4], B[7:4], D0, B0);\nsub_4bit sub1(A[3:0], B[3:0], D1, B1);\n\nsub_4bit sub2(D0, B0, D2, B2);\nsub_4bit sub3(D1, B1, D3, B3);\n\nsub_4bit sub4(D2, B2, D[3:0], B_out);\nsub_4bit sub5(D3, B3, D[3:0], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire [3:1] B_out1, B_out2, B_out3, B_out4;\n\nwire [4:1] B_out;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\n\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign D1 = A1 - B1 - B_out1;\nassign D2 = A2 - B2 - B_out2;\nassign D3 = A3 - B3 - B_out3;\nassign D4 = A4 - B4 - B_out4;\n\nassign B_out1 = (A1 < B1) ? 1'b1 : 1'b0;\nassign B_out2 = (A2 < B2) ? 1'b1 : 1'b0;\nassign B_out3 = (A3 < B3) ? 1'b1 : 1'b0;\nassign B_out4 = (A4 < B4) ? 1'b1 : 1'b0;\n\nassign B_out = {B_out4, B_out3, B_out2, B_out1};\n\nassign D = {D4, D3, D2, D1};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire borrow;\n\n// Subtraction operation\nassign {borrow, subtraction_result} = A - B;\n\n// Carry generation\nassign A_greater = (subtraction_result != 0) && (borrow == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (subtraction_result == 0) && (borrow == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [3:0] rca1_cout, rca2_cout, rca3_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_0, rca1_cout_1, rca1_cout_2, rca1_cout_3;\nwire [3:0] rca1_sum_0, rca1_sum_1, rca1_sum_2, rca1_sum_3;\n\nassign rca1_cout_0 = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\nassign rca1_sum_0 = a[0] ^ b[0] ^ cin;\nassign rca1_cout_1 = (a[1] & b[1]) | (a[1] & rca1_cout_0) | (b[1] & rca1_cout_0);\nassign rca1_sum_1 = a[1] ^ b[1] ^ rca1_cout_0;\nassign rca1_cout_2 = (a[2] & b[2]) | (a[2] & rca1_cout_1) | (b[2] & rca1_cout_1);\nassign rca1_sum_2 = a[2] ^ b[2] ^ rca1_cout_1;\nassign rca1_cout_3 = (a[3] & b[3]) | (a[3] & rca1_cout_2) | (b[3] & rca1_cout_2);\nassign rca1_sum_3 = a[3] ^ b[3] ^ rca1_cout_2;\n\nassign rca1_cout = rca1_cout_3;\nassign rca1_sum = {rca1_sum_3, rca1_sum_2, rca1_sum_1, rca1_sum_0};\n\n// 4-bit carry select adder slice\nwire [3:0] csa_slice1_cout_0, csa_slice1_cout_1, csa_slice1_cout_2, csa_slice1_cout_3;\nwire [3:0] csa_slice1_sum_0, csa_slice1_sum_1, csa_slice1_sum_2, csa_slice1_sum_3;\n\nassign csa_slice1_cout_0 = (rca1_sum[0] & rca1_cout) | (rca1_sum[0] & cin) | (rca1_cout & cin);\nassign csa_slice1_sum_0 = rca1_sum[0] ^ rca1_cout ^ cin;\nassign csa_slice1_cout_1 = (rca1_sum[1] & rca1_cout) | (rca1_sum[1] & rca1_cout_0) | (rca1_cout_0 & rca1_cout_1);\nassign csa_slice1_sum_1 = rca1_sum[1] ^ rca1_cout ^ rca1_cout_0;\nassign csa_slice1_cout_2 = (rca1_sum[2] & rca1_cout) | (rca1_sum[2] & rca1_cout_1) | (rca1_cout_1 & rca1_cout_2);\nassign csa_slice1_sum_2 = rca1_sum[2] ^ rca1_cout ^ rca1_cout_1;\nassign csa_slice1_cout_3 = (rca1_sum[3] & rca1_cout) | (rca1_sum[3] & rca1_cout_2) | (r"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n    adder_8bit adder_8bit_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n    adder_4bit adder_4bit_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [1:0] y0, y1;\n    wire Co0, Co1;\n\n    // 2-bit adder\n    adder_2bit adder_2bit_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n    adder_2bit adder_2bit_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    wire [0:0] y0;\n    wire Co0;\n\n    // 1-bit adder\n    adder_1bit adder_1bit_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n    assign y = {y0};\n    assign Co = Co0;\nendmodule\n\nmodule adder_1bit (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire [6:0] fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // 8-bit full adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout[0]));\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout[0]),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout[1]));\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout[1]),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout[2]));\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout[2]),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout[3]));\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout[3]),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout[4]));\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout[4]),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout[5]));\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout[5]),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout[6]));\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout[6]),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout[7]));\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout[7];\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [15:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 16'b0;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 16'b0;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 16'b1111111111111111) begin\n                shift_cnt <= 16'b0;\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1'b1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m;\nreg [31:0] p;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m <= 16'b0;\n        p <= 32'b0;\n    end else begin\n        if (shift_cnt == 16'b0) begin\n            m <= b_reg;\n            p <= 32'b0;\n        end else begin\n            m <= {m[14:0], 1'b0};\n            p <= p + (m & a_reg);\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = p;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_register_count)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (up_down) begin\n                count <= count + 1;\n            end else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule: Transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Connect submodules\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= Q_reg + 1;\nend\n\n// Logic submodule\nwire [63:0] next_Q;\nassign next_Q = Q_reg ^ (Q_reg >> 1);\nalways @(*) begin\n    Q = next_Q;\nend\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= Q + 1;\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output reg [63:0]   next_Q\n);\n\nalways @(*) begin\n    next_Q = Q ^ (Q >> 1);\nend\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_in_div_2;\n    wire CLK_in_div_10;\n    wire CLK_in_div_100;\n\n    // clk_div_2\n    reg [1:0] clk_div_2_cnt = 2'b00;\n    assign CLK_in_div_2 = clk_div_2_cnt[1];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_2_cnt <= 2'b00;\n        end else begin\n            clk_div_2_cnt <= clk_div_2_cnt + 1;\n        end\n    end\n\n    // clk_div_10\n    reg [2:0] clk_div_10_cnt = 3'b000;\n    assign CLK_in_div_10 = clk_div_10_cnt[2];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_10_cnt <= 3'b000;\n        end else begin\n            clk_div_10_cnt <= clk_div_10_cnt + 1;\n        end\n    end\n\n    // clk_div_100\n    reg [5:0] clk_div_100_cnt = 6'b000000;\n    assign CLK_in_div_100 = clk_div_100_cnt[5];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_100_cnt <= 6'b000000;\n        end else begin\n            clk_div_100_cnt <= clk_div_100_cnt + 1;\n        end\n    end\n\n    // Output clock signals\n    assign CLK_50 = CLK_in_div_2;\n    assign CLK_10 = CLK_in_div_10;\n    assign CLK_1 = CLK_in_div_100;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] counter_out;\nwire [3:0] clk_average_out;\nwire [3:0] clk_adjustment_out;\n\nwire [3:0] clk_div_int;\n\nassign clk_div = |clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == MUL2_DIV_CLK) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\nassign counter_out = counter;\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= counter_out;\n    end\nend\nassign clk_average_out = clk_average;\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= counter_out;\n    end\nend\nassign clk_adjustment_out = clk_adjustment;\n\n// Clock Divider Submodule\nassign clk_div_int = clk_average_out | clk_adjustment_out;\n\nendmodule\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        if (counter == NUM_DIV / 2 - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign clk_div = counter == 0;\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else begin\n        if (q == NUM_DIV / 2 - 1) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else begin\n        if (q == 0) begin\n            clk_div <= ~clk_div;\n        end\n    end\nend\n\nendmodule\n\nmodule u_clk_divider_inst(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nu_counter u_counter_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .q(q)\n);\n\nu_clk_divider u_clk_divider_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div)\n);\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n\n// Addition\nadd add_inst(\n    .a(a),\n    .b(b),\n    .r(add_result)\n);\n\n// Subtraction\nsub sub_inst(\n    .a(a),\n    .b(b),\n    .r(sub_result)\n);\n\n// AND\nand and_inst(\n    .a(a),\n    .b(b),\n    .r(and_result)\n);\n\n// OR\nor or_inst(\n    .a(a),\n    .b(b),\n    .r(or_result)\n);\n\n// XOR\nxor xor_inst(\n    .a(a),\n    .b(b),\n    .r(xor_result)\n);\n\n// NOR\nnor nor_inst(\n    .a(a),\n    .b(b),\n    .r(nor_result)\n);\n\n// SLT\nslt slt_inst(\n    .a(a),\n    .b(b),\n    .r(slt_result)\n);\n\n// SLTU\nsltu sltu_inst(\n    .a(a),\n    .b(b),\n    .r(sltu_result)\n);\n\n// SLL\nsll sll_inst(\n    .a(a),\n    .b(b),\n    .r(sll_result)\n);\n\n// SRL\nsrl srl_inst(\n    .a(a),\n    .b(b),\n    .r(srl_result)\n);\n\n// SRA\nsra sra_inst(\n    .a(a),\n    .b(b),\n    .r(sra_result)\n);\n\n// SLLV\nsllv sllv_inst(\n    .a(a),\n    .b(b),\n    .r(sllv_result)\n);\n\n// SRLV\nsrlv srlv_inst(\n    .a(a),\n    .b(b),\n    .r(srlv_result)\n);\n\n// SRAV\nsrav srav_inst(\n    .a(a),\n    .b(b),\n    .r(srav_result)\n);\n\n// LUI\nlui lui_inst(\n    .a(a),\n    .b(b),\n    .r(lui_result)\n);\n\n// Select the operation based on aluc\nassign r = (aluc == 6'b100000) ? add_result :\n           (aluc == 6'b100001) ? sub_result :\n           (aluc == 6'b100010) ? add_result :\n           (aluc == 6'b100011) ? sub_result :\n           (aluc == 6'b100100) ? and_result :\n           (aluc == 6'b100101) ? or_result :\n           (aluc == 6'b100110) ? xor_result :\n           (aluc == 6'b100111) ? nor_result :\n           (aluc == 6'b101010) ? slt_result :\n           (aluc == 6'b101011) ? sltu_result :\n           (aluc == 6'b000000) ? sll_result :\n           (aluc == 6'b000010) ? srl_result :\n           (aluc == 6'b000011) ? sra_result :\n           (aluc == 6'b000100) ? sllv_result :\n           (aluc == 6'b000110) ? srlv_result :\n           (aluc == 6'"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] mult_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nassign mult_result = a * b;\n\n// Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + mult_result[31:0];\n    end\nend\n\n// Connecting the submodules\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register 1\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register 2\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Submodule 1\n    reg [2:0] ins_p1_sub;\n    reg [4:0] ad1_p1_sub;\n    reg [7:0] ad2_p1_sub;\n\n    // Submodule 2\n    reg [2:0] ins_p2_sub;\n    reg [4:0] ad1_p2_sub;\n    reg [7:0] ad2_p2_sub;\n\n    // Instruction register 1\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register 2\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\n\n    // Submodule 1\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_sub <= 3'b0;\n            ad1_p1_sub <= 5'b0;\n            ad2_p1_sub <= 8'b0;\n        end else begin\n            ins_p1_sub <= ins_p1_reg;\n            ad1_p1_sub <= ad1_p1_reg;\n            ad2_p1_sub <= ad2_p1_reg;\n        end\n    end\n\n    // Submodule 2\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_sub <= 3'b0;\n            ad1_p2_sub <= 5'b0;\n            ad2_p2_sub <= 8'b0;\n        end else begin\n            ins_p2_sub <= ins_p2_reg;\n            ad1_p2_sub <= ad1_p2_reg;\n            ad2_p2_sub <= ad2_p2_reg;\n        end\n    end\n\n    // Output\n    assign ins = ins_"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable;\nreg [7:0] count;\n\nassign enable = (freq > 0);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nassign wave_out = (count == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state_reg;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave_reg;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    always @(posedge clk) begin\n        q <= dff_out[sel];\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // 2-to-1 multiplexer\n    wire [7:0] mux2X1_out;\n    wire sel;\n\n    assign sel = ctrl[2];\n\n    // Stage 1\n    assign stage1_out = (sel) ? {in[3:0], in[7:4]} : {in[1:0], in[7:2]};\n\n    // Stage 2\n    assign stage2_out = (sel) ? {stage1_out[3:0], stage1_out[7:4]} : {stage1_out[1:0], stage1_out[7:2]};\n\n    // Stage 3\n    assign stage3_out = (sel) ? {stage2_out[3:0], stage2_out[7:4]} : {stage2_out[1:0], stage2_out[7:2]};\n\n    // Final output\n    assign out = stage3_out;\n\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [4:0] rs1;\n  reg [4:0] rs2;\n  reg [4:0] rd;\n  reg [5:0] op;\n  reg [31:0] res;\n\n  // Fetch stage\n  wire [31:0] fetch_out;\n  stagepipe5_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetch_out(fetch_out)\n  );\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\n\n  // Decode stage\n  stagepipe5_decode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch_out),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  // Execute stage\n  stagepipe5_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .op(op),\n    .alu_out(alu_out)\n  );\n\n  // Memory stage\n  stagepipe5_memory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .res(res)\n  );\n\n  // Writeback stage\n  stagepipe5_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .res(res),\n    .rd(rd),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\nendmodule\n\nmodule stagepipe5_fetch(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] fetch_out\n);\n  reg [31:0] fetch_out_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      fetch_out_reg <= 0;\n    end else begin\n      fetch_out_reg <= instr_mem[pc];\n    end\n  end\n  assign fetch_out = fetch_out_reg;\nendmodule\n\nmodule stagepipe5_decode(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[25:21];\n      rs2_reg <= instr[20:16];\n      rd_reg <= instr[15:11];\n      op_reg <= instr[31:27];\n    end\n  end\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule stagepipe5_execute(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input ["}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n  reg [15:0] b0_reg_next, b1_reg_next, b2_reg_next, b3_reg_next;\n  reg [31:0] c0_reg_next, c1_reg_next, c2_reg_next, c3_reg_next;\n  reg [15:0] a0_reg_next, a1_reg_next, a2_reg_next, a3_reg_next;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n    end else begin\n      b0_reg <= b0_reg_next;\n      b1_reg <= b1_reg_next;\n      b2_reg <= b2_reg_next;\n      b3_reg <= b3_reg_next;\n      c0_reg <= c0_reg_next;\n      c1_reg <= c1_reg_next;\n      c2_reg <= c2_reg_next;\n      c3_reg <= c3_reg_next;\n      a0_reg <= a0_reg_next;\n      a1_reg <= a1_reg_next;\n      a2_reg <= a2_reg_next;\n      a3_reg <= a3_reg_next;\n    end\n  end\n\n  always @* begin\n    b0_reg_next = b0_reg;\n    b1_reg_next = b1_reg;\n    b2_reg_next = b2_reg;\n    b3_reg_next = b3_reg;\n    c0_reg_next = c0_reg;\n    c1_reg_next = c1_reg;\n    c2_reg_next = c2_reg;\n    c3_reg_next = c3_reg;\n    a0_reg_next = a0_reg;\n    a1_reg_next = a1_reg;\n    a2_reg_next = a2_reg;\n    a3_reg_next = a3_reg;\n\n    c0_reg_next = c0_reg + (a0_reg * b0_reg);\n    c1_reg_next = c1_reg + (a1_reg * b1_reg);\n    c2_reg_next = c2_reg + (a2_reg * b2_reg);\n    c3_reg_next = c3_reg + (a3_reg * b3_reg);\n\n    b0_reg_next = b0_reg;\n    b1_reg_next = b0_reg;\n    b2_reg_next = b1_reg;\n    b3_reg_next = b2_reg;\n\n    a0_reg_next = a0;\n    a1_reg_next = a1;\n    a2_reg_next = a2;\n    a3_reg_next = a3;\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch;\n    wire [31:0] execute;\n    wire [31:0] writeback;\n    wire [4:0] pc;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] out_reg_file_tmp;\n\n    assign out_reg_file = out_reg_file_tmp;\n\n    // Fetch stage\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch(fetch)\n    );\n\n    // Execute stage\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .reg_file(reg_file),\n        .alu_out(alu_out),\n        .add_out(add_out),\n        .sub_out(sub_out),\n        .execute(execute)\n    );\n\n    // Writeback stage\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .execute(execute),\n        .reg_file(reg_file),\n        .rd(rd),\n        .writeback(writeback)\n    );\n\n    // Pipeline control\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n        end\n    end\n\n    // Output\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file_tmp <= 0;\n        end else begin\n            out_reg_file_tmp <= writeback;\n        end\n    end\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetch\n);\n    reg [31:0] fetch_tmp;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetch_tmp <= 0;\n        end else begin\n            fetch_tmp <= instr_mem[pc];\n        end\n    end\n\n    assign fetch = fetch_tmp;\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] fetch,\n    input [31:0] reg_file [0:31],\n    output [31:0] alu_out,\n    output [31:0] add_out,\n    output [31:0] sub_out,\n    output [31:0] execute\n);\n    reg [31:0] alu_out_tmp;\n    reg [31:0] add_out_tmp;\n    reg [31:0] sub_out_tmp;\n    reg [31:0] execute_tmp;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            alu_out_tmp <= 0;\n            add_out_tmp <= 0;\n            sub_out_tmp <= 0;\n            execute_tmp <= 0;\n        end else begin\n            alu_out_tmp <= fetch;\n            add_out_tmp <= reg_file[alu_out_tmp[25:21]] + reg_file[alu_out_tmp[20:16]];\n            sub_out_tmp <= reg_file[alu_out_tmp[25:21]] - reg_file[alu_out_tmp[20:16]];\n            execute_tmp <= al"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt <= cnt + 1;\n            if (cnt == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\nend\n\n// Valid Output Module\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt_r <= cnt_r + 1;\n            if (cnt_r == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign cnt = cnt_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt_r <= cnt_r + 1;\n            if (cnt_r == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg;\n    reg [3:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    // Calculate the absolute value of the dividend\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    // Calculate the negated absolute value of the divisor\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    // Control the division process\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n        end else if (opn_valid && !res_valid) begin\n            counter <= 4;\n            shift_reg <= {abs_dividend, 1'b0};\n        end else if (counter > 0) begin\n            counter <= counter - 1;\n            shift_reg <= {shift_reg[14:0], shift_reg[15]};\n        end\n    end\n\n    // Result Management\n    // Manage the validity of the output result\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (counter == 0) begin\n            res_valid <= 1;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end\n    end\n\n    // Output Result\n    // Output the result of the division\n    always @(posedge clk) begin\n        if (rst) begin\n            quotient <= 0;\n            remainder <= 0;\n        end else if (res_valid) begin\n            quotient <= shift_reg[15:8];\n            remainder <= shift_reg[7:0];\n        end\n    end\n\n    assign result = {remainder, quotient};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor  // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n);\n\n    // Perform division\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] dividend_reg;\n    reg [15:0] divisor_reg;\n    reg [31:0] shift_reg;\n    reg [31:0] temp_reg;\n    reg [31:0] temp_reg2;\n    reg [31:0] temp_reg3;\n    reg [31:0] temp_reg4;\n    reg [31:0] temp_reg5;\n    reg [31:0] temp_reg6;\n    reg [31:0] temp_reg7;\n    reg [31:0] temp_reg8;\n    reg [31:0] temp_reg9;\n    reg [31:0] temp_reg10;\n    reg [31:0] temp_reg11;\n    reg [31:0] temp_reg12;\n    reg [31:0] temp_reg13;\n    reg [31:0] temp_reg14;\n    reg [31:0] temp_reg15;\n    reg [31:0] temp_reg16;\n    reg [31:0] temp_reg17;\n    reg [31:0] temp_reg18;\n    reg [31:0] temp_reg19;\n    reg [31:0] temp_reg20;\n    reg [31:0] temp_reg21;\n    reg [31:0] temp_reg22;\n    reg [31:0] temp_reg23;\n    reg [31:0] temp_reg24;\n    reg [31:0] temp_reg25;\n    reg [31:0] temp_reg26;\n    reg [31:0] temp_reg27;\n    reg [31:0] temp_reg28;\n    reg [31:0] temp_reg29;\n    reg [31:0] temp_reg30;\n    reg [31:0] temp_reg31;\n    reg [31:0] temp_reg32;\n    reg [31:0] temp_reg33;\n    reg [31:0] temp_reg34;\n    reg [3"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_q;\n    wire [15:0] temp_r;\n    wire [7:0] temp_d;\n    wire [7:0] temp_s;\n    wire [3:0] temp_i;\n    wire [15:0] temp_t;\n    wire [15:0] temp_u;\n    wire [15:0] temp_v;\n\n    // Control unit\n    // ...\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] carry_out;\n\nassign B_comp = ~B + 1;\nassign {carry_out, sum} = A + B_comp;\nassign {carry[0], D[0]} = sum[0] + carry_out[0];\nassign {carry[1], D[1]} = sum[1] + carry_out[1] + carry[0];\nassign {carry[2], D[2]} = sum[2] + carry_out[2] + carry[1];\nassign {carry[3], D[3]} = sum[3] + carry_out[3] + carry[2];\nassign {carry[4], D[4]} = sum[4] + carry_out[4] + carry[3];\nassign {carry[5], D[5]} = sum[5] + carry_out[5] + carry[4];\nassign {carry[6], D[6]} = sum[6] + carry_out[6] + carry[5];\nassign {carry[7], D[7]} = sum[7] + carry_out[7] + carry[6];\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign {carry[0], sum[0]} = A[0] + B[0] + carry_in;\nassign {carry[1], D[1]} = sum[1] + carry[0];\nassign {carry[2], D[2]} = sum[2] + carry[1];\nassign {carry[3], D[3]} = sum[3] + carry[2];\nassign {carry[4], D[4]} = sum[4] + carry[3];\nassign {carry[5], D[5]} = sum[5] + carry[4];\nassign {carry[6], D[6]} = sum[6] + carry[5];\nassign {carry[7], D[7]} = sum[7] + carry[6];\nassign carry_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\ninput A, B, carry_in;\noutput sum, carry_out;\n\nassign {carry_out, sum} = A + B + carry_in;\n\nendmodule\n\nmodule adder_inst(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\n\nfull_adder fa0 (.A(A[0]), .B(B[0]), .carry_in(carry_in), .sum(sum[0]), .carry_out(carry[0]));\nfull_adder fa1 (.A(A[1]), .B(B[1]), .carry_in(carry[0]), .sum(sum[1]), .carry_out(carry[1]));\nfull_adder fa2 (.A(A[2]), .B(B[2]), .carry_in(carry[1]), .sum(sum[2]), .carry_out(carry[2]));\nfull_adder fa3 (.A(A[3]), .B(B[3]), .carry_in(carry[2]), .sum(sum[3]), .carry_out(carry[3]));\nfull_adder fa4 (.A(A[4]), .B(B[4]), .carry_in(carry[3]), .sum(sum[4]), .carry_out(carry[4]));\nfull_adder fa5 (.A(A[5]), .B(B[5]), .car"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(A[15:0], B[15:0], Diff16, B_out16);\nsub_16bit sub16_1(A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(A[7:0], B[7:0], Diff8, B_out8);\nsub_8bit sub8_1(A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(A[3:0], B[3:0], Diff4, B_out4);\nsub_4bit sub4_1(A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(A[1:0], B[1:0], Diff2, B_out2);\nsub_2bit sub2_1(A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(A[0], B[0], Diff1, B_out1);\nsub_1bit sub1_1(A[1], B[1], Diff[1], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nwire B0;\n\nsub_1bit sub0(A, B, D, B0);\n\nassign D = A - B;\nassign B_out = B0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\n\nwire [3:1] B_out_sub1, B_out_sub2, B_out_sub3, B_out_sub4;\nwire [3:1] B_out_sub1_sub2, B_out_sub1_sub3, B_out_sub1_sub4;\nwire [3:1] B_out_sub2_sub3, B_out_sub2_sub4;\nwire [3:1] B_out_sub3_sub4;\n\nwire [3:1] B_out_sub1_sub2_sub3, B_out_sub1_sub2_sub4, B_out_sub1_sub3_sub4;\nwire [3:1] B_out_sub2_sub3_sub4;\n\nwire [3:1] B_out_sub1_sub2_sub3_sub4;\n\nwire [3:1] B_out_sub1_sub2_sub3_sub4_sub1;\n\nassign B_out = B_out_sub1_sub2_sub3_sub4_sub1[1];\n\n// sub1\nfull_subtractor_4bit sub1_sub1 (A[1:1], B[1:1], D[1:1], B_out_sub1[1]);\nfull_subtractor_4bit sub1_sub2 (A[2:2], B[2:2], D[2:2], B_out_sub1[2]);\nfull_subtractor_4bit sub1_sub3 (A[3:3], B[3:3], D[3:3], B_out_sub1[3]);\n\n// sub2\nfull_subtractor_4bit sub2_sub1 (A[4:4], B[4:4], D[4:4], B_out_sub2[1]);\nfull_subtractor_4bit sub2_sub2 (A[5:5], B[5:5], D[5:5], B_out_sub2[2]);\nfull_subtractor_4bit sub2_sub3 (A[6:6], B[6:6], D[6:6], B_out_sub2[3]);\n\n// sub3\nfull_subtractor_4bit sub3_sub1 (A[7:7], B[7:7], D[7:7], B_out_sub3[1]);\nfull_subtractor_4bit sub3_sub2 (A[8:8], B[8:8], D[8:8], B_out_sub3[2]);\nfull_subtractor_4bit sub3_sub3 (A[9:9], B[9:9], D[9:9], B_out_sub3[3]);\n\n// sub4\nfull_subtractor_4bit sub4_sub1 (A[10:10], B[10:10], D[10:10], B_out_sub4[1]);\nfull_subtractor_4bit sub4_sub2 (A[11:11], B[11:11], D[11:11], B_out_sub4[2]);\nfull_subtractor_4bit sub4_sub3 (A[12:12], B[12:12], D[12:12], B_out_sub4[3]);\n\n// sub1_sub2\nfull_subtractor_4bit sub1_sub2_sub3 (A[3:3], B[3:3], D[3:3], B_out_sub1_sub2[3]);\nfull_subtractor_4bit sub1_sub2_sub4 (A[4:4], B[4:4], D[4:4], B_out_sub1_sub2[4]);\n\n// sub1_sub3\nfull_subtractor_4bit sub1_sub3_sub4 (A[5:5], B[5:5], D[5:5], B_out_sub1_sub3[4]);\n\n// sub1_sub2_sub3\nfull_subtractor_4"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtraction operation\nassign sub_result = A - B;\nassign carry = (sub_result[31] == 1);\n\n// Comparison logic\nassign A_greater = (sub_result != 0) && (carry == 0);\nassign A_equal = (sub_result == 0);\nassign A_less = (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[32] ^ B[32]) | (A[31] & B[31]) | (A[30] & B[30]) | (A[29] & B[29]) | (A[28] & B[28]) | (A[27] & B[27]) | (A[26] & B[26]) | (A[25] & B[25]) | (A[24] & B[24]) | (A[23] & B[23]) | (A[22] & B[22]) | (A[21] & B[21]) | (A[20] & B[20]) | (A[19] & B[19]) | (A[18] & B[18]) | (A[17] & B[17]) | (A[16] & B[16]);\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\nwire [3:0] carry_slices;\n\n// Ripple carry adder for the first 4 bits\nwire [3:0] a_slices;\nwire [3:0] b_slices;\nwire [3:0] sum_slices_rca;\nwire [3:0] carry_rca;\n\nassign a_slices[0] = a[0];\nassign a_slices[1] = a[1];\nassign a_slices[2] = a[2];\nassign a_slices[3] = a[3];\n\nassign b_slices[0] = b[0];\nassign b_slices[1] = b[1];\nassign b_slices[2] = b[2];\nassign b_slices[3] = b[3];\n\nassign sum_slices_rca[0] = a_slices[0] ^ b_slices[0];\nassign sum_slices_rca[1] = a_slices[1] ^ b_slices[1];\nassign sum_slices_rca[2] = a_slices[2] ^ b_slices[2];\nassign sum_slices_rca[3] = a_slices[3] ^ b_slices[3];\n\nassign carry_rca[0] = a_slices[0] & b_slices[0];\nassign carry_rca[1] = a_slices[1] & b_slices[1];\nassign carry_rca[2] = a_slices[2] & b_slices[2];\nassign carry_rca[3] = a_slices[3] & b_slices[3];\n\n// Carry select adder for the first 4 bits\nwire [3:0] sum_slices_csa;\nwire [3:0] carry_csa;\n\nassign sum_slices_csa[0] = (carry_rca[0] ^ cin) ? sum_slices_rca[0] : 1'b0;\nassign sum_slices_csa[1] = (carry_rca[1] ^ cin) ? sum_slices_rca[1] : 1'b0;\nassign sum_slices_csa[2] = (carry_rca[2] ^ cin) ? sum_slices_rca[2] : 1'b0;\nassign sum_slices_csa[3] = (carry_rca[3] ^ cin) ? sum_slices_rca[3] : 1'b0;\n\nassign carry_csa[0] = (carry_rca[0] ^ cin) ? 1'b1 : 1'b0;\nassign carry_csa[1] = (carry_rca[1] ^ cin) ? 1'b1 : 1'b0;\nassign carry_csa[2] = (carry_rca[2] ^ cin) ? 1'b1 : 1'b0;\nassign carry_csa[3] = (carry_rca[3] ^ cin) ? 1'b1 : 1'b0;\n\n// Carry select adder for the next 4 bits\nwire [3:0] sum_slices_csa2;\nwire [3:0] carry_csa2;\n\nassign sum_slices_csa2[0] = (carry_csa[0] ^ cin) ? sum_slices_csa[0] : 1'b0;\nassign sum_slices_csa2[1] = (carry_csa[1] ^ cin) ? sum_slices_csa[1] : 1'b0;\nassign sum_slices_csa2[2] = (carry_csa[2] ^ cin) ? sum_slices_csa[2] : 1'b0;\nassign sum_slices_csa2[3] = (carry_csa[3] ^ cin) ? sum_slices_csa["}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co1, Co2, Co3, Co4, Co5, Co6, Co7, Co8;\n\n    // 8-bit adder instantiation\n    // Replace the following line with the correct instantiation\n    // adder_8bit adder_8bit_inst1 (.a(a[7:0]), .b(b[7:0]), .Cin(Cin), .y(y[7:0]), .Co(Co1));\n    // adder_8bit adder_8bit_inst2 (.a(a[15:8]), .b(b[15:8]), .Cin(Co1), .y(y[15:8]), .Co(Co2));\n\n    // 8-bit adder implementation\n    // Replace the following line with the correct implementation\n    // assign {Co3, y[7:0]} = a[7:0] + b[7:0] + Cin;\n    // assign {Co4, y[15:8]} = a[15:8] + b[15:8] + Co3;\n\n    assign {Co5, y[7:0]} = a[7:0] + b[7:0] + Cin;\n    assign {Co6, y[15:8]} = a[15:8] + b[15:8] + Co5;\n    assign {Co7, y[15:8]} = y[15:8] + 1'b1;\n    assign {Co8, y[15:8]} = y[15:8] + 1'b1;\n    assign {Co, y[15:0]} = y[15:0] + 1'b1;\n\n    assign Co = Co8;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    \n    // FA0\n    assign FA0 = a[0] ^ b[0] ^ cin;\n    assign sum[0] = FA0;\n    assign FA1 = a[1] ^ b[1] ^ FA0;\n    assign sum[1] = FA1;\n    assign FA2 = a[2] ^ b[2] ^ FA1;\n    assign sum[2] = FA2;\n    assign FA3 = a[3] ^ b[3] ^ FA2;\n    assign sum[3] = FA3;\n    assign FA4 = a[4] ^ b[4] ^ FA3;\n    assign sum[4] = FA4;\n    assign FA5 = a[5] ^ b[5] ^ FA4;\n    assign sum[5] = FA5;\n    assign FA6 = a[6] ^ b[6] ^ FA5;\n    assign sum[6] = FA6;\n    assign FA7 = a[7] ^ b[7] ^ FA6;\n    assign sum[7] = FA7;\n    assign cout = FA7;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1'b1;\n                product <= product + (bin << shift_cnt);\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] a_shift;\nreg [15:0] b_shift;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_shift <= 16'b0;\n        b_shift <= 16'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            a_shift <= a_reg;\n            b_shift <= b_reg;\n        end else begin\n            a_shift <= {a_shift[14:0], 1'b0};\n            b_shift <= {b_shift[14:0], 1'b0};\n        end\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            product <= {16'b0, a_shift};\n        end else begin\n            if (b_shift[shift_cnt]) begin\n                product <= product + (b_shift << (shift_cnt - 1));\n            end\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_register_count)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end else begin\n            init_out <= init_out;\n        end\n    end\n\n    // Submodule for state transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule instantiation\nJC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\nJC_logic logic_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'b0;\n    else\n        Q_reg <= Q_reg + 1;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q_reg <= 64'b0;\n    else\n        Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\nassign Q = Q_reg;\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_reg <= 1'b0;\n    end else begin\n        CLK_50_reg <= ~CLK_50_reg;\n    end\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_reg <= 1'b0;\n    end else begin\n        CLK_10_reg <= ~CLK_10_reg;\n    end\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_reg <= 1'b0;\n    end else begin\n        CLK_1_reg <= ~CLK_1_reg;\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_counter;\nwire clk_div_counter_rst;\nwire clk_div_counter_en;\nwire clk_div_counter_max;\nwire clk_div_counter_max_rst;\nwire clk_div_counter_max_en;\nwire clk_div_counter_max_clk;\nwire clk_div_counter_max_clk_rst;\nwire clk_div_counter_max_clk_en;\nwire clk_div_counter_max_clk_max;\nwire clk_div_counter_max_clk_max_rst;\nwire clk_div_counter_max_clk_max_en;\nwire clk_div_counter_max_clk_max_clk;\nwire clk_div_counter_max_clk_max_clk_rst;\nwire clk_div_counter_max_clk_max_clk_en;\n\nwire clk_div_clk_div;\nwire clk_div_clk_div_rst;\nwire clk_div_clk_div_en;\nwire clk_div_clk_div_clk;\nwire clk_div_clk_div_clk_rst;\nwire clk_div_clk_div_clk_en;\n\nreg [3:0] clk_div_counter_max_clk_max;\nreg [3:0] clk_div_counter_max_clk_max_clk;\n\n// Counter Submodule\nreg [3:0] clk_div_counter_max_clk;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter_max_clk <= 0;\n    end else if (clk_div_counter_max_clk_max_clk_en) begin\n        clk_div_counter_max_clk <= clk_div_counter_max_clk_max_clk;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter_max_clk_max <= 0;\n    end else if (clk_div_counter_max_clk_max_en) begin\n        clk_div_counter_max_clk_max <= clk_div_counter_max;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_div_counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter <= 0;\n    end else if (clk_div_counter_en) begin\n        clk_div_counter <= clk_div_counter + 1;\n    end\nend\n\nassign clk_div_counter_rst = ~rst_n;\nassign clk_div_counter_en = clk;\nassign clk_div_counter_max = (MUL2_DIV_CLK - 1);\nassign clk_div_counter_max_rst = ~rst_n;\nassign clk_div_counter_max_en = clk_div_counter_max_clk_max_clk_en;\nassign clk_div_counter_max_clk = clk_div_counter_max;\nassign clk_div_counter_max_clk_rst = ~rst_n;\nassign clk_div_counter_max_clk_en = clk_div_counter_max_clk_max_clk_en;\nassign clk_div_counter_max_clk_max = clk_div_counter_max;\nassign clk_div_counter_max_clk_max_rst = ~rst_n;\nassign clk_div_counter_max_clk_max_en = clk_div_counter_max_clk_max_clk_en;\nassign clk_div_counter_max_clk_max_clk = clk_div_counter_max;\nassign clk_div_counter_max_clk_max_clk_rst = ~rst_n;\nassign clk_div_counter_max_clk_max_"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV/2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nparameter NUM_DIV = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (q == NUM_DIV/2 - 1)\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter_reset,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter_reset)\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Addition\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    // Subtraction\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    // Logical operations\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n\n    // Shift operations\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_r),\n        .zero(sll_zero),\n        .carry(sll_carry),\n        .negative(sll_negative),\n        .overflow(sll_overflow)\n    );\n    srl srl_inst(\n        .a(a"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [31:0] a_in;\nwire [31:0] b_in;\nwire [63:0] multiplication_result_in;\n\nassign a_in = a;\nassign b_in = b;\nassign multiplication_result_in = a_in * b_in;\n\n// Accumulator Submodule\nwire [31:0] current_value_in;\nwire [31:0] new_value;\n\nassign current_value_in = current_value;\nassign new_value = current_value_in + multiplication_result_in[31:0];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= new_value;\n    end\nend\n\nassign c = current_value;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register 1\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            ins_p1_reg <= 0;\n            ad1_p1_reg <= 0;\n            ad2_p1_reg <= 0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n            ad1_p1_reg <= data[4:0];\n            ad2_p1_reg <= data;\n        end\n    end\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n\n    // Instruction register 2\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            ins_p2_reg <= 0;\n            ad1_p2_reg <= 0;\n            ad2_p2_reg <= 0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data[7:5];\n            ad1_p2_reg <= data[4:0];\n            ad2_p2_reg <= data;\n        end\n    end\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    // Output\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\n// Counter Module\nreg [7:0] count_reg;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\nassign count = count_reg;\n\n// Wave Generator Module\nreg wave_out_reg;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\nend\nassign wave_out = wave_out_reg;\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state_reg;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave_reg;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    assign q = (sel == 2'b00) ? d :\n               (sel == 2'b01) ? dff_out[0] :\n               (sel == 2'b10) ? dff_out[1] :\n               dff_out[2];\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff my_dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff my_dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff my_dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // 2-to-1 multiplexer\n    wire [7:0] mux2X1_out;\n    wire sel;\n\n    // Stage 1\n    assign stage1_out = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n\n    // Stage 2\n    assign stage2_out = (ctrl[1]) ? {stage1_out[3:0], stage1_out[7:4]} : stage1_out;\n\n    // Stage 3\n    assign stage3_out = (ctrl[0]) ? {stage2_out[3:0], stage2_out[7:4]} : stage2_out;\n\n    // Output\n    assign out = stage3_out;\n\n    // 2-to-1 multiplexer\n    assign mux2X1_out = (sel) ? stage1_out : stage2_out;\n    assign sel = ctrl[2];\n\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  reg [31:0] pc;\n  reg [31:0] reg_file_next [0:31];\n  reg [31:0] res_reg_file_next [0:31];\n  reg [31:0] alu_out_next;\n  reg [31:0] pc_next;\n\n  stagepipe5_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .alu_out(alu_out),\n    .pc_next(pc_next)\n  );\n\n  stagepipe5_decode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .reg_file(reg_file),\n    .reg_file_next(reg_file_next),\n    .alu_out_next(alu_out_next)\n  );\n\n  stagepipe5_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out_next(alu_out_next),\n    .reg_file_next(reg_file_next),\n    .res_reg_file_next(res_reg_file_next)\n  );\n\n  stagepipe5_memory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out_next(alu_out_next),\n    .reg_file_next(reg_file_next),\n    .res_reg_file_next(res_reg_file_next)\n  );\n\n  stagepipe5_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file_next(res_reg_file_next),\n    .reg_file(reg_file)\n  );\n\n  assign res_reg_file = res_reg_file_next;\n  assign pc = pc_next;\nendmodule\n\nmodule stagepipe5_fetch (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] alu_out,\n  output [31:0] pc_next\n);\n  reg [31:0] alu_out_reg;\n  reg [31:0] pc_next_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_out_reg <= 0;\n      pc_next_reg <= 0;\n    end else begin\n      alu_out_reg <= instr_mem[pc];\n      pc_next_reg <= pc + 1;\n    end\n  end\n\n  assign alu_out = alu_out_reg;\n  assign pc_next = pc_next_reg;\nendmodule\n\nmodule stagepipe5_decode (\n  input clk,\n  input rst,\n  input [31:0] alu_out,\n  input [31:0] reg_file [0:31],\n  output [31:0] reg_file_next [0:31],\n  output [31:0] alu_out_next\n);\n  reg [31:0] reg_file_next_reg [0:31];\n  reg [31:0] alu_out_next_reg;\n  reg [31:0] rs1_reg;\n  reg [31:0] rs2_reg;\n  reg [31:0] rd_reg;\n  reg [31:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file_next_reg <= 0;\n      alu_out_next_reg <= 0;\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= al"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= b0_reg * a0;\n      c1_reg <= b1_reg * a1;\n      c2_reg <= b2_reg * a2;\n      c3_reg <= b3_reg * a3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] op;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n    wire [31:0] reg_file_out;\n\n    reg [31:0] out_reg_file_reg;\n\n    assign out_reg_file = out_reg_file_reg;\n\n    stagepipe3_fetch_stage fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch_out(fetch_out)\n    );\n\n    stagepipe3_execute_stage execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .fetch_out(fetch_out),\n        .reg_file(reg_file),\n        .execute_out(execute_out)\n    );\n\n    stagepipe3_writeback_stage writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .execute_out(execute_out),\n        .reg_file_out(reg_file_out)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file_reg <= 0;\n        end else begin\n            out_reg_file_reg <= reg_file_out;\n        end\n    end\n\nendmodule\n\nmodule stagepipe3_fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetch_out\n);\n\n    reg [31:0] fetch_out_reg;\n\n    assign fetch_out = fetch_out_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetch_out_reg <= 0;\n        end else begin\n            fetch_out_reg <= instr_mem[pc];\n        end\n    end\n\nendmodule\n\nmodule stagepipe3_execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetch_out,\n    input [31:0] reg_file [0:31],\n    output [31:0] execute_out\n);\n\n    reg [31:0] execute_out_reg;\n\n    assign execute_out = execute_out_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            execute_out_reg <= 0;\n        end else begin\n            case (fetch_out[31:26])\n                6'b000000: execute_out_reg <= reg_file[fetch_out[5:0]] + fetch_out[31:26];\n                6'b000010: execute_out_reg <= reg_file[fetch_out[5:0]] - fetch_out[31:26];\n                default: execute_out_reg <= 0;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule stagepipe3_writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] execute_out,\n    output [31:0] reg_file_out\n);\n\n    reg [31:0] reg_file_out_reg;\n\n    assign reg_file_out = reg_file_out_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file_out_reg <= 0;\n        end else begin\n            reg_file_out_reg <= execute_out;\n        end\n    end\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_reg <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt <= cnt + 3'd1;\n            if (cnt == 3'd4) begin\n                valid_out_reg <= 1'b1;\n            end\n        end else begin\n            valid_out_reg <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_reg;\n\n// Data Accumulator Module\nreg     [9:0]   data_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out_reg <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_out_reg <= data_out_reg + data_in;\n        end\n    end\nend\n\nassign data_out = data_out_reg;\n\nendmodule\n\n// Counter Module\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_reg;\nreg     [2:0]   cnt_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_reg <= 3'd0;\n        valid_out_reg <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt_reg <= cnt_reg + 3'd1;\n            if (cnt_reg == 3'd4) begin\n                valid_out_reg <= 1'b1;\n            end\n        end else begin\n            valid_out_reg <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_reg;\nassign cnt = cnt_reg;\n\nendmodule\n\n// Data Accumulator Module\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_out_reg;\nreg             valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out_reg <= 10'd0;\n        valid_out_reg <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_out_reg <= data_out_reg + data_in;\n            valid_out_reg <= 1'b1;\n        end else begin\n            valid_out_reg <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_reg;\nassign data_out = data_out_reg;\n\nendmodule\n\n// Valid Output Module\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg             valid_out_reg;\nreg     [9:0]   data_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n        data_out_reg <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            valid_out_reg <= 1'b1;\n            data_out_reg <= data_out_reg + 10'd1;\n        end else begin\n            valid_out"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg [0:7];\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            abs_dividend <= 8'b0;\n        end else if (opn_valid) begin\n            if (sign) begin\n                abs_dividend <= -dividend;\n            end else begin\n                abs_dividend <= dividend;\n            end\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            neg_divisor <= 8'b0;\n        end else if (opn_valid) begin\n            if (sign) begin\n                neg_divisor <= -divisor;\n            end else begin\n                neg_divisor <= divisor;\n            end\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 3'b0;\n            shift_reg[0] <= 8'b0;\n            quotient <= 16'b0;\n            remainder <= 16'b0;\n        end else if (opn_valid) begin\n            if (counter == 3'b0) begin\n                shift_reg[0] <= abs_dividend;\n                counter <= 3'b1;\n            end else if (shift_reg[counter-1] < neg_divisor) begin\n                shift_reg[counter] <= shift_reg[counter-1] + shift_reg[counter-1];\n                counter <= counter + 3'b1;\n            end else begin\n                shift_reg[counter] <= shift_reg[counter-1];\n                counter <= counter + 3'b1;\n            end\n        end\n    end\n\n    // Result Management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n            quotient <= 16'b0;\n            remainder <= 16'b0;\n        end else if (opn_valid) begin\n            if (counter == 3'b0) begin\n                res_valid <= 1'b0;\n            end else if (res_ready) begin\n                quotient <= shift_reg[counter-1] >> 1;\n                remainder <= shift_reg[counter-1] - (neg_divisor << (counter-1));\n                res_valid <= 1'b1;\n            end\n        end\n    end\n\n    assign result = {remainder, quotient};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [15:0] divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    // Perform division\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [4:0] i;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient_reg = 32'b0;\n        remainder_reg = 32'b0;\n\n        for (i = 0; i < 16; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient_reg = quotient_reg << 1;\n                quotient_reg = quotient_reg | 1'b1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                quotient_reg = quotient_reg << 1;\n                shifted_dividend = shifted_dividend;\n            end\n            shifted_divisor = shifted_divisor << 1;\n        end\n\n        remainder_reg = shifted_dividend;\n    end\n\n    // Assign outputs\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    // ...\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\nassign {B_out_temp, sum} = A + B_comp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : full_adder_loop\n        full_adder fa (\n            .a(A[i]),\n            .b(B_comp[i]),\n            .cin(carry[i]),\n            .sum(sum[i]),\n            .cout(carry[i+1])\n        );\n    end\nendgenerate\n\nassign D = sum;\nassign B_out = B_out_temp;\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\nassign {B_out_temp, sum} = A + B_comp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : full_adder_loop\n        full_adder fa (\n            .a(A[i]),\n            .b(B_comp[i]),\n            .cin(carry[i]),\n            .sum(sum[i]),\n            .cout(carry[i+1])\n        );\n    end\nendgenerate\n\nassign D = sum;\nassign B_out = B_out_temp;\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\nsub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[31:16]), .B_out(B_out));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff8), .B_out(B_out8));\nsub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[15:8]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff4), .B_out(B_out4));\nsub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff2), .B_out(B_out2));\nsub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(.A(A[0:0]), .B(B[0:0]), .Diff(Diff1), .B_out(B_out1));\nsub_1bit sub1_1(.A(A[1:1]), .B(B[1:1]), .Diff(Diff[1:1]), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput [0:0] A, B;\noutput [0:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A < B) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire [3:1] B_out1, B_out2, B_out3, B_out4;\n\nwire [4:1] B_out;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\n\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign D1 = A1 - B1;\nassign D2 = A2 - B2;\nassign D3 = A3 - B3;\nassign D4 = A4 - B4;\n\nassign B_out1 = D1[4] ? 1'b1 : 1'b0;\nassign B_out2 = D2[4] ? 1'b1 : 1'b0;\nassign B_out3 = D3[4] ? 1'b1 : 1'b0;\nassign B_out4 = D4[4] ? 1'b1 : 1'b0;\n\nassign B_out = {B_out4, B_out3, B_out2, B_out1};\n\nassign D = {D4, D3, D2, D1};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\n\n// Subtractor module\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .sub_result(sub_result)\n);\n\n// Carry generation\nassign A_greater = (sub_result != 0);\nassign A_equal = (sub_result == 0);\nassign A_less = (sub_result[31] == 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result  // Result of subtraction\n);\n\nassign sub_result = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] + B[32:1];\nassign C32 = 1;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [3:0] rca1_cout, rca2_cout, rca3_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] rca1_cout_next, rca2_cout_next, rca3_cout_next;\n\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_cout = rca1_sum[3];\nassign rca2_sum = rca1_cout ? a[7:4] + b[7:4] + 1 : a[7:4] + b[7:4];\nassign rca2_cout = rca2_sum[3];\nassign rca3_sum = rca2_cout ? a[11:8] + b[11:8] + 1 : a[11:8] + b[11:8];\nassign rca3_cout = rca3_sum[3];\n\n// 4-bit carry select adder slice\nwire [3:0] csa_slice1_cout_next, csa_slice2_cout_next, csa_slice3_cout_next;\n\nassign csa_slice1_sum = rca1_sum[3:0] + rca2_sum[3:0];\nassign csa_slice1_cout = rca1_cout ? rca2_sum[3:0] + 4'b0001 : rca2_sum[3:0];\nassign csa_slice2_sum = csa_slice1_cout[3:0] + rca3_sum[3:0];\nassign csa_slice2_cout = csa_slice1_cout[3] ? csa_slice2_sum[3:0] + 4'b0001 : csa_slice2_sum[3:0];\nassign csa_slice3_sum = csa_slice2_cout[3:0] + 4'b0000;\nassign csa_slice3_cout = csa_slice2_cout[3] ? csa_slice3_sum[3:0] + 4'b0001 : csa_slice3_sum[3:0];\n\nassign sum = {csa_slice3_cout[2:0], csa_slice3_sum[2:0], csa_slice2_cout[2:0], csa_slice2_sum[2:0], csa_slice1_cout[2:0], csa_slice1_sum[2:0]};\nassign cout = csa_slice3_cout[3];\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co1, Co2, Co3, Co4, Co5, Co6, Co7, Co8;\n    wire [7:0] y1, y2, y3, y4, y5, y6, y7, y8;\n\n    // 8-bit adder\n    adder_8bit adder8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y1),\n        .Co(Co1)\n    );\n    adder_8bit adder8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n    adder_8bit adder8_inst3 (\n        .a(y1),\n        .b(y2),\n        .Cin(1'b0),\n        .y(y3),\n        .Co(Co3)\n    );\n    adder_8bit adder8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y4),\n        .Co(Co4)\n    );\n    adder_8bit adder8_inst5 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co4),\n        .y(y5),\n        .Co(Co5)\n    );\n    adder_8bit adder8_inst6 (\n        .a(y3),\n        .b(y5),\n        .Cin(1'b0),\n        .y(y6),\n        .Co(Co6)\n    );\n    adder_8bit adder8_inst7 (\n        .a(y4),\n        .b(y6),\n        .Cin(1'b0),\n        .y(y7),\n        .Co(Co7)\n    );\n    adder_8bit adder8_inst8 (\n        .a(y7),\n        .b(y6),\n        .Cin(1'b0),\n        .y(y8),\n        .Co(Co8)\n    );\n\n    assign y = {y8, y7, y6, y5, y4, y3, y2, y1};\n    assign Co = Co8;\nendmodule\n\n// 8-bit adder\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire Co1, Co2, Co3;\n    wire [3:0] y1, y2, y3;\n\n    // 4-bit adder\n    adder_4bit adder4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y1),\n        .Co(Co1)\n    );\n    adder_4bit adder4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n    adder_4bit adder4_inst3 (\n        .a(y1),\n        .b(y2),\n        .Cin(1'b0),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    assign y = {y3, y2, y1};\n    assign Co = Co3;\nendmodule\n\n// 4-bit adder\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire Co1, Co2;\n    wire [1:0] y1, y2;\n\n    // 2-bit adder"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // First bit adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout)\n    );\n    \n    // Second bit adder\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout)\n    );\n    \n    // Third bit adder\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout)\n    );\n    \n    // Fourth bit adder\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout)\n    );\n    \n    // Fifth bit adder\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout)\n    );\n    \n    // Sixth bit adder\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout)\n    );\n    \n    // Seventh bit adder\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout)\n    );\n    \n    // Eighth bit adder\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout)\n    );\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout;\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                shift_cnt <= 4'b0;\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [15:0] a_shift;\nreg [15:0] b_shift;\nreg [31:0] product_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_shift <= 16'b0;\n        b_shift <= 16'b0;\n        product_reg <= 32'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            a_shift <= a_reg;\n            b_shift <= b_reg;\n            product_reg <= 32'b0;\n        end else begin\n            a_shift <= {a_shift[14:0], 1'b0};\n            b_shift <= {b_shift[14:0], 1'b0};\n            if (a_shift[0] == 1'b1) begin\n                product_reg <= product_reg + b_shift;\n            end\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product_reg;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // Instantiate submodules\n    u_counter_logic u_counter_logic_inst (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_out)\n    );\n\n    u_counter_register u_counter_register_inst (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_logic_out),\n        .count_out(u_counter_register_out)\n    );\n\n    assign count = u_counter_register_out;\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else if (up_down) begin\n            count_reg <= count_reg + 1;\n        end else begin\n            count_reg <= count_reg - 1;\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output wire [15:0] count_out\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            count_reg <= count;\n        end\n    end\n\n    assign count_out = count_reg;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // State Initialization submodule\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\n    // State Transition submodule\n    always @(posedge clk) begin\n        out <= {out[6:0], out[7]};\n    end\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule JC_register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= Q + 1;\nend\n\nendmodule\n\n// Submodule JC_logic\nmodule JC_logic(\n    input [63:0]       Q,\n    output reg [63:0]   Q_next\n);\n\nalways @(*) begin\n    Q_next = Q;\n    Q_next[0] = Q[63];\nend\n\nendmodule\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_r;\nreg CLK_10_r;\nreg CLK_1_r;\n\n// clk_div_2\nreg [1:0] clk_div_2_cnt;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_r <= 0;\n        clk_div_2_cnt <= 0;\n    end else begin\n        if (clk_div_2_cnt == 2'b11) begin\n            CLK_50_r <= ~CLK_50_r;\n            clk_div_2_cnt <= 0;\n        end else begin\n            clk_div_2_cnt <= clk_div_2_cnt + 1;\n        end\n    end\nend\n\n// clk_div_10\nreg [1:0] clk_div_10_cnt;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_r <= 0;\n        clk_div_10_cnt <= 0;\n    end else begin\n        if (clk_div_10_cnt == 2'b11) begin\n            CLK_10_r <= ~CLK_10_r;\n            clk_div_10_cnt <= 0;\n        end else begin\n            clk_div_10_cnt <= clk_div_10_cnt + 1;\n        end\n    end\nend\n\n// clk_div_100\nreg [5:0] clk_div_100_cnt;\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_r <= 0;\n        clk_div_100_cnt <= 0;\n    end else begin\n        if (clk_div_100_cnt == 6'b111111) begin\n            CLK_1_r <= ~CLK_1_r;\n            clk_div_100_cnt <= 0;\n        end else begin\n            clk_div_100_cnt <= clk_div_100_cnt + 1;\n        end\n    end\nend\n\nassign CLK_50 = CLK_50_r;\nassign CLK_10 = CLK_10_r;\nassign CLK_1 = CLK_1_r;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_counter;\nwire [3:0] clk_div_counter_2;\nwire [3:0] clk_div_counter_3;\nwire [3:0] clk_div_counter_4;\nwire [3:0] clk_div_counter_5;\n\nwire clk_div_counter_2_neg;\nwire clk_div_counter_3_neg;\nwire clk_div_counter_4_neg;\nwire clk_div_counter_5_neg;\n\nreg [3:0] clk_div_counter_reg;\nreg [3:0] clk_div_counter_2_reg;\nreg [3:0] clk_div_counter_3_reg;\nreg [3:0] clk_div_counter_4_reg;\nreg [3:0] clk_div_counter_5_reg;\n\nreg [3:0] clk_div_counter_2_reg_neg;\nreg [3:0] clk_div_counter_3_reg_neg;\nreg [3:0] clk_div_counter_4_reg_neg;\nreg [3:0] clk_div_counter_5_reg_neg;\n\nreg clk_div_reg;\n\nassign clk_div = clk_div_reg;\n\n// Counter Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter_reg <= 0;\n    end else begin\n        clk_div_counter_reg <= clk_div_counter_reg + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter_2_reg <= 0;\n        clk_div_counter_3_reg <= 0;\n        clk_div_counter_4_reg <= 0;\n        clk_div_counter_5_reg <= 0;\n    end else begin\n        clk_div_counter_2_reg <= clk_div_counter_reg;\n        clk_div_counter_3_reg <= clk_div_counter_2_reg;\n        clk_div_counter_4_reg <= clk_div_counter_3_reg;\n        clk_div_counter_5_reg <= clk_div_counter_4_reg;\n    end\nend\n\nassign clk_div_counter_2_neg = ~clk_div_counter_2_reg;\nassign clk_div_counter_3_neg = ~clk_div_counter_3_reg;\nassign clk_div_counter_4_neg = ~clk_div_counter_4_reg;\nassign clk_div_counter_5_neg = ~clk_div_counter_5_reg;\n\n// Clock Adjustment Submodule\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_counter_2_reg_neg <= 0;\n        clk_div_counter_3_reg_neg <= 0;\n        clk_div_counter_4_reg_neg <= 0;\n        clk_div_counter_5_reg_neg <= 0;\n    end else begin\n        clk_div_counter_2_reg_neg <= clk_div_counter_2_neg;\n        clk_div_counter_3_reg_neg <= clk_div_counter_3_neg;\n        clk_div_counter_4_reg_neg <= clk_div_counter_4_neg;\n        clk_div_counter_5_reg_neg <= clk_div_counter_5_neg;\n    end\nend\n\nassign clk_div_counter = {clk_div_counter_5_reg_neg, clk_div_counter_4_reg_neg, clk_div_counter_3_reg_neg, clk_div_counter_2_reg_neg};\n\n// Final Clock Output\nalways @(posed"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        q <= 0;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Addition\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n\n    // Subtraction\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n\n    // Logical operations\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow),\n        .flag(and_flag)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow),\n        .flag(or_flag)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow),\n        .flag(xor_flag)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow),\n        .flag(nor_flag)\n    );\n\n    // Shift operations\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_r),\n       "}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] multiplication_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] multiplication_result_64;\nassign multiplication_result_64 = a * b;\nassign multiplication_result = multiplication_result_64[31:0];\n\n// Accumulator Submodule\nreg [31:0] current_value_reg;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value_reg <= 0;\n    end else begin\n        current_value_reg <= current_value_reg + multiplication_result;\n    end\nend\nassign current_value = current_value_reg;\n\n// Output\nassign c = current_value;\n\nendmodule\n\n\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n            ad1_p1_reg <= data[4:0];\n            ad2_p1_reg <= data;\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data[7:5];\n            ad1_p2_reg <= data[4:0];\n            ad2_p2_reg <= data;\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = fetch == 2'b01 ? ins_p1 : ins_p2;\n    assign ad1 = fetch == 2'b01 ? ad1_p1 : ad1_p2;\n    assign ad2 = fetch == 2'b01 ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule_state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state_reg <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state_reg <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule submodule_wave_inst (\n    input clk,\n    input rst_n,\n    input [4:0] wave_reg,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg_next <= 5'b00000;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        wave_reg_next <= wave_reg + 1;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        wave_reg_next <= wave_reg - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg_next;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        q <= sel[0] ? q2 : q3;\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    reg [7:0] q1, q2, q3;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q1));\n    my_dff8 u1 (.clk(clk), .d(q1), .q(q2));\n    my_dff8 u2 (.clk(clk), .d(q2), .q(q3));\n\n    always @(posedge clk) begin\n        q <= sel[0] ? q3 : d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    // Instantiate the D flip-flop module\n    my_dff dff0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    wire [7:0] stage1_in;\n    wire [7:0] stage1_ctrl;\n    assign stage1_in = in;\n    assign stage1_ctrl = {ctrl[2], ctrl[1], ctrl[0]};\n    assign stage1_out = (stage1_ctrl[2]) ? {stage1_in[3:0], stage1_in[7:4]} :\n                        (stage1_ctrl[1]) ? {stage1_in[1:0], stage1_in[7:2]} :\n                        (stage1_ctrl[0]) ? {stage1_in[0], stage1_in[7:1]} : stage1_in;\n\n    // Stage 2\n    wire [7:0] stage2_in;\n    wire [7:0] stage2_ctrl;\n    assign stage2_in = stage1_out;\n    assign stage2_ctrl = {stage1_ctrl[2], stage1_ctrl[1], stage1_ctrl[0]};\n    assign stage2_out = (stage2_ctrl[2]) ? {stage2_in[3:0], stage2_in[7:4]} :\n                        (stage2_ctrl[1]) ? {stage2_in[1:0], stage2_in[7:2]} :\n                        (stage2_ctrl[0]) ? {stage2_in[0], stage2_in[7:1]} : stage2_in;\n\n    // Stage 3\n    wire [7:0] stage3_in;\n    wire [7:0] stage3_ctrl;\n    assign stage3_in = stage2_out;\n    assign stage3_ctrl = {stage2_ctrl[2], stage2_ctrl[1], stage2_ctrl[0]};\n    assign stage3_out = (stage3_ctrl[2]) ? {stage3_in[3:0], stage3_in[7:4]} :\n                        (stage3_ctrl[1]) ? {stage3_in[1:0], stage3_in[7:2]} :\n                        (stage3_ctrl[0]) ? {stage3_in[0], stage3_in[7:1]} : stage3_in;\n\n    // Output\n    assign out = stage3_out;\n\n    // MUX2X1\n    wire [7:0] mux_sel;\n    assign mux_sel = {stage1_ctrl[2], stage1_ctrl[1], stage1_ctrl[0]};\n    assign mux_out = (mux_sel[2]) ? {stage1_in[3:0], stage1_in[7:4]} :\n                     (mux_sel[1]) ? {stage1_in[1:0], stage1_in[7:2]} :\n                     (mux_sel[0]) ? {stage1_in[0], stage1_in[7:1]} : stage1_in;\n\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  reg [31:0] next_pc;\n  reg [31:0] alu_out;\n  reg [31:0] res_reg_file [0:31];\n\n  // Fetch stage\n  wire [31:0] instr;\n  reg [31:0] pc_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n    end else begin\n      pc_reg <= next_pc;\n    end\n  end\n  assign instr = instr_mem[pc_reg];\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n    end else begin\n      next_pc <= pc_reg + 4;\n    end\n  end\n\n  // Decode stage\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[20:15];\n      rs2 <= instr[15:10];\n      rd <= instr[4:0];\n      op <= instr[31:26];\n    end\n  end\n\n  // Execute stage\n  wire [31:0] rs1_val, rs2_val;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_val <= 0;\n      rs2_val <= 0;\n    end else begin\n      rs1_val <= reg_file[rs1];\n      rs2_val <= reg_file[rs2];\n    end\n  end\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_out <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_out <= rs1_val + rs2_val;\n        6'b001010: alu_out <= rs1_val - rs2_val;\n        default: alu_out <= 0;\n      endcase\n    end\n  end\n\n  // Memory stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_out;\n    end\n  end\n\n  // Writeback stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_out;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [31:0] pe0, pe1, pe2, pe3;\n\n  assign pe0 = a0 * b0;\n  assign pe1 = a1 * b1_reg;\n  assign pe2 = a2 * b2_reg;\n  assign pe3 = a3 * b3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= pe0;\n      c1_reg <= pe1;\n      c2_reg <= pe2;\n      c3_reg <= pe3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    wire [4:0] reg_file_write_addr;\n    wire [4:0] reg_file_read_addr1;\n    wire [4:0] reg_file_read_addr2;\n    wire [31:0] reg_file_read_data1;\n    wire [31:0] reg_file_read_data2;\n    wire [31:0] reg_file_write_data;\n\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [4:0] rd;\n    wire [4:0] ra;\n    wire [4:0] rb;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n\n    wire [31:0] instr;\n\n    assign instr = instr_mem[pc];\n\n    assign opcode = instr[31:26];\n    assign funct = instr[5:0];\n    assign rd = instr[11:6];\n    assign ra = instr[20:15];\n    assign rb = instr[25:21];\n    assign imm = instr[31:20];\n\n    assign alu_out = (opcode == 6'b000000) ? (reg_file_read_data1 + reg_file_read_data2) : (reg_file_read_data1 - reg_file_read_data2);\n\n    assign writeback_out = alu_out;\n\n    assign out_reg_file = writeback_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            reg_file_write_addr <= 0;\n            reg_file_read_addr1 <= 0;\n            reg_file_read_addr2 <= 0;\n            reg_file_read_data1 <= 0;\n            reg_file_read_data2 <= 0;\n            reg_file_write_data <= 0;\n        end else begin\n            reg_file_write_addr <= rd;\n            reg_file_read_addr1 <= ra;\n            reg_file_read_addr2 <= rb;\n            reg_file_read_data1 <= reg_file[reg_file_read_addr1];\n            reg_file_read_data2 <= reg_file[reg_file_read_addr2];\n            reg_file[reg_file_write_addr] <= reg_file_write_data;\n        end\n    end\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else if (valid_in) begin\n        if (cnt == 3'd3) begin\n            cnt <= 3'd0;\n            valid_out_r <= 1'b1;\n        end else begin\n            cnt <= cnt + 1;\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else if (valid_in) begin\n        data_accum <= data_accum + data_in;\n    end\nend\n\n// Valid Output Module\nreg             valid_out_s;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_s <= 1'b0;\n    end else if (valid_in) begin\n        valid_out_s <= valid_out_r;\n    end\nend\n\nassign valid_out = valid_out_s;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 1'b0;\n        cnt_r <= 3'd0;\n    end else if (valid_in) begin\n        if (cnt_r == 3'd3) begin\n            valid_out_r <= 1'b1;\n            cnt_r <= 3'd0;\n        end else begin\n            valid_out_r <= 1'b0;\n            cnt_r <= cnt_r + 1;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign cnt = cnt_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else if (valid_in) begin\n        data_accum <= data_accum + data_in;\n        valid_out_r <= 1'b1;\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 1'b0;\n        cnt_r <= 3'd0;\n    end else if (valid_in) begin\n        if (cnt_r == 3'd3) begin\n            valid"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [3:0] counter;\n    reg [7:0] shift_reg;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            res_valid <= 0;\n        end else if (opn_valid && !res_ready) begin\n            counter <= 4;\n            shift_reg <= {1'b0, abs_dividend};\n            quotient <= 0;\n            remainder <= 0;\n            res_valid <= 0;\n        end else if (counter > 0) begin\n            counter <= counter - 1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n            quotient <= quotient << 1;\n            remainder <= remainder << 1;\n            if (shift_reg[7]) begin\n                quotient <= quotient | 1;\n            end\n            if (shift_reg[7] ^ neg_divisor[7]) begin\n                remainder <= remainder | 1;\n            end\n            if (counter == 1) begin\n                quotient <= quotient | 1;\n            end\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\n\n    // Result Management\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 0;\n        end else if (res_valid) begin\n            if (sign) begin\n                result <= {remainder[7:0], quotient[7:0]};\n            end else begin\n                result <= {quotient[7:0], remainder[7:0]};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // prep_dividend submodule\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] dividend_prep;\n    wire [15:0] divisor_prep;\n\n    assign dividend_prep = {A[31:16], 16'b0};\n    assign divisor_prep = {B, 16'b0};\n\n    // div_operation submodule\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] dividend_prep,\n    output wire [15:0] divisor_prep\n);\n\n    assign dividend_prep = {dividend[31:16], 16'b0};\n    assign divisor_prep = {divisor, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend_prep,\n    input wire [15:0] divisor_prep,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [7:0] temp_odd;\n\n    assign result = temp;\n    assign odd = temp_odd;\n\n    // Control unit\n    // ...\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] B_out_temp;\n\nassign B_comp = ~B + 1;\nassign {B_out_temp, sum} = A + B_comp;\nassign {carry, D} = sum + 1;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\ninput [7:0] A, B;\ninput C_in;\noutput [7:0] D;\noutput C_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign {carry, sum} = A + B + C_in;\nassign {carry, D} = sum + 1;\nassign C_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\ninput A, B, C_in;\noutput D, C_out;\n\nassign D = A ^ B ^ C_in;\nassign C_out = (A & B) | (B & C_in) | (C_in & A);\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\nsub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[31:16]), .B_out(B_out));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff8), .B_out(B_out8));\nsub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[15:8]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff4), .B_out(B_out4));\nsub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff2), .B_out(B_out2));\nsub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(.A(A[0]), .B(B[0]), .Diff(Diff1), .B_out(B_out1));\nsub_1bit sub1_1(.A(A[1]), .B(B[1]), .Diff(Diff[1]), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A < B) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1, D2, D3;\nwire B0, B1, B2, B3;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\nsub_16bit sub2(D0, B0, D2, B2);\nsub_16bit sub3(D1, B1, D3, B3);\n\nassign D = {D3, D2, D1, D0};\nassign B_out = B3;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nwire B0;\n\nassign D = A - B;\nassign B_out = B0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire B1_out, B2_out, B3_out, B4_out;\n\nassign A1 = A[1:1];\nassign A2 = A[3:2];\nassign A3 = A[5:4];\nassign A4 = A[7:6];\n\nassign B1 = B[1:1];\nassign B2 = B[3:2];\nassign B3 = B[5:4];\nassign B4 = B[7:6];\n\nsub_4bit sub1(.A(A1), .B(B1), .D(D1), .B_out(B1_out));\nsub_4bit sub2(.A(A2), .B(B2), .D(D2), .B_out(B2_out));\nsub_4bit sub3(.A(A3), .B(B3), .D(D3), .B_out(B3_out));\nsub_4bit sub4(.A(A4), .B(B4), .D(D4), .B_out(B4_out));\n\nassign D = {D4, D3, D2, D1};\nassign B_out = B1_out | B2_out | B3_out | B4_out;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:1] A, B;\noutput [3:1] D;\noutput B_out;\n\nwire [2:1] A1, A2;\nwire [2:1] B1, B2;\nwire [2:1] D1, D2;\nwire B1_out, B2_out;\n\nassign A1 = A[2:1];\nassign A2 = A[3:2];\n\nassign B1 = B[2:1];\nassign B2 = B[3:2];\n\nsub_2bit sub1(.A(A1), .B(B1), .D(D1), .B_out(B1_out));\nsub_2bit sub2(.A(A2), .B(B2), .D(D2), .B_out(B2_out));\n\nassign D = {D2, D1};\nassign B_out = B1_out | B2_out;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [2:1] A, B;\noutput [2:1] D;\noutput B_out;\n\nwire [1:1] A1;\nwire [1:1] B1;\nwire [1:1] D1;\nwire B1_out;\n\nassign A1 = A[1:1];\nassign B1 = B[1:1];\n\nsub_1bit sub1(.A(A1), .B(B1), .D(D1), .B_out(B1_out));\n\nassign D = D1;\nassign B_out = B1_out;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput [1:1] A, B;\noutput [1:1] D;\noutput B_out;\n\nwire [1:1] D1;\nwire B1_out;\n\nassign D1 = A - B;\nassign B1_out = (A < B) ? 1 : 0;\n\nassign D = D1;\nassign B_out = B1_out;\n\nendmodule\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtractor module\nsubtractor_32bit sub_inst (\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .carry(carry)\n);\n\n// Comparison logic\nassign A_greater = (sub_result == 32'b0);\nassign A_equal = (sub_result == 32'b0) && (carry == 1);\nassign A_less = (sub_result != 32'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output carry       // Carry output\n);\n\nassign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sum1, csa_sum2, csa_sum3;\nwire [3:0] csa_cout1, csa_cout2, csa_cout3;\n\nwire [3:0] rca_sum1, rca_sum2, rca_sum3;\nwire [3:0] rca_cout1, rca_cout2, rca_cout3;\n\nwire [3:0] csa_cout4, csa_cout5, csa_cout6;\nwire [3:0] rca_cout4, rca_cout5, rca_cout6;\n\nwire [3:0] csa_sum4, csa_sum5, csa_sum6;\nwire [3:0] csa_cout7, csa_cout8, csa_cout9;\nwire [3:0] rca_cout7, rca_cout8, rca_cout9;\n\nwire [3:0] csa_sum7, csa_sum8, csa_sum9;\nwire [3:0] csa_cout10, csa_cout11, csa_cout12;\nwire [3:0] rca_cout10, rca_cout11, rca_cout12;\n\nwire [3:0] csa_sum10, csa_sum11, csa_sum12;\nwire [3:0] csa_cout13, csa_cout14, csa_cout15;\nwire [3:0] rca_cout13, rca_cout14, rca_cout15;\n\nwire [3:0] csa_sum13, csa_sum14, csa_sum15;\nwire [3:0] csa_cout16, csa_cout17, csa_cout18;\nwire [3:0] rca_cout16, rca_cout17, rca_cout18;\n\nwire [3:0] csa_sum16, csa_sum17, csa_sum18;\nwire [3:0] csa_cout19, csa_cout20, csa_cout21;\nwire [3:0] rca_cout19, rca_cout20, rca_cout21;\n\nwire [3:0] csa_sum19, csa_sum20, csa_sum21;\nwire [3:0] csa_cout22, csa_cout23, csa_cout24;\nwire [3:0] rca_cout22, rca_cout23, rca_cout24;\n\nwire [3:0] csa_sum22, csa_sum23, csa_sum24;\nwire [3:0] csa_cout25, csa_cout26, csa_cout27;\nwire [3:0] rca_cout25, rca_cout26, rca_cout27;\n\nwire [3:0] csa_sum25, csa_sum26, csa_sum27;\nwire [3:0] csa_cout28, csa_cout29, csa_cout30;\nwire [3:0] rca_cout28, rca_cout29, rca_cout30;\n\nwire [3:0] csa_sum28, csa_sum29, csa_sum30;\nwire [3:0] csa_cout31, csa_cout32, csa_cout33;\nwire [3:0] rca_cout31, rca_cout32, rca_cout33;\n\nwire [3:0] csa_sum31, csa_sum32, csa_sum33;\nwire [3:0] csa_cout34, csa_cout35, csa_cout36;\nwire [3:0] rca_cout34, rca_cout35, rca_cout36;\n\nwire"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] a0, b0, y0, c0;\n    wire [7:0] a1, b1, y1, c1;\n    wire [7:0] a2, b2, y2, c2;\n    wire [7:0] a3, b3, y3, c3;\n    wire [7:0] a4, b4, y4, c4;\n    wire [7:0] a5, b5, y5, c5;\n    wire [7:0] a6, b6, y6, c6;\n    wire [7:0] a7, b7, y7, c7;\n    wire [7:0] a8, b8, y8, c8;\n    wire [7:0] a9, b9, y9, c9;\n    wire [7:0] a10, b10, y10, c10;\n    wire [7:0] a11, b11, y11, c11;\n    wire [7:0] a12, b12, y12, c12;\n    wire [7:0] a13, b13, y13, c13;\n    wire [7:0] a14, b14, y14, c14;\n    wire [7:0] a15, b15, y15, c15;\n\n    assign a0 = a[0];\n    assign b0 = b[0];\n    assign y0 = a0 ^ b0 ^ Cin;\n    assign c0 = (a0 & b0) | (a0 & Cin) | (b0 & Cin);\n\n    assign a1 = a[1];\n    assign b1 = b[1];\n    assign y1 = a1 ^ b1 ^ c0;\n    assign c1 = (a1 & b1) | (a1 & c0) | (b1 & c0);\n\n    assign a2 = a[2];\n    assign b2 = b[2];\n    assign y2 = a2 ^ b2 ^ c1;\n    assign c2 = (a2 & b2) | (a2 & c1) | (b2 & c1);\n\n    assign a3 = a[3];\n    assign b3 = b[3];\n    assign y3 = a3 ^ b3 ^ c2;\n    assign c3 = (a3 & b3) | (a3 & c2) | (b3 & c2);\n\n    assign a4 = a[4];\n    assign b4 = b[4];\n    assign y4 = a4 ^ b4 ^ c3;\n    assign c4 = (a4 & b4) | (a4 & c3) | (b4 & c3);\n\n    assign a5 = a[5];\n    assign b5 = b[5];\n    assign y5 = a5 ^ b5 ^ c4;\n    assign c5 = (a5 & b5) | (a5 & c4) | (b5 & c4);\n\n    assign a6 = a[6];\n    assign b6 = b[6];\n    assign y6 = a6 ^ b6 ^ c5;\n    assign c6 = (a6 & b6) | (a6 & c5) | (b6 & c5);\n\n    assign a7 = a[7];\n    assign b7 = b[7];\n    assign y7 = a7 ^ b7 ^ c6;\n    assign c7 = (a7 & b7) | (a7 & c6) | (b7 & c6);\n\n    assign a8 = a[8];\n    assign b8 = b[8];\n    assign y8 = a8 ^ b8 ^ c7;\n    assign c8 = (a8 & b8) | (a8 & c7) | (b8 & c7);\n\n    assign a9 = a[9];\n    assign b9 = b[9];\n    assign y9 = a9 ^ b9 ^ c8;\n    assign c9 = (a9 & b9) | (a9 & c8) | (b9 & c8);\n\n    assign a10 = a[10];\n    assign b10 = b[10];\n    assign y10 = a"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n    \n    // FA0\n    assign {FA0_cout, FA0_sum} = a[0] + b[0] + cin;\n    \n    // FA1\n    assign {FA1_cout, FA1_sum} = a[1] + b[1] + FA0_cout;\n    \n    // FA2\n    assign {FA2_cout, FA2_sum} = a[2] + b[2] + FA1_cout;\n    \n    // FA3\n    assign {FA3_cout, FA3_sum} = a[3] + b[3] + FA2_cout;\n    \n    // FA4\n    assign {FA4_cout, FA4_sum} = a[4] + b[4] + FA3_cout;\n    \n    // FA5\n    assign {FA5_cout, FA5_sum} = a[5] + b[5] + FA4_cout;\n    \n    // FA6\n    assign {FA6_cout, FA6_sum} = a[6] + b[6] + FA5_cout;\n    \n    // FA7\n    assign {FA7_cout, FA7_sum} = a[7] + b[7] + FA6_cout;\n    \n    // Output\n    assign sum = FA7_sum;\n    assign cout = FA7_cout;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'd0;\n        product <= 32'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'd0;\n            product <= 32'd0;\n            done_flag <= 1'b0;\n        end else if (shift_cnt < 4'd16) begin\n            shift_cnt <= shift_cnt + 4'd1;\n            product <= product + (bin << shift_cnt);\n            done_flag <= 1'b0;\n        end else begin\n            done_flag <= 1'b1;\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            m_reg <= b_reg;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n\n    // counter_logic\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n\n    // counter_register\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_register_count)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\n// counter_logic\nsubmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendsubmodule\n\n// counter_register\nsubmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            count_reg <= count_reg;\n        end\n    end\n\n    assign count = count_reg;\n\nendsubmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule for state transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output logic\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] reg_inst;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) reg_inst <= 64'b0;\n    else reg_inst <= {reg_inst[62:0], ~reg_inst[63]};\nend\n\n// Logic submodule\nwire [63:0] logic_inst;\nassign logic_inst = {reg_inst[62:0], ~reg_inst[63]};\n\n// Output\nassign Q = logic_inst;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= D;\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         A,\n    output [63:0]        B\n);\n\nassign B = {A[62:0], ~A[63]};\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg [1:0] clk_div_2;\nreg [1:0] clk_div_10;\nreg [1:0] clk_div_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2 <= 2'b00;\n        clk_div_10 <= 2'b00;\n        clk_div_100 <= 2'b00;\n    end else begin\n        clk_div_2 <= clk_div_2 + 1;\n        clk_div_10 <= clk_div_10 + 1;\n        clk_div_100 <= clk_div_100 + 1;\n    end\nend\n\nassign CLK_50 = clk_div_2[0];\nassign CLK_10 = clk_div_10[0];\nassign CLK_1 = clk_div_100[0];\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] clk_div_2;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2 <= 2'b00;\n    end else begin\n        clk_div_2 <= clk_div_2 + 1;\n    end\nend\n\nassign CLK_out = clk_div_2[0];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] clk_div_10;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_10 <= 2'b00;\n    end else begin\n        clk_div_10 <= clk_div_10 + 1;\n    end\nend\n\nassign CLK_out = clk_div_10[0];\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] clk_div_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_100 <= 2'b00;\n    end else begin\n        clk_div_100 <= clk_div_100 + 1;\n    end\nend\n\nassign CLK_out = clk_div_100[0];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == MUL2_DIV_CLK - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= {clk_average[2:0], counter[0]};\n    end\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= {clk_adjustment[2:0], counter[0]};\n    end\nend\n\n// Final Clock Output\nassign clk_div = clk_div_int[0] | clk_div_int[1] | clk_div_int[2] | clk_div_int[3];\n\n// Intermediate Clock Outputs\nassign clk_div_int[0] = clk_average[3] & clk_average[2];\nassign clk_div_int[1] = clk_average[3] & clk_average[1];\nassign clk_div_int[2] = clk_average[3] & clk_average[0];\nassign clk_div_int[3] = clk_adjustment[3] & clk_adjustment[2];\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire clk_div_en;\nreg [3:0] counter;\n\nassign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (clk_div_en)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nassign clk_div = (counter == 0);\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (q == (NUM_DIV / 2 - 1))\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 2;\n\nwire clk_div_en;\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (clk_div_en)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nassign clk_div_en = (counter == (NUM_DIV / 2 - 1));\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (clk_div_en)\n        clk_div <= ~clk_div;\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\nwire [31:0] add_result_zero, sub_result_zero, and_result_zero, or_result_zero, xor_result_zero, nor_result_zero, slt_result_zero, sltu_result_zero, sll_result_zero, srl_result_zero, sra_result_zero, sllv_result_zero, srlv_result_zero, srav_result_zero, lui_result_zero;\nwire [31:0] add_result_carry, sub_result_carry, and_result_carry, or_result_carry, xor_result_carry, nor_result_carry, slt_result_carry, sltu_result_carry, sll_result_carry, srl_result_carry, sra_result_carry, sllv_result_carry, srlv_result_carry, srav_result_carry, lui_result_carry;\nwire [31:0] add_result_negative, sub_result_negative, and_result_negative, or_result_negative, xor_result_negative, nor_result_negative, slt_result_negative, sltu_result_negative, sll_result_negative, srl_result_negative, sra_result_negative, sllv_result_negative, srlv_result_negative, srav_result_negative, lui_result_negative;\nwire [31:0] add_result_overflow, sub_result_overflow, and_result_overflow, or_result_overflow, xor_result_overflow, nor_result_overflow, slt_result_overflow, sltu_result_overflow, sll_result_overflow, srl_result_overflow, sra_result_overflow, sllv_result_overflow, srlv_result_overflow, srav_result_overflow, lui_result_overflow;\nwire [31:0] add_result_flag, sub_result_flag, and_result_flag, or_result_flag, xor_result_flag, nor_result_flag, slt_result_flag, sltu_result_flag, sll_result_flag, srl_result_flag, sra_result_flag, sllv_result_flag, srlv_result_flag, srav_result_flag, lui_result_flag;\n\nassign r = aluc[5:0] == 6'b100000 ? add_result :\n           aluc[5:0] == 6'b100001 ? add_result :\n           aluc[5:0] == 6'b100010 ? sub_result :\n           aluc[5:0] == 6'b100011 ? sub_result :\n           aluc[5:0] == 6'b100100 ? and_result :\n           aluc[5:0] == 6'b100101 ? or_result :\n           aluc[5:0] == 6'b100110 ? xor_result :\n           aluc[5:0] == 6'b100111 ? nor_result :\n           aluc[5:0] == 6'b101010 ? slt_result :\n           aluc[5:0] == 6'b101011 ? sltu_result :\n           aluc[5:0] == 6'b000000 ? sll_result :\n           aluc[5:0] == 6'b000010 ? srl_result :\n           aluc[5:0] == 6'b000011 ? sra_result :\n           aluc[5:0] == 6'b000100 ? sllv_result :\n           aluc[5:0] == 6'b00"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] multiplication_result;\nreg [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] multiplication_result_64;\nassign multiplication_result_64 = a * b;\nassign multiplication_result = multiplication_result_64[31:0];\n\n// Accumulator Submodule\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + multiplication_result;\n    end\nend\n\nassign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nreg [63:0] multiplication_result;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        multiplication_result <= 0;\n    end else begin\n        multiplication_result <= a * b;\n    end\nend\n\nassign c = multiplication_result[31:0];\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\nreg [31:0] current_value;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + a;\n    end\nend\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    // Instruction register for register source\n    reg [7:0] ins_p1_reg;\n    reg [7:0] ins_p2_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_p1_ram;\n    reg [7:0] ins_p2_ram;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 8'b0;\n            ins_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_ram <= 8'b0;\n            ins_p2_ram <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_ram <= data;\n            end else if (fetch == 2'b10) begin\n                ins_p2_ram <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n\n    assign ins = {ins_p1[7], ins_p1[6:3], ins_p2[7]};\n    assign ad1 = {ins_p1[2:0], ins_p2[7:5]};\n    assign ad2 = ins_p2[4:0];\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] freq_inv;\nassign freq_inv = 8'd255 / freq;\n\nwire [7:0] count_inv;\nassign count_inv = 8'd255 - count;\n\nwire [7:0] wave_out_inv;\nassign wave_out_inv = (count_inv < freq_inv) ? 1'b1 : 1'b0;\n\nassign wave_out = wave_out_inv;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 8'd0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            if (wave_reg == 5'b00000) begin\n                wave_reg <= 5'b00001;\n            end else if (wave_reg == 5'b11111) begin\n                wave_reg <= 5'b11110;\n            end else if (wave_reg[0] == 1) begin\n                wave_reg <= wave_reg + 1;\n            end else begin\n                wave_reg <= wave_reg - 1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        q <= (sel == 2'b00) ? q1 :\n             (sel == 2'b01) ? q2 :\n             (sel == 2'b10) ? q3 :\n             d;\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = (sel == 2'b00) ? q1 :\n               (sel == 2'b01) ? q2 :\n               (sel == 2'b10) ? q3 :\n               d;\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    mux2X1 mux1 (stage1, in[3:0], in[7:4], ctrl[2]);\n    mux2X1 mux2 (stage2, stage1[1:0], stage1[3:2], ctrl[1]);\n    mux2X1 mux3 (stage3, stage2[1:0], stage2[3:2], ctrl[0]);\n\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n    input sel;\n    input [1:0] in0, in1;\n    output [1:0] out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res_fetch;\n  wire [31:0] res_decode;\n  wire [31:0] res_execute;\n  wire [31:0] res_memory;\n  wire [31:0] res_writeback;\n  reg [31:0] pc;\n\n  stagepipe5_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_fetch),\n    .pc(pc)\n  );\n\n  stagepipe5_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_fetch),\n    .reg_file(reg_file),\n    .res_reg_file(res_decode)\n  );\n\n  stagepipe5_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_decode),\n    .reg_file(reg_file),\n    .res_reg_file(res_execute)\n  );\n\n  stagepipe5_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_execute),\n    .reg_file(reg_file),\n    .res_reg_file(res_memory)\n  );\n\n  stagepipe5_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_memory),\n    .reg_file(reg_file),\n    .res_reg_file(res_writeback)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule stagepipe5_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31],\n  input [31:0] pc\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg <= 0;\n    end else begin\n      case (pc)\n        0: res_reg_file_reg <= instr_mem[0];\n        1: res_reg_file_reg <= instr_mem[1];\n        2: res_reg_file_reg <= instr_mem[2];\n        3: res_reg_file_reg <= instr_mem[3];\n        4: res_reg_file_reg <= instr_mem[4];\n        5: res_reg_file_reg <= instr_mem[5];\n        6: res_reg_file_reg <= instr_mem[6];\n        7: res_reg_file_reg <= instr_mem[7];\n        8: res_reg_file_reg <= instr_mem[8];\n        9: res_reg_file_reg <= instr_mem[9];\n        10: res_reg_file_reg <= instr_mem[10];\n        11: res_reg_file_reg <= instr_mem[11];\n        12: res_reg_file_reg <= instr_mem[12];\n        13: res_reg_file_reg <= instr_mem[13];\n        14: res_reg_file_reg <= instr_mem[14];\n        15: res_reg_file_reg <= instr_mem[15];\n        16: res_reg_file_reg <= instr_mem[16];\n        17: res_reg_file_reg <= instr_mem[17];\n        18: res_reg_file_reg <= instr_mem[18];\n        19: res_"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] reg_file_out;\n    wire [31:0] writeback_in;\n    wire [31:0] writeback_reg;\n    wire [31:0] writeback_out_reg;\n    wire [31:0] writeback_out_reg_file;\n\n    assign pc = 0;\n    assign instr = instr_mem[pc];\n    assign op1 = reg_file[instr[20:16]];\n    assign op2 = reg_file[instr[15:11]];\n    assign result = instr[15] ? op1 - op2 : op1 + op2;\n    assign reg_file_out = result;\n    assign writeback_in = instr[15:0];\n    assign writeback_reg = instr[25:21];\n    assign writeback_out_reg = writeback_in;\n    assign writeback_out_reg_file = writeback_reg;\n\n    assign out_reg_file = writeback_out_reg_file;\n\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch_out(fetch_out)\n    );\n\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result),\n        .reg_file_out(reg_file_out),\n        .execute_out(execute_out)\n    );\n\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .writeback_in(writeback_in),\n        .writeback_reg(writeback_reg),\n        .writeback_out(writeback_out)\n    );\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetch_out\n);\n    assign fetch_out = instr_mem[pc];\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] op1,\n    input [31:0] op2,\n    input [31:0] result,\n    input [31:0] reg_file_out,\n    output [31:0] execute_out\n);\n    assign execute_out = instr[15] ? op1 - op2 : op1 + op2;\nendmodule\n\nmodule stagepipe3_writeback (\n    input clk,\n    input rst,\n    input [31:0] writeback_in,\n    input [31:0] writeback_reg,\n    output [31:0] writeback_out\n);\n    assign writeback_out = writeback_in;\nendmodule\n\n```\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nreg [2:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'b0;\n    end else if (valid_in) begin\n        cnt <= cnt + 1;\n    end\nend\n\nassign valid_out = (cnt == 3'b111);\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nreg [9:0] accu_data;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        accu_data <= 10'b0;\n    end else if (valid_in) begin\n        accu_data <= accu_data + data_in;\n    end\nend\n\nassign data_out = accu_data;\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nreg valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n    end else if (valid_in) begin\n        valid_out_reg <= 1'b1;\n    end else begin\n        valid_out_reg <= 1'b0;\n    end\nend\n\nassign valid_out = valid_out_reg;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg [0:7];\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            abs_dividend <= 8'd0;\n        end else if (opn_valid) begin\n            abs_dividend <= (sign) ? -dividend : dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            neg_divisor <= 8'd0;\n        end else if (opn_valid) begin\n            neg_divisor <= (sign) ? -divisor : divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 3'd0;\n            shift_reg[0] <= 8'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid) begin\n            if (counter == 3'd0) begin\n                shift_reg[0] <= abs_dividend;\n                counter <= 3'd1;\n            end else if (counter < 3'd8) begin\n                shift_reg[counter] <= shift_reg[counter - 1];\n                quotient[counter - 1] <= shift_reg[counter][7];\n                remainder[counter - 1] <= shift_reg[counter] - (neg_divisor << (counter - 1));\n                counter <= counter + 3'd1;\n            end else begin\n                res_valid <= 1'b1;\n                remainder <= remainder[15:0] - (neg_divisor << 4);\n                quotient <= quotient[15:0] - (neg_divisor << 4);\n                counter <= 3'd0;\n            end\n        end\n    end\n\n    // Result Management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid) begin\n            if (res_ready) begin\n                res_valid <= 1'b0;\n            end else if (counter == 3'd0) begin\n                res_valid <= 1'b0;\n            end else if (counter == 3'd8) begin\n                res_valid <= 1'b1;\n            end\n        end\n    end\n\n    // Output\n    assign result = (sign) ? {remainder[7:0], quotient[7:0]} : {quotient[7:0], remainder[7:0]};\n\nendmodule\n"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // prep_dividend\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] dividend_prep;\n    wire [15:0] divisor_prep;\n\n    assign dividend_prep = {A[31:16], A[15:0]};\n    assign divisor_prep = {B[15:0], 16'b0};\n\n    // div_operation\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] dividend_prep,\n    output wire [15:0] divisor_prep\n);\n\n    assign dividend_prep = {dividend[31:16], dividend[15:0]};\n    assign divisor_prep = {divisor[15:0], 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend_prep,\n    input wire [15:0] divisor_prep,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result;\n    wire [15:0] temp_odd;\n\n    // Control unit\n    // ...\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign sum = A + B_comp;\nassign carry = (A[0] & B[0]) | (B_comp[0] & sum[0]);\n\nalways @(A or B) begin\n    D[0] = sum[0];\n    B_out = carry;\n    for (integer i = 1; i < 8; i = i + 1) begin\n        D[i] = sum[i] ^ carry;\n        carry = (sum[i] & carry) | (carry & sum[i]);\n    end\nend\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] carry;\n\nassign carry = (A[0] & B[0]) | (B[0] & ~A[0]);\n\nalways @(A or B) begin\n    D[0] = A[0] ^ B[0];\n    B_out = carry;\n    for (integer i = 1; i < 8; i = i + 1) begin\n        D[i] = (A[i] ^ B[i]) ^ carry;\n        carry = (A[i] & B[i]) | (carry & (A[i] ^ B[i]));\n    end\nend\n\nendmodule\n\nmodule full_adder(A, B, Cin, Cout);\ninput A, B, Cin;\noutput Cout;\n\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_0(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\nsub_16bit sub16_1(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[31:16]), .B_out(B_out));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_0(.A(A[7:0]), .B(B[7:0]), .Diff(Diff8), .B_out(B_out8));\nsub_8bit sub8_1(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[15:8]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_0(.A(A[3:0]), .B(B[3:0]), .Diff(Diff4), .B_out(B_out4));\nsub_4bit sub4_1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_0(.A(A[1:0]), .B(B[1:0]), .Diff(Diff2), .B_out(B_out2));\nsub_2bit sub2_1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_0(.A(A[0]), .B(B[0]), .Diff(Diff1), .B_out(B_out1));\nsub_1bit sub1_1(.A(A[1]), .B(B[1]), .Diff(Diff[1]), .B_out(B_out));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = (A & B) | (~A & ~B);\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D[15:0];\nwire [3:1] sub1_out, sub2_out, sub3_out, sub4_out;\n\n// 4-bit full subtractor block\n// A - B = D, B_out = B_out\n// B_out is the borrow-out of the subtraction\n\n// sub1\nassign sub1_out = (A[1:1] > B[1:1]) ? 1'b1 : 1'b0;\nassign D[0] = A[1:1] - B[1:1];\nassign B_out[0] = sub1_out;\n\n// sub2\nassign sub2_out = (A[2:2] > B[2:2] || sub1_out) ? 1'b1 : 1'b0;\nassign D[1] = A[2:2] - B[2:2] - sub1_out;\nassign B_out[1] = sub2_out;\n\n// sub3\nassign sub3_out = (A[3:3] > B[3:3] || sub2_out) ? 1'b1 : 1'b0;\nassign D[2] = A[3:3] - B[3:3] - sub2_out;\nassign B_out[2] = sub3_out;\n\n// sub4\nassign sub4_out = (A[4:4] > B[4:4] || sub3_out) ? 1'b1 : 1'b0;\nassign D[3] = A[4:4] - B[4:4] - sub3_out;\nassign B_out[3] = sub4_out;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire carry;\n\n// Subtraction operation\nassign subtraction_result = A - B;\nassign carry = (subtraction_result[31] == 1);\n\n// Comparison logic\nassign A_greater = (subtraction_result != 0) && (carry == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16;\n\nCLA1 CLA1(.A(A[15:1]),.B(B[15:1]),.S(S[15:1]),.C(C16[1]));\nCLA2 CLA2(.A(A[31:16]),.B(B[31:16]),.S(S[31:16]),.C(C16[2]));\n\nassign C32 = C16[1] | C16[2];\n\nendmodule\n\nmodule CLA1(A,B,S,C);\ninput [15:1] A,B;\noutput [15:1] S;\noutput C;\n\nwire [7:1] C7;\n\nCLA7 CLA7(.A(A[7:1]),.B(B[7:1]),.S(S[7:1]),.C(C7[1]));\nCLA8 CLA8(.A(A[15:8]),.B(B[15:8]),.S(S[15:8]),.C(C7[2]));\n\nassign C = C7[1] | C7[2];\n\nendmodule\n\nmodule CLA2(A,B,S,C);\ninput [31:1] A,B;\noutput [31:1] S;\noutput C;\n\nwire [15:1] C16;\n\nCLA1 CLA1(.A(A[15:1]),.B(B[15:1]),.S(S[15:1]),.C(C16[1]));\nCLA2 CLA2(.A(A[31:16]),.B(B[31:16]),.S(S[31:16]),.C(C16[2]));\n\nassign C = C16[1] | C16[2];\n\nendmodule\n\nmodule CLA7(A,B,S,C);\ninput [7:1] A,B;\noutput [7:1] S;\noutput C;\n\nwire [3:1] C3;\n\nCLA3 CLA3(.A(A[3:1]),.B(B[3:1]),.S(S[3:1]),.C(C3[1]));\nCLA4 CLA4(.A(A[7:4]),.B(B[7:4]),.S(S[7:4]),.C(C3[2]));\n\nassign C = C3[1] | C3[2];\n\nendmodule\n\nmodule CLA8(A,B,S,C);\ninput [15:1] A,B;\noutput [15:1] S;\noutput C;\n\nwire [7:1] C7;\n\nCLA7 CLA7(.A(A[7:1]),.B(B[7:1]),.S(S[7:1]),.C(C7[1]));\nCLA8 CLA8(.A(A[15:8]),.B(B[15:8]),.S(S[15:8]),.C(C7[2]));\n\nassign C = C7[1] | C7[2];\n\nendmodule\n\nmodule CLA3(A,B,S,C);\ninput [3:1] A,B;\noutput [3:1] S;\noutput C;\n\nwire [1:1] C1;\n\nCLA1 CLA1(.A(A[1:1]),.B(B[1:1]),.S(S[1:1]),.C(C1[1]));\nCLA2 CLA2(.A(A[3:2]),.B(B[3:2]),.S(S[3:2]),.C(C1[2]));\n\nassign C = C1[1] | C1[2];\n\nendmodule\n\nmodule CLA4(A,B,S,C);\ninput [7:1] A,B;\noutput [7:1] S;\noutput C;\n\nwire [3:1] C3;\n\nCLA3 CLA3(.A(A"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sum;\nwire [3:0] csa_cout;\nwire [3:0] rca_sum;\nwire [3:0] rca_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] rca_sum1, rca_cout1;\nassign rca_sum1[0] = a[0] ^ b[0] ^ cin;\nassign rca_sum1[1] = a[1] ^ b[1] ^ rca_sum1[0];\nassign rca_sum1[2] = a[2] ^ b[2] ^ rca_sum1[1];\nassign rca_sum1[3] = a[3] ^ b[3] ^ rca_sum1[2];\nassign rca_cout1 = {rca_sum1[3], rca_sum1[2], rca_sum1[1], rca_sum1[0]};\n\n// 4-bit carry select adder\nwire [3:0] csa_sum2, csa_cout2;\nassign csa_sum2[0] = rca_sum1[0] ^ cin;\nassign csa_sum2[1] = rca_sum1[1] ^ rca_cout1[0];\nassign csa_sum2[2] = rca_sum1[2] ^ rca_cout1[1];\nassign csa_sum2[3] = rca_sum1[3] ^ rca_cout1[2];\nassign csa_cout2 = {rca_cout1[3], rca_cout1[2], rca_cout1[1], rca_cout1[0]};\n\n// 4-bit carry select adder\nwire [3:0] csa_sum3, csa_cout3;\nassign csa_sum3[0] = rca_sum1[0] ^ cin;\nassign csa_sum3[1] = rca_sum1[1] ^ rca_cout1[0];\nassign csa_sum3[2] = rca_sum1[2] ^ rca_cout1[1];\nassign csa_sum3[3] = rca_sum1[3] ^ rca_cout1[2];\nassign csa_cout3 = {rca_cout1[3], rca_cout1[2], rca_cout1[1], rca_cout1[0]};\n\n// 4-bit carry select adder\nwire [3:0] csa_sum4, csa_cout4;\nassign csa_sum4[0] = rca_sum1[0] ^ cin;\nassign csa_sum4[1] = rca_sum1[1] ^ rca_cout1[0];\nassign csa_sum4[2] = rca_sum1[2] ^ rca_cout1[1];\nassign csa_sum4[3] = rca_sum1[3] ^ rca_cout1[2];\nassign csa_cout4 = {rca_cout1[3], rca_cout1[2], rca_cout1[1], rca_cout1[0]};\n\n// 4-bit carry select adder\nwire [3:0] csa_sum5, csa_cout5;\nassign csa_sum5[0] = rca_sum1[0] ^ cin;\nassign csa_sum5[1] = rca_sum1[1] ^ rca_cout1[0];\nassign csa_sum5[2] = rca_sum1[2] ^ rca_cout1[1];\nassign csa_sum5[3] = rca_sum1[3] ^ rca_cout1[2];\nassign csa_cout5 = {rca_cout1[3], rca_cout1[2], rca_cout1[1], rca_cout1[0]};\n\n// 4-bit carry select adder\nwire [3:0] csa_sum6, csa_cout6;\nassign csa_sum6[0] = rca_sum1[0]"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_8bit;\n    wire [7:0] y_8bit;\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8bit),\n        .Co(Co_8bit)\n    );\n\n    // 16-bit adder\n    assign y = {y_8bit, Co_8bit} + {b[15:8], b[15:8], b[15:8], b[15:8], b[15:8], b[15:8], b[15:8], b[15:8]};\n    assign Co = Co_8bit[7] | (y_8bit[7] & Co_8bit[6]) | (y_8bit[6] & Co_8bit[5]) | (y_8bit[5] & Co_8bit[4]) | (y_8bit[4] & Co_8bit[3]) | (y_8bit[3] & Co_8bit[2]) | (y_8bit[2] & Co_8bit[1]) | (y_8bit[1] & Co_8bit[0]);\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] Co_4bit;\n    wire [3:0] y_4bit;\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y_4bit),\n        .Co(Co_4bit)\n    );\n\n    // 8-bit adder\n    assign y = {y_4bit, Co_4bit} + {b[7:4], b[7:4], b[7:4], b[7:4]};\n    assign Co = Co_4bit[3] | (y_4bit[3] & Co_4bit[2]) | (y_4bit[2] & Co_4bit[1]) | (y_4bit[1] & Co_4bit[0]);\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    // 4-bit adder\n    assign y = a + b + Cin;\n    assign Co = (y[3] & (a[3] | b[3])) | (y[2] & (a[2] | b[2])) | (y[1] & (a[1] | b[1])) | (y[0] & (a[0] | b[0]));\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire [6:0] fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // 8-bit adder using full adders\n    fa fa0(fa0_sum[0], fa0_cout[0], a[0], b[0], cin);\n    fa fa1(fa1_sum[0], fa1_cout[0], a[1], b[1], fa0_cout[0]);\n    fa fa2(fa2_sum[0], fa2_cout[0], a[2], b[2], fa1_cout[0]);\n    fa fa3(fa3_sum[0], fa3_cout[0], a[3], b[3], fa2_cout[0]);\n    fa fa4(fa4_sum[0], fa4_cout[0], a[4], b[4], fa3_cout[0]);\n    fa fa5(fa5_sum[0], fa5_cout[0], a[5], b[5], fa4_cout[0]);\n    fa fa6(fa6_sum[0], fa6_cout[0], a[6], b[6], fa5_cout[0]);\n    fa fa7(fa7_sum[0], fa7_cout[0], a[7], b[7], fa6_cout[0]);\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout[6];\n    \nendmodule\n\nmodule fa(\n    output sum,\n    output cout,\n    input a,\n    input b,\n    input cin);\n    \n    assign {cout, sum} = a + b + cin;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'd0;\n        product <= 32'd0;\n        done_i <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'd0;\n            product <= 32'd0;\n            done_i <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'd15) begin\n                shift_cnt <= 4'd0;\n                done_i <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1'b1;\n                done_i <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'd0;\n    end else begin\n        if (shift_cnt == 4'd0) begin\n            m_reg <= b_reg;\n        end else begin\n            m_reg <= {m_reg[14:0], 1'b0};\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_i;\n\n// Shift-and-Accumulate Logic.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'd0;\n    end else begin\n        if (shift_cnt == 4'd0) begin\n            product <= {a_reg, 16'd0};\n        end else begin\n            if (m_reg[15]) begin\n                product <= product + {16'd0, a_reg};\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_out)\n    );\n\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_register_out)\n    );\n\n    assign count = u_counter_register_out;\n\nendmodule\n\nmodule submodule (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else if (up_down) begin\n            count_reg <= count_reg + 1;\n        end else begin\n            count_reg <= count_reg - 1;\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    // Initializes the counter to its starting state when reset is high.\n    // The counter starts with the least significant bit (LSB) set to 1.\n    // The other bits are set to 0.\n    //\n    // Example:\n    //      out = 8'b0000_0001;\n    //\n    // Module name:\n    //      init\n    //\n    // Input ports:\n    //      reset: Reset signal to initialize the counter.\n    //\n    // Output ports:\n    //      out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //      out = 8'b0000_0001;\n\n    // Submodule: Transition\n    // Handles the cyclic behavior of the ring counter.\n    // The 1 shifts to the next bit in the sequence on each rising edge of the clock signal.\n    // After reaching the most significant bit (MSB), it wraps around to the least significant bit (LSB).\n    //\n    // Example:\n    //      out = (out << 1) | 1'b1;\n    //\n    // Module name:\n    //      transition\n    //\n    // Input ports:\n    //      clk: Clock signal that drives the state transitions of the ring counter.\n    //\n    // Output ports:\n    //      out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //      out = (out << 1) | 1'b1;\n\n    // Submodule: Ring Counter\n    // Combines the initialization and transition submodules to create a modular ring counter.\n    //\n    // Module name:\n    //      ring_counter\n    //\n    // Input ports:\n    //      clk: Clock signal that drives the state transitions of the ring counter.\n    //      reset: Reset signal to initialize the counter.\n    //\n    // Output ports:\n    //      out: 8-bit output representing the current state of the ring counter.\n    //\n    // Internal logic:\n    //      out = init(reset) + transition(clk);\n\n    // Implementation\n    assign out = init(reset) + transition(clk);\n\nendmodule\n\nmodule init (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule transition (\n    input wire clk,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= (out << 1) | 1'b1;\n    end\n\nendmodule\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= init(reset) + transition(clk);\n        end\n    end\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\nreg [3:0] count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else\n        count_r <= count_next;\nend\n\nassign count = count_r;\n\nalways @(*) begin\n    if (valid_count)\n        count_next = count + 1;\n    else\n        count_next = count;\nend\n\nassign out = (count == 4'd11) ? 4'b0000 : count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\nreg [3:0] count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else\n        count_r <= count_next;\nend\n\nassign count = count_r;\n\nalways @(*) begin\n    if (valid_count)\n        count_next = count_r + 1;\n    else\n        count_next = count_r;\nend\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\nreg [3:0] out_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else\n        out_r <= out_next;\nend\n\nassign out = out_r;\n\nalways @(*) begin\n    if (valid_count)\n        out_next = count;\n    else\n        out_next = out_r;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule JC_register\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) Q <= 64'b0;\n        else Q <= Q + 1;\n    end\nendmodule\n\n// Submodule JC_logic\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n    always @(*) begin\n        Q_next = Q;\n        Q_next[0] = Q[63];\n    end\nendmodule\n\n// Instantiate the submodules\nJC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\nJC_logic logic_inst(.Q(Q), .Q_next(Q));\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg [1:0] clk_div_2;\nreg [1:0] clk_div_10;\nreg [1:0] clk_div_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2 <= 2'b00;\n        clk_div_10 <= 2'b00;\n        clk_div_100 <= 2'b00;\n    end else begin\n        clk_div_2 <= clk_div_2 + 1;\n        clk_div_10 <= clk_div_10 + 1;\n        clk_div_100 <= clk_div_100 + 1;\n    end\nend\n\nassign CLK_50 = clk_div_2[0];\nassign CLK_10 = clk_div_10[0];\nassign CLK_1 = clk_div_100[0];\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 2'b00;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign CLK_out = counter[0];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 2'b00;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign CLK_out = counter[0] && counter[1];\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        counter <= 2'b00;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nassign CLK_out = counter[0] && counter[1] && counter[2];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == MUL2_DIV_CLK)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else begin\n        clk_average[0] <= counter[0];\n        clk_average[1] <= counter[1];\n        clk_average[2] <= counter[2];\n        clk_average[3] <= counter[3];\n    end\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= 0;\n    else begin\n        clk_adjustment[0] <= counter[0];\n        clk_adjustment[1] <= counter[1];\n        clk_adjustment[2] <= counter[2];\n        clk_adjustment[3] <= counter[3];\n    end\nend\n\n// Output\nassign clk_div = clk_div_int[0] | clk_div_int[1] | clk_div_int[2] | clk_div_int[3];\n\n// Intermediate Clock Signals\nassign clk_div_int[0] = clk_average[0] & clk_average[1] & clk_average[2] & clk_average[3];\nassign clk_div_int[1] = clk_average[0] & clk_average[1] & clk_average[2] & ~clk_average[3];\nassign clk_div_int[2] = clk_average[0] & clk_average[1] & ~clk_average[2] & clk_average[3];\nassign clk_div_int[3] = clk_average[0] & ~clk_average[1] & clk_average[2] & clk_average[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          count\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (count == MUL2_DIV_CLK)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [3:0]         clk_div,\n    output reg [3:0]    clk_average\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else begin\n        clk_average[0] <= clk_div[0];\n        clk_average[1] <= clk_div[1];\n        clk_average[2] <= clk_div[2];\n        clk_average[3] <= clk_div[3];\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [3:0]         clk_div,\n    output reg [3:0]    clk_adjustment\n);\n\nparameter MUL2_DIV_CLK = 7;"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_edge_counter;\nreg [3:0] neg_edge_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        neg_edge_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (pos_edge_counter < NUM_DIV - 1) begin\n            pos_edge_counter <= pos_edge_counter + 1;\n        end else begin\n            pos_edge_counter <= 0;\n        end\n\n        if (neg_edge_counter < NUM_DIV - 1) begin\n            neg_edge_counter <= neg_edge_counter + 1;\n        end else begin\n            neg_edge_counter <= 0;\n        end\n\n        clk_div1 <= (pos_edge_counter == NUM_DIV - 1);\n        clk_div2 <= (neg_edge_counter == NUM_DIV - 1);\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire [3:0] counter_out;\nwire clk_div_en;\n\nreg [3:0] counter;\nreg clk_div_reg;\n\nassign counter_out = counter;\nassign clk_div_en = (counter == (NUM_DIV / 2 - 1)) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 4'd0;\n        clk_div_reg <= 1'b0;\n    end else if (clk_div_en) begin\n        counter <= 4'd0;\n        clk_div_reg <= ~clk_div_reg;\n    end else begin\n        counter <= counter + 1'b1;\n    end\nend\n\nassign clk_div = clk_div_reg;\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_out <= 4'd0;\n    end else if (counter_out == (NUM_DIV / 2 - 1)) begin\n        counter_out <= 4'd0;\n    end else begin\n        counter_out <= counter_out + 1'b1;\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 1'b0;\n    end else if (clk_div_en) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\nwire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\nwire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\nwire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\nwire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\nwire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\nassign r = aluc[5:0] == 6'b000000 ? sllv_result :\n           aluc[5:0] == 6'b000010 ? srlv_result :\n           aluc[5:0] == 6'b000011 ? srav_result :\n           aluc[5:0] == 6'b000100 ? and_result :\n           aluc[5:0] == 6'b000101 ? or_result :\n           aluc[5:0] == 6'b000110 ? xor_result :\n           aluc[5:0] == 6'b000111 ? nor_result :\n           aluc[5:0] == 6'b001000 ? sll_result :\n           aluc[5:0] == 6'b001010 ? srl_result :\n           aluc[5:0] == 6'b001011 ? sra_result :\n           aluc[5:0] == 6'b001100 ? add_result :\n           aluc[5:0] == 6'b001101 ? sub_result :\n           aluc[5:0] == 6'b001110 ? slt_result :\n           aluc[5:0] == 6'b001111 ? sltu_result :\n           aluc[5:0] == 6'b010000 ? lui_result :\n           32'b0;\n\nassign zero = aluc[5:0] == 6'b000000 ? sllv_zero :\n              aluc[5:0] == 6'b000010 ? srlv_zero :\n              aluc[5:0] == 6'b000011 ? srav_zero :\n              aluc[5:0] == 6'b000100 ? and_zero :\n              aluc[5:0] == 6'b000101 ? or"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] mul_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] mul_result_64;\nassign mul_result_64 = a * b;\nassign mul_result = mul_result_64[31:0];\n\n// Accumulator Submodule\nreg [31:0] current_value_reg;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value_reg <= 0;\n    end else begin\n        current_value_reg <= current_value_reg + mul_result;\n    end\nend\nassign current_value = current_value_reg;\n\n// Connecting the submodules\nassign c = current_value;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable;\nreg [7:0] count;\n\nassign enable = (freq > 0);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nassign wave_out = (count == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            \n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n    \n    assign wave = wave_reg;\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(u0_q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(u0_q),\n        .q(u1_q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(u1_q),\n        .q(u2_q)\n    );\n\n    always @(posedge clk) begin\n        q <= u2_q;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3 = (ctrl[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n\n    assign out = stage3;\n\n    // MUX2X1\n    module mux2X1 (sel, in0, in1, out);\n        input sel;\n        input in0, in1;\n        output out;\n\n        assign out = sel ? in1 : in0;\n    endmodule\nendmodule\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [4:0] rs1, rs2, rd;\n  reg [5:0] op;\n  reg [31:0] res;\n  reg [31:0] reg_file_next [0:31];\n  reg [31:0] res_reg_file_next [0:31];\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file_next)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file_next)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_res(alu_res)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file_next)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .res(res),\n    .reg_file_next(reg_file_next),\n    .res_reg_file(res_reg_file_next)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n      res <= 0;\n      reg_file_next <= 0;\n      res_reg_file_next <= 0;\n    end else begin\n      pc <= pc + 1;\n      instr <= instr_mem[pc];\n      rs1 <= instr[24:20];\n      rs2 <= instr[29:25];\n      rd <= instr[14:10];\n      op <= instr[31:26];\n      res <= alu_res;\n      reg_file_next[rd] <= res;\n      res_reg_file_next[rd] <= res;\n    end\n  end\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] pc;\n  reg [31:0] instr;\n  reg [4:0] rs1, rs2, rd;\n  reg [5:0] op;\n  reg [31:0] res;\n  reg [31:0] reg_file_next [0:31];\n  reg [31:0] res_reg_file_next [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n      res <= 0;\n      reg_file_next <= 0;\n      res_reg_file_next <= 0;\n    end else begin\n      pc <= pc + 1;\n      instr <= instr_mem[pc];\n      rs1 <= instr[24:20];\n      rs2 <= instr[29:25];\n      rd <= instr[14:10];\n      op <= in"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    reg [4:0] pc_next;\n\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [4:0] rt;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n    wire [31:0] reg_file_out;\n\n    wire [31:0] instr;\n\n    assign out_reg_file = writeback_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 0;\n        end else begin\n            pc <= pc_next;\n        end\n    end\n\n    always @(*) begin\n        pc_next = pc + 1;\n    end\n\n    assign instr = instr_mem[pc];\n    assign opcode = instr[31:26];\n    assign funct = instr[5:0];\n    assign imm = instr[31:20];\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign rt = instr[10:6];\n\n    assign fetch_out = instr_mem[pc];\n\n    assign alu_out = (opcode == 6'b000000) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\n\n    assign reg_file_out = (opcode == 6'b000000) ? alu_out : reg_file[rt];\n\n    assign writeback_out = reg_file_out;\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_reg <= 1'b0;\n    end else if (valid_in) begin\n        if (cnt == 3'd3) begin\n            cnt <= 3'd0;\n            valid_out_reg <= 1'b1;\n        end else begin\n            cnt <= cnt + 1'b1;\n            valid_out_reg <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_reg;\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else if (valid_in) begin\n        data_accum <= data_accum + data_in;\n    end\nend\n\nassign data_out = data_accum;\n\nendmodule\n\n// Counter Module\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg                 valid_out_reg;\nreg                 [2:0] cnt_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n        cnt_reg <= 3'd0;\n    end else if (valid_in) begin\n        if (cnt_reg == 3'd3) begin\n            valid_out_reg <= 1'b1;\n            cnt_reg <= 3'd0;\n        end else begin\n            valid_out_reg <= 1'b0;\n            cnt_reg <= cnt_reg + 1'b1;\n        end\n    end\nend\n\nassign valid_out = valid_out_reg;\nassign cnt = cnt_reg;\n\nendmodule\n\n// Data Accumulator Module\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg                 valid_out_reg;\nreg     [9:0]       data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n        data_accum <= 10'd0;\n    end else if (valid_in) begin\n        data_accum <= data_accum + data_in;\n        valid_out_reg <= 1'b1;\n    end else begin\n        valid_out_reg <= 1'b0;\n    end\nend\n\nassign valid_out = valid_out_reg;\nassign data_out = data_accum;\n\nendmodule\n\n// Valid Output Module\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg                 valid_out_reg;\nreg                 [2:0] cnt_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n        cnt_reg <= 3'd0;\n    end else if (valid_in) begin\n        if (cnt_reg == 3'd3) begin\n            valid_out_reg <= 1'b1;\n            cnt_reg <= 3'd0;\n        end else begin\n            valid_out_reg <= 1'b0;\n            c"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg [0:7];\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            abs_dividend <= 8'd0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            neg_divisor <= 8'd0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 3'd0;\n            shift_reg[0] <= 8'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid && !res_ready) begin\n            counter <= 3'd0;\n            shift_reg[0] <= abs_dividend;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid && res_ready) begin\n            counter <= counter + 3'd1;\n            shift_reg[counter] <= shift_reg[counter - 1] >> 1;\n            quotient <= quotient + (shift_reg[counter] & 1'b1);\n            remainder <= remainder + (shift_reg[counter] & 1'b1) * neg_divisor;\n        end\n    end\n\n    // Result Management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid && !res_ready) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid && res_ready) begin\n            res_valid <= 1'b1;\n        end\n    end\n\n    assign result = (sign) ? {remainder[15:8], quotient[15:8]} : {remainder[7:0], quotient[7:0]};\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare the dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [15:0] divisor\n);\n    // Prepare the dividend and divisor\n    assign dividend = {A, 16'b0};\n    assign divisor = B;\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n    // Perform the division operation\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n    reg [31:0] temp_dividend;\n    reg [31:0] temp_divisor;\n    reg [31:0] temp_shifted_dividend;\n    reg [31:0] temp_shifted_divisor;\n    reg [31:0] temp_quotient_reg;\n    reg [31:0] temp_remainder_reg;\n\n    integer i;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient_reg = 0;\n        remainder_reg = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n        temp_dividend = 0;\n        temp_divisor = 0;\n        temp_shifted_dividend = 0;\n        temp_shifted_divisor = 0;\n        temp_quotient_reg = 0;\n        temp_remainder_reg = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            temp_shifted_dividend = shifted_dividend << 1;\n            temp_shifted_divisor = shifted_divisor << 1;\n            temp_quotient = temp_shifted_dividend / temp_shifted_divisor;\n            temp_remainder = temp_shifted_dividend % temp_shifted_divisor;\n            temp_dividend = temp_shifted_dividend;\n            temp_divisor = temp_shifted_divisor;\n            temp_shifted_dividend = temp_dividend;\n            temp_shifted_divisor = temp_divisor;\n            temp_quotient_reg = temp_quotient;\n            temp_remainder_reg = temp_remainder;\n            quotient_reg = quotient_reg << 1;\n            quotient_reg = quotient_reg | temp_quotient_reg;\n            remainder_reg = remainder_reg << 1;\n            remainder_reg = remainder_reg | temp_remainder_reg;\n        end\n    end\n\n    assign quotient = quotient_reg;\n    assign remainder = remainder_reg;\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [7:0] divisor;\n    reg [15:0] dividend;\n    reg [3:0] count;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [3:0] temp_count;\n\n    // Control unit logic\n    always @(*) begin\n        divisor = B;\n        dividend = A;\n        count = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n        temp_dividend = dividend;\n        temp_divisor = divisor;\n        temp_count = count;\n\n        while (temp_count < 16) begin\n            if (temp_dividend[15:8] >= temp_divisor) begin\n                temp_quotient[temp_count] = 1;\n                temp_remainder[temp_count] = temp_dividend[15:8] - temp_divisor;\n                temp_dividend[15:8] = temp_remainder[temp_count];\n            end else begin\n                temp_quotient[temp_count] = 0;\n                temp_remainder[temp_count] = temp_dividend[15:8];\n            end\n\n            temp_dividend[15:8] = temp_dividend[15:8] << 1;\n            temp_count = temp_count + 1;\n        end\n\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] temp_carry;\nwire [7:0] temp_sum;\n\nassign B_comp = ~B + 1;\nassign {B_out, sum} = A + B_comp;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin\n        assign {temp_carry[i], temp_sum[i]} = sum[i] + carry[i];\n        assign carry[i+1] = temp_carry[i];\n    end\nendgenerate\n\nassign D = temp_sum;\n\nendmodule\n\nmodule adder_8bit(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] temp_carry;\nwire [7:0] temp_sum;\n\nassign {carry[0], sum[0]} = A[0] + B[0] + carry_in;\n\ngenvar i;\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin\n        assign {temp_carry[i], temp_sum[i]} = sum[i-1] + carry[i-1];\n        assign carry[i] = temp_carry[i];\n    end\nendgenerate\n\nassign {carry_out, D} = temp_sum;\n\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\ninput A, B, carry_in;\noutput sum, carry_out;\n\nassign {carry_out, sum} = A + B + carry_in;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_1(A[15:0], B[15:0], Diff16, B_out16);\nsub_16bit sub16_2(A[31:16], B[31:16], Diff[31:16], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_1(A[7:0], B[7:0], Diff8, B_out8);\nsub_8bit sub8_2(A[15:8], B[15:8], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_1(A[3:0], B[3:0], Diff4, B_out4);\nsub_4bit sub4_2(A[7:4], B[7:4], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_1(A[1:0], B[1:0], Diff2, B_out2);\nsub_2bit sub2_2(A[3:2], B[3:2], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_1(A[0], B[0], Diff1, B_out1);\nsub_1bit sub1_2(A[1], B[1], Diff[1], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1, D2, D3;\nwire B0, B1, B2, B3;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\nsub_16bit sub2(D0, B0, D2, B2);\nsub_16bit sub3(D1, B1, D3, B3);\n\nassign D = {D3, D2};\nassign B_out = B3;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nwire B0;\n\nassign D = A - B;\nassign B_out = B0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\n\nwire [3:1] D1, D2, D3, D4;\nwire [3:1] B1, B2, B3, B4;\n\n// 4-bit full subtractor block\nwire [3:1] C1, C2, C3, C4;\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1_out, B2_out, B3_out, B4_out;\n\n// 4-bit full subtractor block\nwire [3:1] C5, C6, C7, C8;\nwire [3:1] A5, A6, A7, A8;\nwire [3:1] B5_out, B6_out, B7_out, B8_out;\n\n// 4-bit full subtractor block\nwire [3:1] C9, C10, C11, C12;\nwire [3:1] A9, A10, A11, A12;\nwire [3:1] B9_out, B10_out, B11_out, B12_out;\n\n// 4-bit full subtractor block\nwire [3:1] C13, C14, C15, C16;\nwire [3:1] A13, A14, A15, A16;\nwire [3:1] B13_out, B14_out, B15_out, B16_out;\n\n// 4-bit full subtractor block\nwire [3:1] C17, C18, C19, C20;\nwire [3:1] A17, A18, A19, A20;\nwire [3:1] B17_out, B18_out, B19_out, B20_out;\n\n// 4-bit full subtractor block\nwire [3:1] C21, C22, C23, C24;\nwire [3:1] A21, A22, A23, A24;\nwire [3:1] B21_out, B22_out, B23_out, B24_out;\n\n// 4-bit full subtractor block\nwire [3:1] C25, C26, C27, C28;\nwire [3:1] A25, A26, A27, A28;\nwire [3:1] B25_out, B26_out, B27_out, B28_out;\n\n// 4-bit full subtractor block\nwire [3:1] C29, C30, C31, C32;\nwire [3:1] A29, A30, A31, A32;\nwire [3:1] B29_out, B30_out, B31_out, B32_out;\n\n// 4-bit full subtractor block\nwire [3:1] C33, C34, C35, C36;\nwire [3:1] A33, A34, A35, A36;\nwire [3:1] B33_out, B34_out, B35_out, B36_out;\n\n// 4-bit full subtractor block\nwire [3:1] C37, C38, C39, C40;\nwire [3:1] A37, A38, A39, A40;\nwire [3:1] B37_out, B38_out, B39_out, B40_out;\n\n// 4-bit full subtractor block\nwire [3:1] C41, C42, C43, C44;\nwire [3:1] A41, A42, A43, A44;\nwire [3:1] B41_out, B42_out, B43_out, B44_out;\n\n// "}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] sub_result;\n    wire carry;\n    \n    // Subtraction logic\n    assign sub_result = A - B;\n    assign carry = (sub_result[31] == 1) ? 1 : 0;\n    \n    // Carry generation logic\n    assign A_greater = (sub_result != 0) ? 1 : 0;\n    assign A_equal = (sub_result == 0) ? 1 : 0;\n    assign A_less = (carry == 0) ? 1 : 0;\n    \nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output carry        // Carry output\n);\n    assign {carry, sub_result} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16;\nwire [15:1] A16,B16;\nwire [15:1] S16;\n\nassign A16=A[16:1];\nassign B16=B[16:1];\nassign S16=S[16:1];\n\nassign C32=C16[15];\n\ncla16 CLA1(.A(A16),.B(B16),.S(S16),.C(C16));\ncla16 CLA2(.A(S16),.B(B16),.S(S),.C(C16));\n\nendmodule\n\nmodule cla16(A,B,S,C);\ninput [15:1] A,B;\noutput [15:1] S;\noutput C;\n\nwire [7:1] C7;\nwire [7:1] A7,B7;\nwire [7:1] S7;\n\nassign A7=A[7:1];\nassign B7=B[7:1];\nassign S7=S[7:1];\n\nassign C7[1]=A7[1]&B7[1]|A7[1]&C7[2]|B7[1]&C7[2];\nassign C7[2]=A7[2]&B7[2]|A7[2]&C7[3]|B7[2]&C7[3]|A7[2]&B7[3]|A7[3]&B7[3];\nassign C7[3]=A7[3]&B7[3]|A7[3]&C7[4]|B7[3]&C7[4]|A7[3]&B7[4]|A7[4]&B7[4];\nassign C7[4]=A7[4]&B7[4]|A7[4]&C7[5]|B7[4]&C7[5]|A7[4]&B7[5]|A7[5]&B7[5];\nassign C7[5]=A7[5]&B7[5]|A7[5]&C7[6]|B7[5]&C7[6]|A7[5]&B7[6]|A7[6]&B7[6];\nassign C7[6]=A7[6]&B7[6]|A7[6]&C7[7]|B7[6]&C7[7]|A7[6]&B7[7]|A7[7]&B7[7];\nassign C7[7]=A7[7]&B7[7]|A7[7]&C7[8]|B7[7]&C7[8]|A7[7]&B7[8]|A7[8]&B7[8];\n\nassign C=C7[8];\n\nassign S7[1]=A7[1]^B7[1]^C7[2];\nassign S7[2]=A7[2]^B7[2]^C7[3];\nassign S7[3]=A7[3]^B7[3]^C7[4];\nassign S7[4]=A7[4]^B7[4]^C7[5];\nassign S7[5]=A7[5]^B7[5]^C7[6];\nassign S7[6]=A7[6]^B7[6]^C7[7];\nassign S7[7]=A7[7]^B7[7]^C7[8];\nassign S7[8]=A7[8]^B7[8]^C7[8];\n\nassign S=S7;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\nwire [3:0] rca1_sum;\nwire [3:0] rca2_sum;\nwire [3:0] rca3_sum;\nwire [3:0] rca4_sum;\n\nwire [3:0] rca1_carry;\nwire [3:0] rca2_carry;\nwire [3:0] rca3_carry;\nwire [3:0] rca4_carry;\n\nwire [3:0] csa1_sum;\nwire [3:0] csa2_sum;\nwire [3:0] csa3_sum;\nwire [3:0] csa4_sum;\n\nwire [3:0] csa1_carry;\nwire [3:0] csa2_carry;\nwire [3:0] csa3_carry;\nwire [3:0] csa4_carry;\n\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_carry = {rca1_sum[3], rca1_sum[2], rca1_sum[1], rca1_sum[0]};\n\nassign rca2_sum = a[7:4] + b[7:4] + rca1_carry[3];\nassign rca2_carry = {rca2_sum[3], rca2_sum[2], rca2_sum[1], rca2_sum[0]};\n\nassign rca3_sum = a[11:8] + b[11:8] + rca2_carry[3];\nassign rca3_carry = {rca3_sum[3], rca3_sum[2], rca3_sum[1], rca3_sum[0]};\n\nassign rca4_sum = a[15:12] + b[15:12] + rca3_carry[3];\nassign rca4_carry = {rca4_sum[3], rca4_sum[2], rca4_sum[1], rca4_sum[0]};\n\nassign csa1_sum = rca1_sum[3] ? rca1_sum[3:0] : rca1_sum[2:0];\nassign csa1_carry = rca1_carry[3] ? rca1_carry[3:0] : rca1_carry[2:0];\n\nassign csa2_sum = rca2_sum[3] ? rca2_sum[3:0] : rca2_sum[2:0];\nassign csa2_carry = rca2_carry[3] ? rca2_carry[3:0] : rca2_carry[2:0];\n\nassign csa3_sum = rca3_sum[3] ? rca3_sum[3:0] : rca3_sum[2:0];\nassign csa3_carry = rca3_carry[3] ? rca3_carry[3:0] : rca3_carry[2:0];\n\nassign csa4_sum = rca4_sum[3] ? rca4_sum[3:0] : rca4_sum[2:0];\nassign csa4_carry = rca4_carry[3] ? rca4_carry[3:0] : rca4_carry[2:0];\n\nassign sum = {csa4_sum, csa3_sum, csa2_sum, csa1_sum};\nassign cout = csa4_carry[3] | csa3_carry[3] | csa2_carry[3] | csa1_carry[3];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder\n    adder_8bit adder0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_8bit adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // 8-bit adder\n    adder_8bit adder2 (\n        .a(y0),\n        .b(y1),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    adder_8bit adder3 (\n        .a(y2),\n        .b(y1),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    adder_8bit adder4 (\n        .a(y3),\n        .b(y2),\n        .Cin(Co3),\n        .y(y4),\n        .Co(Co4)\n    );\n\n    adder_8bit adder5 (\n        .a(y4),\n        .b(y3),\n        .Cin(Co4),\n        .y(y5),\n        .Co(Co5)\n    );\n\n    adder_8bit adder6 (\n        .a(y5),\n        .b(y4),\n        .Cin(Co5),\n        .y(y6),\n        .Co(Co6)\n    );\n\n    adder_8bit adder7 (\n        .a(y6),\n        .b(y5),\n        .Cin(Co6),\n        .y(y7),\n        .Co(Co7)\n    );\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // 4-bit adder\n    adder_4bit adder0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_4bit adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // 4-bit adder\n    adder_4bit adder2 (\n        .a(y0),\n        .b(y1),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    adder_4bit adder3 (\n        .a(y2),\n        .b(y1),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    assign y = {y3, y2, y1, y0};\n    assign Co = Co3;\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [1:0] y0, y1;"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // 8-bit full adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout)\n    );\n    \n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout)\n    );\n    \n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout)\n    );\n    \n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout)\n    );\n    \n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout)\n    );\n    \n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout)\n    );\n    \n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout)\n    );\n    \n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout)\n    );\n    \n    assign sum = fa0_sum + fa1_sum + fa2_sum + fa3_sum + fa4_sum + fa5_sum + fa6_sum + fa7_sum;\n    assign cout = fa7_cout;\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000;\n        product <= 32'b0;\n        done_reg <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000;\n            product <= 32'b0;\n            done_reg <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                shift_cnt <= 4'b0000;\n                done_reg <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1;\n                done_reg <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [15:0] m_reg;\nreg [31:0] p_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'b0;\n        p_reg <= 32'b0;\n    end else begin\n        if (shift_cnt == 4'b0000) begin\n            m_reg <= b_reg;\n            p_reg <= 32'b0;\n        end else begin\n            m_reg <= {m_reg[14:0], 1'b0};\n            p_reg <= p_reg + (m_reg & {16{a_reg[shift_cnt - 1]}});\n        end\n    end\nend\n\n// Output Assignment\nassign yout = p_reg;\nassign done = done_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // Counter logic\n    assign u_counter_logic_out = up_down ? count + 1 : count - 1;\n\n    // Counter register\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= u_counter_register_out;\n        end\n    end\n    assign u_counter_register_out = count_reg;\n\n    assign count = u_counter_register_out;\n\nendmodule\n\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] out\n);\n\n    assign out = up_down ? count + 1 : count - 1;\n\nendmodule\n\nmodule u_counter_register (\n    input wire [15:0] count,\n    input wire clk,\n    input wire reset,\n    output wire [15:0] out\n);\n\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count;\n        end\n    end\n    assign out = count_reg;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initialization\n    // Initialize the counter to its starting state\n    // out = 8'b0000_0001\n    // ...\n\n    // Submodule for state transition\n    // Shift the bits of out to the right on each rising edge of clk\n    // out[0] = out[1];\n    // out[1] = out[2];\n    // ...\n    // out[7] = out[0];\n    // ...\n\nendmodule\n\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule: JC_register\n// Register module for the Johnson Counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule\n\n// Submodule: JC_logic\n// Logic module for the Johnson Counter\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\nalways @(*) begin\n    Q_next = Q;\n    Q_next[0] = Q[63];\nend\n\nendmodule\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg [2:0] clk_div_2;\n    reg [2:0] clk_div_10;\n    reg [2:0] clk_div_100;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            clk_div_2 <= 0;\n            clk_div_10 <= 0;\n            clk_div_100 <= 0;\n        end else begin\n            if (clk_div_2 == 2'b111) begin\n                clk_div_2 <= 0;\n            end else begin\n                clk_div_2 <= clk_div_2 + 1;\n            end\n\n            if (clk_div_10 == 2'b111) begin\n                clk_div_10 <= 0;\n            end else begin\n                clk_div_10 <= clk_div_10 + 1;\n            end\n\n            if (clk_div_100 == 2'b111) begin\n                clk_div_100 <= 0;\n            end else begin\n                clk_div_100 <= clk_div_100 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = clk_div_2[2];\n    assign CLK_10 = clk_div_10[2];\n    assign CLK_1 = clk_div_100[2];\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 2'b11) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[1];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 2'b11) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[1];\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK\n);\n\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            if (counter == 3'b111) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK = counter[2];\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] counter_out;\nwire [3:0] clk_average_out;\nwire [3:0] clk_adjustment_out;\n\n// Counter Submodule\nreg [3:0] counter_reg;\nreg [3:0] counter_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_reg <= 0;\n    end else begin\n        counter_reg <= counter_next;\n    end\nend\n\nalways @(*) begin\n    counter_next = counter_reg + 1;\nend\n\nassign counter_out = counter_reg;\n\n// Clock Average Generator Submodule\nassign clk_average_out = counter_out[3:1];\n\n// Clock Adjustment Submodule\nassign clk_adjustment_out = counter_out[3:2];\n\n// Final Output\nassign clk_div = clk_average_out[0] | clk_adjustment_out[0];\n\nendmodule\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_cnt;\nreg [3:0] neg_cnt;\nreg pos_clk_div;\nreg neg_clk_div;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_cnt <= 0;\n        neg_cnt <= 0;\n        pos_clk_div <= 0;\n        neg_clk_div <= 0;\n    end else begin\n        if (pos_cnt == NUM_DIV - 1) begin\n            pos_cnt <= 0;\n            pos_clk_div <= 1;\n        end else begin\n            pos_cnt <= pos_cnt + 1;\n            pos_clk_div <= 0;\n        end\n        if (neg_cnt == NUM_DIV - 1) begin\n            neg_cnt <= 0;\n            neg_clk_div <= 1;\n        end else begin\n            neg_cnt <= neg_cnt + 1;\n            neg_clk_div <= 0;\n        end\n    end\nend\n\nassign clk_div = pos_clk_div | neg_clk_div;\n\nendmodule\n\n-------------------------------------------------\n\nmodule u_pos_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] cnt;\nreg clk_div;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div <= 0;\n    end else begin\n        if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= 1;\n        end else begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n    end\nend\n\nendmodule\n\n-------------------------------------------------\n\nmodule u_neg_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] cnt;\nreg clk_div;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div <= 0;\n    end else begin\n        if (cnt == NUM_DIV - 1) begin\n            cnt <= 0;\n            clk_div <= 1;\n        end else begin\n            cnt <= cnt + 1;\n            clk_div <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nparameter NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (q == NUM_DIV / 2 - 1)\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter_reset,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter_reset)\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n    \n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n    \n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? add_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? sub_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] u_multiplier_out;\nwire [31:0] u_accumulator_out;\n\n// Multiplier Submodule\nwire [63:0] u_multiplier_in;\nassign u_multiplier_in = {a, 1'b0} * {b, 1'b0};\nassign u_multiplier_out = u_multiplier_in[63:0];\n\n// Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + u_multiplier_out[31:0];\n    end\nend\nassign u_accumulator_out = current_value;\n\n// Connecting the submodules\nassign c = u_accumulator_out;\n\nendmodule\n\nmodule u_multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] out\n);\n\nassign out = {a, 1'b0} * {b, 1'b0};\n\nendmodule\n\nmodule u_accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + a * b;\n    end\nend\nassign out = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register 1\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register 2\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Submodule 1\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Submodule 2\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Output\n    assign ins = ins_p1_reg | ins_p2_reg;\n    assign ad1 = ad1_p1_reg | ad1_p2_reg;\n    assign ad2 = ad2_p1_reg | ad2_p2_reg;\n\n    // Submodule 1\n    assign ins1 = data[7:5];\n    assign ad11 = data[4:0];\n    assign ad21 = data;\n\n    // Submodule 2\n    assign ins2 = data[7:5];\n    assign ad12 = data[4:0];\n    assign ad22 = data;\n\n    // Instruction register 1\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= ins1;\n                ad1_p1_reg <= ad11;\n                ad2_p1_reg <= ad21;\n            end\n        end\n    end\n\n    // Instruction register 2\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2_reg <= ins2;\n                ad1_p2_reg <= ad12;\n                ad2_p2_reg <= ad22;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst(\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] freq_inv;\nassign freq_inv = (freq > 0) ? (8'd255 / freq) : 8'd0;\n\nwave_generator wave_generator_inst(\n    .clk(clk),\n    .count(count),\n    .freq(freq_inv),\n    .wave_out(wave_out)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 8'd0;\n        end else begin\n            count_reg <= count_reg + 8'd1;\n        end\n    end\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n\nreg wave_out_reg;\n\nalways @(posedge clk) begin\n    if (count == (freq - 1)) begin\n        wave_out_reg <= ~wave_out_reg;\n    end\nend\n\nassign wave_out = wave_out_reg;\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(u0_q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(u0_q),\n        .q(u1_q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(u1_q),\n        .q(u2_q)\n    );\n\n    assign q = sel[0] ? u2_q : u1_q;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff my_dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff my_dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff my_dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    wire [7:0] mux3_out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    assign stage1_out = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n\n    // Stage 2\n    assign stage2_out = (ctrl[1]) ? {stage1_out[3:0], stage1_out[7:4]} : stage1_out;\n\n    // Stage 3\n    assign stage3_out = (ctrl[0]) ? {stage2_out[3:0], stage2_out[7:4]} : stage2_out;\n\n    // Output\n    assign out = stage3_out;\n\n    // MUX2X1\n    // Select between two input values based on the sel signal\n    // sel = 0: use in1\n    // sel = 1: use in2\n    // sel = 2: use in3\n    // sel = 3: use in4\n    // sel = 4: use in5\n    // sel = 5: use in6\n    // sel = 6: use in7\n    // sel = 7: use in8\n    // sel = 8: use in9\n    // sel = 9: use in10\n    // sel = 10: use in11\n    // sel = 11: use in12\n    // sel = 12: use in13\n    // sel = 13: use in14\n    // sel = 14: use in15\n    // sel = 15: use in16\n    // sel = 16: use in17\n    // sel = 17: use in18\n    // sel = 18: use in19\n    // sel = 19: use in20\n    // sel = 20: use in21\n    // sel = 21: use in22\n    // sel = 22: use in23\n    // sel = 23: use in24\n    // sel = 24: use in25\n    // sel = 25: use in26\n    // sel = 26: use in27\n    // sel = 27: use in28\n    // sel = 28: use in29\n    // sel = 29: use in30\n    // sel = 30: use in31\n    // sel = 31: use in32\n    // sel = 32: use in33\n    // sel = 33: use in34\n    // sel = 34: use in35\n    // sel = 35: use in36\n    // sel = 36: use in37\n    // sel = 37: use in38\n    // sel = 38: use in39\n    // sel = 39: use in40\n    // sel = 40: use in41\n    // sel = 41: use in42\n    // sel = 42: use in43\n    // sel = 43: use in44\n    // sel = 44: use in45\n    // sel = 45: use in46\n    // sel = 46: use in47\n    // sel = 47: use in48\n    // sel = 48: use in49\n    // sel = 49: use in50\n    // sel = 50: use in51\n    // sel = 51: use in52\n    // sel = 52: use in53\n    // sel = 53: use in54\n    // sel = 54: use in55\n    // sel = 55: use in56\n    // sel = 56: use in57\n    // sel = 57: use in58\n    // sel = 58"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  wire [31:0] instr;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n  wire [31:0] alu_res;\n  wire [31:0] mem_res;\n  wire [31:0] writeback_res;\n\n  reg [31:0] pc_reg;\n  reg [31:0] instr_reg;\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n  reg [31:0] alu_res_reg;\n  reg [31:0] mem_res_reg;\n  reg [31:0] writeback_res_reg;\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\n  assign alu_res = alu_res_reg;\n  assign mem_res = mem_res_reg;\n  assign writeback_res = writeback_res_reg;\n\n  assign res_reg_file = writeback_res_reg;\n\n  stagepipe5_fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr),\n    .instr_mem(instr_mem),\n    .pc_reg(pc_reg),\n    .instr_reg(instr_reg)\n  );\n\n  stagepipe5_decode_stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .rs1_reg(rs1_reg),\n    .rs2_reg(rs2_reg),\n    .rd_reg(rd_reg),\n    .op_reg(op_reg)\n  );\n\n  stagepipe5_execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_res(alu_res),\n    .alu_res_reg(alu_res_reg)\n  );\n\n  stagepipe5_memory_stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .mem_res(mem_res),\n    .mem_res_reg(mem_res_reg)\n  );\n\n  stagepipe5_writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .writeback_res(writeback_res),\n    .writeback_res_reg(writeback_res_reg)\n  );\nendmodule\n\nmodule stagepipe5_fetch_stage (\n  input clk,\n  input rst,\n  input [31:0] pc,\n  output [31:0] instr,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc_reg,\n  output [31:0] instr_reg\n);\n  reg [31:0] pc_reg_next;\n  reg [31:0] instr_reg_next;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg_next <= 0;\n      instr_reg_next <= 0;\n    end else begin\n      pc_reg_next <= pc + 1;\n      instr_reg_next <= instr_mem[pc];\n    end\n  end\n\n  assign pc_reg = pc_reg_next;\n  assign instr = instr_reg_next;\n  assign"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 16'd0;\n      b1_reg <= 16'd0;\n      b2_reg <= 16'd0;\n      b3_reg <= 16'd0;\n      c0_reg <= 32'd0;\n      c1_reg <= 32'd0;\n      c2_reg <= 32'd0;\n      c3_reg <= 32'd0;\n      a0_reg <= 16'd0;\n      a1_reg <= 16'd0;\n      a2_reg <= 16'd0;\n      a3_reg <= 16'd0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch;\n    wire [31:0] execute;\n    wire [31:0] writeback;\n    wire [31:0] pc;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] funct;\n    wire [31:0] instr;\n    wire [31:0] instr_mem_read;\n    wire [31:0] reg_file_read;\n    wire [31:0] reg_file_write;\n    wire [31:0] pc_write;\n    wire [31:0] pc_read;\n    wire [31:0] pc_add;\n    wire [31:0] pc_sub;\n    wire [31:0] pc_add_4;\n    wire [31:0] pc_sub_4;\n    wire [31:0] pc_add_8;\n    wire [31:0] pc_sub_8;\n    wire [31:0] pc_add_12;\n    wire [31:0] pc_sub_12;\n\n    assign out_reg_file = reg_file_write;\n\n    // Fetch stage\n    assign fetch = instr_mem_read;\n\n    // Execute stage\n    assign op1 = reg_file_read;\n    assign op2 = reg_file_read;\n    assign result = (funct == 6'b000000) ? op1 + op2 : op1 - op2;\n    assign reg_file_write = result;\n\n    // Writeback stage\n    assign reg_file_write = writeback;\n\n    // Pipeline control\n    assign pc_write = pc + 4;\n    assign pc_read = pc;\n    assign pc_add = pc_read + 4;\n    assign pc_sub = pc_read - 4;\n    assign pc_add_4 = pc_read + 4;\n    assign pc_sub_4 = pc_read - 4;\n    assign pc_add_8 = pc_read + 8;\n    assign pc_sub_8 = pc_read - 8;\n    assign pc_add_12 = pc_read + 12;\n    assign pc_sub_12 = pc_read - 12;\n\n    // Instruction memory read\n    assign instr_mem_read = instr_mem[pc_read];\n\n    // Register file read\n    assign reg_file_read = reg_file[rs1];\n\n    // Program counter\n    assign pc = pc_write;\n\n    // Instruction decoder\n    assign instr = instr_mem_read;\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign funct = instr[31:27];\n\nendmodule\n"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt == 3'd3) begin\n                cnt <= 3'd0;\n                valid_out_r <= 1'b1;\n            end else begin\n                cnt <= cnt + 1'b1;\n                valid_out_r <= 1'b0;\n            end\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\nend\n\n// Valid Output Module\nreg             valid_out_s;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_s <= 1'b0;\n    end else begin\n        valid_out_s <= valid_out_r;\n    end\nend\n\nassign valid_out = valid_out_s;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output              count\n);\n\nreg                 [2:0]   cnt;\nreg                         valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (cnt == 3'd3) begin\n                cnt <= 3'd0;\n                valid_out_r <= 1'b1;\n            end else begin\n                cnt <= cnt + 1'b1;\n                valid_out_r <= 1'b0;\n            end\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign count = cnt;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg                 [2:0]   cnt;\nreg                         valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if ("}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nreg [7:0] abs_dividend;\nreg [7:0] neg_divisor;\nreg [7:0] shift_reg;\nreg [3:0] counter;\n\nassign result = {shift_reg, abs_dividend};\n\n// Absolute Value Calculation\nalways @(posedge clk) begin\n    if (rst)\n        abs_dividend <= 0;\n    else if (opn_valid)\n        abs_dividend <= sign ? -dividend : dividend;\nend\n\n// Negative Divisor Calculation\nalways @(posedge clk) begin\n    if (rst)\n        neg_divisor <= 0;\n    else if (opn_valid)\n        neg_divisor <= sign ? -divisor : divisor;\nend\n\n// Division Control Logic\nalways @(posedge clk) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n    end else if (opn_valid) begin\n        counter <= counter + 1;\n        shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n        if (counter == 7) begin\n            shift_reg <= 0;\n            counter <= 0;\n        end\n    end\nend\n\n// Result Management\nalways @(posedge clk) begin\n    if (rst)\n        res_valid <= 0;\n    else if (opn_valid)\n        res_valid <= 1;\n    else if (res_ready)\n        res_valid <= 0;\nend\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor   // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,   // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder  // 32-bit remainder\n);\n\n    // Perform division\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] dividend_reg;\n    reg [15:0] divisor_reg;\n    reg [31:0] shift_reg;\n    reg [31:0] temp_reg;\n    reg [31:0] temp_reg2;\n    reg [31:0] temp_reg3;\n    reg [31:0] temp_reg4;\n    reg [31:0] temp_reg5;\n    reg [31:0] temp_reg6;\n    reg [31:0] temp_reg7;\n    reg [31:0] temp_reg8;\n    reg [31:0] temp_reg9;\n    reg [31:0] temp_reg10;\n    reg [31:0] temp_reg11;\n    reg [31:0] temp_reg12;\n    reg [31:0] temp_reg13;\n    reg [31:0] temp_reg14;\n    reg [31:0] temp_reg15;\n    reg [31:0] temp_reg16;\n    reg [31:0] temp_reg17;\n    reg [31:0] temp_reg18;\n    reg [31:0] temp_reg19;\n    reg [31:0] temp_reg20;\n    reg [31:0] temp_reg21;\n    reg [31:0] temp_reg22;\n    reg [31:0] temp_reg23;\n    reg [31:0] temp_reg24;\n    reg [31:0] temp_reg25;\n    reg [31:0] temp_reg26;\n    reg [31:0] temp_reg27;\n    reg [31:0] temp_reg28;\n    reg [31:0] temp_reg29;\n    reg [31:0] temp_reg30;\n    reg [31:0] temp_reg31;\n    reg [31:0] temp_reg32;\n    reg [31:0] temp_reg33;\n    reg [31:0] temp_reg34;\n    reg ["}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [7:0] divisor;\n    reg [15:0] dividend;\n    reg [15:0] shifted_dividend;\n    reg [15:0] temp_result;\n    reg [15:0] temp_remainder;\n    reg [3:0] i;\n    reg [3:0] j;\n\n    // Control unit logic\n    always @(*) begin\n        // Initialize\n        quotient = 16'b0;\n        remainder = 16'b0;\n        divisor = B;\n        dividend = A;\n        shifted_dividend = 16'b0;\n        temp_result = 16'b0;\n        temp_remainder = 16'b0;\n        i = 0;\n        j = 0;\n\n        // Shift dividend\n        for (i = 0; i < 16; i = i + 1) begin\n            shifted_dividend[i] = dividend[15 - i];\n        end\n\n        // Compare divisor with shifted dividend\n        for (i = 0; i < 16; i = i + 1) begin\n            if (shifted_dividend[i] == divisor[7 - i]) begin\n                temp_result[i] = 1'b1;\n            end else begin\n                temp_result[i] = 1'b0;\n            end\n        end\n\n        // Update quotient and remainder\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp_result[i] == 1'b1) begin\n                quotient[i] = 1'b1;\n                remainder[i] = shifted_dividend[i];\n            end else begin\n                quotient[i] = 1'b0;\n                remainder[i] = shifted_dividend[i];\n            end\n        end\n\n        // Shift remainder\n        for (i = 0; i < 16; i = i + 1) begin\n            if (i == 0) begin\n                temp_remainder[i] = remainder[15];\n            end else begin\n                temp_remainder[i] = remainder[15 - i];\n            end\n        end\n\n        // Update quotient and remainder\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp_result[i] == 1'b1) begin\n                quotient[i] = 1'b1;\n                remainder[i] = temp_remainder[i];\n            end else begin\n                quotient[i] = 1'b0;\n                remainder[i] = temp_remainder[i];\n            end\n        end\n    end\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {carry[0], sum[0]} = A[0] + B_comp[0];\nassign {carry[1], sum[1]} = A[1] + B_comp[1] + carry[0];\nassign {carry[2], sum[2]} = A[2] + B_comp[2] + carry[1];\nassign {carry[3], sum[3]} = A[3] + B_comp[3] + carry[2];\nassign {carry[4], sum[4]} = A[4] + B_comp[4] + carry[3];\nassign {carry[5], sum[5]} = A[5] + B_comp[5] + carry[4];\nassign {carry[6], sum[6]} = A[6] + B_comp[6] + carry[5];\nassign {carry[7], sum[7]} = A[7] + B_comp[7] + carry[6];\n\nassign D = sum;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {carry[0], sum[0]} = A[0] + B_comp[0];\nassign {carry[1], sum[1]} = A[1] + B_comp[1] + carry[0];\nassign {carry[2], sum[2]} = A[2] + B_comp[2] + carry[1];\nassign {carry[3], sum[3]} = A[3] + B_comp[3] + carry[2];\nassign {carry[4], sum[4]} = A[4] + B_comp[4] + carry[3];\nassign {carry[5], sum[5]} = A[5] + B_comp[5] + carry[4];\nassign {carry[6], sum[6]} = A[6] + B_comp[6] + carry[5];\nassign {carry[7], sum[7]} = A[7] + B_comp[7] + carry[6];\n\nassign D = sum;\nassign B_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C, D, C_out);\ninput A, B, C;\noutput D, C_out;\n\nassign {C_out, D} = A + B + C;\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] ^ B[31]) ? 1 : 0;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire B_out1, B_out2, B_out3, B_out4;\n\n// 4-bit full subtractor block\nwire [3:1] B_out_temp;\nassign B_out_temp[1] = ~(A1[1] ^ B1[1]);\nassign B_out_temp[2] = ~(A2[2] ^ B2[2]);\nassign B_out_temp[3] = ~(A3[3] ^ B3[3]);\n\nassign B_out = B_out_temp[1] & B_out_temp[2] & B_out_temp[3];\n\nassign D1[1] = A1[1] ^ B1[1];\nassign D2[2] = A2[2] ^ B2[2];\nassign D3[3] = A3[3] ^ B3[3];\n\nassign D4[4] = A4[4] ^ B4[4];\n\nassign D[16:1] = {D1[1], D2[2], D3[3], D4[4]};\n\nassign A1[1] = A[1];\nassign A2[2] = A[2];\nassign A3[3] = A[3];\nassign A4[4] = A[4];\n\nassign B1[1] = B[1];\nassign B2[2] = B[2];\nassign B3[3] = B[3];\nassign B4[4] = B[4];\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire carry;\n\n// Subtraction operation\nassign subtraction_result = A - B;\nassign carry = (subtraction_result[31] == 1);\n\n// Carry generation\nassign A_greater = (subtraction_result != 0 && carry == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (subtraction_result == 0 && carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[32] ^ B[32]) | (A[31] & B[31]) | (A[30] & B[30]) | (A[29] & B[29]) | (A[28] & B[28]) | (A[27] & B[27]) | (A[26] & B[26]) | (A[25] & B[25]) | (A[24] & B[24]) | (A[23] & B[23]) | (A[22] & B[22]) | (A[21] & B[21]) | (A[20] & B[20]) | (A[19] & B[19]) | (A[18] & B[18]) | (A[17] & B[17]) | (A[16] & B[16]);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] rca1_sum, rca2_sum;\nwire [3:0] rca1_cout, rca2_cout;\n\n// 4-bit ripple carry adder\nwire [3:0] sum_temp;\nassign sum_temp[0] = a[0] ^ b[0] ^ cin;\nassign sum_temp[1] = a[1] ^ b[1] ^ sum_temp[0];\nassign sum_temp[2] = a[2] ^ b[2] ^ sum_temp[1];\nassign sum_temp[3] = a[3] ^ b[3] ^ sum_temp[2];\nassign sum = {sum_temp[3], sum_temp[2], sum_temp[1], sum_temp[0]};\n\nassign cout = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n// 4-bit carry select adder slice\nwire [3:0] csa_slice1_carry;\nassign csa_slice1_carry[0] = (a[1] & b[1]) | (a[1] & cin) | (b[1] & cin);\nassign csa_slice1_carry[1] = (a[2] & b[2]) | (a[2] & csa_slice1_carry[0]) | (b[2] & csa_slice1_carry[0]);\nassign csa_slice1_carry[2] = (a[3] & b[3]) | (a[3] & csa_slice1_carry[1]) | (b[3] & csa_slice1_carry[1]);\nassign csa_slice1_carry[3] = (cin & csa_slice1_carry[2]) | (a[3] & b[3] & csa_slice1_carry[1]) | (a[3] & b[3] & csa_slice1_carry[0]) | (a[2] & b[2] & csa_slice1_carry[1]) | (a[2] & b[2] & csa_slice1_carry[0]) | (a[1] & b[1] & csa_slice1_carry[0]);\n\nassign csa_slice1_sum[0] = a[0] ^ b[0] ^ cin;\nassign csa_slice1_sum[1] = a[1] ^ b[1] ^ csa_slice1_sum[0];\nassign csa_slice1_sum[2] = a[2] ^ b[2] ^ csa_slice1_sum[1];\nassign csa_slice1_sum[3] = a[3] ^ b[3] ^ csa_slice1_sum[2];\n\nassign csa_slice1_cout = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n// 4-bit carry select adder slice\nwire [3:0] csa_slice2_carry;\nassign csa_slice2_carry[0] = (a[4] & b[4]) | (a[4] & csa_slice1_carry[0]) | (b[4] & csa_slice1_carry[0]);\nassign csa_slice2_carry[1] = (a[5] & b[5]) | (a[5] & csa_slice1_carry[1]) | (b[5] & csa_slice1_carry[1]);\nassign csa_slice2_carry[2] = (a[6] & b[6]) | (a[6] & csa_slice1_carry[2]) | (b[6] & csa_slice1_carry[2]);\nassign csa_"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder\n    adder_8bit adder0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_8bit adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // 8-bit adder\n    adder_8bit adder2 (\n        .a(y0),\n        .b(y1),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    adder_8bit adder3 (\n        .a(y2),\n        .b(y1),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    adder_8bit adder4 (\n        .a(y3),\n        .b(y2),\n        .Cin(Co3),\n        .y(y4),\n        .Co(Co4)\n    );\n\n    adder_8bit adder5 (\n        .a(y4),\n        .b(y3),\n        .Cin(Co4),\n        .y(y5),\n        .Co(Co5)\n    );\n\n    adder_8bit adder6 (\n        .a(y5),\n        .b(y4),\n        .Cin(Co5),\n        .y(y6),\n        .Co(Co6)\n    );\n\n    adder_8bit adder7 (\n        .a(y6),\n        .b(y5),\n        .Cin(Co6),\n        .y(y7),\n        .Co(Co7)\n    );\n\n    // 8-bit adder\n    adder_8bit adder8 (\n        .a(y7),\n        .b(y6),\n        .Cin(Co7),\n        .y(y),\n        .Co(Co)\n    );\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // 4-bit adder\n    adder_4bit adder0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_4bit adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    // 4-bit adder\n    adder_4bit adder2 (\n        .a(y0),\n        .b(y1),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n\n    adder_4bit adder3 (\n        .a(y2),\n        .b(y1),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n\n    // 4-bit adder\n    adder_4bit adder4 (\n        .a(y3),\n        .b(y2),\n        .Cin(Co3),\n        .y(y),\n        .Co(Co)\n    );\nendmodule\n\nmodule adder_4bit ("}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    \n    // FA0\n    assign FA0 = a[0] ^ b[0] ^ cin;\n    assign sum[0] = FA0;\n    assign cout = a[0] & b[0] | a[0] & cin | b[0] & cin;\n    \n    // FA1\n    assign FA1 = a[1] ^ b[1] ^ FA0;\n    assign sum[1] = FA1;\n    assign cout = a[1] & b[1] | a[1] & FA0 | b[1] & FA0;\n    \n    // FA2\n    assign FA2 = a[2] ^ b[2] ^ FA1;\n    assign sum[2] = FA2;\n    assign cout = a[2] & b[2] | a[2] & FA1 | b[2] & FA1;\n    \n    // FA3\n    assign FA3 = a[3] ^ b[3] ^ FA2;\n    assign sum[3] = FA3;\n    assign cout = a[3] & b[3] | a[3] & FA2 | b[3] & FA2;\n    \n    // FA4\n    assign FA4 = a[4] ^ b[4] ^ FA3;\n    assign sum[4] = FA4;\n    assign cout = a[4] & b[4] | a[4] & FA3 | b[4] & FA3;\n    \n    // FA5\n    assign FA5 = a[5] ^ b[5] ^ FA4;\n    assign sum[5] = FA5;\n    assign cout = a[5] & b[5] | a[5] & FA4 | b[5] & FA4;\n    \n    // FA6\n    assign FA6 = a[6] ^ b[6] ^ FA5;\n    assign sum[6] = FA6;\n    assign cout = a[6] & b[6] | a[6] & FA5 | b[6] & FA5;\n    \n    // FA7\n    assign FA7 = a[7] ^ b[7] ^ FA6;\n    assign sum[7] = FA7;\n    assign cout = a[7] & b[7] | a[7] & FA6 | b[7] & FA6;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_count == 4'b1111) begin\n                shift_count <= 4'b0000;\n                done_flag <= 1'b1;\n            end else begin\n                shift_count <= shift_count + 1'b1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m;\nreg [31:0] p;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m <= 16'b0;\n        p <= 32'b0;\n    end else begin\n        if (shift_count == 4'b0000) begin\n            m <= b_reg;\n            p <= 32'b0;\n        end else begin\n            if (m[0] == 1'b1) begin\n                p <= p + a_reg;\n            end\n            m <= {1'b0, m[15:1]};\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = p;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // Counter logic module\n    // Implemented as a submodule\n    // Replace with the correct implementation\n    // Placeholder for now\n    assign u_counter_logic_out = 16'b0;\n\n    // Counter register module\n    // Implemented as a submodule\n    // Replace with the correct implementation\n    // Placeholder for now\n    assign u_counter_register_out = 16'b0;\n\n    assign count = u_counter_register_out;\n\nendmodule\n\n// Counter logic module\n// Implemented as a submodule\n// Replace with the correct implementation\n// Placeholder for now\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    assign next_count = (up_down) ? count + 1 : count - 1;\n\nendmodule\n\n// Counter register module\n// Implemented as a submodule\n// Replace with the correct implementation\n// Placeholder for now\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output wire [15:0] next_count\n);\n\n    reg [15:0] reg_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            reg_count <= 16'b0;\n        end else begin\n            reg_count <= next_count;\n        end\n    end\n\n    assign next_count = reg_count;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule for initialization\n    // Initial state: out = 8'b0000_0001\n    // State transition: out = {out[6:0], out[7]};\n    // Reset behavior: out = 8'b0000_0001\n\n    // Submodule for state transition\n    // State transition: out = {out[6:0], out[7]};\n    // Reset behavior: out = 8'b0000_0001\n\nendmodule\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nRing counter with submodules (Verilog)\n```\nmodule ring_counter (\n    input clk,\n    input reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n        else\n            out <= {out[6:0], out[7]};\n    end\n\nendmodule\n\nmodule ring_counter_init (\n    input clk,\n    input reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n    end\n\nendmodule\n\nmodule ring_counter_transition (\n    input clk,\n    input reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n        else\n            out <= {out[6:0], out[7]};\n    end\n\nendmodule\n```\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_next;\n\nassign out = count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_next <= 4'b0000;\n    else if (valid_count)\n        count_next <= count + 1;\nend\n\nassign count = (count_next == 4'd11) ? 4'b0000 : count_next;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_reg <= 4'b0000;\n    else if (valid_count)\n        count_reg <= count_reg + 1;\nend\n\nassign count = count_reg;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= count;\nend\n\nassign out = out_reg;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'd0;\n    end else begin\n        Q_reg <= Q_reg + 1;\n    end\nend\n\n// Logic submodule\nwire [63:0] next_Q;\nassign next_Q = Q_reg ^ (Q_reg >> 1);\nalways @(*) begin\n    Q = next_Q;\nend\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q_reg <= 64'd0;\n    end else begin\n        Q_reg <= Q_reg + 1;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]       next_Q\n);\n\nassign next_Q = Q ^ (Q >> 1);\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg CLK_50_r, CLK_10_r, CLK_1_r;\n\n// clk_div_2\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_50_r <= 0;\n    end else begin\n        CLK_50_r <= ~CLK_50_r;\n    end\nend\n\n// clk_div_10\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_10_r <= 0;\n    end else begin\n        CLK_10_r <= (CLK_10_r == 3) ? 0 : CLK_10_r + 1;\n    end\nend\n\n// clk_div_100\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        CLK_1_r <= 0;\n    end else begin\n        CLK_1_r <= (CLK_1_r == 49) ? 0 : CLK_1_r + 1;\n    end\nend\n\nassign CLK_50 = CLK_50_r;\nassign CLK_10 = CLK_10_r;\nassign CLK_1 = CLK_1_r;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] counter_out;\nwire [3:0] clk_average_out;\nwire [3:0] clk_adjustment_out;\n\nwire clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_reg <= 0;\n    end else begin\n        counter_reg <= counter_reg + 1;\n    end\nend\nassign counter_out = counter_reg;\n\n// Clock Average Generator Submodule\nassign clk_average_out = counter_out[3:1];\n\n// Clock Adjustment Submodule\nassign clk_adjustment_out = counter_out[0] ? clk_average_out : ~clk_average_out;\n\n// Clock Divider Submodule\nassign clk_div_int = clk_average_out[0] | clk_adjustment_out[0];\n\n// Final Clock Divider\nassign clk_div = clk_div_int | clk_div_int;\n\nendmodule\n\n```\n\n### 4.2.2 \u627e\u51fa\u6240\u6709\u7684\u8f93\u5165\u7aef\u53e3\n\n```verilog\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] counter_out;\nwire [3:0] clk_average_out;\nwire [3:0] clk_adjustment_out;\n\nwire clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_reg <= 0;\n    end else begin\n        counter_reg <= counter_reg + 1;\n    end\nend\nassign counter_out = counter_reg;\n\n// Clock Average Generator Submodule\nassign clk_average_out = counter_out[3:1];\n\n// Clock Adjustment Submodule\nassign clk_adjustment_out = counter_out[0] ? clk_average_out : ~clk_average_out;\n\n// Clock Divider Submodule\nassign clk_div_int = clk_average_out[0] | clk_adjustment_out[0];\n\n// Final Clock Divider\nassign clk_div = clk_div_int | clk_div_int;\n\nendmodule\n\n```\n\n### 4.2.3 \u627e\u51fa\u6240\u6709\u7684\u8f93\u51fa\u7aef\u53e3\n\n```verilog\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] counter_out;\nwire [3:0] clk_average_out;\nwire [3:0] clk_adjustment_out;\n\nwire clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_reg <= 0;\n    end else begin\n        counter_reg <= counter_reg + 1;\n    end\nend\nassign counter_out = counter_reg;\n\n// Clock Average Generator Submodule\nassign clk_average_out = counter_out[3:1];\n\n// Clock Adjustment Submodule\nassign clk_adjustment_out = counter_out[0] ? clk_average_out : ~clk_average_out;\n\n// Clock Divider Submodule\nassign clk_div_int = clk_average_out[0] | clk_adjustment_out[0];\n\n// Final Clock Divider\nassign clk_div = clk"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        neg_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (pos_counter < NUM_DIV - 1) begin\n            pos_counter <= pos_counter + 1;\n        end else begin\n            pos_counter <= 0;\n        end\n        if (neg_counter < NUM_DIV - 1) begin\n            neg_counter <= neg_counter + 1;\n        end else begin\n            neg_counter <= 0;\n        end\n        clk_div1 <= (pos_counter == NUM_DIV - 1) ? 1'b1 : 1'b0;\n        clk_div2 <= (neg_counter == NUM_DIV - 1) ? 1'b1 : 1'b0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nwire [3:0] counter_out;\n\nreg [3:0] counter_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter_reg <= 0;\n    else if (counter_reg == NUM_DIV / 2 - 1)\n        counter_reg <= 0;\n    else\n        counter_reg <= counter_reg + 1;\nend\n\nassign counter_out = counter_reg;\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out\n);\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter_reg <= 0;\n    else if (counter_reg == NUM_DIV / 2 - 1)\n        counter_reg <= 0;\n    else\n        counter_reg <= counter_reg + 1;\nend\n\nassign counter_out = counter_reg;\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter_out == NUM_DIV / 2 - 1)\n        clk_div <= ~clk_div;\nend\n\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n    \n    add add_inst (\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n    \n    sub sub_inst (\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n    \n    and and_inst (\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow),\n        .flag(and_flag)\n    );\n    \n    or or_inst (\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow),\n        .flag(or_flag)\n    );\n    \n    xor xor_inst (\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow),\n        .flag(xor_flag)\n    );\n    \n    nor nor_inst (\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow),\n        .flag(nor_flag)\n    );\n    \n    slt slt_inst (\n        .a(a),\n        .b(b),\n        .r(slt_r),\n        .zero(slt_zero),\n        .carry(slt"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] multiplication_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] multiplication_result;\nassign multiplication_result = a * b;\n\n// Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + multiplication_result[31:0];\n    end\nend\n\n// Connecting the submodules\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for RAM/ROM\n    reg [2:0] ins_p1_ram;\n    reg [4:0] ad1_p1_ram;\n    reg [7:0] ad2_p1_ram;\n    reg [2:0] ins_p2_ram;\n    reg [4:0] ad1_p2_ram;\n    reg [7:0] ad2_p2_ram;\n\n    // Assigning the outputs\n    assign ins = ins_p1_reg | ins_p2_reg;\n    assign ad1 = ad1_p1_reg | ad1_p2_reg;\n    assign ad2 = ad2_p1_reg | ad2_p2_reg;\n\n    // Instruction register for register\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n            ad1_p1_reg <= data[4:0];\n            ad2_p1_reg <= data;\n        end\n    end\n\n    // Instruction register for RAM/ROM\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data[7:5];\n            ad1_p2_reg <= data[4:0];\n            ad2_p2_reg <= data;\n        end\n    end\n\n    // Instruction register for register\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_ram <= 3'b0;\n            ad1_p1_ram <= 5'b0;\n            ad2_p1_ram <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_ram <= data[7:5];\n            ad1_p1_ram <= data[4:0];\n            ad2_p1_ram <= data;\n        end\n    end\n\n    // Instruction register for RAM/ROM\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_ram <= 3'b0;\n            ad1_p2_ram <= 5'b0;\n            ad2_p2_ram <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_ram <= data[7:5];\n            ad1_p2_ram <= data[4:0];\n            ad2_p2_ram <= data;\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire enable = (freq > 0);\n\nwire [7:0] count;\nwire [7:0] next_count;\n\nreg [7:0] count_reg;\n\nassign count = count_reg;\nassign next_count = (count_reg == (freq - 1)) ? 0 : count_reg + 1;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        count_reg <= next_count;\n    end\nend\n\nassign wave_out = (count_reg == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output [4:0] wave_out\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave;\n        end\n    end\n\n    assign wave_out = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    assign q = sel[0] ? (sel[1] ? q2 : q1) : q0;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    assign stage1_out[7:4] = (ctrl[2]) ? in[7:4] : in[3:0];\n    assign stage1_out[3:0] = (ctrl[2]) ? in[3:0] : in[7:4];\n\n    // Stage 2\n    assign stage2_out[7:4] = (ctrl[1]) ? stage1_out[7:4] : stage1_out[3:0];\n    assign stage2_out[3:0] = (ctrl[1]) ? stage1_out[3:0] : stage1_out[7:4];\n\n    // Stage 3\n    assign stage3_out[7:4] = (ctrl[0]) ? stage2_out[7:4] : stage2_out[3:0];\n    assign stage3_out[3:0] = (ctrl[0]) ? stage2_out[3:0] : stage2_out[7:4];\n\n    assign out = stage3_out;\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input sel;\n    input in0, in1;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rd;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [5:0] op;\n  wire [31:0] instr;\n  wire [31:0] res;\n\n  stagepipe5_fetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc),\n    .instr(instr)\n  );\n\n  stagepipe5_decode_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rd(rd),\n    .rs1(rs1),\n    .rs2(rs2),\n    .op(op)\n  );\n\n  stagepipe5_execute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .op(op),\n    .alu_res(alu_res)\n  );\n\n  stagepipe5_memory_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res(res)\n  );\n\n  stagepipe5_writeback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .res(res),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign pc = 0;\n  assign next_pc = pc + 1;\nendmodule\n\nmodule stagepipe5_fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [4:0] pc,\n  output [4:0] next_pc,\n  output [31:0] instr\n);\n  reg [4:0] pc_reg;\n  reg [4:0] next_pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      next_pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      pc_reg <= next_pc_reg;\n      instr_reg <= instr_mem[pc_reg];\n      next_pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = next_pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule stagepipe5_decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rd,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [5:0] op\n);\n  reg [4:0] rd_reg;\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rd_reg <= 0;\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rd_reg <= instr[11:7];\n      rs1_reg <= instr[19:15];\n      rs2_reg <= instr[24:20];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rd = rd_reg;\n  assign rs1 = rs1_reg;\n  assign rs2 ="}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      a0_reg <= a0;\n      a1_reg <= a0_reg;\n      a2_reg <= a1_reg;\n      a3_reg <= a2_reg;\n      c0_reg <= a0_reg * b0_reg;\n      c1_reg <= a1_reg * b1_reg;\n      c2_reg <= a2_reg * b2_reg;\n      c3_reg <= a3_reg * b3_reg;\n    end\n  end\n  \n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n    wire [4:0] pc;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] op;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n    wire [31:0] reg_file_out;\n\n    assign out_reg_file = writeback_out;\n\n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(fetch_out),\n        .pc(pc),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .op(op),\n        .imm(imm)\n    );\n\n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(execute_out),\n        .pc(pc),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .op(op),\n        .imm(imm)\n    );\n\n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(writeback_out),\n        .pc(pc),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .op(op),\n        .imm(imm)\n    );\n\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file,\n    output [4:0] pc,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [5:0] op,\n    output [31:0] imm,\n    output [31:0] alu_out\n);\n\n    assign out_reg_file = alu_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc <= 5'b00000;\n            rd <= 5'b00000;\n            rs1 <= 5'b00000;\n            rs2 <= 5'b00000;\n            op <= 6'b000000;\n            imm <= 32'b0;\n            alu_out <= 32'b0;\n        end else begin\n            pc <= pc + 1;\n            rd <= instr_mem[pc][11:7];\n            rs1 <= instr_mem[pc][19:15];\n            rs2 <= instr_mem[pc][24:20];\n            op <= instr_mem[pc][31:26];\n            imm <= { {12{instr_mem[pc][31]}}, instr_mem[pc][31:20] };\n            alu_out <= reg_file[rs1] + reg_file[rs2];\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n/*----------------------------------------------------------------------------\nModule references\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nParameter Declarations\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nLocal signal declarations\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nData Accumulator Module\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nCounter Module\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nValid Output Module\n----------------------------------------------------------------------------*/\n\n\n\n/*----------------------------------------------------------------------------\nOutput assignments\n----------------------------------------------------------------------------*/\n\n\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg [0:7];\n    reg [2:0] counter;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 8'b0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 8'b0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 3'b0;\n            shift_reg[0] <= 8'b0;\n            quotient <= 16'b0;\n            remainder <= 16'b0;\n        end else if (opn_valid) begin\n            counter <= 3'b0;\n            shift_reg[0] <= abs_dividend;\n            quotient <= 16'b0;\n            remainder <= 16'b0;\n        end else if (counter < 3'd7) begin\n            shift_reg[counter+1] <= shift_reg[counter] >> 1;\n            if (shift_reg[counter+1] >= neg_divisor) begin\n                shift_reg[counter+1] <= shift_reg[counter+1] - neg_divisor;\n                quotient[counter] <= 1'b1;\n            end else begin\n                quotient[counter] <= 1'b0;\n            end\n            counter <= counter + 1;\n        end else begin\n            res_valid <= 1'b1;\n            remainder <= {shift_reg[7], quotient};\n        end\n    end\n\n    // Result Management\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (res_ready) begin\n            res_valid <= 1'b0;\n        end\n    end\n\n    assign result = remainder;\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\n// Prepare dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor   // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A, 16'b0};\n    assign divisor = B;\n\nendmodule\n\n// Perform division\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,   // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder  // 32-bit remainder\n);\n\n    // Perform division\n    assign quotient = dividend / divisor;\n    assign remainder = dividend % divisor;\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    // This submodule performs the division algorithm\n    // and updates the quotient and remainder.\n    //\n    // The control unit submodule should be implemented\n    // as a separate module.\n    //\n    // The control unit submodule should have the following ports:\n    //     A: 16-bit dividend.\n    //     B: 8-bit divisor.\n    //     result: 16-bit quotient.\n    //     odd: 16-bit remainder.\n    //\n    // The control unit submodule should have the following inputs:\n    //     None.\n    //\n    // The control unit submodule should have the following outputs:\n    //     None.\n    //\n    // The control unit submodule should have the following parameters:\n    //     None.\n    //\n    // The control unit submodule should have the following local variables:\n    //     None.\n    //\n    // The control unit submodule should have the following local wires:\n    //     None.\n    //\n    // The control unit submodule should have the following local registers:\n    //     None.\n    //\n    // The control unit submodule should have the following local flip-flops:\n    //     None.\n    //\n    // The control unit submodule should have the following local latches:\n    //     None.\n    //\n    // The control unit submodule should have the following local memories:\n    //     None.\n    //\n    // The control unit submodule should have the following local functions:\n    //     None.\n    //\n    // The control unit submodule should have the following local tasks:\n    //     None.\n    //\n    // The control unit submodule should have the following local generate blocks:\n    //     None.\n    //\n    // The control unit submodule should have the following local unpacked arrays:\n    //     None.\n    //\n    // The control unit submodule should have the following local packed arrays:\n    //     None.\n    //\n    // The control unit submodule should have the following local structures:\n    //     None.\n    //\n    // The control unit submodule should have the following local enumerated types:\n    //     None.\n    //\n    // The control unit submodule should have the following local union types:\n    //     None.\n    //\n    // The control unit submodule should have the following local typedefs:\n    //     None.\n    //\n    // The control unit submodule should have the following local parameters:\n    //     None.\n    //\n    // The control unit submodule should have the following local constants:\n    //     None.\n    //\n    // The control unit submodule should have the following local variables:\n    //     None.\n    //\n    // The control unit submodule should have the following local wires:\n    //     None.\n    //\n    // The control unit submodule should have the following local registers:\n    //     None.\n    //\n    // The control unit submodule should have the following local flip-flops:\n    //     None.\n    //\n    // The control unit submodule should have the following local latches:\n    //     None.\n    //\n    // The control unit submodule should have the following local memories:\n    //     None.\n    //\n    // The control unit submodule should have the following local functions:\n    //     None.\n    //\n    // The control unit submodule should have the following local tasks:\n    //     None.\n    //\n    // The control unit submodule should have the following local generate blocks:\n    //     None.\n    //\n    // The control unit submodule should have the following local unpacked arrays:\n    //     None.\n    //\n    // The control unit submodule should have the following local packed arrays:\n    //     None.\n    //\n    // The control unit submodule should have the following local structures:\n    //     None.\n    //\n    // The control unit submodule should have the following local enumerated types:\n    //     None.\n    //\n    // The control unit submodule should have the following local union types:\n    //     None.\n    //\n    // The control unit submodule should have the following local typedefs:\n    //     None.\n    //\n    // The control unit submodule should have the following local parameters:\n    //     None.\n    //"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] borrow;\n\nassign B_comp = ~B + 1;\nassign {borrow, sum} = A + B_comp;\nassign {carry[0], D} = sum + 1;\nassign B_out = carry[0];\n\nendmodule\n\nmodule adder_8bit(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign {carry[0], sum} = A + B + carry_in;\nassign {carry[1], D} = sum + 1;\nassign carry_out = carry[1];\n\nendmodule\n\nmodule full_adder(A, B, carry_in, sum, carry_out);\ninput A, B, carry_in;\noutput sum, carry_out;\n\nassign {carry_out, sum} = A + B + carry_in;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\n\nwire [3:1] D1, D2, D3, D4;\nwire [3:1] B1, B2, B3, B4;\n\n// 4-bit full subtractor block\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1_out, B2_out, B3_out, B4_out;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\n\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\n// BLS architecture\nassign B1_out = (A1 < B1) ? 1'b1 : 1'b0;\nassign D1 = A1 - B1;\n\nassign B2_out = (A2 < B2) ? B1_out : 1'b0;\nassign D2 = A2 - B2;\n\nassign B3_out = (A3 < B3) ? B2_out : 1'b0;\nassign D3 = A3 - B3;\n\nassign B4_out = (A4 < B4) ? B3_out : 1'b0;\nassign D4 = A4 - B4;\n\nassign B_out = B4_out;\nassign D = {D4, D3, D2, D1};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtractor module\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .carry(carry)\n);\n\n// Comparison logic\nassign A_greater = (sub_result == 32'b0);\nassign A_equal = (sub_result == 32'b0) && (carry == 1'b0);\nassign A_less = (sub_result == 32'b0) && (carry == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output carry       // Carry out\n);\n\nassign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\nassign S[1:0] = A[1:0] ^ B[1:0];\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum;\nwire [3:0] csa_slice2_sum;\nwire [3:0] csa_slice3_sum;\nwire [3:0] csa_slice1_cout;\nwire [3:0] csa_slice2_cout;\nwire [3:0] csa_slice3_cout;\nwire [3:0] rca1_sum;\nwire [3:0] rca2_sum;\nwire [3:0] rca3_sum;\nwire [3:0] rca1_cout;\nwire [3:0] rca2_cout;\nwire [3:0] rca3_cout;\n\nwire [3:0] csa_slice1_cout_mux;\nwire [3:0] csa_slice2_cout_mux;\nwire [3:0] csa_slice3_cout_mux;\n\nassign rca1_sum = a[3:0] + b[3:0] + cin;\nassign rca1_cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\nassign rca2_sum = a[7:4] + b[7:4] + rca1_cout;\nassign rca2_cout = (a[7] & b[7]) | (a[7] & rca1_cout) | (b[7] & rca1_cout);\n\nassign rca3_sum = a[11:8] + b[11:8] + rca2_cout;\nassign rca3_cout = (a[11] & b[11]) | (a[11] & rca2_cout) | (b[11] & rca2_cout);\n\nassign csa_slice1_sum = {rca1_sum[3], rca1_sum[2], rca1_sum[1], rca1_sum[0]};\nassign csa_slice2_sum = {rca2_sum[3], rca2_sum[2], rca2_sum[1], rca2_sum[0]};\nassign csa_slice3_sum = {rca3_sum[3], rca3_sum[2], rca3_sum[1], rca3_sum[0]};\n\nassign csa_slice1_cout_mux = (rca1_cout & a[3]) | (rca1_cout & b[3]) | (rca1_cout & cin);\nassign csa_slice2_cout_mux = (rca2_cout & a[7]) | (rca2_cout & b[7]) | (rca2_cout & rca1_cout);\nassign csa_slice3_cout_mux = (rca3_cout & a[11]) | (rca3_cout & b[11]) | (rca3_cout & rca2_cout);\n\nassign csa_slice1_cout = csa_slice1_cout_mux[0] | csa_slice1_cout_mux[1] | csa_slice1_cout_mux[2] | csa_slice1_cout_mux[3];\nassign csa_slice2_cout = csa_slice2_cout_mux[0] | csa_slice2_cout_mux[1] | csa_slice2_cout_mux[2] | csa_slice2_cout_mux[3];\nassign csa_slice3_cout = csa_slice3_cout_mux[0] | csa_slice3_cout_mux[1] | csa_slice3_cout_mux[2] | csa_slice3_cout_mux[3];\n\nassign sum = {csa_slice3_sum, csa_slice2_sum, csa_slice1_sum};\nassign cout = csa_slice3_cout | csa_slice2_cout | csa_slice1_cout;\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_8bit adder_8bit_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] y0, y1, y2, y3;\n    wire Co0, Co1, Co2, Co3;\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_4bit adder_4bit_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [1:0] y0, y1;\n    wire Co0, Co1;\n\n    // 2-bit adder\n    adder_2bit adder_2bit_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    adder_2bit adder_2bit_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n\n    assign y = {y1, y0};\n    assign Co = Co1;\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    wire [0:0] y0;\n    wire Co0;\n\n    // 1-bit adder\n    adder_1bit adder_1bit_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n\n    assign y = {y0};\n    assign Co = Co0;\nendmodule\n\nmodule adder_1bit (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // First full adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout)\n    );\n    \n    // Second full adder\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout)\n    );\n    \n    // Third full adder\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout)\n    );\n    \n    // Fourth full adder\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout)\n    );\n    \n    // Fifth full adder\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout)\n    );\n    \n    // Sixth full adder\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout)\n    );\n    \n    // Seventh full adder\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout)\n    );\n    \n    // Eighth full adder\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout)\n    );\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout;\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'd0;\n        product <= 32'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'd0;\n            product <= 32'd0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'd15) begin\n                shift_cnt <= 4'd0;\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1'b1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] a_shift;\nreg [15:0] b_shift;\nreg [31:0] product_shift;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_shift <= 16'd0;\n        b_shift <= 16'd0;\n        product_shift <= 32'd0;\n    end else begin\n        if (shift_cnt == 4'd0) begin\n            a_shift <= a_reg;\n            b_shift <= b_reg;\n            product_shift <= 32'd0;\n        end else begin\n            a_shift <= {a_shift[14:0], 1'b0};\n            b_shift <= {b_shift[14:0], b_shift[15]};\n            product_shift <= product_shift + (b_shift & {16{a_shift[shift_cnt-1]}});\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product_shift;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_count;\n    wire [15:0] u_counter_register_count;\n\n    // counter_logic\n    submodule u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(u_counter_logic_count)\n    );\n\n    // counter_register\n    submodule u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(u_counter_register_count)\n    );\n\n    assign count = u_counter_register_count;\n\nendmodule\n\n// counter_logic\nsubmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendsubmodule\n\n// counter_register\nsubmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    output wire [15:0] count\n);\n\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 16'b0;\n        end else begin\n            count_reg <= count_reg;\n        end\n    end\n\n    assign count = count_reg;\n\nendsubmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    // Initialize the counter to its starting state\n    // out = 8'b0000_0001\n    wire [7:0] init_out;\n    assign init_out = 8'b0000_0001;\n\n    // Submodule: Transition\n    // Cyclic state transition\n    reg [7:0] transition_out;\n    always @(posedge clk) begin\n        if (reset) begin\n            transition_out <= init_out;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\n    else\n        count_r <= 4'b0000;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\n    else\n        out_r <= out_r;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule: JC_register\n// Register module for the Johnson Counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule\n\n// Submodule: JC_logic\n// Logic module for the Johnson Counter\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\nalways @(*) begin\n    Q_next = Q;\n    Q_next[0] = Q[63];\nend\n\nendmodule\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nreg [2:0] clk_div_2_cnt = 0;\nreg [2:0] clk_div_10_cnt = 0;\nreg [2:0] clk_div_100_cnt = 0;\n\nreg CLK_50_reg = 0;\nreg CLK_10_reg = 0;\nreg CLK_1_reg = 0;\n\nwire clk_div_2_out = (clk_div_2_cnt == 2'b111);\nwire clk_div_10_out = (clk_div_10_cnt == 2'b111);\nwire clk_div_100_out = (clk_div_100_cnt == 2'b111);\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_div_2_cnt <= 0;\n        clk_div_10_cnt <= 0;\n        clk_div_100_cnt <= 0;\n        CLK_50_reg <= 0;\n        CLK_10_reg <= 0;\n        CLK_1_reg <= 0;\n    end else begin\n        if (clk_div_2_out) begin\n            clk_div_2_cnt <= 0;\n            CLK_50_reg <= ~CLK_50_reg;\n        end else begin\n            clk_div_2_cnt <= clk_div_2_cnt + 1;\n        end\n\n        if (clk_div_10_out) begin\n            clk_div_10_cnt <= 0;\n            CLK_10_reg <= ~CLK_10_reg;\n        end else begin\n            clk_div_10_cnt <= clk_div_10_cnt + 1;\n        end\n\n        if (clk_div_100_out) begin\n            clk_div_100_cnt <= 0;\n            CLK_1_reg <= ~CLK_1_reg;\n        end else begin\n            clk_div_100_cnt <= clk_div_100_cnt + 1;\n        end\n    end\nend\n\nassign CLK_50 = CLK_50_reg;\nassign CLK_10 = CLK_10_reg;\nassign CLK_1 = CLK_1_reg;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [1:0] cnt = 0;\nreg CLK_out_reg = 0;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        cnt <= 0;\n        CLK_out_reg <= 0;\n    end else begin\n        if (cnt == 2'b11) begin\n            cnt <= 0;\n            CLK_out_reg <= ~CLK_out_reg;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\nreg [2:0] cnt = 0;\nreg CLK_out_reg = 0;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        cnt <= 0;\n        CLK_out_reg <= 0;\n    end else begin\n        if (cnt == 3'b111) begin\n            cnt <= 0;\n            CLK_out_reg <= ~CLK_out_reg;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nend\n\nassign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_4;\nwire clk_div_3;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK-1:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= {(MUL2_DIV_CLK){1'b0}};\n    else if (counter == {(MUL2_DIV_CLK){1'b1}})\n        counter <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        counter <= counter + 1'b1;\nend\n\n// Clock Average Generator Submodule\nreg [MUL2_DIV_CLK-1:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        clk_average <= counter;\nend\n\n// Clock Adjustment Submodule\nreg [MUL2_DIV_CLK-1:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= {(MUL2_DIV_CLK){1'b0}};\n    else\n        clk_adjustment <= counter;\nend\n\n// Output Clock Signal\nassign clk_div_4 = clk_average[MUL2_DIV_CLK-1] | clk_average[MUL2_DIV_CLK-2];\nassign clk_div_3 = clk_adjustment[MUL2_DIV_CLK-1] | clk_adjustment[MUL2_DIV_CLK-2] | clk_adjustment[MUL2_DIV_CLK-3];\nassign clk_div = clk_div_4 | clk_div_3;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == NUM_DIV / 2 - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nparameter NUM_DIV = 2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (q == NUM_DIV / 2 - 1)\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input counter_reset,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter_reset)\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n    \n    assign r = aluc[5:0] == 6'b000000 ? sllv_r :\n               aluc[5:0] == 6'b000010 ? srlv_r :\n               aluc[5:0] == 6'b000011 ? srav_r :\n               aluc[5:0] == 6'b000100 ? sll_r :\n               aluc[5:0] == 6'b000110 ? srl_r :\n               aluc[5:0] == 6'b000111 ? sra_r :\n               aluc[5:0] == 6'b001000 ? add_r :\n               aluc[5:0] == 6'b001001 ? addu_r :\n               aluc[5:0] == 6'b001010 ? sub_r :\n               aluc[5:0] == 6'b001011 ? subu_r :\n               aluc[5:0] == 6'b001100 ? and_r :\n               aluc[5:0] == 6'b001101 ? or_r :\n               aluc[5:0] == 6'b001110 ? xor_r :\n               aluc[5:0] == 6'b001111 ? nor_r :\n               aluc[5:0] == 6'b010000 ? slt_r :\n               aluc[5:0] == 6'b010001 ? sltu_r :\n               aluc[5:0] == 6'b010010 ? lui_r : 32'b0;\n    \n    assign zero = aluc[5:0] == 6'b000000 ? sllv_zero :\n                  aluc[5:0] == 6'b000010 ? srlv_zero :\n                  aluc[5:0] == 6'b000011 ? srav_zero :\n                  aluc[5:0] == 6'b"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [63:0] mult_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] mult_result;\nassign mult_result = a * b;\n\n// Accumulator Submodule\nreg [31:0] current_value;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + mult_result[31:0];\n    end\nend\n\n// Output\nassign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] c\n);\n\nassign c = a * b;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output [31:0] c\n);\n\nreg [31:0] current_value;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value <= 0;\n    end else begin\n        current_value <= current_value + mult_result[31:0];\n    end\nend\n\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    assign ins = ins_p1 | ins_p2;\n    assign ad1 = ad1_p1 | ad1_p2;\n    assign ad2 = ad2_p1 | ad2_p2;\n\n    // ins_p1\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1 <= 3'b0;\n            ad1_p1 <= 5'b0;\n            ad2_p1 <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1 <= data[7:5];\n            ad1_p1 <= data[4:0];\n            ad2_p1 <= 8'b0;\n        end\n    end\n\n    // ins_p2\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2 <= 3'b0;\n            ad1_p2 <= 5'b0;\n            ad2_p2 <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data[7:5];\n            ad1_p2 <= data[4:0];\n            ad2_p2 <= data;\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\n// Counter Module\nwire [7:0] next_count;\nreg [7:0] current_count;\n\nassign count = current_count;\nassign next_count = (current_count == (freq - 1)) ? 0 : current_count + 1;\nassign enable = (freq != 0);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        current_count <= next_count;\n    end\nend\n\n// Wave Generator Module\nwire [7:0] next_wave_out;\nreg [7:0] current_wave_out;\n\nassign wave_out = current_wave_out;\nassign next_wave_out = (count == (freq - 1)) ? 1 : 0;\n\nalways @(posedge clk) begin\n    current_wave_out <= next_wave_out;\nend\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                end\n            endcase\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                end\n                default: begin\n                    wave_reg <= 5'b00000;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    wire [7:0] u0_q, u1_q, u2_q;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(u0_q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(u0_q),\n        .q(u1_q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(u1_q),\n        .q(u2_q)\n    );\n\n    assign q = sel[0] ? u2_q : u1_q;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    wire [7:0] mux3_out;\n\n    wire [7:0] mux4_out;\n    wire [7:0] mux5_out;\n    wire [7:0] mux6_out;\n\n    wire [7:0] mux7_out;\n    wire [7:0] mux8_out;\n    wire [7:0] mux9_out;\n\n    wire [7:0] mux10_out;\n    wire [7:0] mux11_out;\n    wire [7:0] mux12_out;\n\n    wire [7:0] mux13_out;\n    wire [7:0] mux14_out;\n    wire [7:0] mux15_out;\n\n    wire [7:0] mux16_out;\n    wire [7:0] mux17_out;\n    wire [7:0] mux18_out;\n\n    wire [7:0] mux19_out;\n    wire [7:0] mux20_out;\n    wire [7:0] mux21_out;\n\n    wire [7:0] mux22_out;\n    wire [7:0] mux23_out;\n    wire [7:0] mux24_out;\n\n    wire [7:0] mux25_out;\n    wire [7:0] mux26_out;\n    wire [7:0] mux27_out;\n\n    wire [7:0] mux28_out;\n    wire [7:0] mux29_out;\n    wire [7:0] mux30_out;\n\n    wire [7:0] mux31_out;\n    wire [7:0] mux32_out;\n    wire [7:0] mux33_out;\n\n    wire [7:0] mux34_out;\n    wire [7:0] mux35_out;\n    wire [7:0] mux36_out;\n\n    wire [7:0] mux37_out;\n    wire [7:0] mux38_out;\n    wire [7:0] mux39_out;\n\n    wire [7:0] mux40_out;\n    wire [7:0] mux41_out;\n    wire [7:0] mux42_out;\n\n    wire [7:0] mux43_out;\n    wire [7:0] mux44_out;\n    wire [7:0] mux45_out;\n\n    wire [7:0] mux46_out;\n    wire [7:0] mux47_out;\n    wire [7:0] mux48_out;\n\n    wire [7:0] mux49_out;\n    wire [7:0] mux50_out;\n    wire [7:0] mux51_out;\n\n    wire [7:0] mux52_out;\n    wire [7:0] mux53_out;\n    wire [7:0] mux54_out;\n\n    wire [7:0] mux55_out;\n    wire [7:0] mux56_out;\n    wire [7:0] mux57_out;\n\n    wire [7:0] mux58_out;\n    wire [7:0] mux59_out;\n    wire [7:0] mux60_out;\n\n    wire [7:0] mux61_out;\n    wire [7:0] mux62_out;\n    wire [7:0] mux6"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  reg [31:0] pc_next;\n  reg [31:0] res_reg_file_next [0:31];\n  wire [31:0] alu_res;\n  wire [31:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  stagepipe5_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .pc_next(pc_next),\n    .alu_res(alu_res)\n  );\n\n  stagepipe5_decode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  stagepipe5_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .alu_res(alu_res)\n  );\n\n  stagepipe5_memory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file_next(res_reg_file_next)\n  );\n\n  stagepipe5_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file_next(res_reg_file_next),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign pc = 0;\n\nendmodule\n\nmodule stagepipe5_fetch (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] pc_next,\n  output [31:0] alu_res\n);\n  reg [31:0] alu_res_reg;\n  reg [31:0] pc_reg;\n  reg [31:0] pc_next_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res_reg <= 0;\n      pc_reg <= 0;\n      pc_next_reg <= 0;\n    end else begin\n      alu_res_reg <= instr_mem[pc];\n      pc_reg <= pc;\n      pc_next_reg <= pc + 1;\n    end\n  end\n\n  assign alu_res = alu_res_reg;\n  assign pc_next = pc_next_reg;\n\nendmodule\n\nmodule stagepipe5_decode (\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output [31:0] rs1,\n  output [31:0] rs2,\n  output [31:0] rd,\n  output [5:0] op\n);\n  reg [31:0] rs1_reg;\n  reg [31:0] rs2_reg;\n  reg [31:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= alu_res[31:27];\n      rs2_reg <= alu_res[26:22];\n      rd_reg <= alu_res[21:17];\n      op_reg <= alu_res[16:12];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [15:0] b1, b2, b3;\n  wire [31:0] c0_next, c1_next, c2_next, c3_next;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  assign c0_next = c0_reg + (a0 * b0);\n  assign c1_next = c1_reg + (a1 * b1);\n  assign c2_next = c2_reg + (a2 * b2);\n  assign c3_next = c3_reg + (a3 * b3);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n      b3_reg <= b3;\n      c0_reg <= c0_next;\n      c1_reg <= c1_next;\n      c2_reg <= c2_next;\n      c3_reg <= c3_next;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [4:0] rs;\n    wire [4:0] rt;\n    wire [4:0] rd;\n    wire [5:0] op;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] out_reg_file_tmp;\n\n    assign out_reg_file = out_reg_file_tmp;\n\n    // Fetch stage\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr(instr)\n    );\n\n    // Execute stage\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .reg_file(reg_file),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    // Writeback stage\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file_tmp)\n    );\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] pc,\n    output [31:0] instr\n);\n\n    reg [31:0] pc_reg;\n    reg [31:0] instr_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc_reg <= 32'b0;\n            instr_reg <= 32'b0;\n        end else begin\n            pc_reg <= pc_reg + 1;\n            instr_reg <= instr_mem[pc_reg];\n        end\n    end\n\n    assign pc = pc_reg;\n    assign instr = instr_reg;\n\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n\n    reg [31:0] op1_reg;\n    reg [31:0] op2_reg;\n    reg [31:0] result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1_reg <= 32'b0;\n            op2_reg <= 32'b0;\n            result_reg <= 32'b0;\n        end else begin\n            op1_reg <= reg_file[instr[25:21]];\n            op2_reg <= reg_file[instr[20:16]];\n            case (instr[5:0])\n                6'b000000: result_reg <= op1_reg + op2_reg;\n                6'b000010: result_reg <= op1_reg - op2_reg;\n                default: result_reg <= 32'b0;\n            endcase\n        end\n    end\n\n    assign op1 = op1_reg;\n    assign op2 = op2_reg;\n    assign result = result_reg;\n\nendmodule\n\nmodule stagepipe3_writeback (\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:3"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt <= cnt + 3'd1;\n            if (cnt == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\nend\n\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg             valid_out_r;\nreg     [2:0]   cnt_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt_r <= cnt_r + 3'd1;\n            if (cnt_r == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign cnt = cnt_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output      [2:0]   cnt\n);\n\nreg     [2:0]   cnt_r;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_r <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt_r <= cnt_r + 3'd1;\n            if (cnt_r == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [3:0] counter;\n    reg [7:0] shift_reg [0:3];\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 0;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 0;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg[0] <= 0;\n            shift_reg[1] <= 0;\n            shift_reg[2] <= 0;\n            shift_reg[3] <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (opn_valid) begin\n            counter <= 0;\n            shift_reg[0] <= abs_dividend;\n            shift_reg[1] <= shift_reg[0];\n            shift_reg[2] <= shift_reg[1];\n            shift_reg[3] <= shift_reg[2];\n            quotient <= 0;\n            remainder <= 0;\n        end else if (counter < 4) begin\n            counter <= counter + 1;\n            shift_reg[counter] <= shift_reg[counter] >> 1;\n            quotient <= quotient << 1;\n            remainder <= remainder << 1;\n            if (shift_reg[counter] >= neg_divisor) begin\n                shift_reg[counter] <= shift_reg[counter] - neg_divisor;\n                quotient <= quotient + 1;\n            end\n            remainder <= remainder | shift_reg[counter][0];\n        end else if (counter == 4) begin\n            res_valid <= 1;\n        end\n    end\n\n    // Result Management\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end else if (res_valid) begin\n            if (sign) begin\n                result <= -remainder;\n            end else begin\n                result <= remainder;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor  // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A, 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder // 32-bit remainder\n);\n\n    // Divide dividend by divisor\n    assign quotient = dividend / divisor;\n    assign remainder = dividend % divisor;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_q;\n    wire [7:0] temp_r;\n    wire [15:0] temp_dividend;\n    wire [7:0] temp_divisor;\n    wire [15:0] temp_shifted_dividend;\n    wire [7:0] temp_shifted_divisor;\n    wire [15:0] temp_remainder;\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_odd;\n    wire [15:0] temp_odd_shifted;\n    wire [15:0] temp_odd_shifted_remainder;\n    wire [15:0] temp_odd_shifted_quotient;\n\n    assign result = temp_quotient;\n    assign odd = temp_odd;\n\n    // Control unit\n    always @(*) begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_shifted_dividend = temp_dividend;\n        temp_shifted_divisor = temp_divisor;\n        temp_remainder = 16'b0;\n        temp_quotient = 16'b0;\n        temp_odd = 16'b0;\n        temp_odd_shifted = 16'b0;\n        temp_odd_shifted_remainder = 16'b0;\n        temp_odd_shifted_quotient = 16'b0;\n\n        while (temp_shifted_dividend[15:8] != 0) begin\n            if (temp_shifted_dividend[15:8] >= temp_shifted_divisor) begin\n                temp_shifted_dividend = temp_shifted_dividend - temp_shifted_divisor;\n                temp_shifted_divisor = temp_divisor;\n                temp_odd_shifted = temp_odd_shifted | temp_shifted_dividend[15];\n                temp_odd_shifted_remainder = temp_odd_shifted_remainder | temp_shifted_dividend[15];\n                temp_odd_shifted_quotient = temp_odd_shifted_quotient | temp_shifted_dividend[15];\n            end\n            temp_shifted_dividend = temp_shifted_dividend << 1;\n            temp_shifted_divisor = temp_divisor << 1;\n        end\n\n        temp_remainder = temp_shifted_dividend;\n        temp_quotient = temp_odd_shifted_quotient;\n        temp_odd = temp_odd_shifted_remainder;\n    end\n\nendmodule\n"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {B_out, sum} = A + B_comp;\nassign D = sum;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire [3:1] B_out1, B_out2, B_out3, B_out4;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\n\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign D1 = A1 - B1;\nassign D2 = A2 - B2;\nassign D3 = A3 - B3;\nassign D4 = A4 - B4;\n\nassign B_out1 = (D1[3] == 1) ? 1 : 0;\nassign B_out2 = (D2[3] == 1) ? 1 : 0;\nassign B_out3 = (D3[3] == 1) ? 1 : 0;\nassign B_out4 = (D4[3] == 1) ? 1 : 0;\n\nassign D = {D4, D3, D2, D1};\nassign B_out = (B_out4 == 1) ? 1 : 0;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\n// Subtractor Module\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .carry(carry)\n);\n\n// Comparison Logic\nassign A_greater = (sub_result == 32'b0);\nassign A_equal = (sub_result == 32'b0) && (carry == 1'b0);\nassign A_less = (sub_result != 32'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output carry       // Carry output\n);\n\nassign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16[3:1];\nwire [32:1] S16[3:1];\n\ncla CLA1(.A(A[32:16]),.B(B[32:16]),.S(S16[1]),.C32(C16[1]));\ncla CLA2(.A(A[15:1]),.B(B[15:1]),.S(S16[2]),.C32(C16[2]));\ncla CLA3(.A(A[14:0]),.B(B[14:0]),.S(S16[3]),.C32(C16[3]));\n\nassign S = {S16[3],S16[2],S16[1],S16[1]};\nassign C32 = C16[3];\n\nendmodule\n\nmodule cla(A,B,S,C32);\ninput [15:1] A,B;\noutput [15:1] S;\noutput C32;\n\nwire [7:1] C8[3:1];\nwire [15:1] S8[3:1];\n\ncla1 CLA1(.A(A[15:8]),.B(B[15:8]),.S(S8[1]),.C8(C8[1]));\ncla1 CLA2(.A(A[7:0]),.B(B[7:0]),.S(S8[2]),.C8(C8[2]));\ncla1 CLA3(.A(A[6:0]),.B(B[6:0]),.S(S8[3]),.C8(C8[3]));\n\nassign S = {S8[3],S8[2],S8[1],S8[1]};\nassign C32 = C8[3];\n\nendmodule\n\nmodule cla1(A,B,S,C8);\ninput [7:1] A,B;\noutput [7:1] S;\noutput C8;\n\nwire [3:1] C4[3:1];\nwire [7:1] S4[3:1];\n\ncla2 CLA1(.A(A[7:4]),.B(B[7:4]),.S(S4[1]),.C4(C4[1]));\ncla2 CLA2(.A(A[3:0]),.B(B[3:0]),.S(S4[2]),.C4(C4[2]));\ncla2 CLA3(.A(A[2:0]),.B(B[2:0]),.S(S4[3]),.C4(C4[3]));\n\nassign S = {S4[3],S4[2],S4[1],S4[1]};\nassign C8 = C4[3];\n\nendmodule\n\nmodule cla2(A,B,S,C4);\ninput [3:1] A,B;\noutput [3:1] S;\noutput C4;\n\nwire [1:1] C2[3:1];\nwire [3:1] S2[3:1];\n\ncla3 CLA1(.A(A[3:2]),.B(B[3:2]),.S(S2[1]),.C2(C2[1]));\ncla3 CLA2(.A(A[1:0]),.B(B[1:0]),.S(S2[2]),.C2(C2[2]));\ncla3 CLA3(.A(A[0:0]),.B(B[0:0]),.S(S2[3]),.C2(C2[3]));\n\nassign S = {S2[3],S2[2],S2[1],S2[1]};\nassign C4 = C2[3];\n\nendmodule\n\nmodule cla3(A,B,S,C2);\ninput [1:1] A,B;\noutput [1:1] S;\noutput C2;\n\nwire [1:1] C1[3:1];\nwire"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit ripple carry adder\nwire [3:0] a_slices, b_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign {carry[0], sum_slices[0]} = a_slices + b_slices + cin;\nassign {carry[1], sum_slices[1]} = a[7:4] + b[7:4] + carry[0];\nassign {carry[2], sum_slices[2]} = a[11:8] + b[11:8] + carry[1];\nassign {carry[3], sum_slices[3]} = a[15:12] + b[15:12] + carry[2];\n\n// 4-bit carry select adder\nwire [3:0] sum_slices_mux;\nassign sum_slices_mux[0] = sum_slices[0];\nassign sum_slices_mux[1] = sum_slices[1] ^ {2'b00, carry[0]};\nassign sum_slices_mux[2] = sum_slices[2] ^ {2'b00, carry[1]};\nassign sum_slices_mux[3] = sum_slices[3] ^ {2'b00, carry[2]};\n\nassign sum = {sum_slices_mux[3], sum_slices_mux[2], sum_slices_mux[1], sum_slices_mux[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit ripple carry adder\nwire [3:0] a_slices, b_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign {carry[0], sum_slices[0]} = a_slices + b_slices + cin;\nassign {carry[1], sum_slices[1]} = a[7:4] + b[7:4] + carry[0];\nassign {carry[2], sum_slices[2]} = a[11:8] + b[11:8] + carry[1];\nassign {carry[3], sum_slices[3]} = a[15:12] + b[15:12] + carry[2];\n\n// 4-bit carry select adder\nwire [3:0] sum_slices_mux;\nassign sum_slices_mux[0] = sum_slices[0];\nassign sum_slices_mux[1] = sum_slices[1] ^ {2'b00, carry[0]};\nassign sum_slices_mux[2] = sum_slices[2] ^ {2'b00, carry[1]};\nassign sum_slices_mux[3] = sum_slices[3] ^ {2'b00, carry[2]};\n\nassign sum = {sum_slices_mux[3], sum_slices_mux[2], sum_slices_mux[1], sum_slices_mux[0]};\nassign cout = carry[3];\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] a0, b0, y0, c0;\n    wire [7:0] a1, b1, y1, c1;\n    wire [7:0] a2, b2, y2, c2;\n    wire [7:0] a3, b3, y3, c3;\n    wire [7:0] a4, b4, y4, c4;\n    wire [7:0] a5, b5, y5, c5;\n    wire [7:0] a6, b6, y6, c6;\n    wire [7:0] a7, b7, y7, c7;\n    wire [7:0] a8, b8, y8, c8;\n    wire [7:0] a9, b9, y9, c9;\n    wire [7:0] a10, b10, y10, c10;\n    wire [7:0] a11, b11, y11, c11;\n    wire [7:0] a12, b12, y12, c12;\n    wire [7:0] a13, b13, y13, c13;\n    wire [7:0] a14, b14, y14, c14;\n    wire [7:0] a15, b15, y15, c15;\n\n    // 8-bit adder\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(Cin), .y(y0), .Co(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(c0), .y(y1), .Co(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(c1), .y(y2), .Co(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(c2), .y(y3), .Co(c3));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(c3), .y(y4), .Co(c4));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(c4), .y(y5), .Co(c5));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(c5), .y(y6), .Co(c6));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(c6), .y(y7), .Co(c7));\n    full_adder fa8 (.a(a[8]), .b(b[8]), .Cin(c7), .y(y8), .Co(c8));\n    full_adder fa9 (.a(a[9]), .b(b[9]), .Cin(c8), .y(y9), .Co(c9));\n    full_adder fa10 (.a(a[10]), .b(b[10]), .Cin(c9), .y(y10), .Co(c10));\n    full_adder fa11 (.a(a[11]), .b(b[11]), .Cin(c10), .y(y11), .Co(c11));\n    full_adder fa12 (.a(a[12]), .b(b[12]), .Cin(c11), .y(y12), .Co(c12));\n    full_adder fa13 (.a(a[13]), .b(b[13]), .Cin(c12), .y(y13), .Co(c13));\n    full_adder fa14 (.a(a[14]), .b(b[14]), .Cin(c13), .y(y14), .Co(c14));\n    full_adder fa15 (.a(a[15]), .b(b[15]), ."}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire [6:0] fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // First bit-level adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout[0])\n    );\n    \n    // Second bit-level adder\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout[0]),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout[1])\n    );\n    \n    // Third bit-level adder\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout[1]),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout[2])\n    );\n    \n    // Fourth bit-level adder\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout[2]),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout[3])\n    );\n    \n    // Fifth bit-level adder\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout[3]),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout[4])\n    );\n    \n    // Sixth bit-level adder\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout[4]),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout[5])\n    );\n    \n    // Seventh bit-level adder\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout[5]),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout[6])\n    );\n    \n    // Eighth bit-level adder\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout[6]),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout[7])\n    );\n    \n    // Carry-out\n    assign cout = fa7_cout[7];\n    \n    // Sum\n    assign sum = fa0_sum + fa1_sum + fa2_sum + fa3_sum + fa4_sum + fa5_sum + fa6_sum + fa7_sum;\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_count == 4'b1111) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_count <= shift_count + 1;\n                product <= product + (bin << shift_count);\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] reg_a;\nreg [15:0] reg_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 16'b0;\n        reg_b <= 16'b0;\n    end else begin\n        if (start) begin\n            reg_a <= ain;\n            reg_b <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] shifted_b;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shifted_b <= 16'b0;\n    end else begin\n        if (shift_count == 4'b0000) begin\n            shifted_b <= reg_b;\n        end else begin\n            shifted_b <= reg_b << shift_count;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n/*\n * Submodule: u_counter_logic\n */\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    assign next_count = up_down ? count + 1 : count - 1;\n\nendmodule\n\n/*\n * Submodule: u_counter_register\n */\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule\n\nendmodule\n--------------------------------------------------------------------------------\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\nwire [15:0] next_count;\n\nu_counter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down),\n    .next_count(next_count)\n);\n\nu_counter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count(count)\n);\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // State Initialization\n    // Initialize the counter to its starting state\n    initial begin\n        out = 8'b0000_0001;\n    end\n\n    // State Transition\n    // Cyclically shift the bits of the counter\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule\n\n// Submodule: State Initialization\n// Initialize the counter to its starting state\nmodule ring_counter_init (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\n\nendmodule\n\n// Submodule: State Transition\n// Cyclically shift the bits of the counter\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\nreg [3:0] count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else\n        count_r <= count_next;\nend\n\nassign count = count_r;\n\nalways @(*) begin\n    if (valid_count)\n        count_next = count + 1;\n    else\n        count_next = count;\nend\n\nassign out = (count == 4'd11) ? 4'b0000 : count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\nreg [3:0] count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else\n        count_r <= count_next;\nend\n\nassign count = count_r;\n\nalways @(*) begin\n    if (valid_count)\n        count_next = count_r + 1;\n    else\n        count_next = count_r;\nend\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\nreg [3:0] out_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else\n        out_r <= out_next;\nend\n\nassign out = out_r;\n\nalways @(*) begin\n    if (valid_count)\n        out_next = count;\n    else\n        out_next = out_r;\nend\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Submodule: JC_register\n// Register module for the Johnson Counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule\n\n// Submodule: JC_logic\n// Logic module for the Johnson Counter\nmodule JC_logic(\n    input [63:0]         Q,\n    output reg [63:0]    Q_next\n);\n\nalways @(*) begin\n    Q_next = Q;\n    Q_next[0] = Q[63];\nend\n\nendmodule\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg CLK_50_r;\n    reg CLK_10_r;\n    reg CLK_1_r;\n    reg [1:0] count_50;\n    reg [1:0] count_10;\n    reg [1:0] count_1;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_50_r <= 0;\n            CLK_10_r <= 0;\n            CLK_1_r <= 0;\n            count_50 <= 0;\n            count_10 <= 0;\n            count_1 <= 0;\n        end else begin\n            CLK_50_r <= ~CLK_50_r;\n            CLK_10_r <= ~CLK_10_r;\n            CLK_1_r <= ~CLK_1_r;\n            if (count_50 == 2) begin\n                count_50 <= 0;\n                CLK_50_r <= ~CLK_50_r;\n            end else begin\n                count_50 <= count_50 + 1;\n            end\n            if (count_10 == 4) begin\n                count_10 <= 0;\n                CLK_10_r <= ~CLK_10_r;\n            end else begin\n                count_10 <= count_10 + 1;\n            end\n            if (count_1 == 49) begin\n                count_1 <= 0;\n                CLK_1_r <= ~CLK_1_r;\n            end else begin\n                count_1 <= count_1 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = CLK_50_r;\n    assign CLK_10 = CLK_10_r;\n    assign CLK_1 = CLK_1_r;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            CLK_out_r <= ~CLK_out_r;\n            if (count == 1) begin\n                count <= 0;\n                CLK_out_r <= ~CLK_out_r;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            CLK_out_r <= ~CLK_out_r;\n            if (count == 4) begin\n                count <= 0;\n                CLK_out_r <= ~CLK_out_r;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_r;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_r;\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_r <= 0;\n            count <= 0;\n        end else begin\n            CLK_out_r <= ~CLK_out_r;\n            if (count == 49) begin\n                count <= 0;\n                CLK_out_r"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == MUL2_DIV_CLK - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else begin\n        clk_average[0] <= counter[0];\n        clk_average[1] <= counter[1];\n        clk_average[2] <= counter[2];\n        clk_average[3] <= counter[3];\n    end\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= 0;\n    else begin\n        clk_adjustment[0] <= counter[0];\n        clk_adjustment[1] <= counter[1];\n        clk_adjustment[2] <= counter[2];\n        clk_adjustment[3] <= counter[3];\n    end\nend\n\n// Output\nassign clk_div = clk_div_int[0] | clk_div_int[1] | clk_div_int[2] | clk_div_int[3];\n\n// Intermediate Clock Signals\nassign clk_div_int[0] = clk_average[0] | clk_adjustment[0];\nassign clk_div_int[1] = clk_average[1] | clk_adjustment[1];\nassign clk_div_int[2] = clk_average[2] | clk_adjustment[2];\nassign clk_div_int[3] = clk_average[3] | clk_adjustment[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   counter\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == MUL2_DIV_CLK - 1)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [3:0]         counter,\n    output reg  [3:0]   clk_average\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else begin\n        clk_average[0] <= counter[0];\n        clk_average[1] <= counter[1];\n        clk_average[2] <= counter[2];\n        clk_average[3] <= counter[3];\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [3:0]         counter,\n    output reg  [3:0]   clk_adjustment\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= 0;\n    else begin\n        clk_adjustment[0] <= counter[0];\n        clk_adjustment[1] <= counter"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter = 0;\nreg [3:0] neg_counter = 0;\nreg clk_div1 = 0;\nreg clk_div2 = 0;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        neg_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else if (pos_counter < NUM_DIV - 1) begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end else begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter < NUM_DIV - 1) begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end else begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        q <= 0;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nreg [3:0] q;\n\nendmodule\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_r;\nwire [31:0] sub_r;\nwire [31:0] and_r;\nwire [31:0] or_r;\nwire [31:0] xor_r;\nwire [31:0] nor_r;\nwire [31:0] slt_r;\nwire [31:0] sltu_r;\nwire [31:0] sll_r;\nwire [31:0] srl_r;\nwire [31:0] sra_r;\nwire [31:0] sllv_r;\nwire [31:0] srlv_r;\nwire [31:0] srav_r;\nwire [31:0] lui_r;\n\nwire [31:0] add_zero;\nwire [31:0] sub_zero;\nwire [31:0] and_zero;\nwire [31:0] or_zero;\nwire [31:0] xor_zero;\nwire [31:0] nor_zero;\nwire [31:0] slt_zero;\nwire [31:0] sltu_zero;\nwire [31:0] sll_zero;\nwire [31:0] srl_zero;\nwire [31:0] sra_zero;\nwire [31:0] sllv_zero;\nwire [31:0] srlv_zero;\nwire [31:0] srav_zero;\nwire [31:0] lui_zero;\n\nwire [31:0] add_carry;\nwire [31:0] sub_carry;\nwire [31:0] and_carry;\nwire [31:0] or_carry;\nwire [31:0] xor_carry;\nwire [31:0] nor_carry;\nwire [31:0] slt_carry;\nwire [31:0] sltu_carry;\nwire [31:0] sll_carry;\nwire [31:0] srl_carry;\nwire [31:0] sra_carry;\nwire [31:0] sllv_carry;\nwire [31:0] srlv_carry;\nwire [31:0] srav_carry;\nwire [31:0] lui_carry;\n\nwire [31:0] add_negative;\nwire [31:0] sub_negative;\nwire [31:0] and_negative;\nwire [31:0] or_negative;\nwire [31:0] xor_negative;\nwire [31:0] nor_negative;\nwire [31:0] slt_negative;\nwire [31:0] sltu_negative;\nwire [31:0] sll_negative;\nwire [31:0] srl_negative;\nwire [31:0] sra_negative;\nwire [31:0] sllv_negative;\nwire [31:0] srlv_negative;\nwire [31:0] srav_negative;\nwire [31:0] lui_negative;\n\nwire [31:0] add_overflow;\nwire [31:0] sub_overflow;\nwire [31:0] and_overflow;\nwire [31:0] or_overflow;\nwire [31:0] xor_overflow;\nwire [31:0] nor_overflow;\nwire [31:0] slt_overflow;\nwire [31:0] sltu_overflow;\nwire [31:0] sll_overflow;\nwire [31:0] srl_overflow;\nwire [31:0] sra_overflow;\nwire [31:0] sllv_overflow;\nwire [31:0] srlv_overflow;\nwire [31:0] srav_overflow;\nwire [31:0] lui_overflow;\n\nwire [31:0] add_flag;\nwire [31:0] sub_flag;\nwire [31:0] and_flag;\nwire [31:0"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] multiplication_result;\nwire [31:0] current_value;\n\n// Multiplier Submodule\nwire [63:0] multiplication_result_64;\nassign multiplication_result_64 = a * b;\nassign multiplication_result = multiplication_result_64[31:0];\n\n// Accumulator Submodule\nreg [31:0] current_value_reg;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_value_reg <= 0;\n    end else begin\n        current_value_reg <= current_value_reg + multiplication_result;\n    end\nend\nassign current_value = current_value_reg;\n\n// Connecting the submodules\nassign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\nwire [7:0] next_count;\n\nassign next_count = (count + 1) % freq;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nend\n\nassign wave_out = (count == 0);\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] shift_reg [2:0];\n\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        q <= shift_reg[sel];\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff_out [2:0];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    assign q = (sel == 2'b00) ? d :\n               (sel == 2'b01) ? dff_out[0] :\n               (sel == 2'b10) ? dff_out[1] :\n               (sel == 2'b11) ? dff_out[2] :\n               8'b0;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux_out;\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    // Stage 1\n    wire [7:0] stage1_mux_out;\n    wire [7:0] stage1_shift_out;\n    wire [7:0] stage1_shift_in;\n    wire [7:0] stage1_shift_ctrl;\n\n    assign stage1_shift_ctrl = {3'b000, ctrl[2:0]};\n    assign stage1_shift_in = in;\n    assign stage1_shift_out = stage1_shift_in << stage1_shift_ctrl;\n    assign stage1_mux_out = (stage1_shift_ctrl[2]) ? stage1_shift_out : in;\n\n    // Stage 2\n    wire [7:0] stage2_mux_out;\n    wire [7:0] stage2_shift_out;\n    wire [7:0] stage2_shift_in;\n    wire [7:0] stage2_shift_ctrl;\n\n    assign stage2_shift_ctrl = {3'b000, ctrl[2:0]};\n    assign stage2_shift_in = stage1_mux_out;\n    assign stage2_shift_out = stage2_shift_in << stage2_shift_ctrl;\n    assign stage2_mux_out = (stage2_shift_ctrl[2]) ? stage2_shift_out : stage1_mux_out;\n\n    // Stage 3\n    wire [7:0] stage3_mux_out;\n    wire [7:0] stage3_shift_out;\n    wire [7:0] stage3_shift_in;\n    wire [7:0] stage3_shift_ctrl;\n\n    assign stage3_shift_ctrl = {3'b000, ctrl[2:0]};\n    assign stage3_shift_in = stage2_mux_out;\n    assign stage3_shift_out = stage3_shift_in << stage3_shift_ctrl;\n    assign stage3_mux_out = (stage3_shift_ctrl[2]) ? stage3_shift_out : stage2_mux_out;\n\n    assign out = stage3_mux_out;\n\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  wire [31:0] alu_res;\n  wire [31:0] next_pc;\n  wire [31:0] next_instr;\n  wire [31:0] next_reg_file [0:31];\n  wire [31:0] next_alu_res;\n  wire [31:0] next_pc_plus_4;\n  wire [31:0] next_pc_plus_8;\n  wire [31:0] next_pc_plus_12;\n  wire [31:0] next_pc_plus_16;\n  wire [31:0] next_pc_plus_20;\n  wire [31:0] next_pc_plus_24;\n  wire [31:0] next_pc_plus_28;\n  wire [31:0] next_pc_plus_32;\n  wire [31:0] next_pc_plus_36;\n  wire [31:0] next_pc_plus_40;\n  wire [31:0] next_pc_plus_44;\n  wire [31:0] next_pc_plus_48;\n  wire [31:0] next_pc_plus_52;\n  wire [31:0] next_pc_plus_56;\n  wire [31:0] next_pc_plus_60;\n  wire [31:0] next_pc_plus_64;\n  wire [31:0] next_pc_plus_68;\n  wire [31:0] next_pc_plus_72;\n  wire [31:0] next_pc_plus_76;\n  wire [31:0] next_pc_plus_80;\n  wire [31:0] next_pc_plus_84;\n  wire [31:0] next_pc_plus_88;\n  wire [31:0] next_pc_plus_92;\n  wire [31:0] next_pc_plus_96;\n  wire [31:0] next_pc_plus_100;\n  wire [31:0] next_pc_plus_104;\n  wire [31:0] next_pc_plus_108;\n  wire [31:0] next_pc_plus_112;\n  wire [31:0] next_pc_plus_116;\n  wire [31:0] next_pc_plus_120;\n  wire [31:0] next_pc_plus_124;\n  wire [31:0] next_pc_plus_128;\n  wire [31:0] next_pc_plus_132;\n  wire [31:0] next_pc_plus_136;\n  wire [31:0] next_pc_plus_140;\n  wire [31:0] next_pc_plus_144;\n  wire [31:0] next_pc_plus_148;\n  wire [31:0] next_pc_plus_152;\n  wire [31:0] next_pc_plus_156;\n  wire [31:0] next_pc_plus_160;\n  wire [31:0] next_pc_plus_164;\n  wire [31:0] next_pc_plus_168;\n  wire [31:0] next_pc_plus_172;\n  wire [31:0] next_pc_plus_176;\n  wire [31:0] next_pc_plus_180;\n  wire [31:0] next_pc_plus_184;\n  wire [31:0] next_pc_plus_188;\n  wire [31:0] next_pc_plus_192;\n  wire [31:0] next_pc_plus_196;\n  wire [31:0] next_pc_plus_200;\n  wire [31:0] next_pc_"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [15:0] b1, b2, b3;\n  wire [31:0] c0_next, c1_next, c2_next, c3_next;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  assign c0_next = c0_reg + (a0 * b0);\n  assign c1_next = c1_reg + (a1 * b1);\n  assign c2_next = c2_reg + (a2 * b2);\n  assign c3_next = c3_reg + (a3 * b3);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n      c0_reg <= c0_next;\n      c1_reg <= c1_next;\n      c2_reg <= c2_next;\n      c3_reg <= c3_next;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [4:0] rt;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] instr;\n    wire [31:0] rs1_val;\n    wire [31:0] rs2_val;\n    wire [31:0] rt_val;\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] out_reg_file_out;\n\n    assign out_reg_file = out_reg_file_out;\n\n    // Fetch stage\n    stagepipe3_fetch fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch_out(fetch_out)\n    );\n\n    // Execute stage\n    stagepipe3_execute execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(fetch_out),\n        .rs1_val(rs1_val),\n        .rs2_val(rs2_val),\n        .rt_val(rt_val),\n        .add_out(add_out),\n        .sub_out(sub_out),\n        .execute_out(execute_out)\n    );\n\n    // Writeback stage\n    stagepipe3_writeback writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .execute_out(execute_out),\n        .out_reg_file_out(out_reg_file_out)\n    );\n\nendmodule\n\nmodule stagepipe3_fetch (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetch_out\n);\n\n    reg [31:0] instr;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [4:0] rt;\n    reg [5:0] opcode;\n    reg [5:0] funct;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            instr <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            rt <= 0;\n            opcode <= 0;\n            funct <= 0;\n        end else begin\n            instr <= instr_mem[pc];\n            rd <= instr[11:7];\n            rs1 <= instr[19:15];\n            rs2 <= instr[24:20];\n            rt <= instr[31:25];\n            opcode <= instr[31:26];\n            funct <= instr[5:0];\n        end\n    end\n\n    assign fetch_out = instr;\n\nendmodule\n\nmodule stagepipe3_execute (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] rs1_val,\n    input [31:0] rs2_val,\n    input [31:0] rt_val,\n    input [31:0] add_out,\n    input [31:0] sub_out,\n    output [31:0] execute_out\n);\n\n    reg [31:0] out_val;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_val <= 0;\n        end else begin\n            case (instr[5:0])\n                6'b000000"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n//------------------------------------------------\n// Counter Module\n//------------------------------------------------\nreg [1:0] cnt_reg, cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 2'b00;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        2'b00: cnt_next = valid_in ? 2'b01 : 2'b00;\n        2'b01: cnt_next = valid_in ? 2'b10 : 2'b00;\n        2'b10: cnt_next = valid_in ? 2'b11 : 2'b00;\n        2'b11: cnt_next = valid_in ? 2'b11 : 2'b00;\n        default: cnt_next = 2'b00;\n    endcase\nend\n\n//------------------------------------------------\n// Data Accumulator Module\n//------------------------------------------------\nreg [9:0] accu_reg, accu_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        accu_reg <= 10'b0;\n    else\n        accu_reg <= accu_next;\nend\n\nalways @(*) begin\n    accu_next = (cnt_reg == 2'b11) ? accu_reg + data_in : accu_reg;\nend\n\n//------------------------------------------------\n// Valid Output Module\n//------------------------------------------------\nreg valid_out_reg, valid_out_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out_reg <= 1'b0;\n    else\n        valid_out_reg <= valid_out_next;\nend\n\nalways @(*) begin\n    valid_out_next = (cnt_reg == 2'b11) ? 1'b1 : 1'b0;\nend\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output              count\n);\n\nreg [1:0] cnt_reg, cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_reg <= 2'b00;\n    else\n        cnt_reg <= cnt_next;\nend\n\nalways @(*) begin\n    case (cnt_reg)\n        2'b00: cnt_next = valid_in ? 2'b01 : 2'b00;\n        2'b01: cnt_next = valid_in ? 2'b10 : 2'b00;\n        2'b10: cnt_next = valid_in ? 2'b11 : 2'b00;\n        2'b11: cnt_next = valid_in ? 2'b11 : 2'b00;\n        default: cnt_next = 2'b00;\n    endcase\nend\n\nassign count = (cnt_reg == 2'b11);\nassign valid_out = (cnt_reg == 2'b11);\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg [9:0] accu_reg, accu_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        accu_reg <= 10'b0;\n    else\n        accu_reg <= accu_next;\nend\n\nalways @(*) begin\n    accu_next = (valid_in) ? accu_reg + data_in : accu_reg"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [15:0] quotient;\n    reg [7:0] remainder;\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [7:0] shift_reg;\n    reg [3:0] counter;\n    reg [3:0] next_counter;\n    reg [3:0] next_next_counter;\n    reg [3:0] next_next_next_counter;\n    reg [3:0] next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_counter;\n    reg [3:0] next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Perform division\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] dividend, // 32-bit dividend\n    output wire [15:0] divisor   // 16-bit divisor\n);\n\n    // Prepare dividend and divisor\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,   // 16-bit divisor\n    output wire [31:0] quotient, // 32-bit quotient\n    output wire [31:0] remainder  // 32-bit remainder\n);\n\n    // Perform division\n    reg [31:0] quotient_reg;\n    reg [31:0] remainder_reg;\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n    reg [15:0] shifted_divisor_reg;\n    reg [15:0] shifted_divisor_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg_reg;\n    reg [15:0] shifted_divisor_reg_reg_reg_reg_reg_reg_reg_reg_reg"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    reg [15:0] q;\n    reg [15:0] r;\n    reg [3:0] i;\n    reg [7:0] d;\n    reg [7:0] s;\n    reg [15:0] t;\n    reg [15:0] t_next;\n    reg [15:0] odd_next;\n\n    always @(*) begin\n        // Initialize\n        q = 0;\n        r = 0;\n        i = 0;\n        d = B;\n        s = 0;\n        t = A;\n        t_next = t;\n        odd_next = r;\n\n        // Division algorithm\n        for (i = 0; i < 16; i = i + 1) begin\n            if (t_next >= d) begin\n                t_next = t_next - d;\n                s = s + 1;\n            end\n            d = d << 1;\n        end\n\n        // Update quotient and remainder\n        q = s;\n        odd = odd_next;\n    end\n\n    assign result = q;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] carry_out;\n\nassign B_comp = ~B + 1;\nassign {carry_out, sum} = A + B_comp;\nassign {carry, D} = sum + carry_out;\nassign B_out = carry[7];\n\nendmodule\n\nmodule adder_8bit(A, B, carry_in, D, carry_out);\ninput [7:0] A, B;\ninput carry_in;\noutput [7:0] D;\noutput carry_out;\n\nwire [7:0] carry;\nwire [7:0] sum;\n\nassign {carry, sum} = A + B + carry_in;\nassign {carry_out, D} = sum + carry;\n\nendmodule\n\nmodule full_adder(A, B, carry_in, D, carry_out);\ninput A, B, carry_in;\noutput D, carry_out;\n\nassign D = A ^ B ^ carry_in;\nassign carry_out = (A & B) | (B & carry_in) | (A & carry_in);\n\nendmodule\n\nmodule adder_inst(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\nwire [7:0] carry_out;\n\nassign B_comp = ~B + 1;\nassign {carry_out, sum} = A + B_comp;\nassign {carry, D} = sum + carry_out;\nassign B_out = carry[7];\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = 0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D_out;\nwire [3:1] C_out;\nwire [3:1] A_out;\nwire [3:1] B_out_sub;\nwire [3:1] D_out_sub;\nwire [3:1] C_out_sub;\nwire [3:1] A_out_sub;\n\nsub_4bit sub1 (.A(A[16:1]), .B(B[16:1]), .D(D_out[3:1]), .B_out(B_out[3:1]));\nsub_4bit sub2 (.A(A[12:4]), .B(B[12:4]), .D(D_out[2:1]), .B_out(B_out[2:1]));\nsub_4bit sub3 (.A(A[8:8]), .B(B[8:8]), .D(D_out[1:1]), .B_out(B_out[1:1]));\nsub_4bit sub4 (.A(A[4:4]), .B(B[4:4]), .D(D_out[0:0]), .B_out(B_out[0:0]));\n\nassign D = {D_out[3:1], D_out_sub[2:1], D_out_sub[1:1], D_out_sub[0:0]};\nassign B_out = {B_out[3:1], B_out_sub[2:1], B_out_sub[1:1], B_out_sub[0:0]};\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [4:1] A, B;\noutput [4:1] D;\noutput B_out;\n\nwire [2:1] B_out;\nwire [2:1] D_out;\nwire [2:1] C_out;\nwire [2:1] A_out;\nwire [2:1] B_out_sub;\nwire [2:1] D_out_sub;\nwire [2:1] C_out_sub;\nwire [2:1] A_out_sub;\n\nsub_2bit sub1 (.A(A[4:2]), .B(B[4:2]), .D(D_out[1:1]), .B_out(B_out[1:1]));\nsub_2bit sub2 (.A(A[2:2]), .B(B[2:2]), .D(D_out[0:0]), .B_out(B_out[0:0]));\n\nassign D = {D_out[1:1], D_out_sub[0:0]};\nassign B_out = {B_out[1:1], B_out_sub[0:0]};\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [2:1] A, B;\noutput [2:1] D;\noutput B_out;\n\nwire [1:1] B_out;\nwire [1:1] D_out;\nwire [1:1] C_out;\nwire [1:1] A_out;\nwire [1:1] B_out_sub;\nwire [1:1] D_out_sub;\nwire [1:1] C_out_sub;\nwire [1:1] A_out_sub;\n\nsub_1bit sub1 (.A(A[2:1]), .B(B[2:1]), .D(D_out[0:0]), .B_out(B_out[0:0]));\n\nassign D = {D_out[0:0], D_out_sub[0:0]};\nassign B_out = {B_out[0:0], B_out_sub[0:0]};\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput [1:1] A, B;\noutput [1:1] D;\noutput B_out;\n\nwire [0:0] B_out"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire carry;\n\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .carry(carry)\n);\n\nassign A_greater = (sub_result != 0);\nassign A_equal = (sub_result == 0) && (carry == 0);\nassign A_less = (carry == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output carry        // Carry output\n);\n\nassign {carry, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15;\nwire [15:1] C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15;\n\nwire [15:1] CLA1_S,CLA1_C;\nwire [15:1] CLA2_S,CLA2_C;\n\nassign S = {S15,S14,S13,S12,S11,S10,S9,S8,S7,S6,S5,S4,S3,S2,S1};\nassign C32 = C15;\n\nCLA CLA1(.A(A[15:1]),.B(B[15:1]),.S(CLA1_S),.C(CLA1_C));\nCLA CLA2(.A(CLA1_S),.B(CLA1_C),.S(CLA2_S),.C(CLA2_C));\n\nassign S1 = CLA2_S;\nassign S2 = CLA2_C;\nassign S3 = A[3:1] + B[3:1] + CLA1_C;\nassign S4 = A[7:4] + B[7:4] + CLA1_S;\nassign S5 = A[11:8] + B[11:8] + CLA2_S;\nassign S6 = A[15:12] + B[15:12] + CLA2_C;\n\nassign C1 = A[3:1] + B[3:1] + CLA1_C;\nassign C2 = A[7:4] + B[7:4] + CLA1_S;\nassign C3 = A[11:8] + B[11:8] + CLA2_S;\nassign C4 = A[15:12] + B[15:12] + CLA2_C;\n\nassign C5 = C1 + CLA1_C;\nassign C6 = C2 + CLA1_S;\nassign C7 = C3 + CLA2_S;\nassign C8 = C4 + CLA2_C;\n\nassign C9 = C5 + CLA1_C;\nassign C10 = C6 + CLA1_S;\nassign C11 = C7 + CLA2_S;\nassign C12 = C8 + CLA2_C;\n\nassign C13 = C9 + CLA1_C;\nassign C14 = C10 + CLA1_S;\nassign C15 = C11 + CLA2_S;\n\nendmodule\n\nmodule CLA(A,B,S,C);\ninput [15:1] A,B;\noutput [15:1] S;\noutput C;\n\nwire [15:1] P,G;\n\nassign P = A ^ B;\nassign G = A & B;\n\nassign S = P ^ C;\nassign C = G | (P & C);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [3:0] rca1_cout, rca2_cout, rca3_cout;\n\n// ripple carry adder\nwire [3:0] rca1_cin, rca2_cin, rca3_cin;\nassign rca1_cin[0] = a[0];\nassign rca1_cin[1] = a[1];\nassign rca1_cin[2] = a[2];\nassign rca1_cin[3] = a[3];\nassign rca2_cin[0] = rca1_sum[0];\nassign rca2_cin[1] = rca1_sum[1];\nassign rca2_cin[2] = rca1_sum[2];\nassign rca2_cin[3] = rca1_sum[3];\nassign rca3_cin[0] = rca2_sum[0];\nassign rca3_cin[1] = rca2_sum[1];\nassign rca3_cin[2] = rca2_sum[2];\nassign rca3_cin[3] = rca2_sum[3];\n\nassign rca1_sum[0] = a[0] ^ b[0];\nassign rca1_sum[1] = a[1] ^ b[1];\nassign rca1_sum[2] = a[2] ^ b[2];\nassign rca1_sum[3] = a[3] ^ b[3];\nassign rca1_cout[0] = a[0] & b[0];\nassign rca1_cout[1] = a[1] & b[1];\nassign rca1_cout[2] = a[2] & b[2];\nassign rca1_cout[3] = a[3] & b[3];\n\nassign rca2_sum[0] = rca1_sum[0] ^ rca1_cin[0];\nassign rca2_sum[1] = rca1_sum[1] ^ rca1_cin[1];\nassign rca2_sum[2] = rca1_sum[2] ^ rca1_cin[2];\nassign rca2_sum[3] = rca1_sum[3] ^ rca1_cin[3];\nassign rca2_cout[0] = rca1_cout[0] ^ rca1_cin[0];\nassign rca2_cout[1] = rca1_cout[1] ^ rca1_cin[1];\nassign rca2_cout[2] = rca1_cout[2] ^ rca1_cin[2];\nassign rca2_cout[3] = rca1_cout[3] ^ rca1_cin[3];\n\nassign rca3_sum[0] = rca2_sum[0] ^ rca2_cin[0];\nassign rca3_sum[1] = rca2_sum[1] ^ rca2_cin[1];\nassign rca3_sum[2] = rca2_sum[2] ^ rca2_cin[2];\nassign rca3_sum[3] = rca2_sum[3] ^ rca2_cin[3];\nassign rca3_cout[0] = rca2_cout[0] ^ rca2_cin[0];\nassign rca3_cout[1] = rca2_cout[1] ^ rca2_cin[1];\nassign rca3_cout[2] = rca2_cout[2] ^ rca2_cin[2];\nassign rca3_cout[3] = rca2_cout[3] ^ rca2_cin[3];\n\n// carry select adder\nwire [3:0] csa_slice1_cin, csa"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire Co1, Co2, Co3, Co4, Co5, Co6, Co7, Co8;\n    wire [7:0] y1, y2, y3, y4, y5, y6, y7, y8;\n\n    // 8-bit adder\n    // ...\n\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire [7:0] fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // First FA\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(fa0_sum[0]),\n        .cout(fa0_cout[0]));\n    \n    // Second FA\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(fa0_cout[0]),\n        .sum(fa1_sum[1]),\n        .cout(fa1_cout[1]));\n    \n    // Third FA\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(fa1_cout[1]),\n        .sum(fa2_sum[2]),\n        .cout(fa2_cout[2]));\n    \n    // Fourth FA\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(fa2_cout[2]),\n        .sum(fa3_sum[3]),\n        .cout(fa3_cout[3]));\n    \n    // Fifth FA\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(fa3_cout[3]),\n        .sum(fa4_sum[4]),\n        .cout(fa4_cout[4]));\n    \n    // Sixth FA\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(fa4_cout[4]),\n        .sum(fa5_sum[5]),\n        .cout(fa5_cout[5]));\n    \n    // Seventh FA\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(fa5_cout[5]),\n        .sum(fa6_sum[6]),\n        .cout(fa6_cout[6]));\n    \n    // Eighth FA\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(fa6_cout[6]),\n        .sum(fa7_sum[7]),\n        .cout(fa7_cout[7]));\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout[7];\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'd0;\n        product <= 32'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'd0;\n            product <= 32'd0;\n            done_flag <= 1'b0;\n        end else if (shift_count < 4'd16) begin\n            shift_count <= shift_count + 4'd1;\n            done_flag <= 1'b0;\n        end else begin\n            done_flag <= 1'b1;\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [15:0] m_reg;\nreg [15:0] p_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'd0;\n        p_reg <= 16'd0;\n    end else begin\n        if (shift_count < 4'd16) begin\n            m_reg <= {m_reg[14:0], 1'b0};\n            p_reg <= p_reg + (m_reg & b_reg);\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // counter_logic\n    assign u_counter_logic_out = up_down ? count + 1 : count - 1;\n\n    // counter_register\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= u_counter_register_out;\n        end\n    end\n    assign u_counter_register_out = count_reg;\n\n    assign count = u_counter_register_out;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule: Transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign count = count_r;\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count) begin\n        if (count_r == 4'd11)\n            count_r <= 4'b0000;\n        else\n            count_r <= count_r + 1;\n    end\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= {Q_reg[62:0], Q_reg[63]};\nend\n\n// Logic submodule\nwire [63:0] Q_logic;\nassign Q_logic = {Q_reg[62:0], Q_reg[63]};\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= {Q[62:0], Q[63]};\nend\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]      Q_logic\n);\n\nassign Q_logic = {Q[62:0], Q[63]};\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n    reg [1:0] count_50, count_10, count_1;\n\n    // clk_div_2\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_50_reg <= 0;\n        end else begin\n            CLK_50_reg <= ~CLK_50_reg;\n        end\n    end\n\n    // clk_div_10\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count_10 <= 0;\n            CLK_10_reg <= 0;\n        end else if (count_10 == 4) begin\n            count_10 <= 0;\n            CLK_10_reg <= ~CLK_10_reg;\n        end else begin\n            count_10 <= count_10 + 1;\n        end\n    end\n\n    // clk_div_100\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count_1 <= 0;\n            CLK_1_reg <= 0;\n        end else if (count_1 == 49) begin\n            count_1 <= 0;\n            CLK_1_reg <= ~CLK_1_reg;\n        end else begin\n            count_1 <= count_1 + 1;\n        end\n    end\n\n    assign CLK_50 = CLK_50_reg;\n    assign CLK_10 = CLK_10_reg;\n    assign CLK_1 = CLK_1_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [MUL2_DIV_CLK:0] clk_div_int;\n\n// Counter Submodule\nreg [MUL2_DIV_CLK:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Clock Average Generator Submodule\nreg [MUL2_DIV_CLK:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= counter;\n    end\nend\n\n// Clock Adjustment Submodule\nreg [MUL2_DIV_CLK:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= counter;\n    end\nend\n\n// Output\nassign clk_div = |clk_div_int;\n\n// Intermediate Clock Signals\nassign clk_div_int[0] = clk_average[MUL2_DIV_CLK];\nassign clk_div_int[1] = clk_average[MUL2_DIV_CLK-1];\nassign clk_div_int[2] = clk_average[MUL2_DIV_CLK-2];\nassign clk_div_int[3] = clk_adjustment[MUL2_DIV_CLK];\nassign clk_div_int[4] = clk_adjustment[MUL2_DIV_CLK-1];\nassign clk_div_int[5] = clk_adjustment[MUL2_DIV_CLK-2];\nassign clk_div_int[6] = clk_adjustment[MUL2_DIV_CLK-3];\nassign clk_div_int[7] = clk_adjustment[MUL2_DIV_CLK-4];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [MUL2_DIV_CLK:0] counter\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [MUL2_DIV_CLK:0] counter,\n    output reg [MUL2_DIV_CLK:0] clk_average\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_average <= 0;\n    end else begin\n        clk_average <= counter;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [MUL2_DIV_CLK:0] counter,\n    output reg [MUL2_DIV_CLK:0] clk_adjustment\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_adjustment <= 0;\n    end else begin\n        clk_adjustment <= counter;\n    end\nend\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_edge_counter;\nreg [3:0] neg_edge_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_edge_counter <= 0;\n        neg_edge_counter <= 0;\n        clk_div1 <= 0;\n        clk_div2 <= 0;\n    end else begin\n        if (pos_edge_counter < NUM_DIV - 1) begin\n            pos_edge_counter <= pos_edge_counter + 1;\n        end else begin\n            pos_edge_counter <= 0;\n        end\n        if (neg_edge_counter < NUM_DIV - 1) begin\n            neg_edge_counter <= neg_edge_counter + 1;\n        end else begin\n            neg_edge_counter <= 0;\n        end\n        clk_div1 <= (pos_edge_counter == NUM_DIV - 1);\n        clk_div2 <= (neg_edge_counter == NUM_DIV - 1);\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == (NUM_DIV / 2 - 1))\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nparameter NUM_DIV = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (q == (NUM_DIV / 2 - 1))\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule freq_divbyeven_clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_div <= 0;\n    else if (counter == (NUM_DIV / 2 - 1))\n        clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] a_add = a;\n    wire [31:0] b_add = b;\n    wire [31:0] a_sub = a;\n    wire [31:0] b_sub = b;\n    wire [31:0] a_and = a;\n    wire [31:0] b_and = b;\n    wire [31:0] a_or = a;\n    wire [31:0] b_or = b;\n    wire [31:0] a_xor = a;\n    wire [31:0] b_xor = b;\n    wire [31:0] a_nor = a;\n    wire [31:0] b_nor = b;\n    wire [31:0] a_slt = a;\n    wire [31:0] b_slt = b;\n    wire [31:0] a_sltu = a;\n    wire [31:0] b_sltu = b;\n    wire [31:0] a_sll = a;\n    wire [31:0] b_sll = b;\n    wire [31:0] a_srl = a;\n    wire [31:0] b_srl = b;\n    wire [31:0] a_sra = a;\n    wire [31:0] b_sra = b;\n    wire [31:0] a_sllv = a;\n    wire [31:0] b_sllv = b;\n    wire [31:0] a_srlv = a;\n    wire [31:0] b_srlv = b;\n    wire [31:0] a_srav = a;\n    wire [31:0] b_srav = b;\n    wire [31:0] a_lui = a;\n    wire [31:0] b_lui = b;\n    \n    assign r = (aluc == 6'b100000) ? a_add + b_add :\n               (aluc == 6'b100001) ? a_add + b_add :\n               (aluc == 6'b100010) ? a_sub - b_sub :\n               (aluc == 6'b100011) ? a_sub - b_sub :\n               (aluc == 6'b100100) ? a_and & b_and :\n               (aluc == 6'b100101) ? a_or | b_or :\n               (aluc == 6'b100110) ? a_xor ^ b_xor :\n               (aluc == 6'b100111) ? ~(a_nor | b_nor) :\n               (aluc == 6'b101010) ? (a_slt < b_slt) :\n               (aluc == 6'b101011) ? (a_sltu < b_sltu) :\n               (aluc == 6'b000000) ? a_sll << b_sll :\n               (aluc == 6'b000010) ? a_srl >> b_srl :\n               (aluc == 6'b000011) ? a_sra >>> b_sra :\n               (aluc == 6'b000100) ? a_sllv << b_sllv :\n               (aluc == 6'b000110) ? a_srlv >> b_srlv :\n               (aluc == 6'b000111) ? a_srav >>> b_srav :\n               (aluc == 6'b001111) ? a_lui : 32'b0;\n    \n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] == 1 && a[31] == b["}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] m_result;\nwire [31:0] a_reg;\nwire [31:0] b_reg;\nwire [31:0] m_result_reg;\n\nreg [31:0] current_value;\n\n// Multiplier Submodule\nassign m_result = a * b;\n\n// Accumulator Submodule\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        a_reg <= 0;\n        b_reg <= 0;\n        m_result_reg <= 0;\n        current_value <= 0;\n    end else begin\n        a_reg <= a;\n        b_reg <= b;\n        m_result_reg <= m_result;\n        current_value <= current_value + m_result_reg;\n    end\nend\n\nassign c = current_value;\n\nendmodule\n"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data[7:5];\n            ad1_p1_reg <= data[4:0];\n            ad2_p1_reg <= data;\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data[7:5];\n            ad1_p2_reg <= data[4:0];\n            ad2_p2_reg <= data;\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\n// Counter Module\nreg [7:0] count_reg;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == (freq - 1)) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\nassign count = count_reg;\nassign enable = (freq != 0);\n\n// Wave Generator Module\nreg wave_out_reg;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\nend\nassign wave_out = wave_out_reg;\n\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b00001) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_inst (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            state_reg <= state_reg;\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule wave_inst (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave_reg;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        q <= (sel == 2'b00) ? q1 :\n             (sel == 2'b01) ? q2 :\n             (sel == 2'b10) ? q3 :\n             d;\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output [7:0] q\n);\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q[0]),\n        .q(q[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q[1]),\n        .q(q[2])\n    );\n\n    my_dff8 u3 (\n        .clk(clk),\n        .d(q[2]),\n        .q(q[3])\n    );\n\n    my_dff8 u4 (\n        .clk(clk),\n        .d(q[3]),\n        .q(q[4])\n    );\n\n    my_dff8 u5 (\n        .clk(clk),\n        .d(q[4]),\n        .q(q[5])\n    );\n\n    my_dff8 u6 (\n        .clk(clk),\n        .d(q[5]),\n        .q(q[6])\n    );\n\n    my_dff8 u7 (\n        .clk(clk),\n        .d(q[6]),\n        .q(q[7])\n    );\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    my_dff dff1 (clk, d, q1);\n    my_dff dff2 (clk, q1, q2);\n    my_dff dff3 (clk, q2, q3);\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    wire [7:0] mux3_out;\n    wire [7:0] mux4_out;\n    wire [7:0] mux5_out;\n    wire [7:0] mux6_out;\n    wire [7:0] mux7_out;\n    wire [7:0] mux8_out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n    wire [7:0] stage4_out;\n    wire [7:0] stage5_out;\n    wire [7:0] stage6_out;\n    wire [7:0] stage7_out;\n    wire [7:0] stage8_out;\n\n    wire sel1;\n    wire sel2;\n    wire sel3;\n    wire sel4;\n    wire sel5;\n    wire sel6;\n    wire sel7;\n    wire sel8;\n\n    assign sel1 = ctrl[2];\n    assign sel2 = ctrl[1];\n    assign sel3 = ctrl[0];\n\n    mux2X1 mux1 (mux1_out, in, stage1_out);\n    mux2X1 mux2 (mux2_out, mux1_out, stage2_out);\n    mux2X1 mux3 (mux3_out, mux2_out, stage3_out);\n    mux2X1 mux4 (mux4_out, mux3_out, stage4_out);\n    mux2X1 mux5 (mux5_out, mux4_out, stage5_out);\n    mux2X1 mux6 (mux6_out, mux5_out, stage6_out);\n    mux2X1 mux7 (mux7_out, mux6_out, stage7_out);\n    mux2X1 mux8 (mux8_out, mux7_out, stage8_out);\n\n    assign stage1_out = {in[6:0], 1'b0};\n    assign stage2_out = {in[5:0], sel1, 1'b0};\n    assign stage3_out = {in[4:0], sel2, sel1, 1'b0};\n    assign stage4_out = {in[3:0], sel3, sel2, sel1, 1'b0};\n    assign stage5_out = {in[2:0], sel3, sel2, sel1, 1'b0};\n    assign stage6_out = {in[1:0], sel3, sel2, sel1, 1'b0};\n    assign stage7_out = {in[0], sel3, sel2, sel1, 1'b0};\n    assign stage8_out = {1'b0, sel3, sel2, sel1, 1'b0};\n\n    assign out = mux8_out;\nendmodule\n\nmodule mux2X1 (out, in1, in2);\n    input [7:0] in1, in2;\n    output [7:0] out;\n    input sel;\n\n    assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [15:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= {a0, 16'b0} * {b0, 16'b0};\n      pe1_out <= {a1, 16'b0} * {b1, 16'b0};\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  reg [31:0] pc;\n\n  stage fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] instr,\n    output [31:0] pc_next\n  );\n  stage decode_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] rs1,\n    output [31:0] rs2,\n    output [31:0] rd,\n    output [31:0] op\n  );\n  stage execute_stage(\n    input clk,\n    input rst,\n    input [31:0] rs1,\n    input [31:0] rs2,\n    input [31:0] op,\n    output [31:0] alu_res\n  );\n  stage memory_stage(\n    input clk,\n    input rst,\n    input [31:0] alu_res,\n    output [31:0] alu_res_next\n  );\n  stage writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] alu_res_next,\n    input [31:0] rd,\n    output [31:0] res_reg_file [0:31]\n  );\n\n  assign res_reg_file = writeback_stage.res_reg_file;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= fetch_stage.pc_next;\n    end\n  end\n\n  assign fetch_stage.instr = instr_mem[pc];\n  assign fetch_stage.pc = pc;\n\n  assign decode_stage.instr = fetch_stage.instr;\n\n  assign execute_stage.rs1 = decode_stage.rs1;\n  assign execute_stage.rs2 = decode_stage.rs2;\n  assign execute_stage.op = decode_stage.op;\n\n  assign memory_stage.alu_res = execute_stage.alu_res;\n\n  assign writeback_stage.alu_res_next = memory_stage.alu_res_next;\n  assign writeback_stage.rd = decode_stage.rd;\n\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [31:0] pe0_out, pe1_out, pe2_out, pe3_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      pe0_out <= a0 * b0_reg;\n      pe1_out <= a1 * b1_reg;\n      pe2_out <= a2 * b2_reg;\n      pe3_out <= a3 * b3_reg;\n      c0_reg <= pe0_out;\n      c1_reg <= pe1_out;\n      c2_reg <= pe2_out;\n      c3_reg <= pe3_out;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    wire [4:0] pc;\n    reg [4:0] next_pc;\n\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [4:0] rt;\n    wire [5:0] op;\n    wire [31:0] imm;\n    wire [31:0] alu_out;\n\n    wire [31:0] instr;\n\n    assign out_reg_file = writeback_out;\n\n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .out_reg_file(fetch_out),\n        .pc(pc),\n        .next_pc(next_pc),\n        .instr(instr)\n    );\n\n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .reg_file(reg_file),\n        .alu_out(alu_out)\n    );\n\n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .alu_out(alu_out),\n        .reg_file(reg_file),\n        .out_reg_file(writeback_out)\n    );\n\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file,\n    input [4:0] pc,\n    output [4:0] next_pc,\n    output [31:0] instr\n);\n\n    wire [31:0] fetched_instr;\n    wire [31:0] alu_out;\n\n    assign out_reg_file = alu_out;\n\n    assign instr = fetched_instr;\n\n    assign next_pc = pc + 1;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            fetched_instr <= 32'b0;\n        end else begin\n            fetched_instr <= instr_mem[pc];\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg [2:0] cnt;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'b0;\n    end else if (valid_in) begin\n        cnt <= cnt + 1;\n    end\nend\nwire count_done = (cnt == 3'b111);\n\n// Data Accumulator Module\nreg [9:0] data_accum;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'b0;\n    end else if (valid_in) begin\n        data_accum <= data_accum + data_in;\n    end\nend\n\n// Valid Output Module\nreg valid_out_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_reg <= 1'b0;\n    end else if (count_done) begin\n        valid_out_reg <= 1'b1;\n    end else if (valid_in) begin\n        valid_out_reg <= 1'b0;\n    end\nend\nassign valid_out = valid_out_reg;\n\nassign data_out = data_accum;\n\nendmodule\n"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Calculate absolute value of dividend\n    wire [7:0] abs_dividend = (sign) ? -dividend : dividend;\n\n    // Calculate negated absolute value of divisor\n    wire [7:0] neg_divisor = (sign) ? -divisor : divisor;\n\n    // Calculate quotient and remainder\n    wire [7:0] quotient_tmp = abs_dividend / neg_divisor;\n    wire [7:0] remainder_tmp = abs_dividend % neg_divisor;\n\n    // Assign result\n    assign result = {remainder_tmp, quotient_tmp};\n\n    // Check if result is valid\n    always @(posedge clk) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else if (opn_valid && res_ready) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep_dividend_inst (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire [15:0] divisor\n);\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n    reg [4:0] counter;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = {divisor, 16'b0};\n        temp_quotient = 32'b0;\n        temp_remainder = 32'b0;\n        counter = 5'd0;\n\n        while (counter < 32) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                temp_quotient[counter] = 1'b1;\n            end else begin\n                temp_quotient[counter] = 1'b0;\n            end\n\n            shifted_divisor = shifted_divisor >> 1;\n            counter = counter + 1;\n        end\n\n        temp_remainder = shifted_dividend;\n    end\n\n    assign quotient = temp_quotient;\n    assign remainder = temp_remainder;\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result;\n    wire [15:0] temp_odd;\n    wire [7:0] temp_divisor;\n    wire [15:0] temp_dividend;\n    wire [15:0] temp_shifted_dividend;\n    wire [15:0] temp_shifted_dividend_next;\n    wire [15:0] temp_shifted_dividend_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next;\n    wire [15:0] temp_shifted_dividend_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign sum = A + B_comp;\nassign carry = (A[0] & B[0]) | (B[0] & sum[7]);\n\nalways @(*) begin\n    D = sum;\n    B_out = carry;\nend\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] carry;\n\nassign carry = (A[0] & B[0]) | (B[0] & D[7]);\n\nalways @(*) begin\n    D[0] = A[0] ^ B[0];\n    D[1] = A[1] ^ B[1] ^ carry;\n    D[2] = A[2] ^ B[2] ^ carry;\n    D[3] = A[3] ^ B[3] ^ carry;\n    D[4] = A[4] ^ B[4] ^ carry;\n    D[5] = A[5] ^ B[5] ^ carry;\n    D[6] = A[6] ^ B[6] ^ carry;\n    D[7] = A[7] ^ B[7] ^ carry;\n    B_out = carry;\nend\n\nendmodule\n\nmodule full_adder(A, B, Cin, Cout);\ninput A, B, Cin;\noutput Cout;\n\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nassign Diff = A - B;\nassign B_out = (A[31] == B[31]) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] A1, A2, A3, A4;\nwire [3:1] B1, B2, B3, B4;\nwire [3:1] D1, D2, D3, D4;\nwire [2:1] B_out1, B_out2, B_out3, B_out4;\n\nassign A1 = A[1:1];\nassign A2 = A[2:2];\nassign A3 = A[3:3];\nassign A4 = A[4:4];\n\nassign B1 = B[1:1];\nassign B2 = B[2:2];\nassign B3 = B[3:3];\nassign B4 = B[4:4];\n\nassign D1 = A1 - B1 - B_out1;\nassign D2 = A2 - B2 - B_out2;\nassign D3 = A3 - B3 - B_out3;\nassign D4 = A4 - B4 - B_out4;\n\nassign D = {D4, D3, D2, D1};\n\nassign B_out1 = (A1 < B1) ? 1'b1 : 1'b0;\nassign B_out2 = (A2 < B2) ? 1'b1 : (A2 == B2) ? B_out1 : 1'b0;\nassign B_out3 = (A3 < B3) ? 1'b1 : (A3 == B3) ? B_out2 : 1'b0;\nassign B_out4 = (A4 < B4) ? 1'b1 : (A4 == B4) ? B_out3 : 1'b0;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\nwire carry;\n\n// Subtraction operation\nassign subtraction_result = A - B;\nassign carry = (subtraction_result[31] == 1);\n\n// Comparison logic\nassign A_greater = (subtraction_result != 0) && (carry == 0);\nassign A_equal = (subtraction_result == 0);\nassign A_less = (carry == 1);\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\nassign S[1:0] = A[1:0] ^ B[1:0];\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit ripple carry adder\nwire [3:0] a_slices, b_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign {carry[0], sum_slices[0]} = a_slices + b_slices + cin;\nassign {carry[1], sum_slices[1]} = a[7:4] + b[7:4] + carry[0];\nassign {carry[2], sum_slices[2]} = a[11:8] + b[11:8] + carry[1];\nassign {carry[3], sum_slices[3]} = a[15:12] + b[15:12] + carry[2];\n\n// 4-bit carry select adder\nwire [3:0] sum_slices_mux;\nassign sum_slices_mux[0] = sum_slices[0] ^ (a_slices & b_slices);\nassign sum_slices_mux[1] = sum_slices[1] ^ (a[7:4] & b[7:4]);\nassign sum_slices_mux[2] = sum_slices[2] ^ (a[11:8] & b[11:8]);\nassign sum_slices_mux[3] = sum_slices[3] ^ (a[15:12] & b[15:12]);\n\nassign sum = {sum_slices_mux[3], sum_slices_mux[2], sum_slices_mux[1], sum_slices_mux[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// 4-bit ripple carry adder\nwire [3:0] a_slices, b_slices;\nassign a_slices = a[3:0];\nassign b_slices = b[3:0];\nassign {carry[0], sum_slices[0]} = a_slices + b_slices + cin;\nassign {carry[1], sum_slices[1]} = a[7:4] + b[7:4] + carry[0];\nassign {carry[2], sum_slices[2]} = a[11:8] + b[11:8] + carry[1];\nassign {carry[3], sum_slices[3]} = a[15:12] + b[15:12] + carry[2];\n\n// 4-bit carry select adder\nwire [3:0] sum_slices_mux;\nassign sum_slices_mux[0] = sum_slices[0] ^ (a_slices & b_slices);\nassign sum_slices_mux[1] = sum_slices[1] ^ (a[7:4] & b[7:4]);\nassign sum_slices_mux[2] = sum_slices[2] ^ (a[11:8] & b[11:8]);\nassign sum_slices_mux[3] = sum_slices[3] ^ (a[15:12] & b[15:12]);\n\nassign sum = {sum_slices_mux[3], sum_slices_mux[2], sum_slices_mux[1], sum_slices_mux[0]};\nassign cout = carry[3];\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_8bit;\n    wire [7:0] y_8bit;\n\n    // 8-bit adder\n    adder_8bit adder_8bit_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8bit),\n        .Co(Co_8bit)\n    );\n\n    // 16-bit adder\n    assign y = {y_8bit, Co_8bit} + {b[15:8], a[15:8]};\n    assign Co = (a[15] & b[15]) | (a[15] & Co_8bit) | (b[15] & Co_8bit);\nendmodule\n\n// 8-bit adder\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] Co_4bit;\n    wire [3:0] y_4bit;\n\n    // 4-bit adder\n    adder_4bit adder_4bit_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y_4bit),\n        .Co(Co_4bit)\n    );\n\n    // 8-bit adder\n    assign y = {y_4bit, Co_4bit} + {b[7:4], a[7:4]};\n    assign Co = (a[7] & b[7]) | (a[7] & Co_4bit) | (b[7] & Co_4bit);\nendmodule\n\n// 4-bit adder\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    assign y = a + b + Cin;\n    assign Co = (a[3] & b[3]) | (a[3] & Cin) | (b[3] & Cin);\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] fa0_sum, fa1_sum, fa2_sum, fa3_sum, fa4_sum, fa5_sum, fa6_sum, fa7_sum;\n    wire [6:0] fa0_cout, fa1_cout, fa2_cout, fa3_cout, fa4_cout, fa5_cout, fa6_cout, fa7_cout;\n    \n    // 8-bit full adder\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(fa0_sum[0]), .cout(fa0_cout[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(fa0_cout[0]), .sum(fa1_sum[1]), .cout(fa1_cout[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(fa1_cout[1]), .sum(fa2_sum[2]), .cout(fa2_cout[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(fa2_cout[2]), .sum(fa3_sum[3]), .cout(fa3_cout[3]));\n    full_adder fa4(.a(a[4]), .b(b[4]), .cin(fa3_cout[3]), .sum(fa4_sum[4]), .cout(fa4_cout[4]));\n    full_adder fa5(.a(a[5]), .b(b[5]), .cin(fa4_cout[4]), .sum(fa5_sum[5]), .cout(fa5_cout[5]));\n    full_adder fa6(.a(a[6]), .b(b[6]), .cin(fa5_cout[5]), .sum(fa6_sum[6]), .cout(fa6_cout[6]));\n    full_adder fa7(.a(a[7]), .b(b[7]), .cin(fa6_cout[6]), .sum(fa7_sum[7]), .cout(fa7_cout[7]));\n    \n    assign sum = fa7_sum;\n    assign cout = fa7_cout[7];\n    \nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_cnt;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 4'b0000;\n        product <= 32'b0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4'b0000;\n            product <= 32'b0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_cnt == 4'b1111) begin\n                done_flag <= 1'b1;\n            end else begin\n                shift_cnt <= shift_cnt + 1'b1;\n                product <= product + (bin << shift_cnt);\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'b0;\n        b_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'b0;\n    end else begin\n        if (start) begin\n            m_reg <= b_reg;\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] u_counter_logic_out;\n    wire [15:0] u_counter_register_out;\n\n    // u_counter_logic\n    assign u_counter_logic_out = up_down ? count + 1 : count - 1;\n\n    // u_counter_register\n    reg [15:0] count_reg;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= u_counter_register_out;\n        end\n    end\n    assign u_counter_register_out = count_reg;\n\n    assign count = u_counter_register_out;\n\nendmodule\n"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Submodule: Initialization\n    reg [7:0] init_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            init_out <= 8'b0000_0001;\n        end\n    end\n\n    // Submodule: Transition\n    reg [7:0] transition_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= 8'b0000_0001;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\nreg [3:0] count_r;\n\nassign count = count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\nend\n\nassign out = count;\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count\n);\n\nreg [3:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_r <= 4'b0000;\n    else if (valid_count)\n        count_r <= count_r + 1;\n    else\n        count_r <= 4'b0000;\nend\n\nassign count = count_r;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output [3:0] out\n);\n\nreg [3:0] out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out_r <= 4'b0000;\n    else if (valid_count)\n        out_r <= count;\n    else\n        out_r <= out_r;\nend\n\nassign out = out_r;\n\nendmodule\n"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n// Register submodule\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= {Q_reg[62:0], ~Q_reg[63]};\nend\n\n// Logic submodule\nwire [63:0] next_Q;\nassign next_Q = {Q_reg[62:0], ~Q_reg[63]};\nalways @(*) begin\n    Q = next_Q;\nend\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output [63:0]        Q\n);\n\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= D;\nend\n\nassign Q = Q_reg;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output [63:0]        Q\n);\n\nreg [63:0] Q_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q_reg <= 64'b0;\n    else Q_reg <= D;\nend\n\nassign Q = {Q_reg[62:0], ~Q_reg[63]};\n\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    reg CLK_50_reg, CLK_10_reg, CLK_1_reg;\n    reg [1:0] counter_50, counter_10, counter_1;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_50_reg <= 0;\n            CLK_10_reg <= 0;\n            CLK_1_reg <= 0;\n            counter_50 <= 0;\n            counter_10 <= 0;\n            counter_1 <= 0;\n        end else begin\n            if (counter_50 == 2) begin\n                CLK_50_reg <= ~CLK_50_reg;\n                counter_50 <= 0;\n            end else begin\n                counter_50 <= counter_50 + 1;\n            end\n\n            if (counter_10 == 4) begin\n                CLK_10_reg <= ~CLK_10_reg;\n                counter_10 <= 0;\n            end else begin\n                counter_10 <= counter_10 + 1;\n            end\n\n            if (counter_1 == 49) begin\n                CLK_1_reg <= ~CLK_1_reg;\n                counter_1 <= 0;\n            end else begin\n                counter_1 <= counter_1 + 1;\n            end\n        end\n    end\n\n    assign CLK_50 = CLK_50_reg;\n    assign CLK_10 = CLK_10_reg;\n    assign CLK_1 = CLK_1_reg;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_reg;\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            counter <= 0;\n        end else begin\n            if (counter == 2) begin\n                CLK_out_reg <= ~CLK_out_reg;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_reg;\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            counter <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out_reg <= ~CLK_out_reg;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg CLK_out_reg;\n    reg [5:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            counter <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out_reg <= ~CLK_out_reg;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n\nendmodule\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [3:0] clk_div_int;\n\n// Counter Submodule\nreg [3:0] counter;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == MUL2_DIV_CLK)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Clock Average Generator Submodule\nreg [3:0] clk_average;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_average <= 0;\n    else if (counter == 4)\n        clk_average <= clk_average + 1;\nend\n\n// Clock Adjustment Submodule\nreg [3:0] clk_adjustment;\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_adjustment <= 0;\n    else if (counter == 3)\n        clk_adjustment <= clk_adjustment + 1;\nend\n\n// Output\nassign clk_div = clk_div_int[0] | clk_div_int[1] | clk_div_int[2] | clk_div_int[3];\n\n// Intermediate Clock Signals\nassign clk_div_int[0] = counter[0] & counter[1] & counter[2] & counter[3];\nassign clk_div_int[1] = counter[0] & counter[1] & counter[2] & ~counter[3];\nassign clk_div_int[2] = counter[0] & counter[1] & ~counter[2] & counter[3];\nassign clk_div_int[3] = counter[0] & ~counter[1] & counter[2] & counter[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          count_out\n);\n\nparameter COUNT_MAX = 7;\n\nreg [2:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == COUNT_MAX)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_out <= 0;\n    else if (counter == COUNT_MAX)\n        count_out <= 1;\n    else\n        count_out <= 0;\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_in,\n    output reg          clk_out\n);\n\nparameter COUNT_MAX = 3;\n\nreg [2:0] counter;\nreg [2:0] clk_buffer;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == COUNT_MAX)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_buffer <= 0;\n    else if (counter == COUNT_MAX)\n        clk_buffer <= {clk_buffer[2:0], clk_in};\n    else\n        clk_buffer <= clk_buffer;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_out <= 0;\n    else if (counter == COUNT_MAX)\n        clk_out <= clk_buffer[0] | clk_buffer[1] | clk_buffer[2];\n    else\n        clk_out <= 0;\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nreg [3:0] pos_counter;\nreg [3:0] neg_counter;\nreg clk_div1;\nreg clk_div2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pos_counter <= 0;\n        clk_div1 <= 0;\n    end else if (pos_counter == NUM_DIV - 1) begin\n        pos_counter <= 0;\n        clk_div1 <= 1;\n    end else begin\n        pos_counter <= pos_counter + 1;\n        clk_div1 <= 0;\n    end\nend\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        neg_counter <= 0;\n        clk_div2 <= 0;\n    end else if (neg_counter == NUM_DIV - 1) begin\n        neg_counter <= 0;\n        clk_div2 <= 1;\n    end else begin\n        neg_counter <= neg_counter + 1;\n        clk_div2 <= 0;\n    end\nend\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter == NUM_DIV / 2 - 1) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        q <= 0;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (q == NUM_DIV / 2 - 1) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\nwire [31:0] xor_result;\nwire [31:0] nor_result;\nwire [31:0] slt_result;\nwire [31:0] sltu_result;\nwire [31:0] sll_result;\nwire [31:0] srl_result;\nwire [31:0] sra_result;\nwire [31:0] sllv_result;\nwire [31:0] srlv_result;\nwire [31:0] srav_result;\nwire [31:0] lui_result;\n\nassign r = aluc[5] ? lui_result : aluc[4] ? srav_result : aluc[3] ? srlv_result : aluc[2] ? sllv_result : aluc[1] ? srl_result : aluc[0] ? sra_result : aluc[4] ? sltu_result : aluc[3] ? slt_result : aluc[2] ? nor_result : aluc[1] ? xor_result : aluc[0] ? or_result : aluc[4] ? and_result : aluc[3] ? sub_result : aluc[2] ? add_result : 32'b0;\n\nassign zero = r == 32'b0;\nassign carry = add_result[32] | sub_result[32];\nassign negative = r[31];\nassign overflow = add_result[32] ^ sub_result[32] ^ r[31];\nassign flag = aluc[5] ? sltu_result[31] : aluc[4] ? slt_result[31] : 1'b0;\n\n// Addition\nadd u_add(\n    .a(a),\n    .b(b),\n    .r(add_result)\n);\n\n// Subtraction\nsub u_sub(\n    .a(a),\n    .b(b),\n    .r(sub_result)\n);\n\n// AND\nand u_and(\n    .a(a),\n    .b(b),\n    .r(and_result)\n);\n\n// OR\nor u_or(\n    .a(a),\n    .b(b),\n    .r(or_result)\n);\n\n// XOR\nxor u_xor(\n    .a(a),\n    .b(b),\n    .r(xor_result)\n);\n\n// NOR\nnor u_nor(\n    .a(a),\n    .b(b),\n    .r(nor_result)\n);\n\n// SLT\nslt u_slt(\n    .a(a),\n    .b(b),\n    .r(slt_result)\n);\n\n// SLTU\nsltu u_sltu(\n    .a(a),\n    .b(b),\n    .r(sltu_result)\n);\n\n// SLL\nsll u_sll(\n    .a(a),\n    .b(b),\n    .r(sll_result)\n);\n\n// SRL\nsrl u_srl(\n    .a(a),\n    .b(b),\n    .r(srl_result)\n);\n\n// SRA\nsra u_sra(\n    .a(a),\n    .b(b),\n    .r(sra_result)\n);\n\n// SLLV\nsllv u_sllv(\n    .a(a),\n    .b(b),\n    .r(sllv_result)\n);\n\n// SRLV\nsrlv u_srlv(\n    .a(a),\n    .b(b),\n    .r(srlv_result)\n);\n\n// SRAV\nsrav u_srav(\n    .a(a),\n    .b(b),\n    .r(srav_result)\n);\n\n// LUI\nlui u_lui(\n    .a"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign multiplication_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] current_value;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + multiplication_result[31:0];\n        end\n    end\n\n    // Output\n    assign c = current_value;\n\nendmodule\n\nmodule pe_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] c\n);\n\n    assign c = a * b;\n\nendmodule\n\nmodule pe_accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    reg [31:0] current_value;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + a;\n        end\n    end\n\n    assign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_p1_reg;\n    reg [4:0] ad1_p1_reg;\n    reg [7:0] ad2_p1_reg;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_p2_reg;\n    reg [4:0] ad1_p2_reg;\n    reg [7:0] ad2_p2_reg;\n\n    // Instruction register for register source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1_reg <= 3'b0;\n            ad1_p1_reg <= 5'b0;\n            ad2_p1_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= data[7:5];\n                ad1_p1_reg <= data[4:0];\n                ad2_p1_reg <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p2_reg <= 3'b0;\n            ad1_p2_reg <= 5'b0;\n            ad2_p2_reg <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2_reg <= data[7:5];\n                ad1_p2_reg <= data[4:0];\n                ad2_p2_reg <= data;\n            end\n        end\n    end\n\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ad1_p1_reg;\n    assign ad2_p1 = ad2_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ad1_p2_reg;\n    assign ad2_p2 = ad2_p2_reg;\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire [7:0] count;\nwire enable;\n\nassign enable = (freq > 0);\n\ncounter counter_inst (\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n);\n\nwire [7:0] freq_inv;\nassign freq_inv = 8'd255 / freq;\n\nwire [7:0] count_inv;\nassign count_inv = 8'd255 - count;\n\nwire [7:0] wave_out_inv;\nassign wave_out_inv = (count_inv < freq_inv) ? 1'b1 : 1'b0;\n\nassign wave_out = wave_out_inv;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1)) begin\n            count <= 8'd0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b11111) begin\n                        state <= 2'b10;\n                    end\n                end\n                2'b10: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                2'b10: wave_reg <= wave_reg + 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule submodule_state_control (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                2'b00: begin\n                    if (state_reg == 2'b11) begin\n                        state_reg <= 2'b00;\n                    end\n                end\n                2'b01: begin\n                    if (state_reg == 2'b00) begin\n                        state_reg <= 2'b01;\n                    end\n                end\n                2'b10: begin\n                    if (state_reg == 2'b01) begin\n                        state_reg <= 2'b10;\n                    end\n                end\n                2'b11: begin\n                    if (state_reg == 2'b10) begin\n                        state_reg <= 2'b11;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign state = state_reg;\n\nendmodule\n\nmodule submodule_waveform_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            if (wave_reg == 5'b00000) begin\n                wave_reg <= 5'b00001;\n            end else if (wave_reg == 5'b11111) begin\n                wave_reg <= 5'b00000;\n            end else if (wave_reg[0] == 1) begin\n                wave_reg <= wave_reg + 1;\n            end else begin\n                wave_reg <= wave_reg - 1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    reg [7:0] q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= d;\n        q2 <= q1;\n        q3 <= q2;\n        q <= sel[1] ? (sel[0] ? q3 : d) : q3;\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q),\n        .q(q)\n    );\n\n    always @(posedge clk) begin\n        q <= sel[1] ? (sel[0] ? q : d) : d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Instantiate D flip-flop module\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3;\n\n    // Stage 1\n    assign stage1 = (ctrl[2]) ? {in[3:0], in[7:4]} : in;\n    assign stage2 = (ctrl[1]) ? {stage1[3:0], stage1[7:4]} : stage1;\n    assign stage3 = (ctrl[0]) ? {stage2[3:0], stage2[7:4]} : stage2;\n\n    assign out = stage3;\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input sel;\n    input in0, in1;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n  reg [31:0] pe0_out;\n  reg [31:0] pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      pe0_out <= 0;\n      pe1_out <= 0;\n    end else begin\n      b1 <= b0;\n      pe0_out <= a0 * b0;\n      pe1_out <= a1 * b1;\n    end\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res_decode;\n  wire [31:0] res_execute;\n  wire [31:0] res_memory;\n  wire [31:0] res_writeback;\n  reg [31:0] pc;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .pc(pc),\n    .res_fetch(res_decode)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_decode),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .res_decode(res_execute)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_execute),\n    .reg_file(res_reg_file),\n    .res_reg_file(res_reg_file),\n    .res_execute(res_memory)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_memory),\n    .reg_file(res_reg_file),\n    .res_reg_file(res_reg_file),\n    .res_memory(res_writeback)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(res_writeback),\n    .reg_file(res_reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 32'h00000000;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [31:0] res_reg_file [0:31],\n  input [31:0] pc,\n  output [31:0] res_fetch\n);\n  reg [31:0] res_decode;\n  reg [31:0] res_execute;\n  reg [31:0] res_memory;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_decode <= 32'h00000000;\n      res_execute <= 32'h00000000;\n      res_memory <= 32'h00000000;\n    end else begin\n      res_decode <= instr_mem[pc];\n      res_execute <= res_decode;\n      res_memory <= res_execute;\n    end\n  end\n\n  assign res_fetch = res_decode;\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0 * b0_reg;\n      c1_reg <= a1 * b1_reg;\n      c2_reg <= a2 * b2_reg;\n      c3_reg <= a3 * b3_reg;\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    wire [31:0] pc_next;\n\n    assign pc = 32'd0;\n\n    stagepipe3_fetch_stage fetch_stage (\n        .clk(clk),\n        .rst(rst),\n        .pc(pc),\n        .instr_mem(instr_mem),\n        .instr(instr)\n    );\n\n    stagepipe3_execute_stage execute_stage (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .reg_file(reg_file),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n\n    stagepipe3_writeback_stage writeback_stage (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .rd(rd),\n        .reg_file(reg_file)\n    );\n\n    assign out_reg_file = reg_file[rd];\n\nendmodule\n\nmodule stagepipe3_fetch_stage (\n    input clk,\n    input rst,\n    input [31:0] pc,\n    input [31:0] instr_mem [0:31],\n    output [31:0] instr\n);\n\n    reg [31:0] instr_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            instr_reg <= 32'd0;\n        end else begin\n            instr_reg <= instr_mem[pc];\n        end\n    end\n\n    assign instr = instr_reg;\n\nendmodule\n\nmodule stagepipe3_execute_stage (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n\n    reg [31:0] op1_reg;\n    reg [31:0] op2_reg;\n    reg [4:0] rd_reg;\n    reg [4:0] rs1_reg;\n    reg [4:0] rs2_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1_reg <= 32'd0;\n            op2_reg <= 32'd0;\n            rd_reg <= 5'd0;\n            rs1_reg <= 5'd0;\n            rs2_reg <= 5'd0;\n        end else begin\n            op1_reg <= reg_file[instr[25:21]];\n            op2_reg <= reg_file[instr[20:16]];\n            rd_reg <= instr[10:6];\n            rs1_reg <= instr[25:21];\n            rs2_reg <= instr[20:16];\n        end\n    end\n\n    assign op1 = op1_reg;\n    assign op2 = op2_reg;\n    assign rd = rd_reg;\n    assign rs1 = rs1_reg;\n    assign rs2 = rs2_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 32'd0;\n        end else begin\n            case (instr[31:26])\n                6'b00000"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n// Counter Module\nreg     [2:0]   cnt;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 3'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt <= cnt + 1'b1;\n            if (cnt == 3'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\n// Data Accumulator Module\nreg     [9:0]   data_accum;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n        end\n    end\nend\n\n// Valid Output Module\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output              count\n);\n\nreg                 valid_out_r;\nreg                 [1:0] count_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 1'b0;\n        count_r <= 2'd0;\n    end else begin\n        if (valid_in) begin\n            count_r <= count_r + 1'b1;\n            if (count_r == 2'd4) begin\n                valid_out_r <= 1'b1;\n            end\n        end else begin\n            valid_out_r <= 1'b0;\n            count_r <= 2'd0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign count = count_r;\n\nendmodule\n\nmodule u_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\nreg     [9:0]   data_accum;\nreg             valid_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accum <= 10'd0;\n        valid_out_r <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            data_accum <= data_accum + data_in;\n            valid_out_r <= 1'b1;\n        end else begin\n            valid_out_r <= 1'b0;\n        end\n    end\nend\n\nassign valid_out = valid_out_r;\nassign data_out = data_accum;\n\nendmodule\n\nmodule u_valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output              valid_out,\n    output              data_out\n);\n\nreg                 valid_out_r;\nreg                 [1:0] count_r;\nreg                 [9:0] data_out_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out_r <= 1'b0;\n        count_r <= 2'd0;\n        data_out_r <= 10'd0;\n    end else begin\n        if (valid_in) begin\n            count_r <= count_r + 1'b1;\n            if (count_r == 2'd4) begin\n                valid_out_r <= 1'b1;\n                data_out_r <="}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    reg [7:0] abs_dividend;\n    reg [7:0] neg_divisor;\n    reg [3:0] counter;\n    reg [15:0] shift_reg;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n\n    // Absolute Value Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            abs_dividend <= 8'h00;\n        end else if (sign) begin\n            abs_dividend <= -dividend;\n        end else begin\n            abs_dividend <= dividend;\n        end\n    end\n\n    // Negative Divisor Calculation\n    always @(posedge clk) begin\n        if (rst) begin\n            neg_divisor <= 8'h00;\n        end else if (sign) begin\n            neg_divisor <= -divisor;\n        end else begin\n            neg_divisor <= divisor;\n        end\n    end\n\n    // Division Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 4'h0;\n            shift_reg <= 16'h0;\n            quotient <= 16'h0;\n            remainder <= 16'h0;\n        end else if (opn_valid) begin\n            counter <= 4'h0;\n            shift_reg <= {8'h0, abs_dividend};\n            quotient <= 16'h0;\n            remainder <= 16'h0;\n        end else if (counter < 4'h4) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], 1'b0};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h4) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], neg_divisor[7]};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h5) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], neg_divisor[6:0]};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h6) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], neg_divisor[5:0]};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h7) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], neg_divisor[4:0]};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h8) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg[14:0], neg_divisor[3:0]};\n            quotient <= quotient + (shift_reg[15] ? 16'hFFFF : 16'h0000);\n            remainder <= shift_reg[15:8];\n        end else if (counter == 4'h9) begin\n            counter <= counter + 4'h1;\n            shift_reg <= {shift_reg["}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // prep_dividend\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] dividend_prep;\n    wire [15:0] divisor_prep;\n\n    assign dividend_prep = {A[31:16], 16'b0};\n    assign divisor_prep = {B, 16'b0};\n\n    // div_operation\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] dividend_prep,\n    output wire [15:0] divisor_prep\n);\n\n    assign dividend_prep = {dividend[31:16], 16'b0};\n    assign divisor_prep = {divisor, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend_prep,\n    input wire [15:0] divisor_prep,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n\n    assign quotient = dividend_prep / divisor_prep;\n    assign remainder = dividend_prep % divisor_prep;\n\nendmodule\n"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    // This submodule performs the division algorithm\n    // and updates the quotient and remainder.\n    // The submodule should be defined here.\n    //\n    // Note: This submodule should be defined in the correct\n    // location, and should be named correctly.\n    //\n    // Hint: Use a simple division algorithm to implement the\n    // submodule.\n    //\n    // Module name: div_ctrl_unit\n    // Input ports:\n    //     A: 16-bit dividend.\n    //     B: 8-bit divisor.\n    // Output ports:\n    //     result: 16-bit quotient.\n    //     odd: 16-bit remainder.\n    // Implementation:\n    //     ...\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire [7:0] carry;\n\nassign B_comp = ~B + 1;\nassign {B_out, sum} = A + B_comp;\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin\n        if (i == 0) begin\n            assign D[i] = sum[i] ^ B_comp[i];\n        end else begin\n            assign D[i] = sum[i] ^ B_comp[i] ^ carry[i-1];\n        end\n        if (i == 0) begin\n            assign carry[i] = sum[i] & B_comp[i];\n        end else begin\n            assign carry[i] = sum[i] & B_comp[i] | sum[i] & carry[i-1];\n        end\n    end\nendgenerate\n\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nreg [7:0] D;\nreg B_out;\n\nwire [7:0] carry;\nwire [7:0] sum;\n\nassign {B_out, sum} = A + B;\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin\n        if (i == 0) begin\n            assign D[i] = sum[i] ^ B[i];\n        end else begin\n            assign D[i] = sum[i] ^ B[i] ^ carry[i-1];\n        end\n        if (i == 0) begin\n            assign carry[i] = sum[i] & B[i];\n        end else begin\n            assign carry[i] = sum[i] & B[i] | sum[i] & carry[i-1];\n        end\n    end\nendgenerate\n\nendmodule\n\nmodule full_adder(A, B, Cin, sum, Cout);\ninput A, B, Cin;\noutput sum, Cout;\n\nassign sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (B & Cin) | (Cin & A);\n\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\ninput [31:0] A, B;\noutput [31:0] Diff;\noutput B_out;\n\nwire [15:0] Diff16, B_out16;\n\nsub_16bit sub16_1(A[15:0], B[15:0], Diff16, B_out16);\nsub_16bit sub16_2(A[31:16], B[31:16], Diff[15:0], B_out);\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\ninput [15:0] A, B;\noutput [15:0] Diff;\noutput B_out;\n\nwire [7:0] Diff8, B_out8;\n\nsub_8bit sub8_1(A[7:0], B[7:0], Diff8, B_out8);\nsub_8bit sub8_2(A[15:8], B[15:8], Diff[7:0], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\ninput [7:0] A, B;\noutput [7:0] Diff;\noutput B_out;\n\nwire [3:0] Diff4, B_out4;\n\nsub_4bit sub4_1(A[3:0], B[3:0], Diff4, B_out4);\nsub_4bit sub4_2(A[7:4], B[7:4], Diff[3:0], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\ninput [3:0] A, B;\noutput [3:0] Diff;\noutput B_out;\n\nwire [1:0] Diff2, B_out2;\n\nsub_2bit sub2_1(A[1:0], B[1:0], Diff2, B_out2);\nsub_2bit sub2_2(A[3:2], B[3:2], Diff[1:0], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\ninput [1:0] A, B;\noutput [1:0] Diff;\noutput B_out;\n\nwire [0:0] Diff1, B_out1;\n\nsub_1bit sub1_1(A[0], B[0], Diff1, B_out1);\nsub_1bit sub1_2(A[1], B[1], Diff[0], B_out);\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\ninput A, B;\noutput Diff;\noutput B_out;\n\nassign Diff = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [0:0] D0, D1;\nwire B0, B1;\n\nsub_1bit sub0(A[0], B[0], D0, B0);\nsub_1bit sub1(A[1], B[1], D1, B1);\n\nassign D = {D1, D0};\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A ^ B;\nassign B_out = A & B;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D[15:0];\n\nwire [3:1] B_out_sub1, B_out_sub2, B_out_sub3, B_out_sub4;\nwire [3:1] D_sub1[14:0], D_sub2[13:0], D_sub3[12:0], D_sub4[11:0];\n\n// submodule instantiation\nsub1 sub1_inst (\n    .A(A[16:1]),\n    .B(B[16:1]),\n    .D(D_sub1[14:0]),\n    .B_out(B_out_sub1)\n);\n\nsub2 sub2_inst (\n    .A(D_sub1[14:0]),\n    .B(B[16:1]),\n    .D(D_sub2[13:0]),\n    .B_out(B_out_sub2)\n);\n\nsub3 sub3_inst (\n    .A(D_sub2[13:0]),\n    .B(B[16:1]),\n    .D(D_sub3[12:0]),\n    .B_out(B_out_sub3)\n);\n\nsub4 sub4_inst (\n    .A(D_sub3[12:0]),\n    .B(B[16:1]),\n    .D(D_sub4[11:0]),\n    .B_out(B_out_sub4)\n);\n\n// B_out\nassign B_out = B_out_sub1[3] | B_out_sub2[3] | B_out_sub3[3] | B_out_sub4[3];\n\n// D\nassign D[16:1] = {D_sub4[11:0], D_sub3[12:0], D_sub2[13:0], D_sub1[14:0]};\n\nendmodule\n\nmodule sub1(A, B, D, B_out);\ninput [3:1] A, B;\noutput [3:1] D;\noutput B_out;\n\nwire [3:1] B_out;\nwire [3:1] D_sub1[2:0], D_sub2[2:0];\n\n// submodule instantiation\nsub1_sub1 sub1_sub1_inst (\n    .A(A[3:1]),\n    .B(B[3:1]),\n    .D(D_sub1[2:0]),\n    .B_out(B_out)\n);\n\nsub1_sub2 sub1_sub2_inst (\n    .A(D_sub1[2:0]),\n    .B(B[3:1]),\n    .D(D_sub2[2:0]),\n    .B_out(B_out)\n);\n\n// B_out\nassign B_out = B_out | B_out;\n\n// D\nassign D[3:1] = {D_sub2[2:0], D_sub1[2:0]};\n\nendmodule\n\nmodule sub1_sub1(A, B, D, B_out);\ninput [2:1] A, B;\noutput [2:1] D;\noutput B_out;\n\nwire [2:1] B_out;\nwire [2:1] D_sub1[1:0], D_sub2[1:0];\n\n// submodule instantiation\nsub1_sub1_sub1 sub1_sub1_sub1_inst (\n    .A(A[2:1]),\n    .B(B[2:1]),\n    .D(D_sub1[1:0]),\n    .B_out(B_out)\n);\n\nsub1_sub1_sub2 sub1_sub1_sub2_inst (\n    .A(D_sub1[1:0]),\n    .B(B[2:1]),\n    .D(D_sub2[1:0]),\n    .B_out(B_out)\n);\n"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\nwire borrow;\n\n// Subtractor\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .sub_result(sub_result),\n    .borrow(borrow)\n);\n\n// Comparison Logic\nassign A_greater = (sub_result == 32'b0);\nassign A_equal = (sub_result == 32'b0) && (borrow == 1'b0);\nassign A_less = (sub_result != 32'b0) && (borrow == 1'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // 32-bit subtraction result\n    output borrow         // Carry out\n);\n\nassign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nassign S[32:1] = A[32:1] ^ B[32:1];\nassign C32 = (A[1] & B[1]) | (A[2] & B[2]) | (A[3] & B[3]) | (A[4] & B[4]) | (A[5] & B[5]) | (A[6] & B[6]) | (A[7] & B[7]) | (A[8] & B[8]) | (A[9] & B[9]) | (A[10] & B[10]) | (A[11] & B[11]) | (A[12] & B[12]) | (A[13] & B[13]) | (A[14] & B[14]) | (A[15] & B[15]) | (A[16] & B[16]) | (A[17] & B[17]) | (A[18] & B[18]) | (A[19] & B[19]) | (A[20] & B[20]) | (A[21] & B[21]) | (A[22] & B[22]) | (A[23] & B[23]) | (A[24] & B[24]) | (A[25] & B[25]) | (A[26] & B[26]) | (A[27] & B[27]) | (A[28] & B[28]) | (A[29] & B[29]) | (A[30] & B[30]) | (A[31] & B[31]);\nassign S[1:0] = A[1:0] ^ B[1:0];\n\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\nwire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [3:0] rca1_cout, rca2_cout, rca3_cout;\n\n// ripple carry adder\nwire [3:0] rca1_a, rca1_b, rca1_cin;\nwire [3:0] rca2_a, rca2_b, rca2_cin;\nwire [3:0] rca3_a, rca3_b, rca3_cin;\n\nassign rca1_a = a[3:0];\nassign rca1_b = b[3:0];\nassign rca1_cin = cin;\nassign rca1_sum = rca1_a ^ rca1_b ^ rca1_cin;\nassign rca1_cout = (rca1_a & rca1_b) | (rca1_a & rca1_cin) | (rca1_b & rca1_cin);\n\nassign rca2_a = rca1_sum;\nassign rca2_b = b[7:4];\nassign rca2_cin = rca1_cout;\nassign rca2_sum = rca2_a ^ rca2_b ^ rca2_cin;\nassign rca2_cout = (rca2_a & rca2_b) | (rca2_a & rca2_cin) | (rca2_b & rca2_cin);\n\nassign rca3_a = rca2_sum;\nassign rca3_b = b[11:8];\nassign rca3_cin = rca2_cout;\nassign rca3_sum = rca3_a ^ rca3_b ^ rca3_cin;\nassign rca3_cout = (rca3_a & rca3_b) | (rca3_a & rca3_cin) | (rca3_b & rca3_cin);\n\n// carry select adder slice\nwire [3:0] csa_slice1_a, csa_slice1_b, csa_slice1_cin;\nwire [3:0] csa_slice2_a, csa_slice2_b, csa_slice2_cin;\nwire [3:0] csa_slice3_a, csa_slice3_b, csa_slice3_cin;\n\nassign csa_slice1_a = rca1_sum;\nassign csa_slice1_b = b[3:0];\nassign csa_slice1_cin = rca1_cout;\nassign csa_slice1_sum = csa_slice1_a ^ csa_slice1_b ^ csa_slice1_cin;\nassign csa_slice1_cout = (csa_slice1_a & csa_slice1_b) | (csa_slice1_a & csa_slice1_cin) | (csa_slice1_b & csa_slice1_cin);\n\nassign csa_slice2_a = csa_slice1_sum;\nassign csa_slice2_b = b[7:4];\nassign csa_slice2_cin = csa_slice1_cout;\nassign csa_slice2_sum = csa_slice2_a ^ csa_slice2_b ^ csa_slice2_cin;\nassign csa_slice2_cout = (csa_slice2_a & csa_slice2_b) | (csa_slice2_a & csa_slice2_cin) | (csa_slice2_b & csa_slice2_cin);\n\nassign csa_slice3_a = csa_slice2_sum;\nassign csa_slice3_b = b[11:8];\nassign csa_slice3_cin = csa_"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    // 8-bit adder implementation\n    // Replace the missing module with a simple adder implementation\n    assign {Co7, y7} = a[7] + b[7] + Cin;\n    assign {Co6, y6} = a[6] + b[6] + Co7;\n    assign {Co5, y5} = a[5] + b[5] + Co6;\n    assign {Co4, y4} = a[4] + b[4] + Co5;\n    assign {Co3, y3} = a[3] + b[3] + Co4;\n    assign {Co2, y2} = a[2] + b[2] + Co3;\n    assign {Co1, y1} = a[1] + b[1] + Co2;\n    assign {Co0, y0} = a[0] + b[0] + Co1;\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co0;\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0_sum, FA1_sum, FA2_sum, FA3_sum, FA4_sum, FA5_sum, FA6_sum, FA7_sum;\n    wire FA0_cout, FA1_cout, FA2_cout, FA3_cout, FA4_cout, FA5_cout, FA6_cout, FA7_cout;\n    \n    // FA0\n    assign {FA0_cout, FA0_sum} = a[0] + b[0] + cin;\n    \n    // FA1\n    assign {FA1_cout, FA1_sum} = a[1] + b[1] + FA0_cout;\n    \n    // FA2\n    assign {FA2_cout, FA2_sum} = a[2] + b[2] + FA1_cout;\n    \n    // FA3\n    assign {FA3_cout, FA3_sum} = a[3] + b[3] + FA2_cout;\n    \n    // FA4\n    assign {FA4_cout, FA4_sum} = a[4] + b[4] + FA3_cout;\n    \n    // FA5\n    assign {FA5_cout, FA5_sum} = a[5] + b[5] + FA4_cout;\n    \n    // FA6\n    assign {FA6_cout, FA6_sum} = a[6] + b[6] + FA5_cout;\n    \n    // FA7\n    assign {FA7_cout, FA7_sum} = a[7] + b[7] + FA6_cout;\n    \n    // Final sum and cout\n    assign sum = FA7_sum;\n    assign cout = FA7_cout;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [3:0] shift_count;\nreg [31:0] product;\nreg done_flag;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'd0;\n        product <= 32'd0;\n        done_flag <= 1'b0;\n    end else begin\n        if (start) begin\n            shift_count <= 4'd0;\n            product <= 32'd0;\n            done_flag <= 1'b0;\n        end else begin\n            if (shift_count == 4'd15) begin\n                shift_count <= 4'd0;\n                done_flag <= 1'b1;\n            end else begin\n                shift_count <= shift_count + 4'd1;\n                done_flag <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register Unit.\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 16'd0;\n        b_reg <= 16'd0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit.\nreg [15:0] m_reg;\nreg [31:0] p_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        m_reg <= 16'd0;\n        p_reg <= 32'd0;\n    end else begin\n        if (start) begin\n            m_reg <= b_reg;\n            p_reg <= 32'd0;\n        end else begin\n            if (shift_count == 4'd0) begin\n                p_reg <= p_reg + (m_reg & a_reg);\n            end else begin\n                m_reg <= {m_reg[14:0], 1'b0};\n            end\n        end\n    end\nend\n\n// Output Assignment.\nassign yout = p_reg;\nassign done = done_flag;\n\nendmodule"}
