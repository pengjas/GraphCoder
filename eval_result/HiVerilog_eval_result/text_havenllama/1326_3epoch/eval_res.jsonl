{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\n\nu_counter_logic u_logic (\n    .clk(clk),\n    .reset(reset),\n    .count_in(count),\n    .up_down(up_down),\n    .count_out(next_count)\n);\n\nu_counter_register u_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count_out(count)\n);\n\nendmodule\n\nmodule u_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count_in,\n    input wire up_down,\n    output wire [15:0] count_out\n);\n\nwire [15:0] next_count;\n\nassign next_count = (up_down == 1) ? count_in + 1 : count_in - 1;\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 16'b0;\n    else\n        count <= next_count;\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] state;\n    wire [7:0] next_state;\n\n    ring_counter_init init_module (\n        .clk(clk),\n        .reset(reset),\n        .out(state)\n    );\n\n    ring_counter_transition trans_module (\n        .clk(clk),\n        .state(state),\n        .next_state(next_state)\n    );\n\n    assign out = state;\n\nendmodule\n\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule ring_counter_transition (\n    input wire clk,\n    input wire [7:0] state,\n    output reg [7:0] next_state\n);\n    always @(*) begin\n        case (state)\n            8'b0000_0001: next_state = 8'b0000_0001;\n            8'b0000_0010: next_state = 8'b0000_0010;\n            8'b0000_0100: next_state = 8'b0000_0100;\n            8'b0000_1000: next_state = 8'b0000_1000;\n            8'b0001_0000: next_state = 8'b0001_0000;\n            8'b0010_0000: next_state = 8'b0010_0000;\n            8'b0100_0000: next_state = 8'b0100_0000;\n            8'b1000_0000: next_state = 8'b1000_0000;\n            default: next_state = 8'b0000_0001;\n        endcase\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] next_count;\n    reg [3:0] current_count;\n    reg [3:0] next_output;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .next_count(next_count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .current_count(current_count),\n        .next_output(next_output)\n    );\n\n    assign out = next_output;\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] next_count\n);\n    reg [3:0] next_count_internal;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_count_internal <= 4'b0000;\n        end else if (valid_count) begin\n            next_count_internal <= next_count_internal + 1;\n        end\n    end\n\n    assign next_count = next_count_internal;\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] current_count,\n    output [3:0] next_output\n);\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!valid_count) begin\n            next_output <= current_count;\n        end else begin\n            next_output <= current_count;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_state;\n\n    // Instantiate the register module.\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_state)\n    );\n\n    // Instantiate the logic module.\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .current_state(next_state),\n        .next_state(Q)\n    );\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         current_state,\n    output reg [63:0]    next_state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state <= {current_state[62:0], current_state[63]};\n        end\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire clk_50_out, clk_10_out, clk_1_out;\n\nclk_div_2 clk_div_50 (\n    .clk_in(CLK_in),\n    .clk_out(clk_50_out)\n);\n\nclk_div_10 clk_div_10 (\n    .clk_in(CLK_in),\n    .clk_out(clk_10_out)\n);\n\nclk_div_100 clk_div_1 (\n    .clk_in(CLK_in),\n    .clk_out(clk_1_out)\n);\n\nreg clk_50, clk_10, clk_1;\nreg [1:0] count_50, count_10, count_1;\n\nassign CLK_50 = clk_50_out;\nassign CLK_10 = clk_10_out;\nassign CLK_1 = clk_1_out;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        clk_50 <= 0;\n        clk_10 <= 0;\n        clk_1 <= 0;\n        count_50 <= 0;\n        count_10 <= 0;\n        count_1 <= 0;\n    end else begin\n        if (count_50 == 1) begin\n            clk_50 <= ~clk_50;\n            count_50 <= 0;\n        end else begin\n            count_50 <= count_50 + 1;\n        end\n        if (count_10 == 3) begin\n            clk_10 <= ~clk_10;\n            count_10 <= 0;\n        end else begin\n            count_10 <= count_10 + 1;\n        end\n        if (count_1 == 49) begin\n            clk_1 <= ~clk_1;\n            count_1 <= 0;\n        end else begin\n            count_1 <= count_1 + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_div_2 (\n    input clk_in,\n    output reg clk_out\n);\n\nreg [1:0] count;\n\nalways @(posedge clk_in) begin\n    if (count == 1) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_10 (\n    input clk_in,\n    output reg clk_out\n);\n\nreg [3:0] count;\n\nalways @(posedge clk_in) begin\n    if (count == 3) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_100 (\n    input clk_in,\n    output reg clk_out\n);\n\nreg [5:0] count;\n\nalways @(posedge clk_in) begin\n    if (count == 49) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_50 (\n    input clk_in,\n    output reg clk_out\n);\n\nreg [1:0] count;\n\nalways @(posedge clk_in) begin\n    if (count == 1) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_10 (\n    input clk_in,\n    output reg clk_out\n);\n\nreg [2:0] count;\n\nalways @(posedge clk_in) begin\n    if (count == 3) begin\n        clk_out <= ~clk_out;\n        count <= 0;\n    end else begin\n"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7; // Divide factor.\n\nwire clk_div_4;\nwire clk_div_3;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_out(clk_div_4)\n);\n\nclk_average u_clk_average(\n    .clk(clk),\n    .clk_div_in(clk_div_4),\n    .clk_div_out(clk_div_3)\n);\n\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .clk_div_in(clk_div_3),\n    .clk_div_out(clk_div)\n);\n\nassign clk_div = clk_div_4 | clk_div_3;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div_out\n);\n    reg [3:0] cnt;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == MUL2_DIV_CLK)\n            clk_div_out <= 1;\n        else\n            clk_div_out <= 0;\n        cnt <= cnt + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div_in,\n    output reg          clk_div_out\n);\n    reg [1:0] cnt;\n\n    always @(posedge clk) begin\n        if (cnt == 0)\n            clk_div_out <= 0;\n        else if (cnt == 1)\n            clk_div_out <= clk_div_in;\n        else if (cnt == 2)\n            clk_div_out <= 0;\n        else\n            clk_div_out <= 1;\n        cnt <= cnt + 1;\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_in,\n    output reg          clk_div_out\n);\n    reg [1:0] cnt;\n\n    always @(negedge clk) begin\n        if (cnt == 0)\n            clk_div_out <= clk_div_in;\n        else if (cnt == 1)\n            clk_div_out <= ~clk_div_in;\n        else\n            clk_div_out <= clk_div_out;\n        cnt <= cnt + 1;\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1, clk_div2;\n\n// Increase the divisor by 1\nassign clk_div1 = pos_edge_counter.clk_div;\nassign clk_div2 = neg_edge_counter.clk_div;\n\n// Instantiate the submodules\npos_edge_counter pos_edge_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter neg_edge_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter MAX_COUNT = NUM_DIV - 1;\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end else if (count < MAX_COUNT) begin\n        count <= count + 1;\n        clk_div <= 0;\n    end else begin\n        count <= 0;\n        clk_div <= 1;\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter MAX_COUNT = NUM_DIV - 1;\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end else if (count < MAX_COUNT) begin\n        count <= count + 1;\n        clk_div <= 0;\n    end else begin\n        count <= 0;\n        clk_div <= 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            counter <= 0;\n        end else begin\n            if(counter == NUM_DIV / 2 - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            q <= 0;\n        end else begin\n            if(q == NUM_DIV / 2 - 1) begin\n                q <= 0;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if(q == NUM_DIV / 2 - 1) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] c;\n    wire [31:0] z;\n    wire [31:0] n;\n    wire [31:0] v;\n\n    assign {carry, c} = a + b;\n    assign {z, zero} = c == 0;\n    assign {n, negative} = c[31];\n    assign v = (aluc == 6'b101010) ? ~(a < b) : 0;\n    assign overflow = (aluc == 6'b101010) ? v : 0;\n    assign flag = (aluc == 6'b101010) ? v : 0;\n    assign r = c;\n\n    submodule add(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign {carry, c} = a + b;\n    endsubmodule\n\n    submodule addu(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign {carry, c} = a + b;\n    endsubmodule\n\n    submodule sub(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign {carry, c} = a - b;\n    endsubmodule\n\n    submodule subu(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign {carry, c} = a - b;\n    endsubmodule\n\n    submodule and1(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign c = a & b;\n    endsubmodule\n\n    submodule or1(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign c = a | b;\n    endsubmodule\n\n    submodule xor1(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign c = a ^ b;\n    endsubmodule\n\n    submodule nor1(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign c = ~(a | b);\n    endsubmodule\n\n    submodule slt(\n        input [31:0] a,\n        input [31:0] b,\n        output c\n    );\n        assign c = a < b;\n    endsubmodule\n\n    submodule sltu(\n        input [31:0] a,\n        input [31:0] b,\n        output c\n    );\n        assign c = a < b;\n    endsubmodule\n\n    submodule sll(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] c\n    );\n        assign c = a << b;\n    endsubmodule\n\n    submodule srl(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] c\n    );\n        assign c = a >> b;\n    endsubmodule\n\n    submodule sra(\n        input [31:0] a,\n        input [4:0] b,\n        output [31:0] c\n    );\n        assign c = $signed(a) >>> b;\n    endsubmodule\n\n    submodule sllv(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] c\n    );\n        assign c = a << b[4:0];\n    endsubmodule\n\n    submodule srlv(\n        input [31:0] a,\n        input [31:0] b,\n       "}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [31:0] mul_res;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .mul_res(mul_res)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .mul_res(mul_res),\n        .current_value(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mul_res\n);\n    assign mul_res = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mul_res,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mul_res[31:0];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] opcode, ad;\n    wire [7:0] data1;\n\n    // Instruction register\n    reg [2:0] ins_p1, ins_p2;\n    reg [4:0] ad_p1, ad_p2;\n    reg [7:0] data_p1, data_p2;\n\n    // Instruction input ports\n    assign ins[0] = ins_p1[0];\n    assign ins[1] = ins_p2[0];\n    assign ins[2] = ins_p1[1];\n\n    // Address input ports\n    assign ad1 = ad_p1;\n    assign ad2 = ad_p2;\n\n    // Instruction output ports\n    assign ins_p1 = (fetch == 2'b01) ? data : ins_p1;\n    assign ins_p2 = (fetch == 2'b10) ? data : ins_p2;\n    assign ad_p1 = (fetch == 2'b01) ? data[4:0] : ad_p1;\n    assign ad_p2 = (fetch == 2'b10) ? data[4:0] : ad_p2;\n    assign data_p1 = (fetch == 2'b01) ? data : data_p1;\n    assign data_p2 = (fetch == 2'b10) ? data : data_p2;\n    assign ad = (fetch == 2'b01) ? data[4:0] : data[7:2];\n\n    // Clock\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            ins_p1 <= 0;\n            ins_p2 <= 0;\n            ad_p1 <= 0;\n            ad_p2 <= 0;\n            data_p1 <= 0;\n            data_p2 <= 0;\n        end else begin\n            ins_p1 <= ins_p1;\n            ins_p2 <= ins_p2;\n            ad_p1 <= ad_p1;\n            ad_p2 <= ad_p2;\n            data_p1 <= data_p1;\n            data_p2 <= data_p2;\n        end\n    end\nendmodule\n\n// Instruction register for data fetched from RAM/ROM\nmodule ins_reg_ram (\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(*) begin\n        ins = data[7:5];\n        ad = data[4:0];\n    end\nendmodule\n\n// Instruction register for data fetched from register\nmodule ins_reg_reg (\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n    always @(*) begin\n        ins = data[7:5];\n        ad = data[4:0];\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n    \n    counter counter(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator wave_generator(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n    \n    assign enable = (freq > 0);\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= ((freq - 1) == count);\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 5'b00001;\n                2'b01: wave_reg <= wave_reg - 5'b00001;\n                default: wave_reg <= wave_reg;\n            endcase\n            state <= state + 1;\n            if (state == 2'b11) state <= 2'b00;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) state <= 2'b00;\n        else state <= state + 1;\n    end\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) wave <= 5'b00000;\n        else begin\n            case (state)\n                2'b00: wave <= wave + 5'b00001;\n                2'b01: wave <= wave - 5'b00001;\n                default: wave <= wave;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [3:0] q_array;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(q_array[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q_array[0]),\n        .q(q_array[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q_array[1]),\n        .q(q_array[2])\n    );\n\n    my_dff8 u3 (\n        .clk(clk),\n        .d(q_array[2]),\n        .q(q_array[3])\n    );\n\n    assign q = (sel == 2'b00) ? d :\n               (sel == 2'b01) ? q_array[0] :\n               (sel == 2'b10) ? q_array[1] :\n                                q_array[2];\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux4to1 (\n    input [3:0] in_array,\n    input [1:0] sel,\n    output reg q\n);\n    always @(*) begin\n        q = (sel == 2'b00) ? in_array[0] :\n             (sel == 2'b01) ? in_array[1] :\n                              in_array[2] :\n                                in_array[3];\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q_internal;\n    wire q_internal_1;\n    wire q_internal_2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q_internal)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q_internal),\n        .q(q_internal_1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q_internal_1),\n        .q(q_internal_2)\n    );\n\n    assign q = q_internal_2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] mux0, mux1, mux2, mux3, mux4, mux5, mux6;\n\n    mux2X1 mux0_inst (\n        .in0(in),\n        .in1(mux1),\n        .sel(ctrl[2]),\n        .out(mux0)\n    );\n\n    mux2X1 mux1_inst (\n        .in0(mux0),\n        .in1(mux2),\n        .sel(ctrl[1]),\n        .out(mux1)\n    );\n\n    mux2X1 mux2_inst (\n        .in0(mux1),\n        .in1(mux3),\n        .sel(ctrl[0]),\n        .out(mux2)\n    );\n\n    mux2X1 mux3_inst (\n        .in0(mux0),\n        .in1(mux4),\n        .sel(ctrl[2]),\n        .out(mux3)\n    );\n\n    mux2X1 mux4_inst (\n        .in0(mux1),\n        .in1(mux5),\n        .sel(ctrl[1]),\n        .out(mux4)\n    );\n\n    mux2X1 mux5_inst (\n        .in0(mux2),\n        .in1(mux6),\n        .sel(ctrl[0]),\n        .out(mux5)\n    );\n\n    mux2X1 mux6_inst (\n        .in0(mux3),\n        .in1(mux4),\n        .sel(ctrl[2]),\n        .out(mux6)\n    );\n\n    assign out = mux6;\n\nendmodule\n\nmodule mux2X1 (in0, in1, sel, out);\n    input in0, in1, sel;\n    output out;\n    assign out = sel ? in1 : in0;\nendmodule\n"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n\n  // First PE\n  wire [31:0] pe0_out;\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  assign c0 = pe0_out;\n\n  // Second PE\n  wire [31:0] pe1_out;\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  assign c1 = pe1_out;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n\n  wire [31:0] p;\n\n  assign p = a * b;\n  assign out = p;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetched_instr, decoded_instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_res;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .fetched_instr(fetched_instr)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetched_instr),\n    .decoded_instr(decoded_instr)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(decoded_instr),\n    .reg_file(reg_file),\n    .alu_res(alu_res)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .reg_file(res_reg_file)\n  );\n\n  stage pipe_reg_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetched_instr),\n    .decoded_instr(decoded_instr),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file)\n  );\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] fetched_instr\n);\n  reg [4:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      fetched_instr <= 0;\n      pc <= 0;\n    end else begin\n      fetched_instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] fetched_instr, decoded_instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_res;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .fetched_instr(fetched_instr)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetched_instr),\n    .decoded_instr(decoded_instr)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(decoded_instr),\n    .reg_file(reg_file),\n    .alu_res(alu_res)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .reg_file(res_reg_file)\n  );\n\n  stage pipe_reg_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetched_instr),\n    .decoded_instr(decoded_instr),\n    .alu_res(alu_res),\n"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b1_reg, b2_reg, b3_reg;\n\n  // Instantiate PEs\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1_reg),\n    .c(c1)\n  );\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2_reg),\n    .c(c2)\n  );\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3_reg),\n    .c(c3)\n  );\n\n  // Update the b values\n  always @(posedge clk) begin\n    if (rst) begin\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b1_reg <= b0;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr;\n    wire [4:0] rd, rs1, rs2;\n    wire [5:0] opcode;\n    wire [31:0] op1, op2, result;\n    wire [6:0] func;\n\n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr(instr)\n    );\n    execute_stage execute(\n        .clk(clk),\n        .rst(rst),\n        .op1(op1),\n        .op2(op2),\n        .func(func),\n        .result(result)\n    );\n    writeback_stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .reg_file(reg_file),\n        .rd(rd),\n        .result(result)\n    );\n    assign pc = 0;\n    assign out_reg_file = result;\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] instr\n);\n    reg [31:0] pc_reg;\n    reg [31:0] instr_reg;\n    assign instr = instr_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc_reg <= 0;\n            instr_reg <= 0;\n        end else begin\n            instr_reg <= instr_mem[pc_reg];\n            pc_reg <= pc_reg + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] op1,\n    input [31:0] op2,\n    input [5:0] func,\n    output [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] func_result;\n\n    assign result = func_result;\n    assign add_result = op1 + op2;\n    assign sub_result = op1 - op2;\n\n    always @(op1 or op2 or func) begin\n        case(func)\n            6'b000000: func_result = add_result;\n            6'b000010: func_result = sub_result;\n            default: func_result = 32'bx;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    input [4:0] rd,\n    input [31:0] result\n);\n    reg [31:0] reg_file_reg [0:31];\n    reg [4:0] rd_reg;\n    reg [31:0] result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rd_reg <= 0;\n            result_reg <= 0;\n            reg_file_reg <= 0;\n        end else begin\n            reg_file_reg[rd_reg] <= result_reg;\n            rd_reg <= rd;\n            result_reg <= result;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [3:0] valid_cnt;\n\n    // Counter Module\n    accu_counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_cnt(valid_cnt)\n    );\n\n    // Data Accumulator Module\n    accu_data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Valid Output Module\n    accu_valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_cnt(valid_cnt),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule accu_counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [3:0]  valid_cnt\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_cnt <= 0;\n        else if (valid_in)\n            valid_cnt <= valid_cnt + 1;\n    end\n\nendmodule\n\nmodule accu_data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n\n    output reg  [9:0]  data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule accu_valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   valid_cnt,\n\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (valid_cnt == 4)\n            valid_out <= 1;\n        else if (valid_cnt == 0)\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    \n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [3:0] ctrl_cnt;\n    wire [7:0] shift_reg;\n    wire [15:0] res;\n    wire div_finished;\n    \n    // Absolute Value Calculation\n    abs_value abs_dividend_calc(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(dividend),\n        .output(abs_dividend)\n    );\n    \n    // Negative Divisor Calculation\n    neg_value neg_divisor_calc(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(divisor),\n        .output(neg_divisor)\n    );\n    \n    // Division Control Logic\n    divider_control div_cnt(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .ready(res_ready),\n        .divisor(neg_divisor),\n        .counter(ctrl_cnt)\n    );\n    \n    // Result Management\n    result_mgmt res_mgmt(\n        .clk(clk),\n        .rst(rst),\n        .ctrl_cnt(ctrl_cnt),\n        .res_ready(res_ready),\n        .divisor(divisor),\n        .remainder(shift_reg[7:0]),\n        .quotient(shift_reg[15:8]),\n        .res_valid(res_valid),\n        .res(res)\n    );\n    \n    // Result Output\n    assign result = res;\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            output <= 0;\n        else if (sign)\n            output <= -input;\n        else\n            output <= input;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            output <= 0;\n        else if (sign)\n            output <= ~input + 1;\n        else\n            output <= input;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire ready,\n    input wire [7:0] divisor,\n    output reg [3:0] counter\n);\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            counter <= 0;\n        else if (opn_valid && !ready) begin\n            counter <= 4;\n        end else if (!ready) begin\n            counter <= counter - 1;\n        end\n    end\nendmodule\n\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] ctrl_cnt,\n    input wire res_ready,\n    input wire [7:0] divisor,\n    input wire [7:0] remainder,\n    input wire [7:0] quotient,\n    output reg res_valid,\n    output reg [15:0] res\n);\n    \n    reg [15:0] q_reg;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            q_reg <= 0;\n        end else if (ctrl_cnt == 4) begin\n            res_valid <= 1;\n            q_reg <= quotient;\n        end else if (res_ready && res_valid) begin\n            res_valid <= 0;\n            q_reg <= quotient;"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [63:0] B_ext; // Extended divisor for 32-bit division\n    wire [31:0] A_prep; // Prepared dividend for division\n    wire [31:0] Q_op; // Quotient from division operation\n    wire [31:0] R_op; // Remainder from division operation\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .B_ext(B_ext),\n        .A_prep(A_prep)\n    );\n\n    div_operation div_op_inst(\n        .A(A_prep),\n        .B_ext(B_ext),\n        .Q_op(Q_op),\n        .R_op(R_op)\n    );\n\n    assign result = Q_op;\n    assign odd = R_op;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [63:0] B_ext,\n    output reg [31:0] A_prep\n);\n    always @(*) begin\n        B_ext = {{16{B[15]}}, B}; // Extend divisor to 64 bits\n        A_prep = A;\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,\n    input wire [63:0] B_ext,\n    output reg [31:0] Q_op,\n    output reg [31:0] R_op\n);\n    integer i;\n    reg [31:0] dividend;\n    reg [15:0] divisor;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B_ext[15:0];\n        Q_op = 0;\n        R_op = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (dividend[31] == 1) begin\n                Q_op[31] = 1;\n                dividend = dividend - divisor;\n            end\n            dividend = {dividend[30:0], 1'b0};\n        end\n\n        R_op = dividend;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit submodule\n    div_ctrl ctrl (\n        .dividend(A),\n        .divisor(B),\n        .quotient(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [7:0] divisor_tmp;\n    reg [15:0] dividend_tmp;\n    reg [2:0] count;\n\n    always @(*) begin\n        divisor_tmp = divisor;\n        dividend_tmp = dividend;\n        count = 0;\n        quotient = 0;\n        remainder = 0;\n    end\n\n    // Shift dividend to the left by 1 bit\n    always @(dividend_tmp) begin\n        dividend_tmp = {dividend_tmp[14:0], 1'b0};\n    end\n\n    // Compare divisor with the shifted dividend\n    always @(dividend_tmp or divisor_tmp) begin\n        if (dividend_tmp >= divisor_tmp) begin\n            count = count + 1;\n            dividend_tmp = dividend_tmp - divisor_tmp;\n        end\n    end\n\n    // Update quotient and remainder\n    always @(count or dividend or divisor) begin\n        quotient = dividend / divisor;\n        remainder = dividend % divisor;\n    end\n\nendmodule\n"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n    wire [7:0] B_complement;\n\n    assign B_complement = ~B + 1;\n\n    adder_8bit adder_inst(.A(A), .B(B_complement), .C(1'b0), .D(D), .G(B_out));\n\nendmodule\n\nmodule adder_8bit(A, B, C, D, G);\n    input [7:0] A;\n    input [7:0] B;\n    input C;\n    output [7:0] D;\n    output G;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    full_adder fa0(.A(A[0]), .B(B[0]), .C(C), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder fa1(.A(A[1]), .B(B[1]), .C(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder fa2(.A(A[2]), .B(B[2]), .C(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder fa3(.A(A[3]), .B(B[3]), .C(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder fa4(.A(A[4]), .B(B[4]), .C(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder fa5(.A(A[5]), .B(B[5]), .C(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder fa6(.A(A[6]), .B(B[6]), .C(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder fa7(.A(A[7]), .B(B[7]), .C(carry[6]), .Sum(sum[7]), .Cout(G));\n\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, C, Sum, Cout);\n    input A;\n    input B;\n    input C;\n    output Sum;\n    output Cout;\n\n    assign {Cout, Sum} = A + B + C;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out, S2_out;\n    wire [15:0] A_high, B_high;\n    wire [15:0] A_low, B_low;\n\n    // Instantiate 16-bit subtractor blocks.\n    sub_16bit S1(.A(A[31:16]), .B(B[31:16]), .Diff(S1_out), .B_out(B_high));\n    sub_16bit S2(.A(A[15:0]), .B(B[15:0]), .Diff(S2_out), .B_out(B_low));\n\n    // Generate output Diff and Borrow-out.\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_high[15] & B_low[15];\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1_out, S2_out;\n    wire [7:0] A_high, B_high;\n    wire [7:0] A_low, B_low;\n\n    // Instantiate 8-bit subtractor blocks.\n    sub_8bit S1(.A(A[15:8]), .B(B[15:8]), .Diff(S1_out), .B_out(B_high));\n    sub_8bit S2(.A(A[7:0]), .B(B[7:0]), .Diff(S2_out), .B_out(B_low));\n\n    // Generate output Diff and Borrow-out.\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_high[7] & B_low[7];\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    // Instantiate 4-bit subtractor blocks.\n    sub_4bit S1(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[7:4]), .B_out(B_out));\n    sub_4bit S2(.A(A[3:0]), .B(B[3:0]), .Diff(Diff[3:0]), .B_out(B_out));\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    // Instantiate 2-bit subtractor blocks.\n    sub_2bit S1(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[3:2]), .B_out(B_out));\n    sub_2bit S2(.A(A[1:0]), .B(B[1:0]), .Diff(Diff[1:0]), .B_out(B_out));\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n\n    // Instantiate 1-bit subtractor blocks.\n    sub_1bit S1(.A(A[1]), .B(B[1]), .Diff(Diff[1]), .B_out(B_out));\n    sub_1bit S2(.A(A[0]), .B(B[0]), .Diff(Diff[0]), .B_out(B_out));\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A, B;\n    output Diff;\n    output B_out;\n\n    assign Diff = A ^ B;\n    assign B_out ="}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] diff[3:0], borrow[3:0];\n    wire [7:0] diff0, diff1, diff2, diff3, borrow0, borrow1, borrow2, borrow3;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(diff[0]),\n        .B_out(borrow[0])\n    );\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(diff[1]),\n        .B_out(borrow[1])\n    );\n    sub_16bit sub2(\n        .A(A[47:32]),\n        .B(B[47:32]),\n        .D(diff[2]),\n        .B_out(borrow[2])\n    );\n    sub_16bit sub3(\n        .A(A[63:48]),\n        .B(B[63:48]),\n        .D(diff[3]),\n        .B_out(borrow[3])\n    );\n\n    assign D = {diff[3], diff[2], diff[1], diff[0]};\n    assign B_out = borrow[3] | borrow[2] | borrow[1] | borrow[0];\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] diff0, diff1, borrow0, borrow1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(diff0),\n        .B_out(borrow0)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(diff1),\n        .B_out(borrow1)\n    );\n\n    assign D = {diff1, diff0};\n    assign B_out = borrow1 | borrow0;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] diff0, diff1, borrow0, borrow1;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(diff0),\n        .B_out(borrow0)\n    );\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(diff1),\n        .B_out(borrow1)\n    );\n\n    assign D = {diff1, diff0};\n    assign B_out = borrow1 | borrow0;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire diff0, diff1, borrow0, borrow1;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(diff0),\n        .B_out(borrow0)\n    );\n    sub_2bit sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(diff1),\n        .B_out(borrow1)\n    );\n\n    assign D = {diff1, diff0};\n    assign B_out = borrow1 | borrow0;\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\n    input [1:0] A, B;\n    output [1"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] borrow;\n\nsub_4bit sub1(.A(A[1:0]), .B(B[1:0]), .C(1'b0), .D(D[1:0]), .B_out(borrow[0]));\nsub_4bit sub2(.A(A[3:2]), .B(B[3:2]), .C(borrow[0]), .D(D[3:2]), .B_out(borrow[1]));\nsub_4bit sub3(.A(A[5:4]), .B(B[5:4]), .C(borrow[1]), .D(D[5:4]), .B_out(borrow[2]));\nsub_4bit sub4(.A(A[7:6]), .B(B[7:6]), .C(borrow[2]), .D(D[7:6]), .B_out(borrow[3]));\n\nassign B_out = borrow[3];\n\nendmodule\n\nmodule sub_4bit(A, B, C, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\ninput C;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] borrow;\n\nfull_subtractor fsub1(.A(A), .B(B), .C(C), .D(D[0]), .B_out(borrow[0]));\nfull_subtractor fsub2(.A(A), .B(B), .C(borrow[0]), .D(D[1]), .B_out(borrow[1]));\nfull_subtractor fsub3(.A(A), .B(B), .C(borrow[1]), .D(D[2]), .B_out(borrow[2]));\nfull_subtractor fsub4(.A(A), .B(B), .C(borrow[2]), .D(D[3]), .B_out(borrow[3]));\n\nassign B_out = borrow[3];\n\nendmodule\n\nmodule full_subtractor(A, B, C_in, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\ninput C_in;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] sum;\nwire [3:0] borrow;\n\nassign sum = A + B;\nassign B_out = C_in & (sum[3] | borrow[3]);\nassign borrow = {C_in & (~A[3] & ~sum[3]), C_in & (~A[2] & ~sum[2]), C_in & (~A[1] & ~sum[1]), C_in & (~A[0] & ~sum[0])};\nassign D = sum - borrow;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] A_B_diff;\n    wire borrow_greater, borrow_equal, borrow_less;\n    \n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .A_B_diff(A_B_diff),\n        .borrow_greater(borrow_greater),\n        .borrow_equal(borrow_equal),\n        .borrow_less(borrow_less)\n    );\n    \n    assign A_greater = (borrow_greater | (A_B_diff != 0)) & (A_equal == 0);\n    assign A_equal = (borrow_equal | (A_B_diff == 0)) & (A_greater == 0) & (A_less == 0);\n    assign A_less = (borrow_less | (A_B_diff == 0)) & (A_greater == 0) & (A_equal == 0);\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,       // First 32-bit input operand\n    input [31:0] B,       // Second 32-bit input operand\n    output [31:0] A_B_diff, // A - B\n    output borrow_greater, // Carry out for greater than case\n    output borrow_equal,   // Carry out for equal case\n    output borrow_less     // Carry out for less than case\n);\n    wire [31:0] carry_greater, carry_equal, carry_less;\n    wire [30:0] A_greater, A_equal, A_less;\n    \n    // Combinational subtraction logic\n    genvar i;\n    generate\n    for (i = 0; i < 31; i = i + 1) begin : bit_level_subtractor\n        assign A_greater[i] = (A[i] ^ B[i]) & ~(A[i] & B[i]);\n        assign A_equal[i] = (A[i] ^ B[i]) & (A[i] & B[i]);\n        assign A_less[i] = (A[i] ^ B[i]) & ~(A[i] & ~B[i]);\n    end\n    endgenerate\n    \n    // Carry generation logic for greater than case\n    assign carry_greater[0] = 1'b0;\n    assign carry_greater[1] = A_greater[0] | (A_greater[1] & carry_greater[0]);\n    assign carry_greater[2] = A_greater[1] | (A_greater[2] & carry_greater[1]);\n    assign carry_greater[3] = A_greater[2] | (A_greater[3] & carry_greater[2]);\n    assign carry_greater[4] = A_greater[3] | (A_greater[4] & carry_greater[3]);\n    assign carry_greater[5] = A_greater[4] | (A_greater[5] & carry_greater[4]);\n    assign carry_greater[6] = A_greater[5] | (A_greater[6] & carry_greater[5]);\n    assign carry_greater[7] = A_greater[6] | (A_greater[7] & carry_greater[6]);\n    assign carry_greater[8] = A_greater[7] | (A_greater[8] & carry_greater[7]);\n    assign carry_greater[9] = A_greater[8] | (A_greater[9] & carry_greater[8]);\n    assign carry_greater[10] = A_greater[9] | (A_greater[10] & carry_greater[9]);\n    assign carry_greater[11] = A_greater[10] | (A_greater[11] & carry_greater[10]);\n    assign carry_greater[12] = A_greater[11] | (A_greater[12] & carry_greater[11]);\n   "}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] CLA1_C15;\n    wire [15:1] CLA2_C15;\n    wire [15:1] CLA1_C14;\n    wire [15:1] CLA2_C14;\n    wire [15:1] CLA1_C13;\n    wire [15:1] CLA2_C13;\n    wire [15:1] CLA1_C12;\n    wire [15:1] CLA2_C12;\n    wire [15:1] CLA1_C11;\n    wire [15:1] CLA2_C11;\n    wire [15:1] CLA1_C10;\n    wire [15:1] CLA2_C10;\n    wire [15:1] CLA1_C9;\n    wire [15:1] CLA2_C9;\n    wire [15:1] CLA1_C8;\n    wire [15:1] CLA2_C8;\n    wire [15:1] CLA1_C7;\n    wire [15:1] CLA2_C7;\n    wire [15:1] CLA1_C6;\n    wire [15:1] CLA2_C6;\n    wire [15:1] CLA1_C5;\n    wire [15:1] CLA2_C5;\n    wire [15:1] CLA1_C4;\n    wire [15:1] CLA2_C4;\n    wire [15:1] CLA1_C3;\n    wire [15:1] CLA2_C3;\n    wire [15:1] CLA1_C2;\n    wire [15:1] CLA2_C2;\n    wire [15:1] CLA1_C1;\n    wire [15:1] CLA2_C1;\n    wire [15:1] CLA1_C0;\n    wire [15:1] CLA2_C0;\n\n    CLA CLA1(.A(A[16:1]), .B(B[16:1]), .C_in(0), .C_out(CLA1_C15));\n    CLA CLA2(.A(A[16:1]), .B(B[16:1]), .C_in(0), .C_out(CLA2_C15));\n    CLA CLA1(.A(A[15:1]), .B(B[15:1]), .C_in(CLA1_C15), .C_out(CLA1_C14));\n    CLA CLA2(.A(A[15:1]), .B(B[15:1]), .C_in(CLA2_C15), .C_out(CLA2_C14));\n    CLA CLA1(.A(A[14:1]), .B(B[14:1]), .C_in(CLA1_C14), .C_out(CLA1_C13));\n    CLA CLA2(.A(A[14:1]), .B(B[14:1]), .C_in(CLA2_C14), .C_out(CLA2_C13));\n    CLA CLA1(.A(A[13:1]), .B(B[13:1]), .C_in(CLA1_C13), .C_out(CLA1_C12));\n    CLA CLA2(.A(A[13:1]), .B(B[13:1]), .C_in(CLA2_C13), .C_out(CLA2_C12));\n    CLA CLA1(.A(A[12:1]), .B(B[12:1]), .C_in(CLA1_C12), .C_out(CLA1_C11));\n    CLA CLA2(.A"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry1, carry2;\nwire [3:0] sum1, sum2;\nwire [3:0] sum3;\nwire [3:0] sum4;\nwire [3:0] sum5;\nwire [3:0] sum6;\nwire [3:0] sum7;\nwire [3:0] sum8;\n\nwire [15:0] temp;\n\n// 4-bit ripple carry adder\nadder_4bit rca1(a[3:0], b[3:0], cin, temp[3:0], carry1[0]);\nadder_4bit rca2(a[7:4], b[7:4], carry1[0], temp[7:4], carry1[1]);\nadder_4bit rca3(a[11:8], b[11:8], carry1[1], temp[11:8], carry1[2]);\nadder_4bit rca4(a[15:12], b[15:12], carry1[2], temp[15:12], carry1[3]);\n\n// 4-bit carry select adder slices\ncarry_select_adder_slice csa1(temp[3:0], temp[7:4], temp[11:8], temp[15:12], carry1[0], carry1[1], carry1[2], carry1[3], sum1, sum2, cout);\ncarry_select_adder_slice csa2(sum1, sum2, temp[15:12], temp[15:12], cout, cout, cout, cout, sum3, sum4, cout);\ncarry_select_adder_slice csa3(sum3, sum4, temp[15:12], temp[15:12], cout, cout, cout, cout, sum5, sum6, cout);\ncarry_select_adder_slice csa4(sum5, sum6, temp[15:12], temp[15:12], cout, cout, cout, cout, sum7, sum8, cout);\n\nassign sum = {sum8, sum7, sum6, sum5, sum4, sum3, sum2, sum1};\n\nendmodule\n\nmodule adder_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\nadder_4bit rca(a, b, cin, sum, carry[0]);\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout, csa_cout);\ninput [3:0] a, b, cin;\noutput [3:0] sum;\noutput cout, csa_cout;\n\nwire [3:0] carry;\nwire [3:0] sum1, sum2;\nwire [3:0] sum3;\nwire [3:0] sum4;\n\n// 2-bit ripple carry adder\nadder_4bit rca1(a, b, cin, sum1, carry[0]);\nadder_4bit rca2(a, b, carry[0], sum2, carry[1]);\n\n// 2-bit carry select adder\ncarry_select_adder_2bit csa(sum1, sum2, carry[1], sum3, carry[2]);\n\nassign sum = sum3;\nassign cout = carry[2];\nassign csa_cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_2bit(a, b, cin, sum, cout);\ninput [1:0] a, b;\ninput cin;\noutput [1:0] sum;\noutput cout;\n\nwire [1:0] carry;\n\n// Carry-in\nassign carry[0] = cin;\n\n// Carry-out\nassign cout = carry[1];\n\n// Sum\nassign sum = a ^ b ^ carry[0];\n\nendmodule\n\nmodule ripple_carry_adder_4bit"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] add8_Co;\n\n    add8_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(add8_Co[0])\n    );\n\n    add8_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(add8_Co[0]),\n        .y(y[15:8]),\n        .Co(add8_Co[1])\n    );\n\n    assign Co = add8_Co[1];\nendmodule\n\nmodule add8_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .Cin(Cin), .y(y[0]), .Co(carry[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .Cin(carry[0]), .y(y[1]), .Co(carry[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .Cin(carry[1]), .y(y[2]), .Co(carry[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .Cin(carry[2]), .y(y[3]), .Co(carry[3]));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .Cin(carry[3]), .y(y[4]), .Co(carry[4]));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .Cin(carry[4]), .y(y[5]), .Co(carry[5]));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .Cin(carry[5]), .y(y[6]), .Co(carry[6]));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .Cin(carry[6]), .y(y[7]), .Co(Co));\n\nendmodule\n\nmodule full_adder (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [2:0] c;\n    assign c[0] = cin;\n    assign c[1] = a[0] ^ b[0] ^ c[0];\n    assign c[2] = a[1] ^ b[1] ^ c[1];\n    assign c[2] = a[2] ^ b[2] ^ c[2];\n    assign c[2] = a[3] ^ b[3] ^ c[2];\n    assign c[2] = a[4] ^ b[4] ^ c[2];\n    assign c[2] = a[5] ^ b[5] ^ c[2];\n    assign c[2] = a[6] ^ b[6] ^ c[2];\n    assign c[2] = a[7] ^ b[7] ^ c[2];\n\n    assign sum = a ^ b ^ c[0];\n    assign cout = c[1];\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control unit\nreg [3:0] cnt;\nreg done_r;\n\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .done(done_r),\n    .cnt(cnt)\n);\n\n// Register unit\nreg [15:0] a_reg, b_reg;\n\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .cnt(cnt),\n    .a(a_reg),\n    .b(b_reg)\n);\n\n// Multiplier unit\nreg [31:0] product;\n\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .a(a_reg),\n    .b(b_reg),\n    .product(product)\n);\n\n// Output assignment\nassign yout = product;\nassign done = done_r;\n\nendmodule\n\nmodule control_unit (\n    input clk,         // Chip clock signal.\n    input rst_n,       // Active-low reset signal.\n    input start,       // Chip enable signal.\n    input done,        // Chip output flag signal.\n    output [3:0] cnt   // Shift count register.\n);\n\nreg [3:0] cnt_reg;\nreg done_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_reg <= 4'b0;\n        done_r <= 1'b0;\n    end else if (done) begin\n        done_r <= 1'b1;\n    end else if (start) begin\n        cnt_reg <= 4'b0;\n        done_r <= 1'b0;\n    end else begin\n        cnt_reg <= cnt_reg + 1;\n    end\nend\n\nassign cnt = cnt_reg;\n\nendmodule\n\nmodule register_unit (\n    input clk,         // Chip clock signal.\n    input rst_n,       // Active-low reset signal.\n    input start,       // Chip enable signal.\n    input [3:0] cnt,   // Shift count register.\n    input [15:0] a,    // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b,    // Input b (multiplier) with a data width of 16 bits.\n    output [15:0] a_reg, // Registered multiplicand.\n    output [15:0] b_reg  // Registered multiplier.\n);\n\nreg [15:0] a_reg_r, b_reg_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg_r <= 16'b0;\n        b_reg_r <= 16'b0;\n    end else if (start) begin\n        a_reg_r <= a;\n        b_reg_r <= b;\n    end else if (cnt == 4'b0111) begin\n        a_reg_r <= a;\n        b_reg_r <= b;\n    end else if (cnt == 4'b1000) begin\n        a_reg_r <= a;\n        b_reg_r <= b;\n    end\nend\n\nassign a_reg = a_reg_r;\nassign b_reg = b_reg_r;\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,         // Chip clock signal.\n    input rst_n,       // Active-low reset signal.\n    input start,       // Chip enable signal.\n    input [15:0] a,    // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b,    // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] product // Product output with a data width of 32 bits"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n    wire [15:0] next_count;\n\n    up_down_counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    up_down_counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\nendmodule\n\nmodule up_down_counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n    always @(*) begin\n        if (up_down == 1) begin\n            next_count = count + 1;\n        end else begin\n            next_count = count - 1;\n        end\n    end\nendmodule\n\nmodule up_down_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n    wire [7:0] init_state;\n\n    initial_state init_sub (\n        .clk(clk),\n        .reset(reset),\n        .out(init_state)\n    );\n\n    state_transition transition_sub (\n        .clk(clk),\n        .reset(reset),\n        .init_state(init_state),\n        .next_state(next_state)\n    );\n\n    assign out = next_state;\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_state,\n    output reg [7:0] next_state\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            next_state <= 8'b0000_0001;\n        else\n            next_state <= init_state >> 1;\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] counter_out;\n\ncounter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count(counter_out)\n);\n\noutput_register u_output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .out(counter_out),\n    .out_reg(out)\n);\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] count,\n    output out_reg\n);\n\nreg [3:0] count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_reg <= 4'b0000;\n    else if (valid_count)\n        count_reg <= count_reg + 1;\nend\n\nassign count = count_reg;\nassign out_reg = count_reg == 4'd11;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] out,\n    output reg [3:0] out_reg\n);\n\nalways @(posedge rst_n or negedge valid_count) begin\n    if (!rst_n)\n        out_reg <= 4'b0000;\n    else if (valid_count)\n        out_reg <= out;\nend\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_state;\n\nJC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q), .next_state(next_state));\nJC_logic logic_inst(.clk(clk), .rst_n(rst_n), .current_state(Q), .next_state(next_state));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output [63:0]       next_state\n);\n\nreg [63:0] current_state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) current_state <= 64'b0;\n    else current_state <= next_state;\nend\n\nassign next_state = current_state;\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         current_state,\n    input [63:0]         next_state\n);\n\nreg [63:0] Q;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) Q <= 64'b0;\n    else Q <= next_state[0];\nend\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_in_div_2;\n    wire clk_in_div_10;\n    wire clk_in_div_100;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .CLK_out(clk_in_div_2)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(clk_in_div_2),\n        .CLK_out(clk_in_div_10)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(clk_in_div_10),\n        .CLK_out(clk_in_div_100)\n    );\n\n    assign CLK_50 = clk_in_div_2;\n    assign CLK_10 = clk_in_div_10;\n    assign CLK_1 = clk_in_div_100;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    output reg CLK_out\n);\n    reg [3:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    output reg CLK_out\n);\n    reg [6:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_average;\nwire clk_adjustment;\nwire clk_div_int1;\nwire clk_div_int2;\n\n// Counter\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_int2)\n);\n\n// Clock Averager\nclk_average u_clk_average(\n    .clk(clk),\n    .clk_average(clk_average)\n);\n\n// Clock Adjuster\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .clk_adjustment(clk_adjustment)\n);\n\n// Intermediate Clock Signals\nassign clk_div_int1 = clk_average & ~clk_div_int2;\nassign clk_div_int2 = clk_average & clk_div_int2;\n\n// Final Clock Signal\nassign clk_div = clk_div_int1 | clk_adjustment;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\nparameter CNT_MAX = MUL2_DIV_CLK * 2 - 1;\n\nreg [CNT_MAX-1:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div <= 0;\n    end else if (cnt == CNT_MAX) begin\n        cnt <= 0;\n        clk_div <= 1;\n    end else begin\n        cnt <= cnt + 1;\n        clk_div <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    output reg          clk_average\n);\n\nparameter CNT_MAX = MUL2_DIV_CLK - 1;\n\nreg [CNT_MAX-1:0] cnt;\n\nalways @(posedge clk) begin\n    if (cnt == CNT_MAX) begin\n        cnt <= 0;\n        clk_average <= 1;\n    end else begin\n        cnt <= cnt + 1;\n        clk_average <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    output reg          clk_adjustment\n);\n\nparameter CNT_MAX = MUL2_DIV_CLK - 1;\n\nreg [CNT_MAX-1:0] cnt;\n\nalways @(posedge clk) begin\n    if (cnt == CNT_MAX) begin\n        cnt <= 0;\n        clk_adjustment <= 0;\n    end else begin\n        cnt <= cnt + 1;\n        clk_adjustment <= 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    reg [3:0] pos_edge_count = 0;\n    reg [3:0] neg_edge_count = 0;\n    reg clk_div1 = 0;\n    reg clk_div2 = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pos_edge_count <= 0;\n            neg_edge_count <= 0;\n            clk_div1 <= 0;\n            clk_div2 <= 0;\n        end else if (pos_edge_count < NUM_DIV - 1) begin\n            pos_edge_count <= pos_edge_count + 1;\n            clk_div1 <= 0;\n        end else if (neg_edge_count < NUM_DIV - 1) begin\n            neg_edge_count <= neg_edge_count + 1;\n            clk_div2 <= 0;\n        end else begin\n            pos_edge_count <= 0;\n            neg_edge_count <= 0;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div2 <= 0;\n        end else if (pos_edge_count == NUM_DIV - 1) begin\n            clk_div2 <= 1;\n        end else begin\n            clk_div2 <= 0;\n        end\n    end\n\n    assign clk_div = clk_div1 | clk_div2;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    reg [3:0] count = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n    reg [3:0] count = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            counter <= 0;\n        else if (counter == (NUM_DIV/2 - 1))\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n\n    reg clk_div_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_reg <= 0;\n        else if (counter == (NUM_DIV/2 - 1))\n            clk_div_reg <= ~clk_div_reg;\n    end\n\n    assign clk_div = clk_div_reg;\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 0;\n        else if (q == (NUM_DIV/2 - 1))\n            q <= 0;\n        else\n            q <= q + 1;\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (q == (NUM_DIV/2 - 1))\n            clk_div <= ~clk_div;\n    end\n\n    reg [3:0] q;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 0;\n        else if (q == (NUM_DIV/2 - 1))\n            q <= 0;\n        else\n            q <= q + 1;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] result;\n\n\n// Addition\nadd u_add(.a(a), .b(b), .result(result));\n\n// Addition with Unsigned\naddu u_addu(.a(a), .b(b), .result(result));\n\n// Subtraction\nsub u_sub(.a(a), .b(b), .result(result));\n\n// Subtraction with Unsigned\nsubu u_subu(.a(a), .b(b), .result(result));\n\n// Logical AND\nand1 u_and1(.a(a), .b(b), .result(result));\n\n// Logical OR\nor1 u_or1(.a(a), .b(b), .result(result));\n\n// Logical XOR\nxor1 u_xor1(.a(a), .b(b), .result(result));\n\n// Logical NOT OR\nnor1 u_nor1(.a(a), .b(b), .result(result));\n\n// Set Less Than\nslt u_slt(.a(a), .b(b), .result(result));\n\n// Set Less Than Unsigned\nsltu u_sltu(.a(a), .b(b), .result(result));\n\n// Shift Left Logical\nsll u_sll(.a(a), .b(b), .result(result));\n\n// Shift Left Arithmetic\nsra u_sra(.a(a), .b(b), .result(result));\n\n// Shift Right Logical\nsrl u_srl(.a(a), .b(b), .result(result));\n\n// Load Upper Immediate\nlui u_lui(.a(a), .result(result));\n\n// Select the operation based on the control signal\nassign r = (aluc == 6'b100000) ? result :\n           (aluc == 6'b100001) ? result :\n           (aluc == 6'b100010) ? result :\n           (aluc == 6'b100011) ? result :\n           (aluc == 6'b100100) ? result :\n           (aluc == 6'b100101) ? result :\n           (aluc == 6'b100110) ? result :\n           (aluc == 6'b100111) ? result :\n           (aluc == 6'b000000) ? result :\n           (aluc == 6'b000010) ? result :\n           (aluc == 6'b000011) ? result :\n           (aluc == 6'b000100) ? result :\n           (aluc == 6'b000110) ? result :\n           (aluc == 6'b000111) ? result :\n           (aluc == 6'b001111) ? result : 32'd0;\n\nassign zero = (r == 32'd0) ? 1'b1 : 1'b0;\n\nassign carry = ((a[31] & b[31]) | (a[31] & ~result[31]) | (~a[31] & result[31])) ? 1'b1 : 1'b0;\n\nassign negative = result[31];\n\nassign overflow = 1'b0;\n\nassign flag = (aluc == 6'b101010) ? result[31] :\n               (aluc == 6'b101011) ? result[31] : 1'b0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] multiplication_result;\n\n    multiplier u_multiplier(\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .c(multiplication_result)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .a(multiplication_result[31:0]),\n        .b(multiplication_result[63:32]),\n        .c(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] c\n);\n\n    reg [63:0] multiplication_result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            multiplication_result <= 0;\n        end else begin\n            multiplication_result <= a * b;\n        end\n    end\n\n    assign c = multiplication_result;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    reg [31:0] current_value;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + a + b;\n        end\n    end\n\n    assign c = current_value;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n    wire [7:0] ad1_p1;\n    wire [7:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Instruction register 1\n    reg [7:0] ins_p1_reg = 0;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 0;\n        end else if (fetch == 2'b01) begin\n            ins_p1_reg <= data;\n        end\n    end\n    assign ins_p1 = ins_p1_reg;\n    assign ad1_p1 = ins_p1[7:3];\n    assign ad2_p1 = ins_p1[2:0];\n\n    // Instruction register 2\n    reg [7:0] ins_p2_reg = 0;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2_reg <= 0;\n        end else if (fetch == 2'b10) begin\n            ins_p2_reg <= data;\n        end\n    end\n    assign ins_p2 = ins_p2_reg;\n    assign ad1_p2 = ins_p2[7:3];\n    assign ad2_p2 = ins_p2[2:0];\n\n    // Connect the outputs\n    assign ins = fetch[1] ? ins_p2[7:5] : ins_p1[7:5];\n    assign ad1 = fetch[1] ? ad1_p2 : ad1_p1;\n    assign ad2 = fetch[1] ? ad2_p2 : ad2_p1;\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data;\n            ad1 <= data[7:3];\n            ad2 <= data[2:0];\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data;\n            ad1 <= data[7:3];\n            ad2 <= data[2:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n\n    counter counter0(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wave_generator0(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    assign enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            count <= count + 1;\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count >= (freq / 2)) ? 1 : 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b01111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q1, q2, q3;\n\n    my_dff8 u0 (.clk(clk), .d(d), .q(q1));\n    my_dff8 u1 (.clk(clk), .d(q1), .q(q2));\n    my_dff8 u2 (.clk(clk), .d(q2), .q(q3));\n\n    assign q = sel[1] ? (sel[0] ? q3 : q2) : q1;\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output reg [7:0] out;\n    \n    wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7;\n    wire [3:0] sel;\n    \n    assign sel[0] = ~ctrl[2];\n    assign sel[1] = ctrl[2] & ~ctrl[1];\n    assign sel[2] = ctrl[2] & ctrl[1] & ~ctrl[0];\n    assign sel[3] = ctrl[2] & ctrl[1] & ctrl[0];\n    \n    // stage 1\n    assign stage1 = mux2X1(in, {sel[0], sel[1], sel[2], sel[3]});\n    \n    // stage 2\n    assign stage2 = mux2X1(stage1, {sel[1], sel[2], sel[3], sel[0]});\n    \n    // stage 3\n    assign stage3 = mux2X1(stage2, {sel[2], sel[3], sel[0], sel[1]});\n    \n    // stage 4\n    assign stage4 = mux2X1(stage3, {sel[3], sel[0], sel[1], sel[2]});\n    \n    // stage 5\n    assign stage5 = mux2X1(stage4, {sel[0], sel[1], sel[2], sel[3]});\n    \n    // stage 6\n    assign stage6 = mux2X1(stage5, {sel[1], sel[2], sel[3], sel[0]});\n    \n    // stage 7\n    assign stage7 = mux2X1(stage6, {sel[2], sel[3], sel[0], sel[1]});\n    \n    assign out = stage7;\n    \n    // 2-to-1 multiplexer\n    function [7:0] mux2X1;\n        input [7:0] x, y;\n        begin\n            mux2X1 = x & ~y | y & ~x;\n        end\n    endfunction\nendmodule\n\nmodule submodule (in, out);\n    input in;\n    output out;\n    assign out = in;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  assign b1 = (rst) ? 16'b0 : b0;\n\n  PE pe0 (\n    .clk(clk),\n    .a0(a0),\n    .b0(b0),\n    .c0(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .a0(a1),\n    .b0(b1),\n    .c0(c1)\n  );\nendmodule\n\nmodule PE (\n  input clk,\n  input [15:0] a0,\n  input [15:0] b0,\n  output [31:0] c0\n);\n  wire [15:0] b1;\n\n  assign b1 = (rst) ? 16'b0 : b0;\n\n  // Accumulate A0 and B0\n  assign c0 = a0 * b0;\n\n  // Pass B0 to B1\n  assign b1 = b0;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_result [0:31];\n  wire [31:0] pc [0:31];\n  \n  fetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc)\n  );\n\n  decode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(fetch.instr),\n    .rs1(fetch.rs1),\n    .rs2(fetch.rs2),\n    .rd(fetch.rd),\n    .op(fetch.op)\n  );\n\n  execute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .rs1(decode.rs1),\n    .rs2(decode.rs2),\n    .op(decode.op),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result)\n  );\n\n  writeback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .rd(decode.rd),\n    .result(alu_result)\n  );\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc [0:31],\n  output reg [31:0] instr [0:31],\n  output reg [4:0] rs1 [0:31],\n  output reg [4:0] rs2 [0:31],\n  output reg [4:0] rd [0:31],\n  output reg [5:0] op [0:31]\n);\n  reg [5:0] pc_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n    end else begin\n      pc_reg <= pc;\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      pc <= pc_reg + 1;\n      instr <= instr_mem[pc_reg];\n      rs1 <= instr[15:11];\n      rs2 <= instr[20:16];\n      rd <= instr[15:11];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc [0:31],\n  input [31:0] instr [0:31],\n  output reg [4:0] rs1 [0:31],\n  output reg [4:0] rs2 [0:31],\n  output reg [4:0] rd [0:31],\n  output reg [5:0] op [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1 [0:31],\n  input [31:0] rs2 [0:31],\n  input [5:0] op [0:31],\n  output reg [31:0] alu_result [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [15:0] b1_next, b2_next, b3_next;\n\n  always @(posedge clk) begin\n    if(rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      b1_next <= 0;\n      b2_next <= 0;\n      b3_next <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1_next;\n      b2_reg <= b2_next;\n      b3_reg <= b3_next;\n      b1_next <= b0_reg;\n      b2_next <= b1_reg;\n      b3_next <= b2_reg;\n    end\n  end\n\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0_reg),\n    .c(c0)\n  );\n\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1_reg),\n    .c(c1)\n  );\n\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2_reg),\n    .c(c2)\n  );\n\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3_reg),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk) begin\n    if(rst)\n      product <= 0;\n    else\n      product <= a * b;\n  end\n  assign c = product;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr_fetched;\n    wire [31:0] operand1, operand2, result;\n    wire [5:0] reg_index1, reg_index2, reg_index3;\n\n    // Fetch stage\n    fetch_stage fetch_stage_inst(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr_fetched(instr_fetched)\n    );\n\n    // Execute stage\n    execute_stage execute_stage_inst(\n        .clk(clk),\n        .instr_fetched(instr_fetched),\n        .reg_file(reg_file),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(result)\n    );\n\n    // Writeback stage\n    writeback_stage writeback_stage_inst(\n        .clk(clk),\n        .result(result),\n        .reg_index1(reg_index1),\n        .reg_index2(reg_index2),\n        .reg_index3(reg_index3),\n        .out_reg_file(out_reg_file)\n    );\n\n    // Input/output ports\n    reg [31:0] pc;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] instr_fetched\n);\n    reg [31:0] instr_mem_r;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            instr_mem_r <= 32'h00000000;\n        else\n            instr_mem_r <= instr_mem[pc];\n    end\n\n    assign instr_fetched = instr_mem_r;\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] instr_fetched,\n    input [31:0] reg_file [0:31],\n    output [31:0] operand1,\n    output [31:0] operand2,\n    output [31:0] result\n);\n    reg [31:0] operand1_r, operand2_r;\n\n    always @(*) begin\n        case (instr_fetched[31:26])\n            6'b000000: begin // Add\n                operand1_r = reg_file[instr_fetched[5:0]];\n                operand2_r = reg_file[instr_fetched[25:20]];\n            end\n            6'b001000: begin // Sub\n                operand1_r = reg_file[instr_fetched[5:0]];\n                operand2_r = reg_file[instr_fetched[25:20]];\n            end\n            default: begin // Default\n                operand1_r = 32'h00000000;\n                operand2_r = 32'h00000000;\n            end\n        endcase\n    end\n\n    assign operand1 = operand1_r;\n    assign operand2 = operand2_r;\n\n    always @(*) begin\n        case (instr_fetched[31:26])\n            6'b000000: result = operand1_r + operand2_r; // Add\n            6'b001000: result = operand1_r - operand2_r; // Sub\n            default: result = 32'h00000000;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] result,\n    input [5:0] reg_index1,\n    input [5:0] reg_index2,\n    input [5:0] reg_index3,\n    output reg [31:0] out"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire        [9:0]       accumulator;\nwire                [3:0]   counter;\n\n// Counter Module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .counter(counter)\n);\n\n// Data Accumulator Module\ndata_accumulator u_data_accumulator (\n    .clk(clk),\n    .data_in(data_in),\n    .valid_in(valid_in),\n    .counter(counter),\n    .data_out(data_out)\n);\n\n// Valid Output Module\nvalid_output u_valid_output (\n    .clk(clk),\n    .valid_in(valid_in),\n    .valid_out(valid_out),\n    .data_out(data_out)\n);\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [3:0]   counter\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (valid_in)\n        counter <= counter + 1;\nend\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accumulator (\n    input               clk,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [3:0]   counter,\n\n    output reg  [9:0]   data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_out <= 0;\n    else if (valid_in)\n        data_out <= data_out + data_in;\nend\n\nendmodule\n\n// Valid Output Module\nmodule valid_output (\n    input               clk,\n    input               valid_in,\n    input               valid_out,\n    input       [9:0]   data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out <= 0;\n    else if (valid_in)\n        valid_out <= 1;\n    else if (counter == 4)\n        valid_out <= 0;\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] quotient;\nwire [7:0] remainder;\nwire [2:0] counter;\nwire [2:0] shift;\n\n// Submodules\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift(shift),\n    .res_valid(res_valid)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .counter(counter),\n    .sign(sign),\n    .result(remainder),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient)\n);\n\n// Output\nassign result = {quotient, remainder};\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 8'b0;\n    else if (sign)\n        result <= -value;\n    else\n        result <= value;\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 8'b0;\n    else if (sign)\n        result <= ~value + 1;\n    else\n        result <= value;\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire sign,\n    input wire opn_valid,\n    output reg [2:0] counter,\n    output reg [2:0] shift,\n    output reg res_valid\n);\n\nreg [2:0] next_counter;\nreg [2:0] next_shift;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 3'b0;\n        shift <= 3'b0;\n        res_valid <= 1'b0;\n    end else if (opn_valid && !res_valid) begin\n        counter <= 3'b0;\n        shift <= 3'b0;\n        res_valid <= 1'b1;\n    end else if (counter < 3) begin\n        next_counter <= counter + 1;\n        next_shift <= shift + 1;\n    end else begin\n        next_counter <= 3'b0;\n        next_shift <= 3'b0;\n        res_valid <= 1'b0;\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        shift <= 3'b0;\n    else\n        shift <= next_shift;\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        counter <= 3'b0;\n    else\n        counter <= next_counter;\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst(\n        .in(A),\n        .out_dividend(result),\n        .out_divisor(odd)\n    );\n\n    div_operation div_operation_inst(\n        .dividend(result),\n        .divisor(odd),\n        .result(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] in,\n    output reg [31:0] out_dividend,\n    output reg [31:0] out_divisor\n);\n    // Adjust bit width of dividend and divisor\n    assign out_dividend = {in[31:16], in[15:0]}; // 16:0\n    assign out_divisor = {16'b0, B};             // 16:0\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] remainder\n);\n    // Shift dividend and compare with divisor\n    integer i;\n    always @(*) begin\n        result = 32'b0;\n        remainder = dividend;\n        for (i = 0; i < 32; i = i + 1) begin\n            result = {result[30:0], remainder[31]};\n            remainder = remainder << 1;\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    wire [15:0] odd_temp;\n    wire [15:0] result_temp;\n    wire [7:0] B_temp;\n    \n    control_unit control (\n        .A(A),\n        .B(B),\n        .odd(odd_temp),\n        .result(result_temp),\n        .B_temp(B_temp)\n    );\n    \n    assign result = result_temp;\n    assign odd = odd_temp;\n    \nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] odd,\n    output wire [15:0] result,\n    output reg [7:0] B_temp\n);\n    reg [15:0] odd_temp;\n    reg [15:0] result_temp;\n    reg [4:0] i;\n    reg [7:0] shifted_B;\n    reg [15:0] dividend;\n    reg [31:0] temp;\n    \n    initial begin\n        B_temp = B;\n        odd_temp = 0;\n        result_temp = 0;\n        dividend = A;\n    end\n    \n    always @(*) begin\n        shifted_B = B << i;\n        if (dividend >= shifted_B) begin\n            dividend = dividend - shifted_B;\n            odd_temp = odd_temp | (1 << i);\n            result_temp = result_temp + (1 << (15 - i));\n        end\n        i = i + 1;\n    end\n    \n    assign odd = odd_temp;\n    assign result = result_temp;\n    \nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_complement;\n    wire [7:0] B_out_wire;\n\n    assign B_complement = ~B;\n\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_complement),\n        .C(1'b0),\n        .D(D),\n        .B_out(B_out_wire)\n    );\n\n    assign B_out = B_out_wire;\nendmodule\n\nmodule adder_8bit(A, B, C, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    input C;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    full_adder FA0 (.A(A[0]), .B(B[0]), .C(C), .S(sum[0]), .Cout(carry[0]));\n    full_adder FA1 (.A(A[1]), .B(B[1]), .C(carry[0]), .S(sum[1]), .Cout(carry[1]));\n    full_adder FA2 (.A(A[2]), .B(B[2]), .C(carry[1]), .S(sum[2]), .Cout(carry[2]));\n    full_adder FA3 (.A(A[3]), .B(B[3]), .C(carry[2]), .S(sum[3]), .Cout(carry[3]));\n    full_adder FA4 (.A(A[4]), .B(B[4]), .C(carry[3]), .S(sum[4]), .Cout(carry[4]));\n    full_adder FA5 (.A(A[5]), .B(B[5]), .C(carry[4]), .S(sum[5]), .Cout(carry[5]));\n    full_adder FA6 (.A(A[6]), .B(B[6]), .C(carry[5]), .S(sum[6]), .Cout(carry[6]));\n    full_adder FA7 (.A(A[7]), .B(B[7]), .C(carry[6]), .S(sum[7]), .Cout(B_out));\n\n    assign D = sum;\nendmodule\n\nmodule full_adder(A, B, C, S, Cout);\n    input A, B, C;\n    output S, Cout;\n\n    assign S = A ^ B ^ C;\n    assign Cout = (A & B) | (C & (A ^ B));\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] B_16, A_16, Diff_16, B_out_16;\n\n    // Instantiate the 16-bit subtractor block here.\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(A[31:0], B[31:0], D0, B0);\nsub_32bit sub1(A[63:32], B[63:32], D1, B1);\nassign {D1, D0} = D;\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(A[15:0], B[15:0], D0, B0);\nsub_16bit sub1(A[31:16], B[31:16], D1, B1);\nassign {D1, D0} = D;\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(A[7:0], B[7:0], D0, B0);\nsub_8bit sub1(A[15:8], B[15:8], D1, B1);\nassign {D1, D0} = D;\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(A[3:0], B[3:0], D0, B0);\nsub_4bit sub1(A[7:4], B[7:4], D1, B1);\nassign {D1, D0} = D;\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(A[1:0], B[1:0], D0, B0);\nsub_2bit sub1(A[3:2], B[3:2], D1, B1);\nassign {D1, D0} = D;\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire B0;\n\nsub_1bit sub0(A[0], B[0], D[0], B0);\nsub_1bit sub1(A[1], B[1], D[1], B1);\nassign B_out = B1 | B0;\n\nendmodule\n\nmodule sub_1bit(A, B, D, B_out);\ninput A, B;\noutput D;\noutput B_out;\n\nassign D = A - B;\nassign B_out = 0;\n\nendmodule"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n    wire [3:1] B_out_3, B_out_2, B_out_1;\n\n    bls_subtractor bls_0(.A(A[1:1]), .B(B[1:1]), .D(D[1:1]), .B_out(B_out_1));\n    bls_subtractor bls_1(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(B_out_2));\n    bls_subtractor bls_2(.A(A[5:4]), .B(B[5:4]), .D(D[5:4]), .B_out(B_out_3));\n    bls_subtractor bls_3(.A(A[7:6]), .B(B[7:6]), .D(D[7:6]), .B_out(B_out_out));\n\n    assign B_out = B_out_1 & B_out_2 & B_out_3 & B_out_out;\nendmodule\n\nmodule bls_subtractor(A, B, D, B_out);\n    input [2:1] A;\n    input [2:1] B;\n    output [2:1] D;\n    output B_out;\n\n    wire [1:0] B_in;\n\n    assign B_in = B[1] ? B[2:1] : 2'b0;\n    assign D = A - B_in;\n    assign B_out = ~(D[2] | (D[1] & B_in[1]));\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\nwire [31:0] A_minus_B;\nwire borrow;\n\n// Carry generation\nassign {borrow, A_minus_B} = A - B;\n\n// Comparison logic\nassign A_greater = ~borrow & (A_minus_B != 0);\nassign A_equal = (A_minus_B == 0);\nassign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,    // First 32-bit input operand\n    input [31:0] B,    // Second 32-bit input operand\n    output borrow,     \n    output [31:0] diff // 32-bit difference\n);\nassign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [32:1] C16;\n    wire [15:1] C8;\n    wire [7:1] C4;\n    wire [3:1] C2;\n\n    wire [32:1] P;\n    wire [32:1] G;\n    wire [32:1] C;\n    wire [32:1] G_inv;\n    wire [32:1] C_inv;\n    wire [32:1] P_inv;\n\n    // First half of CLA\n    CLA1 CLA1_inst1(.A(A[15:1]), .B(B[15:1]), .C(C16[15:1]), .P(P[15:1]), .G(G[15:1]), .C_inv(C_inv[15:1]), .P_inv(P_inv[15:1]));\n    CLA1 CLA1_inst2(.A(A[14:1]), .B(B[14:1]), .C(C16[14:1]), .P(P[14:1]), .G(G[14:1]), .C_inv(C_inv[14:1]), .P_inv(P_inv[14:1]));\n    CLA1 CLA1_inst3(.A(A[13:1]), .B(B[13:1]), .C(C16[13:1]), .P(P[13:1]), .G(G[13:1]), .C_inv(C_inv[13:1]), .P_inv(P_inv[13:1]));\n    CLA1 CLA1_inst4(.A(A[12:1]), .B(B[12:1]), .C(C16[12:1]), .P(P[12:1]), .G(G[12:1]), .C_inv(C_inv[12:1]), .P_inv(P_inv[12:1]));\n    CLA1 CLA1_inst5(.A(A[11:1]), .B(B[11:1]), .C(C16[11:1]), .P(P[11:1]), .G(G[11:1]), .C_inv(C_inv[11:1]), .P_inv(P_inv[11:1]));\n    CLA1 CLA1_inst6(.A(A[10:1]), .B(B[10:1]), .C(C16[10:1]), .P(P[10:1]), .G(G[10:1]), .C_inv(C_inv[10:1]), .P_inv(P_inv[10:1]));\n    CLA1 CLA1_inst7(.A(A[9:1]), .B(B[9:1]), .C(C16[9:1]), .P(P[9:1]), .G(G[9:1]), .C_inv(C_inv[9:1]), .P_inv(P_inv[9:1]));\n    CLA1 CLA1_inst8(.A(A[8:1]), .B(B[8:1]), .C(C16[8:1]), .P(P[8:1]), .G(G[8:1]), .C_inv(C_inv[8:1]), .P_inv(P_inv[8:1]));\n    CLA1 CLA1_inst9(.A(A[7:1]), .B(B[7:1]), .C(C16[7:1]), .P(P[7:1]), .G(G[7:1]), .C_inv(C_inv[7:1]), .P_inv(P_inv[7:1]));\n    CLA1 CLA1_inst10(.A(A[6:1]), .B(B[6:1]), .C(C16[6:1]), .P(P[6"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    \n    wire [3:0] sum_0, sum_1, sum_2, sum_3;\n    wire c_in_0, c_in_1, c_in_2;\n    \n    // Ripple carry adder for 4 bits\n    ripple_carry_adder rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum_0),\n        .cout(c_in_0)\n    );\n    ripple_carry_adder rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c_in_0),\n        .sum(sum_1),\n        .cout(c_in_1)\n    );\n    ripple_carry_adder rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c_in_1),\n        .sum(sum_2),\n        .cout(c_in_2)\n    );\n    ripple_carry_adder rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c_in_2),\n        .sum(sum_3),\n        .cout(cout)\n    );\n    \n    // Carry select adder for the first 4 bits\n    carry_select_adder_slice csa1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum_0),\n        .cout(c_in_0)\n    );\n    // Carry select adder for the second 4 bits\n    carry_select_adder_slice csa2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c_in_0),\n        .sum(sum_1),\n        .cout(c_in_1)\n    );\n    // Carry select adder for the third 4 bits\n    carry_select_adder_slice csa3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c_in_1),\n        .sum(sum_2),\n        .cout(c_in_2)\n    );\n    // Carry select adder for the last 4 bits\n    carry_select_adder_slice csa4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c_in_2),\n        .sum(sum_3),\n        .cout(cout)\n    );\n    \n    assign sum = {sum_3, sum_2, sum_1, sum_0};\nendmodule\n\nmodule ripple_carry_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    wire [4:0] carry;\n    \n    // Full adder\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry = {1'b0, a[7:0]} + b + Cin;\n    assign y = {carry[7:0], carry[7]};\n    assign Co = carry[8];\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] carry = {1'b0, a} + b + Cin;\n    assign y = {carry[7:0], carry[7]};\n    assign Co = carry[8];\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] carry = {1'b0, a} + b + Cin;\n    assign y = {carry[7:0], carry[7]};\n    assign Co = carry[8];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    wire [3:0] c;\n    \n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nwire [3:0] shift_count; // Shift count register.\nwire [15:0] product;    // Product register.\nwire [3:0] enable;      // Enable register.\n\n// Control Unit.\ncontrol_unit ctrl_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .enable(enable)\n);\n\n// Register Unit.\nregister_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .enable(enable),\n    .ain(ain),\n    .bin(bin),\n    .product(product)\n);\n\n// Multiplier Unit.\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .enable(enable),\n    .product(product),\n    .shift_count(shift_count)\n);\n\n// Output Assignment.\nassign yout = product;\nassign done = enable[3];\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] enable\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        enable <= 4'b0;\n    end else if (start) begin\n        enable <= 4'b1111;\n    end else if (enable) begin\n        enable <= enable << 1;\n    end\nend\n\nendmodule\n\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input [3:0] enable,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [31:0] product\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 32'b0;\n    end else if (enable[3]) begin\n        product <= 32'b0;\n    end else if (enable[2]) begin\n        product <= product + {16'b0, ain} * bin;\n    end else if (enable[1]) begin\n        product <= product + {16'b0, ain << 1} * bin;\n    end else if (enable[0]) begin\n        product <= product + {16'b0, ain << 2} * bin;\n    end\nend\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [3:0] enable,\n    input [15:0] product,\n    output reg [3:0] shift_count\n);\n\nalways @(posedge clk) begin\n    if (enable[3]) begin\n        shift_count <= 4'b0;\n    end else if (enable[2]) begin\n        shift_count <= 4'b1111;\n    end else if (shift_count) begin\n        shift_count <= shift_count << 1;\n    end\nend\n\nalways @* begin\n    if (shift_count[3]) begin\n        product = product + {16'b0, enable[2] ? bin : 16'b0};\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(current_count),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .current_count(current_count),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (up_down == 1)\n            next_count = current_count + 1;\n        else\n            next_count = current_count - 1;\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    ring_counter_init init_submodule (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    ring_counter_transition transition_submodule (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= (count == 4'd11) ? 4'b0000 : count + 1;\n        end\n    end\n\n    assign out = count;\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] out,\n    output [3:0] count\n);\n    reg [3:0] internal_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            internal_out <= 4'b0000;\n        end else if (valid_count) begin\n            internal_out <= out;\n        end\n    end\n\n    assign count = internal_out;\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_Q;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    JC_logic logic_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n    end\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            next_Q <= 64'b0;\n        else\n            next_Q <= {Q[62:0], ~Q[0]};\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire clk_div_2_out;\nwire clk_div_10_out;\nwire clk_div_100_out;\n\nclk_div clk_div_2 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .clk_div_out(clk_div_2_out)\n);\n\nclk_div clk_div_10 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .clk_div_out(clk_div_10_out)\n);\n\nclk_div clk_div_100 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .clk_div_out(clk_div_100_out)\n);\n\nassign CLK_50 = clk_div_2_out;\nassign CLK_10 = clk_div_10_out;\nassign CLK_1 = clk_div_100_out;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg clk_div_out\n);\n\nreg [2:0] counter;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        counter <= 0;\n    else if (counter == 3'b111)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        clk_div_out <= 0;\n    else if (counter == 3'b111)\n        clk_div_out <= ~clk_div_out;\nend\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_3, clk_div_4;\n\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_3)\n);\n\nclk_average u_clk_average (\n    .clk(clk),\n    .clk_div(clk_div_3),\n    .clk_div_2(clk_div_4)\n);\n\nclk_adjustment u_clk_adjustment (\n    .clk(clk),\n    .clk_div_2(clk_div_4),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\nparameter LIMIT = 1 << MUL2_DIV_CLK;\n\nreg [MUL2_DIV_CLK-1:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 0;\n        clk_div <= 0;\n    end else if (cnt == LIMIT-1) begin\n        cnt <= 0;\n        clk_div <= 1;\n    end else begin\n        cnt <= cnt + 1;\n        clk_div <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div,\n    output reg          clk_div_2\n);\n\nparameter CLK_DIV_2_PERIOD = 4;\n\nreg [CLK_DIV_2_PERIOD-1:0] cnt_2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt_2 <= 0;\n        clk_div_2 <= 0;\n    end else if (cnt_2 == CLK_DIV_2_PERIOD-1) begin\n        cnt_2 <= 0;\n        clk_div_2 <= clk_div;\n    end else begin\n        cnt_2 <= cnt_2 + 1;\n        clk_div_2 <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div_2,\n    output reg          clk_div\n);\n\nparameter CLK_DIV_PERIOD = 2;\n\nalways @(posedge clk) begin\n    clk_div <= clk_div_2;\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    localparam NUM_DIV = 5;\n\n    wire pos_clk_div, neg_clk_div;\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(pos_clk_div)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(neg_clk_div)\n    );\n\n    assign clk_div = pos_clk_div | neg_clk_div;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 8;\n\n    reg [3:0] counter;\n    wire toggle;\n    wire clk_div_int;\n\n    counter_submodule u_counter(.clk(clk), .rst_n(rst_n), .toggle(toggle), .clk_div(clk_div_int));\n    clk_divider_submodule u_clk_divider(.clk_div(clk_div), .toggle(toggle), .clk_div_int(clk_div_int));\n\nendmodule\n\nmodule counter_submodule(\n    input clk,\n    input rst_n,\n    output toggle,\n    output reg clk_div\n);\n    parameter NUM_DIV = 8;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else if (counter == (NUM_DIV / 2 - 1)) begin\n            counter <= 0;\n            clk_div <= 1;\n        end else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule clk_divider_submodule(\n    input clk_div,\n    input toggle,\n    input clk_div_int,\n    output reg clk_div_out\n);\n    always @(posedge clk_div_int) begin\n        if (toggle)\n            clk_div_out <= ~clk_div_out;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, addu_r, sub_r, subu_r, and_r, or_r, xor_r, nor_r, sll_r, srl_r, sra_r, slt_r, sltu_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire [31:0] add_c, addu_c, sub_c, subu_c, and_c, or_c, xor_c, nor_c, sll_c, srl_c, sra_c, slt_c, sltu_c, sllv_c, srlv_c, srav_c, lui_c;\n    wire add_n, addu_n, sub_n, subu_n, and_n, or_n, xor_n, nor_n, sll_n, srl_n, sra_n, slt_n, sltu_n, sllv_n, srlv_n, srav_n, lui_n;\n\n    add addu(\n        .a(a),\n        .b(b),\n        .r(addu_r),\n        .c(addu_c)\n    );\n    add addu_r(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .c(add_c)\n    );\n    sub subu(\n        .a(a),\n        .b(b),\n        .r(subu_r),\n        .c(subu_c)\n    );\n    sub subu_r(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .c(sub_c)\n    );\n    and and_r(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .c(and_c)\n    );\n    or or_r(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .c(or_c)\n    );\n    xor xor_r(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .c(xor_c)\n    );\n    nor nor_r(\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .c(nor_c)\n    );\n    sll sll_r(\n        .a(a),\n        .b(b),\n        .r(sll_r),\n        .c(sll_c)\n    );\n    srl srl_r(\n        .a(a),\n        .b(b),\n        .r(srl_r),\n        .c(srl_c)\n    );\n    sra sra_r(\n        .a(a),\n        .b(b),\n        .r(sra_r),\n        .c(sra_c)\n    );\n    sllv sllv_r(\n        .a(a),\n        .b(b),\n        .r(sllv_r),\n        .c(sllv_c)\n    );\n    srlv srlv_r(\n        .a(a),\n        .b(b),\n        .r(srlv_r),\n        .c(srlv_c)\n    );\n    srav srav_r(\n        .a(a),\n        .b(b),\n        .r(srav_r),\n        .c(srav_c)\n    );\n    lui lui_r(\n        .a(a),\n        .b(b),\n        .r(lui_r),\n        .c(lui_c)\n    );\n\n    assign r = (aluc == 6'b100000) ? add_r : (aluc == 6'b100001) ? addu_r : (aluc == 6'b100010) ? sub_r : (aluc == 6'b100011) ? sub"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] multiplication_result;\n\n    // Multiplier Submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .rst(rst),\n        .clk(clk),\n        .result(multiplication_result)\n    );\n\n    // Accumulator Submodule\n    accumulator u_accumulator(\n        .rst(rst),\n        .clk(clk),\n        .current_value(current_value),\n        .new_value(multiplication_result[31:0]),\n        .result(c)\n    );\n\n    reg [31:0] current_value;\n\nendmodule\n\n// Multiplier Submodule\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input rst,\n    input clk,\n    output [63:0] result\n);\n\n    reg [63:0] product;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            product <= 0;\n        end else begin\n            product <= a * b;\n        end\n    end\n\n    assign result = product;\n\nendmodule\n\n// Accumulator Submodule\nmodule accumulator(\n    input rst,\n    input clk,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output [31:0] result\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= current_value + new_value;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1, ins2;\n\n    // Instruction register 1\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1)\n    );\n\n    // Instruction register 2\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = {ins1[7:5], ins2[7:5]};\n    assign ad1 = {ins1[4:0], ins2[4:0]};\n    assign ad2 = {ins1[3:0], ins2[3:0]};\n\nendmodule\n\n// Instruction register submodule\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 0;\n        else if (fetch)\n            ins <= data;\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n    wire [7:0] cnt;\n    wire [7:0] wg;\n\n    counter counter(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(cnt)\n    );\n\n    wave_generator wave_generator(\n        .clk(clk),\n        .count(cnt),\n        .freq(freq),\n        .wave_out(wg)\n    );\n\n    assign wave_out = wg;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                        wave_reg <= 5'd31;\n                    end else begin\n                        wave_reg <= wave_reg + 1;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                        wave_reg <= 5'd0;\n                    end else begin\n                        wave_reg <= wave_reg - 1;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 5'd0;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            if (wave == 5'd31) begin\n                wave <= 5'd0;\n            end else begin\n                wave <= wave + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] outs [0:2];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d[0]),\n        .q(outs[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(outs[0]),\n        .q(outs[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(outs[1]),\n        .q(outs[2])\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= outs[0];\n            2'b10: q <= outs[1];\n            2'b11: q <= outs[2];\n            default: q <= 8'bx;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n    always @(*) begin\n        case (sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n            default: out = 1'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] shifted;\n    wire [2:0] sel;\n    \n    assign sel = ctrl;\n    \n    // Stage 1: Shift by 4\n    mux2X1 stage1_mux (in, shifted, sel[2]);\n    assign shifted = (sel[2]) ? shifted << 4 : shifted;\n    \n    // Stage 2: Shift by 2\n    mux2X1 stage2_mux (shifted, shifted, sel[1]);\n    assign shifted = (sel[1]) ? shifted << 2 : shifted;\n    \n    // Stage 3: Shift by 1\n    mux2X1 stage3_mux (shifted, in, sel[0]);\n    assign out = (sel[0]) ? shifted << 1 : shifted;\nendmodule\n\nmodule mux2X1(a, b, sel, y);\n    input a, b, sel;\n    output y;\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  assign b1 = b0;\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b_reg <= 0;\n    else\n      b_reg <= b;\n  end\n\n  assign c = a * b_reg;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [31:0] res_mem;\n  wire [31:0] res_writeback;\n\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] instr;\n\n  stagepipe5_fetch fetch_stage(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc), .instr(instr));\n  stagepipe5_decode decode_stage(.clk(clk), .rst(rst), .instr(instr), .pc(pc), .alu_res(alu_res));\n  stagepipe5_execute execute_stage(.clk(clk), .rst(rst), .alu_res(alu_res), .reg_file(reg_file), .res_mem(res_mem));\n  stagepipe5_memory memory_stage(.clk(clk), .rst(rst), .res_mem(res_mem), .res_writeback(res_writeback));\n  stagepipe5_writeback writeback_stage(.clk(clk), .rst(rst), .res_writeback(res_writeback), .reg_file(reg_file), .res_reg_file(res_reg_file));\nendmodule\n\nmodule stagepipe5_fetch(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc,\n  output [31:0] instr\n);\n  reg [31:0] pc_reg;\n\n  assign pc = pc_reg;\n  assign instr = instr_mem[pc_reg / 4];\n  assign next_pc = pc_reg + 4;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 32'd0;\n    else\n      pc_reg <= next_pc;\n  end\nendmodule\n\nmodule stagepipe5_decode(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [31:0] pc,\n  output [31:0] alu_res\n);\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [5:0] op;\n\n  assign {rs1, rs2, rd, op} = instr;\n  assign alu_res = (op == 6'b001000) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\nendmodule\n\nmodule stagepipe5_execute(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_mem\n);\n  assign res_mem = alu_res;\nendmodule\n\nmodule stagepipe5_memory(\n  input clk,\n  input rst,\n  input [31:0] res_mem,\n  output [31:0] res_writeback\n);\n  assign res_writeback = res_mem;\nendmodule\n\nmodule stagepipe5_writeback(\n  input clk,\n  input rst,\n  input [31:0] res_writeback,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n  reg [31:0] pc_reg;\n\n  assign res_reg_file = res_reg_file_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      res_reg_file_reg <= 32'd0;\n    else\n      res_reg_file_reg"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\nwire [15:0] b1, b2, b3;\n\nassign b1 = rst ? 16'd0 : b0;\nassign b2 = rst ? 16'd0 : b1;\nassign b3 = rst ? 16'd0 : b2;\n\nreg [15:0] b0_reg, b1_reg, b2_reg;\nalways @(posedge clk or posedge rst) begin\n  if(rst) begin\n    b0_reg <= 16'd0;\n    b1_reg <= 16'd0;\n    b2_reg <= 16'd0;\n  end\n  else begin\n    b0_reg <= b0;\n    b1_reg <= b1;\n    b2_reg <= b2;\n  end\nend\n\nwire [31:0] p0, p1, p2, p3;\n\nsystolic1x1 pe0(\n  .clk(clk),\n  .rst(rst),\n  .a(a0),\n  .b(b0),\n  .p(p0)\n);\n\nsystolic1x1 pe1(\n  .clk(clk),\n  .rst(rst),\n  .a(a1),\n  .b(b1),\n  .p(p1)\n);\n\nsystolic1x1 pe2(\n  .clk(clk),\n  .rst(rst),\n  .a(a2),\n  .b(b2),\n  .p(p2)\n);\n\nsystolic1x1 pe3(\n  .clk(clk),\n  .rst(rst),\n  .a(a3),\n  .b(b3),\n  .p(p3)\n);\n\nassign c0 = p0;\nassign c1 = p1;\nassign c2 = p2;\nassign c3 = p3;\n\nendmodule\n\nmodule systolic1x1(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n\nreg [15:0] a_reg, b_reg;\nreg [31:0] p_reg;\n\nalways @(posedge clk or posedge rst) begin\n  if(rst) begin\n    a_reg <= 16'd0;\n    b_reg <= 16'd0;\n    p_reg <= 32'd0;\n  end\n  else begin\n    a_reg <= a;\n    b_reg <= b;\n    p_reg <= a_reg * b_reg;\n  end\nend\n\nassign p = p_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op_a;\n    wire [31:0] op_b;\n    wire [31:0] res;\n    wire [4:0] rd;\n    wire [4:0] ra;\n    wire [4:0] rb;\n    wire [5:0] funct;\n    wire [5:0] alu_op;\n    wire [31:0] tmp_reg;\n\n    // 3-stage pipeline\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .pc(pc),\n        .instr(instr)\n    );\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .op_a(op_a),\n        .op_b(op_b),\n        .res(res),\n        .rd(rd),\n        .ra(ra),\n        .rb(rb),\n        .funct(funct),\n        .alu_op(alu_op)\n    );\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .res(res),\n        .rd(rd),\n        .ra(ra),\n        .rb(rb),\n        .funct(funct),\n        .alu_op(alu_op),\n        .out_reg_file(out_reg_file)\n    );\n\n    // pipeline control\n    assign pc = reg_file[0];\n\n    // fetch stage\n    assign instr = instr_mem[pc];\n\n    // execute stage\n    assign op_a = reg_file[ra];\n    assign op_b = reg_file[rb];\n    assign tmp_reg = (alu_op == 6'b000000) ? op_a + op_b : op_a - op_b;\n    assign res = (funct == 6'b000010) ? tmp_reg : 32'bx;\n    assign reg_file[rd] = res;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    output [31:0] pc,\n    output [31:0] instr\n);\n    reg [31:0] pc_reg;\n    reg [31:0] instr_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pc_reg <= 0;\n            instr_reg <= 32'bx;\n        end else begin\n            pc_reg <= pc_reg + 1;\n            instr_reg <= instr_mem[pc_reg];\n        end\n    end\n\n    assign pc = pc_reg;\n    assign instr = instr_reg;\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] op_a,\n    output [31:0] op_b,\n    output [31:0] res,\n    output [4:0] rd,\n    output [4:0] ra,\n    output [4:0] rb,\n    output [5:0] funct,\n    output [5:0] alu_op\n);\n    wire [5:0] opcode;\n\n    assign op_a = instr[25:20];\n    assign op_b = instr[15:10];\n    assign rd = instr[11:6];\n    assign ra = instr[5:0];\n    assign rb = instr[15:10];\n    assign funct = instr[5:0];\n    assign alu_op = instr[31:26];\n\n    assign opcode = instr[31:26];\n\n    always @(*) begin\n        case (opcode)\n            6'b100000: res = op_a + op_b;\n            6'b101010: res = op_a"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire [3:0] cnt_out;\n\n// Counter Module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .data_in(valid_in),\n    .cnt_out(cnt_out)\n);\n\n// Data Accumulator Module\ndata_accumulator u_data_accumulator (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .data_in(data_in),\n    .data_out(data_out)\n);\n\n// Valid Output Module\nvalid_output u_valid_output (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cnt_out(cnt_out),\n    .valid_out(valid_out)\n);\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               data_in,\n    output reg  [3:0]   cnt_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_out <= 0;\n    else if (data_in)\n        cnt_out <= cnt_out + 1;\nend\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_out <= 0;\n    else if (valid_in)\n        data_out <= data_out + data_in;\nend\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   cnt_out,\n    output reg          valid_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out <= 0;\n    else if (cnt_out == 4)\n        valid_out <= 1;\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend, neg_divisor_mod;\nwire [3:0] count;\nwire [7:0] shift_reg;\nwire divisor_sign;\nwire [7:0] quotient;\n\n// Submodule Instantiation\nabs_value abs_dividend_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value_in(dividend),\n    .value_out(abs_dividend)\n);\n\nabs_value neg_divisor_mod_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value_in(divisor),\n    .value_out(neg_divisor_mod)\n);\n\ndivider_control ctrl_inst(\n    .clk(clk),\n    .rst(rst),\n    .count(count),\n    .divisor_sign(divisor_sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor_mod),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt_inst(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .count(count),\n    .quotient(quotient),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value_in,\n    output reg [7:0] value_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        value_out <= 0;\n    end else begin\n        value_out <= sign ? ~value_in + 1 : value_in;\n    end\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value_in,\n    output reg [7:0] value_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        value_out <= 0;\n    end else begin\n        value_out <= sign ? ~value_in + 1 : value_in;\n    end\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] count,\n    input wire divisor_sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [7:0] shift_reg\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        shift_reg <= 0;\n    end else begin\n        shift_reg <= {1'b0, dividend[7:1]} + (count == 4'd3 ? {1'b0, divisor_sign ? ~divisor + 1 : divisor} : 8'd0);\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg res_valid,\n    input wire res_ready,\n    input wire [3:0] count,\n    input wire [7:0] quotient,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        result <= 0;\n    end else if (opn_valid && res_ready) begin\n        res_valid <= 1;\n        result <= {quotient, result[15:8]};\n    end else if (count == 4'd0) begin\n        res_valid <= 0;\n    end\nend\n\nendmodule\n\nmodule radix2_div_verilog(\n    input wire clk,\n    input wire r"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend_prepared;\n    wire [31:0] divisor_prepared;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .result(dividend_prepared),\n        .odd(divisor_prepared)\n    );\n\n    div_operation div_operation_inst(\n        .A(dividend_prepared),\n        .B(divisor_prepared),\n        .result(quotient),\n        .odd(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    // Prepare the dividend\n    // The dividend must be 32 bits\n    assign result = {A[31:16], 16'b0};\n    assign odd = {B, 16'b0};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,\n    input wire [31:0] B,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n\n    // Divide A by B\n    // The result should be 32 bits\n    // The remainder should be 32 bits\n\n    // First shift A by 16 bits to the left\n    reg [31:0] shifted_A;\n    always @(*) begin\n        shifted_A = {A[15:0], 16'b0};\n    end\n\n    // Compare the shifted A with B\n    // If the shifted A is less than B, shift it left by 1 bit\n    // Otherwise, shift B left by 1 bit\n    reg [31:0] next_A;\n    reg [31:0] next_B;\n    always @(*) begin\n        if (shifted_A < B) begin\n            next_A = {shifted_A[14:0], 1'b0};\n            next_B = {B[14:0], 1'b0};\n        end else begin\n            next_A = A;\n            next_B = {B[14:0], 1'b0};\n        end\n    end\n\n    // If the shifted A is less than B, shift it left by 1 bit and compare again\n    // If the shifted A is greater than B, shift B left by 1 bit and compare again\n    always @(*) begin\n        while (next_A >= next_B) begin\n            next_A = {next_A[30:0], 1'b0};\n            next_B = {next_B[30:0], 1'b0};\n        end\n    end\n\n    // The result is the quotient of the two shifted A and B\n    assign result = next_A;\n\n    // The remainder is the difference of the shifted A and B\n    assign odd = next_B;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    // Instantiate control unit\n    div_ctrl_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .odd(odd),\n        .result(result)\n    );\nendmodule\n\n// Submodule for control unit\nmodule div_ctrl_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n    // Internal variables\n    wire [15:0] dividend;\n    wire [7:0] divisor;\n    wire [15:0] remainder;\n    wire [15:0] quotient;\n    wire [15:0] shifted_dividend;\n    wire [15:0] shifted_dividend_2;\n    wire [15:0] shifted_dividend_3;\n    wire [15:0] shifted_dividend_4;\n    wire [15:0] shifted_dividend_5;\n    wire [15:0] shifted_dividend_6;\n    wire [15:0] shifted_dividend_7;\n    wire [15:0] shifted_dividend_8;\n    wire [15:0] shifted_dividend_9;\n    wire [15:0] shifted_dividend_10;\n    wire [15:0] shifted_dividend_11;\n    wire [15:0] shifted_dividend_12;\n    wire [15:0] shifted_dividend_13;\n    wire [15:0] shifted_dividend_14;\n    wire [15:0] shifted_dividend_15;\n    wire [15:0] shifted_dividend_16;\n    wire [15:0] shifted_dividend_17;\n    wire [15:0] shifted_dividend_18;\n    wire [15:0] shifted_dividend_19;\n    wire [15:0] shifted_dividend_20;\n    wire [15:0] shifted_dividend_21;\n    wire [15:0] shifted_dividend_22;\n    wire [15:0] shifted_dividend_23;\n    wire [15:0] shifted_dividend_24;\n    wire [15:0] shifted_dividend_25;\n    wire [15:0] shifted_dividend_26;\n    wire [15:0] shifted_dividend_27;\n    wire [15:0] shifted_dividend_28;\n    wire [15:0] shifted_dividend_29;\n    wire [15:0] shifted_dividend_30;\n    wire [15:0] shifted_dividend_31;\n    wire [15:0] shifted_dividend_32;\n    wire [15:0] shifted_dividend_33;\n    wire [15:0] shifted_dividend_34;\n    wire [15:0] shifted_dividend_35;\n    wire [15:0] shifted_dividend_36;\n    wire [15:0] shifted_dividend_37;\n    wire [15:0] shifted_dividend_38;\n    wire [15:0] shifted_dividend_39;\n    wire [15:0] shifted_dividend_40;\n    wire [15:0] shifted_dividend_41;\n    wire [15:0] shifted_dividend_42;\n    wire [15:0] shifted_dividend_43;\n    wire [15:0] shifted_dividend"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire carry_out;\n\n    assign B_comp = ~B + 1;\n    assign {carry_out, sum} = adder_8bit(A, B_comp);\n    assign D = sum;\n    assign B_out = carry_out;\n\nendmodule\n\nmodule adder_8bit(a, b, carry_out);\n    input [7:0] a;\n    input [7:0] b;\n    output carry_out;\n    output [7:0] sum;\n\n    wire [7:0] carry;\n\n    assign {carry[0], sum[0]} = full_adder(a[0], b[0], 1'b0);\n    assign {carry[1], sum[1]} = full_adder(a[1], b[1], carry[0]);\n    assign {carry[2], sum[2]} = full_adder(a[2], b[2], carry[1]);\n    assign {carry[3], sum[3]} = full_adder(a[3], b[3], carry[2]);\n    assign {carry[4], sum[4]} = full_adder(a[4], b[4], carry[3]);\n    assign {carry[5], sum[5]} = full_adder(a[5], b[5], carry[4]);\n    assign {carry[6], sum[6]} = full_adder(a[6], b[6], carry[5]);\n    assign {carry_out, sum[7]} = full_adder(a[7], b[7], carry[6]);\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a;\n    input b;\n    input carry_in;\n    output sum;\n    output carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (b & carry_in) | (a & carry_in);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire b1, b2;\n\n    sub_16bit S1_instance(A[15:0], B[15:0], S1, b1);\n    sub_16bit S2_instance(A[31:16], B[31:16], S2, b2);\n\n    assign Diff = {S1, S2};\n    assign B_out = b1 ^ b2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1, S2;\n    wire b1, b2;\n\n    sub_8bit S1_instance(A[7:0], B[7:0], S1, b1);\n    sub_8bit S2_instance(A[15:8], B[15:8], S2, b2);\n\n    assign Diff = {S1, S2};\n    assign B_out = b1 ^ b2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1, S2;\n    wire b1, b2;\n\n    sub_4bit S1_instance(A[3:0], B[3:0], S1, b1);\n    sub_4bit S2_instance(A[7:4], B[7:4], S2, b2);\n\n    assign Diff = {S1, S2};\n    assign B_out = b1 ^ b2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1, S2;\n    wire b1, b2;\n\n    sub_2bit S1_instance(A[1:0], B[1:0], S1, b1);\n    sub_2bit S2_instance(A[3:2], B[3:2], S2, b2);\n\n    assign Diff = {S1, S2};\n    assign B_out = b1 ^ b2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [1:0] S1, S2;\n    wire b1, b2;\n\n    sub_1bit S1_instance(A[0], B[0], S1, b1);\n    sub_1bit S2_instance(A[1], B[1], S2, b2);\n\n    assign Diff = {S1, S2};\n    assign B_out = b1 ^ b2;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;\n    input B;\n    output Diff;\n    output B_out;\n\n    wire b1, b2;\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] D_16, D_32;\n    wire B_out_1, B_out_2;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D_16),\n        .B_out(B_out_1)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D_16),\n        .B_out(B_out_2)\n    );\n\n    sub_8bit sub2_1(\n        .A(D_16[7:0]),\n        .B(B_out_1),\n        .D(D_32[7:0]),\n        .B_out(B_out_1)\n    );\n\n    sub_8bit sub2_2(\n        .A(D_16[15:8]),\n        .B(B_out_2),\n        .D(D_32[15:8]),\n        .B_out(B_out_2)\n    );\n\n    assign D = {D_32[15:0], 1'b0};\n    assign B_out = B_out_1 | B_out_2;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] D_8, D_16;\n    wire B_out_1, B_out_2;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D_8),\n        .B_out(B_out_1)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D_8),\n        .B_out(B_out_2)\n    );\n\n    assign D = {D_8[7:0], 1'b0};\n    assign B_out = B_out_1 | B_out_2;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] D_4, D_8;\n    wire B_out_1, B_out_2;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D_4),\n        .B_out(B_out_1)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D_4),\n        .B_out(B_out_2)\n    );\n\n    assign D = {D_4[3:0], 1'b0};\n    assign B_out = B_out_1 | B_out_2;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] D_2, D_4;\n    wire B_out_1, B_out_2;\n\n    sub_2bit sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D_2),\n        .B_out(B_out_1)\n    );\n\n    sub_"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] B_out1;\nwire [3:0] B_out2;\nwire [3:0] B_out3;\nwire [3:0] B_out4;\n\nsub4subtractor BLS1(A[4:1], B[4:1], D[4:1], B_out1);\nsub4subtractor BLS2(A[8:5], B[8:5], D[8:5], B_out2);\nsub4subtractor BLS3(A[12:9], B[12:9], D[12:9], B_out3);\nsub4subtractor BLS4(A[16:12], B[16:12], D[16:12], B_out4);\n\nassign B_out = B_out1 & B_out2 & B_out3 & B_out4;\n\nendmodule\n\nmodule sub4subtractor(A, B, D, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] D;\noutput B_out;\n\nwire [3:0] borrow_out;\n\nsub3subtractor BLS1(A, B, D, borrow_out[0]);\nsub3subtractor BLS2(D, borrow_out[0], D, borrow_out[1]);\nsub3subtractor BLS3(D, borrow_out[1], D, borrow_out[2]);\nsub3subtractor BLS4(D, borrow_out[2], D, B_out);\n\nendmodule\n\nmodule sub3subtractor(A, B, D, B_out);\ninput [2:0] A;\ninput [2:0] B;\noutput [2:0] D;\noutput B_out;\n\nwire [2:0] borrow_out;\n\nsub2subtractor BLS1(A, B, D, borrow_out[0]);\nsub2subtractor BLS2(D, borrow_out[0], D, borrow_out[1]);\nsub2subtractor BLS3(D, borrow_out[1], D, borrow_out[2]);\nsub2subtractor BLS4(D, borrow_out[2], D, B_out);\n\nendmodule\n\nmodule sub2subtractor(A, B, D, B_out);\ninput [1:0] A;\ninput [1:0] B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] borrow_out;\n\nsub1subtractor BLS1(A, B, D, borrow_out[0]);\nsub1subtractor BLS2(D, borrow_out[0], D, B_out);\n\nendmodule\n\nmodule sub1subtractor(A, B, D, B_out);\ninput [0:0] A;\ninput [0:0] B;\noutput [0:0] D;\noutput B_out;\n\nwire borrow_out;\n\nassign {B_out, D[0]} = A[0] ? {1'b0, B[0]} - {1'b1, 1'b0} : {1'b1, B[0]} - {1'b0, 1'b1};\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] result; // Result of subtraction\n    wire carry;         // Carry output\n    \n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .result(result),\n        .carry(carry)\n    );\n    \n    assign A_greater = ~carry & ~result[31];\n    assign A_equal = ~carry & ~result[31] & ~result[30];\n    assign A_less = carry;\n    \nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] result,  // Result of subtraction\n    output carry        // Carry output\n);\n    wire [31:0] A_sub_B; // Result of A - B\n    \n    assign A_sub_B = A - B;\n    \n    assign result = A_sub_B;\n    assign carry = A[31] ^ B[31] ^ A_sub_B[31];\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16[1:2];\nwire [15:1] S16[1:2];\n\nCLA1 CLA1_inst(.A(A[16:1]),.B(B[16:1]),.Cin(0),.S(S16[1]),.Cout(C16[1]));\nCLA2 CLA2_inst(.A(A[32:16]),.B(B[32:16]),.Cin(C16[1]),.S(S16[2]),.Cout(C16[2]));\n\nassign S = {S16[2],S16[1]};\nassign C32 = C16[2];\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\ninput [15:1] A,B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\n\nwire [14:0] C;\n\ngenvar i;\ngenerate\n    for (i=0; i<15; i=i+1) begin: carry\n        full_adder FA (.a(A[i]),.b(B[i]),.cin(Cin),.sum(S[i]),.cout(C[i]));\n    end\nendgenerate\nassign Cout = C[14];\n\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\ninput [31:1] A,B;\ninput Cin;\noutput [31:1] S;\noutput Cout;\n\nwire [14:0] C;\n\ngenvar i;\ngenerate\n    for (i=0; i<15; i=i+1) begin: carry\n        full_adder FA (.a(A[i*2+1]),.b(B[i*2+1]),.cin(C[i]),.sum(S[i*2+1]),.cout(C[i+1]));\n    end\nendgenerate\nassign Cout = C[14];\n\nendmodule\n\nmodule full_adder(a,b,cin,sum,cout);\ninput a,b,cin;\noutput sum,cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] csa_slice1_sum, csa_slice2_sum, csa_slice3_sum;\n    wire [3:0] csa_slice1_cout, csa_slice2_cout, csa_slice3_cout;\n\n    // 4-bit ripple carry adder\n    wire [3:0] rca1_sum, rca2_sum, rca3_sum, rca4_sum;\n    wire [3:0] rca1_cout, rca2_cout, rca3_cout, rca4_cout;\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(rca1_sum),\n        .cout(rca1_cout)\n    );\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(rca1_cout),\n        .sum(rca2_sum),\n        .cout(rca2_cout)\n    );\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(rca2_cout),\n        .sum(rca3_sum),\n        .cout(rca3_cout)\n    );\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(rca3_cout),\n        .sum(rca4_sum),\n        .cout(rca4_cout)\n    );\n\n    // 4-bit carry select adder slice\n    carry_select_adder_slice csa_slice1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(csa_slice1_sum),\n        .cout(csa_slice1_cout)\n    );\n    carry_select_adder_slice csa_slice2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(csa_slice1_cout),\n        .sum(csa_slice2_sum),\n        .cout(csa_slice2_cout)\n    );\n    carry_select_adder_slice csa_slice3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(csa_slice2_cout),\n        .sum(csa_slice3_sum),\n        .cout(csa_slice3_cout)\n    );\n\n    assign sum = {csa_slice3_sum, csa_slice2_sum, csa_slice1_sum, rca4_sum};\n    assign cout = rca4_cout;\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]),"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_temp;\n\n    add8_1 adder1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp[0])\n    );\n\n    add8_2 adder2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp[0]),\n        .y(y[15:8]),\n        .Co(Co_temp[1])\n    );\n\n    assign Co = Co_temp[1];\nendmodule\n\nmodule add8_1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Simple 8-bit adder implementation.\n    wire [7:0] sum;\n    assign sum = a + b + Cin;\n    assign y = sum;\n    assign Co = sum[7];\nendmodule\n\nmodule add8_2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Simple 8-bit adder implementation.\n    wire [7:0] sum;\n    assign sum = a + b + Cin;\n    assign y = sum;\n    assign Co = sum[7];\nendmodule\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\nwire [6:0] c;\nwire [7:0] sum_fa;\n\nfa fa0(a[0], b[0], cin, sum[0], c[0]);\nfa fa1(a[1], b[1], c[0], sum[1], c[1]);\nfa fa2(a[2], b[2], c[1], sum[2], c[2]);\nfa fa3(a[3], b[3], c[2], sum[3], c[3]);\nfa fa4(a[4], b[4], c[3], sum[4], c[4]);\nfa fa5(a[5], b[5], c[4], sum[5], c[5]);\nfa fa6(a[6], b[6], c[5], sum[6], c[6]);\nfa fa7(a[7], b[7], c[6], sum[7], cout);\n\nendmodule\n\nmodule fa(input a, b, cin, output s, cout);\n    assign {cout, s} = a + b + cin;\nendmodule\n"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nwire [3:0] shift_count;\nassign shift_count = rst_n ? (start ? 3 : 0) : 0;\n\n// Register Unit\nreg [15:0] a, b;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else if (start) begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\n// Multiplier Unit\nreg [31:0] product;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0;\n    end else if (start) begin\n        product <= 0;\n    end else begin\n        for (int i = 0; i < 16; i++) begin\n            if (a[i])\n                product = product + (b << i);\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = (shift_count == 3);\n\nendmodule\n\nmodule ctrl (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [3:0] shift_count,\n    output [3:0] shift_count_next\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count_next <= 0;\n    end else begin\n        shift_count_next <= start ? (shift_count + 1) : 0;\n    end\nend\n\nendmodule\n\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [15:0] a,    // Input a (multiplicand) with a data width of 16 bits.\n    output [15:0] b    // Input b (multiplier) with a data width of 16 bits.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else if (start) begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\nendmodule\n\nmodule mul_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b,     // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] product // Product output with a data width of 32 bits.\n);\n\nreg [31:0] product_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product_reg <= 0;\n    end else if (start) begin\n        product_reg <= 0;\n    end else begin\n        for (int i = 0; i < 16; i++) begin\n            if (a[i])\n                product_reg = product_reg + (b << i);\n        end\n    end\nend\n\nassign product = product_reg;\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .current_count(next_count),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (reset)\n            next_count = 0;\n        else if (up_down)\n            next_count = current_count + 1;\n        else\n            next_count = current_count - 1;\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= current_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Local signals\n    reg [2:0] init_state;\n    reg [2:0] transition_state;\n\n    // Submodule for state initialization\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_state)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .state_init(init_state),\n        .state_next(transition_state)\n    );\n\n    // Output logic\n    assign out = 8'b0000_0001 << transition_state;\n\nendmodule\n\n// Submodule for state initialization\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [2:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 3'b001;\n        end\n    end\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [2:0] state_init,\n    output reg [2:0] state_next\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state_next <= state_init;\n        end else begin\n            state_next <= (state_next == 3'b100) ? 3'b001 : state_next + 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] counter_logic_out;\n    wire [3:0] output_register_out;\n\n    counter_logic counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(counter_logic_out)\n    );\n\n    output_register output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(output_register_out)\n    );\n\n    assign out = output_register_out;\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] counter_logic_out,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= counter_logic_out;\n    end\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            if (out == 4'd11)\n                out <= 4'b0000;\n            else\n                out <= out + 1;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register and logic submodules.\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(next_Q));\n    JC_logic logic_inst(.clk(clk), .rst_n(rst_n), .Q(next_Q), .Q_next(Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) Q <= 64'b0;\n    end\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output [63:0]        Q_next\n);\n    always @(*) begin\n        Q_next = Q ^ (Q >> 1) ^ (Q >> 2);\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_50_int, CLK_10_int, CLK_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1_int)\n    );\n\n    assign CLK_50 = CLK_50_int;\n    assign CLK_10 = CLK_10_int;\n    assign CLK_1 = CLK_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            cnt <= 0;\n        else if (cnt == 1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            CLK_out <= 0;\n        else if (cnt == 1)\n            CLK_out <= ~CLK_out;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            cnt <= 0;\n        else if (cnt == 4)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            CLK_out <= 0;\n        else if (cnt == 4)\n            CLK_out <= ~CLK_out;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] cnt;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            cnt <= 0;\n        else if (cnt == 49)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n\n    always @ (posedge CLK_in or posedge RST)\n        if (RST)\n            CLK_out <= 0;\n        else if (cnt == 49)\n            CLK_out <= ~CLK_out;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [2:0] counter_out;\n    wire clk_div_int_4;\n    wire clk_div_int_3;\n\n    // Counter Submodule\n    counter #(\n        .COUNT_MAX(MUL2_DIV_CLK - 1)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out)\n    );\n\n    // Clock Average Generator Submodule\n    clk_average #(\n        .COUNT_MAX(2),\n        .CLK_FREQ_MHZ(50),\n        .CLK_DUTY_CYCLE(50)\n    ) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_avg(counter_out[1]),\n        .clk_div(clk_div_int_4)\n    );\n\n    // Clock Adjustment Submodule\n    clk_adjustment #(\n        .COUNT_MAX(2),\n        .CLK_FREQ_MHZ(50),\n        .CLK_DUTY_CYCLE(50)\n    ) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_avg(counter_out[0]),\n        .clk_div(clk_div_int_3)\n    );\n\n    // Intermediate Clock Output Logic\n    assign clk_div = clk_div_int_4 | clk_div_int_3;\n\nendmodule\n\n// Counter Submodule\nmodule counter #(\n    parameter COUNT_MAX = 4\n) (\n    input               clk,\n    input               rst_n,\n    output reg  [2:0]   counter_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_out <= 0;\n        end else if (counter_out == COUNT_MAX) begin\n            counter_out <= 0;\n        end else begin\n            counter_out <= counter_out + 1;\n        end\n    end\n\nendmodule\n\n// Clock Average Generator Submodule\nmodule clk_average #(\n    parameter COUNT_MAX = 2,\n    parameter CLK_FREQ_MHZ = 50,\n    parameter CLK_DUTY_CYCLE = 50\n) (\n    input               clk,\n    input               rst_n,\n    input               clk_avg,\n    output reg          clk_div\n);\n\n    localparam PERIOD_NS = (1000000000 / CLK_FREQ_MHZ) / (COUNT_MAX + 1);\n    localparam PULSE_WIDTH_NS = (PERIOD_NS * CLK_DUTY_CYCLE) / 100;\n\n    reg [COUNT_MAX:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n            counter <= 0;\n        end else if (counter == COUNT_MAX) begin\n            clk_div <= 0;\n            counter <= 0;\n        end else if (clk_avg) begin\n            counter <= counter + 1;\n            if (counter == 1) begin\n                clk_div <= 1;\n            end else if (counter == COUNT_MAX) begin\n                clk_div <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Clock Adjustment Submodule\nmodule clk_adjustment #(\n    parameter COUNT_MAX = 2,\n    parameter CLK_FREQ_MHZ = 50,\n    parameter CLK_DUTY_CYCLE = 50\n) (\n    input               clk,\n    input               rst_n,\n    input               clk_avg,\n    output reg          clk_div\n);\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter [31:0] NUM_DIV = 5;\n\n    reg [31:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 1'b0;\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n\n            if (counter == 0) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    parameter [31:0] NUM_DIV = 5;\n\n    reg [31:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 1'b0;\n            counter <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n\n            if (counter == 0) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 4;\n\nwire counter_reset, counter_limit;\nwire counter_inc, counter_toggle;\n\nreg [3:0] counter;\n\nassign counter_reset = ~rst_n;\nassign counter_limit = (counter == (NUM_DIV / 2 - 1));\nassign counter_inc = counter_reset | counter_limit;\nassign counter_toggle = counter_limit;\n\nassign clk_div = counter_toggle;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter_reset)\n        counter <= 0;\n    else if (counter_inc)\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q,\n    input limit\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        q <= 0;\n    else if (limit && q == (limit - 1))\n        q <= 0;\n    else if (limit && q == limit - 1)\n        q <= q + 1;\n    else if (~limit && q == (2 ** 4 - 1))\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input toggle,\n    output reg clk_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_out <= 0;\n    else if (toggle)\n        clk_out <= ~clk_out;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\nwire [31:0] alu_result;\n\n// Instantiate the submodules\nalu_add add (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .carry(carry)\n);\n\nalu_addsub addu (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .carry(carry)\n);\n\nalu_sub sub (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .carry(carry)\n);\n\nalu_subsub subu (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .carry(carry)\n);\n\nalu_and and1 (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_or or1 (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_xor xor1 (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_nor nor1 (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_slt slt_inst (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .flag(flag)\n);\n\nalu_sltu sltu_inst (\n    .a(a),\n    .b(b),\n    .r(alu_result),\n    .flag(flag)\n);\n\nalu_sll sll (\n    .a(a),\n    .b(b[4:0]),\n    .r(alu_result)\n);\n\nalu_srl srl (\n    .a(a),\n    .b(b[4:0]),\n    .r(alu_result)\n);\n\nalu_sra sra (\n    .a(a),\n    .b(b[4:0]),\n    .r(alu_result)\n);\n\nalu_sllv sllv (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_srlv srlv (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_srav srav (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nalu_lui lui_inst (\n    .a(a),\n    .b(b),\n    .r(alu_result)\n);\n\nassign r = alu_result;\nassign zero = alu_result == 0;\nassign negative = alu_result[31];\nassign overflow = 1'b0;\n\nendmodule\n\n// Addition\nmodule alu_add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\nassign {carry, r} = a + b;\nendmodule\n\n// Addition with carry\nmodule alu_addsub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\nassign {carry, r} = a + b;\nendmodule\n\n// Subtraction\nmodule alu_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\nassign {carry, r} = a - b;\nendmodule\n\n// Subtraction with borrow\nmodule alu_subsub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry\n);\nassign {carry, r} = a - b;\nendmodule\n\n// Logical AND\nmodule alu_and(\n    input [31:0] a,\n    input [31:0] b"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [31:0] multiplication_result;\n    wire [31:0] accumulation_result;\n\n    // Multiplier submodule\n    multiply u_multiplier(.a(a), .b(b), .c(multiplication_result));\n\n    // Accumulator submodule\n    accumulator u_accumulator(.clk(clk), .rst(rst), .c(current_value), .new_value(multiplication_result), .accumulated_value(accumulation_result));\n\n    // Intermediate variables\n    reg [31:0] current_value;\n\n    // Output port\n    assign c = accumulation_result;\n\nendmodule\n\nmodule multiply(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    // Calculate product of a and b\n    assign c = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] c,\n    input [31:0] new_value,\n    output reg [31:0] accumulated_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulated_value <= 0;\n        end else begin\n            accumulated_value <= accumulated_value + new_value;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] op;\n    wire [4:0] adr1;\n    wire [7:0] adr2;\n\n    ins_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins[0]),\n        .adr(adr1[4:0])\n    );\n    ins_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins[1]),\n        .adr(adr2)\n    );\n\n    assign ad1 = adr1;\n    assign ad2 = adr2;\n\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] adr\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            adr <= 5'b0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            adr <= data[4:0];\n        end else begin\n            ins <= ins;\n            adr <= adr;\n        end\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [7:0] adr\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            adr <= 8'b0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            adr <= data;\n        end else begin\n            ins <= ins;\n            adr <= adr;\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire [7:0] wave_freq;\n\n    wire enable;\n\n    counter counter_inst(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wave_generator_inst(\n        .clk(clk),\n        .count(count),\n        .freq(wave_freq),\n        .wave_out(wave_out)\n    );\n\n    assign enable = (freq != 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out <= 1;\n        end else if (count == 0) begin\n            wave_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n            wave_reg <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b00;\n                end\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) state <= 0;\n        else state <= 0;\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) wave <= 0;\n        else if (state == 0) wave <= wave + 1;\n        else wave <= wave - 1;\n    end\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] dff_out;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    assign q = (sel[0] && sel[1]) ? dff_out[2] : d;\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\nwire q1, q2;\n\nmy_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q1)\n);\n\nmy_dff u1 (\n    .clk(clk),\n    .d(q1),\n    .q(q2)\n);\n\nmy_dff u2 (\n    .clk(clk),\n    .d(q2),\n    .q(q)\n);\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output reg [7:0] out;\n\n    wire [7:0] shifted;\n    wire [2:0] sel;\n    wire [1:0] stage;\n\n    assign sel = ctrl[2:1];\n    assign stage = ctrl[0];\n\n    // Instantiate the 8-to-4 barrel shifter\n    barrel_shifter_8to4 bshifter_8to4 (\n        .in(in),\n        .ctrl(sel),\n        .out(shifted)\n    );\n\n    // Instantiate the 4-to-2 barrel shifter\n    barrel_shifter_4to2 bshifter_4to2 (\n        .in(shifted),\n        .ctrl(stage),\n        .out(out)\n    );\n\nendmodule\n\nmodule barrel_shifter_8to4 (\n    input [7:0] in,\n    input [1:0] ctrl,\n    output reg [7:0] out\n);\n    wire [3:0] sel;\n\n    assign sel = ctrl;\n\n    // Select between the 8 input bits and shift them accordingly\n    always @(*) begin\n        case (sel)\n            2'b00: out = in;\n            2'b01: out = {in[7:4], in[3:0]};\n            2'b10: out = {in[3:0], in[7:4]};\n            2'b11: out = {in[1:0], in[7:2], in[5:3]};\n        endcase\n    end\nendmodule\n\nmodule barrel_shifter_4to2 (\n    input [7:0] in,\n    input [0:0] ctrl,\n    output reg [7:0] out\n);\n    wire [1:0] sel;\n\n    assign sel = ctrl;\n\n    // Select between the 4 input bits and shift them accordingly\n    always @(*) begin\n        case (sel)\n            2'b00: out = in;\n            2'b01: out = {in[7:2], in[1:0]};\n        endcase\n    end\nendmodule\n\nmodule mux2X1 (\n    input [1:0] a,\n    input [1:0] b,\n    input sel,\n    output [1:0] y\n);\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n  wire [31:0] p0, p1;\n\n  // Implement a single Processing Element with direct inputs.\n  assign p0 = a0 * b0;\n  assign c0 = p0;\n\n  // Implement a single Processing Element with delayed inputs.\n  assign b1 = rst ? 0 : b0;\n  assign p1 = a1 * b1;\n  assign c1 = p1;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n\n  stage fetch_stage(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .fetched(fetched));\n  stage decode_stage(.clk(clk), .rst(rst), .fetched(fetched), .decode_result(decode_result));\n  stage execute_stage(.clk(clk), .rst(rst), .decode_result(decode_result), .alu_res(alu_res));\n  stage memory_stage(.clk(clk), .rst(rst), .alu_res(alu_res), .memory_result(memory_result));\n  stage writeback_stage(.clk(clk), .rst(rst), .pc(pc), .memory_result(memory_result), .res_reg_file(res_reg_file));\n\n  reg [31:0] pc;\n  reg [31:0] fetched;\n  reg [31:0] decode_result;\n  reg [31:0] alu_res;\n  reg [31:0] memory_result;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else begin\n      pc <= pc + 4;\n      if (pc == 32)\n        pc <= 0;\n    end\n  end\n\nendmodule\n\nmodule stagepipe5_regs(\n  input clk,\n  input rst,\n  input [31:0] fetched,\n  input [31:0] decode_result,\n  input [31:0] alu_res,\n  output [31:0] memory_result\n);\n  reg [31:0] next_pc;\n  reg [31:0] next_fetched;\n  reg [31:0] next_decode_result;\n  reg [31:0] next_alu_res;\n  reg [31:0] next_memory_result;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n      next_fetched <= 0;\n      next_decode_result <= 0;\n      next_alu_res <= 0;\n      next_memory_result <= 0;\n    end else begin\n      next_pc <= pc;\n      next_fetched <= fetched;\n      next_decode_result <= decode_result;\n      next_alu_res <= alu_res;\n      next_memory_result <= memory_result;\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= next_pc;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      fetched <= 0;\n    else\n      fetched <= next_fetched;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      decode_result <= 0;\n    else\n      decode_result <= next_decode_result;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_res <= 0;\n    else\n      alu_res <= next_alu_res;\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      memory_result <= 0;\n    else\n      memory_result <= next_memory_result;\n  end\nendmodule\n\nmodule fetch(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input pc,\n  output [31:0] fetched\n);\n  reg [31:0] fetched_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      fetched_reg <= 0;\n    else\n      fetched_reg <= instr_mem[pc];\n  end\n\n  assign fetched = fetched_reg;\nendmodule\n\nmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\nreg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\nreg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    b0_reg <= 0;\n    b1_reg <= 0;\n    b2_reg <= 0;\n    b3_reg <= 0;\n    c0_reg <= 0;\n    c1_reg <= 0;\n    c2_reg <= 0;\n    c3_reg <= 0;\n  end else begin\n    b0_reg <= b0;\n    b1_reg <= b0_reg;\n    b2_reg <= b1_reg;\n    b3_reg <= b2_reg;\n    c0_reg <= b0_reg * a0;\n    c1_reg <= b1_reg * a1 + c0_reg;\n    c2_reg <= b2_reg * a2 + c1_reg;\n    c3_reg <= b3_reg * a3 + c2_reg;\n  end\nend\n\nassign c0 = c0_reg;\nassign c1 = c1_reg;\nassign c2 = c2_reg;\nassign c3 = c3_reg;\n\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n\nreg [31:0] c_reg;\n\nalways @(posedge clk) begin\n  if (rst)\n    c_reg <= 0;\n  else\n    c_reg <= a * b;\nend\n\nassign c = c_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch_inst, op1, op2;\n    wire [5:0] opcode, rd, rs1, rs2;\n\n    // Instantiate stages\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .inst(fetch_inst)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetch_inst(fetch_inst),\n        .reg_file(reg_file),\n        .op1(op1),\n        .op2(op2),\n        .opcode(opcode),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .op1(op1),\n        .rd(rd),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\n    // Instruction memory\n    reg [31:0] pc = 32'b0;\n    always @(posedge clk or posedge rst) begin\n        if (rst) pc <= 32'b0;\n        else pc <= pc + 1;\n    end\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] inst\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) inst <= 32'b0;\n        else inst <= instr_mem[pc];\n    end\nendmodule\n\n// Execute stage\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetch_inst,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [5:0] opcode,\n    output reg [5:0] rd,\n    output reg [5:0] rs1,\n    output reg [5:0] rs2\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 32'b0;\n            op2 <= 32'b0;\n            opcode <= 6'b0;\n            rd <= 6'b0;\n            rs1 <= 6'b0;\n            rs2 <= 6'b0;\n        end else begin\n            // Fetch instruction\n            op1 <= reg_file[fetch_inst[25:21]];\n            op2 <= reg_file[fetch_inst[20:16]];\n\n            // Decode\n            opcode <= fetch_inst[5:0];\n            rd <= fetch_inst[11:7];\n            rs1 <= fetch_inst[19:15];\n            rs2 <= fetch_inst[24:20];\n        end\n    end\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] op1,\n    input [5:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) out_reg_file <= 32'b0;\n        else out_reg_file[rd] <= op1;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire valid_in_sync;\n\nassign valid_in_sync = valid_in & valid_out;\n\n// Instance of Counter Module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in_sync),\n    .count_out(valid_out)\n);\n\n// Instance of Data Accumulator Module\ndata_accumulator u_data_accumulator (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in_sync),\n    .data_in(data_in),\n    .data_out(data_out)\n);\n\n// Instance of Valid Output Module\nvalid_output u_valid_output (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in_sync),\n    .valid_out(valid_out)\n);\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg          count_out\n);\n\nreg [1:0] cnt;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 2'b00;\n        count_out <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            cnt <= cnt + 1;\n        end\n        if (cnt == 2'b11) begin\n            cnt <= 2'b00;\n            count_out <= 1'b1;\n        end else begin\n            count_out <= 1'b0;\n        end\n    end\nend\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n\n    output reg  [9:0]   data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 10'b0;\n    end else begin\n        if (valid_in) begin\n            data_out <= data_out + data_in;\n        end\n    end\nend\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg          valid_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out <= 1'b0;\n    end else begin\n        valid_out <= valid_in;\n    end\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [7:0] abs_dividend, neg_divisor_mod;\n    wire [2:0] cnt;\n    wire [7:0] shift_reg;\n    wire done;\n    \n    abs_value abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(dividend),\n        .result(abs_dividend)\n    );\n    \n    neg_value neg_divisor_mod_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(divisor),\n        .result(neg_divisor_mod)\n    );\n    \n    divider_control div_ctrl_inst(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .done(done)\n    );\n    \n    result_management res_mgmt_inst(\n        .clk(clk),\n        .rst(rst),\n        .cnt(cnt),\n        .shift_reg(shift_reg),\n        .divisor(neg_divisor_mod),\n        .dividend(abs_dividend),\n        .res_valid(res_valid),\n        .result(result)\n    );\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else if (sign)\n            result <= -dividend;\n        else\n            result <= dividend;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= sign ? ~dividend + 1 : ~dividend;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [2:0] cnt,\n    output reg [7:0] shift_reg\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cnt <= 0;\n            shift_reg <= 0;\n        end\n        else if (opn_valid) begin\n            cnt <= 3;\n            shift_reg <= dividend;\n        end\n        else if (cnt > 0 && !res_ready) begin\n            cnt <= cnt - 1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [2:0] cnt,\n    input wire [7:0] shift_reg,\n    input wire [7:0] divisor,\n    input wire [7:0] dividend,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end\n        else if (cnt == 0 && opn_valid) begin\n            res_valid <= 1;\n            result <= {shift_reg, dividend - divisor};\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] prep_result;\n    wire [31:0] div_result;\n    wire [15:0] div_odd;\n\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .prep_result(prep_result)\n    );\n\n    div_operation div_operation_inst(\n        .A(prep_result),\n        .B(B),\n        .div_result(div_result),\n        .div_odd(div_odd)\n    );\n\n    assign result = div_result;\n    assign odd = div_odd;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] prep_result\n);\n\n    wire [15:0] A_high, A_low;\n\n    assign A_high = A[31:16];\n    assign A_low = A[15:0];\n\n    assign prep_result = {A_high, A_low};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] div_result,\n    output wire [31:0] div_odd\n);\n\n    wire [31:0] shifted_dividend;\n    wire [15:0] shifted_divisor;\n    reg [31:0] i;\n\n    assign shifted_dividend = A >> 16;\n    assign shifted_divisor = B;\n\n    assign div_result = 0;\n    assign div_odd = 0;\n\n    always @(shifted_dividend or shifted_divisor) begin\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend[31:16] >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                shifted_dividend[31:16] = shifted_dividend[31:16] + 1;\n            end\n            div_result = div_result << 1;\n            div_result[0] = shifted_dividend[31];\n        end\n        div_odd = shifted_dividend;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n\n    // Instantiate the control unit\n    control_unit ctrl_unit (\n        .A(A),\n        .B(B),\n        .ctrl_output(temp),\n        .odd(odd)\n    );\n\n    // Output port\n    assign result = temp;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] ctrl_output,\n    output reg [15:0] odd\n);\n    reg [15:0] dividend, divisor, quotient;\n    reg [3:0] counter;\n\n    always @(*) begin\n        // Initialize\n        dividend = A;\n        divisor = B;\n        quotient = 16'b0;\n        odd = 16'b0;\n\n        // Control loop\n        for (counter = 0; counter < 16; counter = counter + 1) begin\n            // Update divisor\n            divisor = divisor << 1;\n\n            // Shift dividend\n            if (dividend[15] == 1) begin\n                dividend = dividend << 1;\n                dividend[0] = 0;\n            end\n\n            // Compare and update\n            if (dividend > divisor) begin\n                dividend = dividend - divisor;\n                quotient = quotient << 1;\n                quotient[0] = 1;\n            end else begin\n                quotient = quotient << 1;\n                quotient[0] = 0;\n            end\n        end\n\n        // Final output\n        ctrl_output = quotient;\n        odd = dividend;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_complement;\nwire carry_out;\n\nassign B_complement = ~B + 1;\n\n// Instantiate the adder module to perform the subtraction operation\nadder_8bit adder_inst(.A(A), .B(B_complement), .Cin(0), .D(D), .Cout(carry_out));\nassign B_out = carry_out;\n\nendmodule\n\nmodule adder_8bit(A, B, Cin, D, Cout);\ninput [7:0] A, B;\ninput Cin;\noutput [7:0] D;\noutput Cout;\n\nwire [7:0] C;\nwire [7:0] sum;\nwire carry;\n\nassign {carry, sum} = A + B + Cin;\nassign D = sum;\nassign Cout = carry;\n\nendmodule\n\nmodule full_adder(A, B, Cin, D, C);\ninput A, B, Cin;\noutput D, C;\n\nassign D = A ^ B ^ Cin;\nassign C = (A & B) | (B & Cin) | (Cin & A);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [31:0] B_inv;\n\n    // Invert the second operand\n    assign B_inv = ~B;\n\n    // Instantiate 16-bit subtractor blocks\n    sub_16bit S1(.A(A[15:0]), .B(B[15:0]), .B_out(B_out), .Diff(Diff[15:0]));\n    sub_16bit S2(.A(A[31:16]), .B(B_inv[15:0]), .B_out(B_out), .Diff(Diff[31:16]));\n\nendmodule\n\n// 16-bit subtractor block\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A, B;\n    output B_out;\n    output [15:0] Diff;\n\n    wire [15:0] B_inv;\n\n    // Invert the second operand\n    assign B_inv = ~B;\n\n    // Subtractor\n    assign Diff = A - B_inv;\n    assign B_out = A[15] ^ B_inv[15];\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] D0, D1;\nwire B0, B1;\n\nsub_32bit sub0(\n    .A(A[31:0]),\n    .B(B[31:0]),\n    .D(D0),\n    .B_out(B0)\n);\n\nsub_32bit sub1(\n    .A(A[63:32]),\n    .B(B[63:32]),\n    .D(D1),\n    .B_out(B1)\n);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] D0, D1;\nwire B0, B1;\n\nsub_16bit sub0(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .D(D0),\n    .B_out(B0)\n);\n\nsub_16bit sub1(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .D(D1),\n    .B_out(B1)\n);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] D0, D1;\nwire B0, B1;\n\nsub_8bit sub0(\n    .A(A[7:0]),\n    .B(B[7:0]),\n    .D(D0),\n    .B_out(B0)\n);\n\nsub_8bit sub1(\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .D(D1),\n    .B_out(B1)\n);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [3:0] D0, D1;\nwire B0, B1;\n\nsub_4bit sub0(\n    .A(A[3:0]),\n    .B(B[3:0]),\n    .D(D0),\n    .B_out(B0)\n);\n\nsub_4bit sub1(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .D(D1),\n    .B_out(B1)\n);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\ninput [3:0] A, B;\noutput [3:0] D;\noutput B_out;\n\nwire [1:0] D0, D1;\nwire B0, B1;\n\nsub_2bit sub0(\n    .A(A[1:0]),\n    .B(B[1:0]),\n    .D(D0),\n    .B_out(B0)\n);\n\nsub_2bit sub1(\n    .A(A[3:2]),\n    .B(B[3:2]),\n    .D(D1),\n    .B_out(B1)\n);\n\nassign D = {D1, D0};\nassign B_out = B0 | B1;\nendmodule\n\nmodule sub_2bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\n"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [16:1] B_neg;\n    wire [16:1] B_neg_1;\n    wire [16:1] B_neg_2;\n    wire [16:1] B_neg_3;\n    wire [16:1] B_neg_4;\n    wire [16:1] B_neg_5;\n    wire [16:1] B_neg_6;\n    wire [16:1] B_neg_7;\n    wire [16:1] B_neg_8;\n\n    wire [16:1] B_neg_9;\n    wire [16:1] B_neg_10;\n    wire [16:1] B_neg_11;\n    wire [16:1] B_neg_12;\n    wire [16:1] B_neg_13;\n    wire [16:1] B_neg_14;\n    wire [16:1] B_neg_15;\n    wire [16:1] B_neg_16;\n    wire [16:1] B_neg_17;\n\n    wire [16:1] B_neg_18;\n    wire [16:1] B_neg_19;\n    wire [16:1] B_neg_20;\n    wire [16:1] B_neg_21;\n    wire [16:1] B_neg_22;\n    wire [16:1] B_neg_23;\n    wire [16:1] B_neg_24;\n    wire [16:1] B_neg_25;\n    wire [16:1] B_neg_26;\n\n    wire [16:1] B_neg_27;\n    wire [16:1] B_neg_28;\n    wire [16:1] B_neg_29;\n    wire [16:1] B_neg_30;\n    wire [16:1] B_neg_31;\n    wire [16:1] B_neg_32;\n    wire [16:1] B_neg_33;\n    wire [16:1] B_neg_34;\n    wire [16:1] B_neg_35;\n\n    wire [16:1] B_neg_36;\n    wire [16:1] B_neg_37;\n    wire [16:1] B_neg_38;\n    wire [16:1] B_neg_39;\n    wire [16:1] B_neg_40;\n    wire [16:1] B_neg_41;\n    wire [16:1] B_neg_42;\n    wire [16:1] B_neg_43;\n    wire [16:1] B_neg_44;\n\n    wire [16:1] B_neg_45;\n    wire [16:1] B_neg_46;\n    wire [16:1] B_neg_47;\n    wire [16:1] B_neg_48;\n    wire [16:1] B_neg_49;\n    wire [16:1] B_neg_50;\n    wire [16:1] B_neg_51;\n    wire [16:1] B_neg_52;\n    wire [16:1] B_neg_53;\n\n    wire [16:1] B_neg_54;\n    wire [16:1] B_neg_55;\n    wire [16:1] B_neg_56;\n    wire [16:1] B_neg_57;\n    wire [16:1] B_neg_58;\n    wire [16:1] B_neg_59;\n    wire [16:1] B_neg_60;\n    wire [16:1] B_neg_61;\n    wire [16"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (~borrow & (sub_result != 0));\n    assign A_equal = (~borrow & (sub_result == 0));\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,   // Result of A - B\n    output borrow         // Carry output\n);\n\n    wire [32:0] sum;\n    wire [31:0] carry;\n\n    assign sum = {1'b0, A} - {1'b0, B};\n    assign carry = sum[32];\n    assign sub_result = sum[31:0];\n    assign borrow = carry;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire [15:1] sum[32:1], carry[32:1];\n    \n    // Use a loop to instantiate the 16-bit CLA\n    genvar i;\n    for(i = 1; i <= 16; i = i + 1) begin\n        // The carry chain\n        assign carry[i] = (i == 1) ? A[1] : (carry[i-1] ^ A[1]);\n        assign sum[i] = (i == 1) ? A[1] ^ B[1] : (carry[i-1] ^ B[i]) ^ carry[i-1];\n        // The next-to-last sum for the next CLA\n        assign carry[i+1] = (i == 1) ? sum[i] : (carry[i] ^ sum[i]);\n    end\n    assign S = {sum[16], sum[15], sum[14], sum[13], sum[12], sum[11], sum[10], sum[9], sum[8], sum[7], sum[6], sum[5], sum[4], sum[3], sum[2], sum[1], sum[16]};\n    assign C32 = carry[16];\nendmodule\n\nmodule CLA1(A,B,Cin,S);\n    input A,B,Cin;\n    output S,Cout;\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule\n\nmodule CLA2(A,B,Cin,S);\n    input A,B,Cin;\n    output S,Cout;\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry_in;\n    wire [3:0] sum_in;\n    wire [3:0] carry_out;\n\n    assign carry_in[0] = cin;\n    assign carry_in[1] = carry_out[0];\n    assign carry_in[2] = carry_out[1];\n    assign carry_in[3] = carry_out[2];\n\n    assign sum_in[0] = a[0] ^ b[0] ^ carry_in[0];\n    assign sum_in[1] = a[1] ^ b[1] ^ carry_in[1];\n    assign sum_in[2] = a[2] ^ b[2] ^ carry_in[2];\n    assign sum_in[3] = a[3] ^ b[3] ^ carry_in[3];\n\n    assign sum = {sum_in[3], sum_in[2], sum_in[1], sum_in[0]};\n    assign carry_out[0] = (a[0] & b[0]) | (carry_in[0] & (a[0] ^ b[0]));\n    assign carry_out[1] = (a[1] & b[1]) | (carry_in[1] & (a[1] ^ b[1]));\n    assign carry_out[2] = (a[2] & b[2]) | (carry_in[2] & (a[2] ^ b[2]));\n    assign carry_out[3] = (a[3] & b[3]) | (carry_in[3] & (a[3] ^ b[3]));\n    assign cout = carry_out[3];\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    assign carry[0] = cin;\n    assign carry[1] = (a[0] & b[0]) | (carry[0] & (a[0] ^ b[0]));\n    assign carry[2] = (a[1] & b[1]) | (carry[1] & (a[1] ^ b[1]));\n    assign carry[3] = (a[2] & b[2]) | (carry[2] & (a[2] ^ b[2]));\n    assign sum = {carry[3], carry[2], carry[1], carry[0]};\n    assign cout = carry[3];\nendmodule\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, carry_out);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output carry_out;\n\n    wire [3:0] carry;\n\n    assign carry[0] = cin;\n    assign carry[1] = (a[0] & b[0]) | (carry[0] & (a[0] ^ b[0]));\n    assign carry[2] = (a[1] & b[1]) | (carry[1] & (a[1] ^ b[1]));\n    assign carry[3] = (a[2] & b[2]) | (carry[2] & (a[2] ^ b[2]));\n    assign sum = {carry[3], carry[2], carry[1], carry[0]};\n    assign carry_out = carry[3];\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry[15:0];\n    wire [3:0] sum_in[15:0];\n\n    assign carry[0] = cin;\n    assign carry[1] = (a[0] & b["}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [1:0] carry;\n    wire [7:0] add_out;\n\n    // 8-bit adder instantiation\n    add8_inst1 add8_1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(add_out[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(add_out[15:8]),\n        .Co(carry[1])\n    );\n\n    assign y = {add_out[15:8], add_out[7:0]};\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // 8-bit adder implementation here\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // 8-bit adder implementation here\nendmodule\n\n"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7;\n    \n    // Instantiate 8 Full Adders\n    FA FA0_inst(\n        .a(a[0]), .b(b[0]), .cin(cin), \n        .sum(FA0), .cout(FA1)\n    );\n    FA FA1_inst(\n        .a(a[1]), .b(b[1]), .cin(FA1), \n        .sum(FA2), .cout(FA3)\n    );\n    FA FA2_inst(\n        .a(a[2]), .b(b[2]), .cin(FA2), \n        .sum(FA4), .cout(FA5)\n    );\n    FA FA3_inst(\n        .a(a[3]), .b(b[3]), .cin(FA3), \n        .sum(FA6), .cout(FA7)\n    );\n    FA FA4_inst(\n        .a(a[4]), .b(b[4]), .cin(FA4), \n        .sum(sum[4]), .cout(FA5)\n    );\n    FA FA5_inst(\n        .a(a[5]), .b(b[5]), .cin(FA5), \n        .sum(sum[5]), .cout(FA6)\n    );\n    FA FA6_inst(\n        .a(a[6]), .b(b[6]), .cin(FA6), \n        .sum(sum[6]), .cout(FA7)\n    );\n    FA FA7_inst(\n        .a(a[7]), .b(b[7]), .cin(FA7), \n        .sum(sum[7]), .cout(cout)\n    );\n    \nendmodule\n\nmodule FA(\n    input a, b, cin,\n    output sum, cout\n    );\n    \n    assign {cout, sum} = a + b + cin;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nwire [3:0] shift_count;\nwire [15:0] reg_a;\nwire [15:0] reg_b;\nwire [31:0] reg_product;\nwire [3:0] next_shift_count;\nwire [31:0] next_reg_product;\n\ncontrol_unit control_unit_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .shift_count(shift_count),\n    .reg_a(reg_a),\n    .reg_b(reg_b),\n    .reg_product(reg_product),\n    .next_shift_count(next_shift_count),\n    .next_reg_product(next_reg_product)\n);\n\n// Register Unit\nreg [15:0] reg_a_inst;\nreg [15:0] reg_b_inst;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_a_inst <= 16'd0;\n        reg_b_inst <= 16'd0;\n    end else begin\n        reg_a_inst <= ain;\n        reg_b_inst <= bin;\n    end\nend\n\n// Multiplier Unit\nwire [31:0] multiply_result;\n\nassign multiply_result = reg_a_inst * reg_b_inst;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_product <= 32'd0;\n    end else begin\n        reg_product <= next_reg_product;\n    end\nend\n\n// Output Assignment\nassign yout = reg_product;\nassign done = start && (shift_count == 4'd15);\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count,\n    output reg [15:0] reg_a,\n    output reg [15:0] reg_b,\n    output reg [31:0] reg_product,\n    input [3:0] next_shift_count,\n    input [31:0] next_reg_product\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        shift_count <= 4'd0;\n    end else if (start) begin\n        shift_count <= 4'd0;\n    end else if (shift_count == 4'd15) begin\n        shift_count <= 4'd0;\n    end else begin\n        shift_count <= next_shift_count;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else if (start) begin\n        reg_a <= 16'd0;\n        reg_b <= 16'd0;\n    end else begin\n        reg_a <= reg_a_inst;\n        reg_b <= reg_b_inst;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_product <= 32'd0;\n    end else if (start) begin\n        reg_product <= 32'd0;\n    end else begin\n        reg_product <= next_reg_product;\n    end\nend\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input [3:0] shift_count,\n    input [15:0] reg_a,\n    input [15:0] reg_b,\n    output [31:0] multiply_result\n);\n\nwire [31:0] reg_product;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_product <= 32'd0;\n   "}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\n\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .next_count(next_count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        next_count <= 16'd0;\n    end else if (up_down) begin\n        next_count <= next_count + 16'd1;\n    end else begin\n        next_count <= next_count - 16'd1;\n    end\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'd0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate submodule for initialization\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .out(transition_out)\n    );\n\n    assign out = init_out & transition_out;\n\nendmodule\n\n// Submodule for initial state initialization\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= {~out[7], out[6:0]};\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\nwire [3:0] count_out;\n\n// counter_logic\ncounter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count_out(count_out)\n);\n\n// output_register\noutput_register u_output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .count_out(count_out),\n    .out(out)\n);\n\nendmodule\n\nmodule\ncounter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count_out <= 4'b0000;\n    else if (valid_count) begin\n        if (count_out == 4'd11)\n            count_out <= 4'b0000;\n        else\n            count_out <= count_out + 1;\n    end\nend\n\nendmodule\n\nmodule\noutput_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 4'b0000;\n    else if (valid_count)\n        out <= count_out;\nend\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0]    next_Q;\n\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(next_Q));\n    JC_logic logic_inst(.Q(next_Q), .next_Q(Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q,\n    output reg [63:0]   next_Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= Q;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    input [63:0]       next_Q,\n    output reg [63:0]  next_Q_out\n);\n    always @(*) begin\n        next_Q_out = {Q[62:0], Q[63]};\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_div_2_out, clk_div_10_out, clk_div_100_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [1:0] counter = 2'd0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 2'd0;\n            CLK_out <= 1'b0;\n        end else if (counter == 2'd1) begin\n            CLK_out <= ~CLK_out;\n            counter <= 2'd0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [3:0] counter = 4'd0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 4'd0;\n            CLK_out <= 1'b0;\n        end else if (counter == 4'd3) begin\n            CLK_out <= ~CLK_out;\n            counter <= 4'd0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\n    reg [5:0] counter = 6'd0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 6'd0;\n            CLK_out <= 1'b0;\n        end else if (counter == 6'd49) begin\n            CLK_out <= ~CLK_out;\n            counter <= 6'd0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    wire clk_div_int1;\n    wire clk_div_int2;\n    \n    // Counter Submodule\n    reg [1:0] counter;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 2'd0;\n        end\n        else if (counter == 2'd3) begin\n            counter <= 2'd0;\n        end\n        else begin\n            counter <= counter + 2'd1;\n        end\n    end\n    \n    // Clock Average Generator Submodule\n    wire clk_average_0;\n    wire clk_average_1;\n    assign clk_average_0 = counter[0];\n    assign clk_average_1 = counter[1];\n    \n    assign clk_div_int1 = clk_average_0 & clk_average_1;\n    \n    // Clock Adjustment Submodule\n    assign clk_div_int2 = ~clk_div_int1;\n    \n    // Clock Output\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n    \n    reg [2:0] counter;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 3'd0;\n            clk_div <= 1'b0;\n        end\n        else if (counter == 3'd7) begin\n            counter <= 3'd0;\n            clk_div <= 1'b1;\n        end\n        else begin\n            counter <= counter + 3'd1;\n            clk_div <= 1'b0;\n        end\n    end\n    \nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg          clk_avg\n);\n    \n    reg [1:0] counter;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 2'd0;\n            clk_avg <= 1'b0;\n        end\n        else if (counter == 2'd1) begin\n            counter <= 2'd0;\n            clk_avg <= clk_div;\n        end\n        else begin\n            counter <= counter + 2'd1;\n        end\n    end\n    \nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_div,\n    output reg          clk_adj_neg\n);\n    \n    reg [1:0] counter;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 2'd0;\n            clk_adj_neg <= 1'b0;\n        end\n        else if (counter == 2'd1) begin\n            counter <= 2'd0;\n            clk_adj_neg <= clk_div;\n        end\n        else begin\n            counter <= counter + 2'd1;\n        end\n    end\n    \nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n    wire clk_div1, clk_div2;\n    wire pos_clk, neg_clk;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_out(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_out\n);\n    reg [NUM_DIV - 1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n)\n            counter <= 0;\n        else\n            if (counter < NUM_DIV - 1)\n                counter <= counter + 1;\n    end\n\n    assign clk_out = counter == NUM_DIV - 1;\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_out\n);\n    reg [NUM_DIV - 1:0] counter;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n)\n            counter <= 0;\n        else\n            if (counter < NUM_DIV - 1)\n                counter <= counter + 1;\n    end\n\n    assign clk_out = counter == NUM_DIV - 1;\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            counter <= 4'd0;\n        else if (counter == NUM_DIV/2 - 1)\n            counter <= 4'd0;\n        else\n            counter <= counter + 4'd1;\n    end\n\n    reg clk_div_int;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_int <= 0;\n        else if (counter == NUM_DIV/2 - 1)\n            clk_div_int <= ~clk_div_int;\n    end\n    assign clk_div = clk_div_int;\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 4'd0;\n        else if (q == NUM_DIV/2 - 1)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (q == NUM_DIV/2 - 1)\n            clk_div <= ~clk_div;\n    end\n    reg [3:0] q;\n    u_counter u_counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .q(q)\n    );\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] s;\n    wire [31:0] c;\n\n    // Implement the addition and subtraction operations\n    // ...\n    // ...\n\n    // Implement the logic operations\n    // ...\n    // ...\n\n    // Implement the shift operations\n    // ...\n    // ...\n\n    // Implement the load upper immediate operation\n    // ...\n    // ...\n\n    // Compute the result\n    assign {carry, s} = a + b + c;\n    assign r = s;\n\n    // Determine the flags\n    assign zero = (r == 0);\n    assign negative = r[31];\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\n    assign flag = (aluc == 6'b101010 || aluc == 6'b101011) ? ~(a[31] ^ b[31] ^ r[31]) : 1'b0;\n\nendmodule\n\n// Addition\nmodule alu_add(\n    input [31:0] a,\n    input [31:0] b,\n    input [31:0] c,\n    output [31:0] r\n);\n    assign r = a + b + c;\nendmodule\n\n// Subtraction\nmodule alu_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input [31:0] c,\n    output [31:0] r\n);\n    assign r = a - b - ~c + 1;\nendmodule\n\n// Logic operations\nmodule alu_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a & b;\nendmodule\n\nmodule alu_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a | b;\nendmodule\n\nmodule alu_xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a ^ b;\nendmodule\n\nmodule alu_nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = ~(a | b);\nendmodule\n\n// Shift operations\nmodule alu_sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\n    assign r = a << b;\nendmodule\n\nmodule alu_srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\n    assign r = a >>> b;\nendmodule\n\nmodule alu_sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r\n);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule alu_sllv(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a << b[4:0];\nendmodule\n\nmodule alu_srlv(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = a >>> b[4:0];\nendmodule\n\nmodule alu_srav(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r\n);\n    assign r = $signed(a) >>> b[4:0];\nendmodule\n\n// Load Upper Immediate\nmodule alu_lui(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r\n);"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] product;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .product(product),\n        .current_value(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n\n    assign product = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] product,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + product[31:0];\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] opcode;\n    wire [4:0] raddr;\n    wire [7:0] data2;\n\n    // Instruction register submodules\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .opcode(opcode[0]),\n        .raddr(raddr[0]),\n        .data2(data2[0:7])\n    );\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .opcode(opcode[1]),\n        .raddr(raddr[1]),\n        .data2(data2[8:15])\n    );\n\n    // Output\n    assign ins = opcode;\n    assign ad1 = raddr;\n    assign ad2 = data2;\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] opcode,\n    output reg [4:0] raddr,\n    output reg [7:0] data2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            opcode <= 0;\n            raddr <= 0;\n            data2 <= 0;\n        end else if (fetch) begin\n            opcode <= data[7:5];\n            raddr <= data[4:0];\n            data2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n\n    wire [7:0] enable = 8'd1;\n\n    counter counter_inst(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wave_generator_inst(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input [7:0] enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= count % freq == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n            wave_reg <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10111) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b10;\n                end\n                2'b10: begin\n                    wave_reg <= wave_reg;\n                    if (wave_reg == 5'b10111) state <= 2'b01;\n                    else if (wave_reg == 5'b00000) state <= 2'b10;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule signal_generator_state (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule signal_generator_wave (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk, negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 0;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                2'b10: wave <= wave;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] stage1, stage2, stage3;\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(stage1)\n    );\n    my_dff8 u1 (\n        .clk(clk),\n        .d(stage1),\n        .q(stage2)\n    );\n    my_dff8 u2 (\n        .clk(clk),\n        .d(stage2),\n        .q(stage3)\n    );\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= stage1;\n            2'b01: q <= stage2;\n            2'b10: q <= stage3;\n            2'b11: q <= d;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case(sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2, q3;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [2:0] ctrl_sel;\n\n    assign ctrl_sel = ctrl[2:0];\n\n    // Stage 1\n    mux2X1 mux1 (in[7:4], shifted_in[7:4], ctrl_sel[2], shifted_in[7:4]);\n    mux2X1 mux2 (in[3:0], shifted_in[3:0], ctrl_sel[1], shifted_in[3:0]);\n    assign shifted_in[3:0] = mux2.out;\n\n    // Stage 2\n    mux2X1 mux3 (shifted_in[7:4], shifted_in[3:0], ctrl_sel[0], shifted_in[3:0]);\n    assign shifted_in[7:4] = mux3.out;\n\n    // Stage 3\n    mux2X1 mux4 (shifted_in[7:4], shifted_in[3:0], ctrl_sel[0], out);\n    assign shifted_in[3:0] = mux4.out;\n\nendmodule\n\nmodule mux2X1 (a, b, sel, y);\n    input a, b, sel;\n    output y;\n\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [31:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a0(a0),\n    .b0(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a0(a1),\n    .b0(b1),\n    .out(pe1_out)\n  );\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n  assign b1 = (rst) ? 0 : b0;\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] b0,\n  output [31:0] out\n);\n  wire [31:0] product;\n  assign product = a0 * b0;\n  assign out = (rst) ? 0 : product;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] res_execute;\n  \n  wire [4:0] pc;\n  \n  stagepipe5_fetch fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .res_fetch(res_fetch)\n  );\n  stagepipe5_decode decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .fetch(res_fetch),\n    .res_decode(res_decode)\n  );\n  stagepipe5_execute execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .decode(res_decode),\n    .reg_file(reg_file),\n    .res_execute(res_execute)\n  );\n  stagepipe5_memory memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .execute(res_execute),\n    .res_memory(res_memory)\n  );\n  stagepipe5_writeback writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .res_memory(res_memory),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n  \n  assign pc = res_fetch[4:0];\n  assign res_reg_file = res_memory;\n  \n  wire [31:0] res_fetch, res_decode [3:0], res_memory;\n  \nendmodule\n\nmodule stagepipe5_fetch(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] res_fetch\n);\n  wire [4:0] pc;\n  reg [31:0] fetch_instr;\n  assign res_fetch = fetch_instr;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      fetch_instr <= 32'h00000000;\n    else\n      fetch_instr <= instr_mem[pc];\n  end\nendmodule\n\nmodule stagepipe5_decode(\n  input clk,\n  input rst,\n  input [31:0] fetch,\n  output [3:0] res_decode\n);\n  reg [3:0] decode;\n  assign res_decode = decode;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      decode <= 4'h0;\n    else\n      decode <= fetch[31:28];\n  end\nendmodule\n\nmodule stagepipe5_execute(\n  input clk,\n  input rst,\n  input [3:0] decode,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_execute\n);\n  wire [31:0] instr_rs1, instr_rs2;\n  \n  assign instr_rs1 = reg_file[decode[2:0]];\n  assign instr_rs2 = reg_file[decode[5:3]];\n  \n  assign res_execute = (decode == 4'h0) ? instr_rs1 : (decode == 4'h1) ? (instr_rs1 + instr_rs2) : (decode == 4'h2) ? (instr_rs1 - instr_rs2) : 0;\nendmodule\n\nmodule stagepipe5_memory(\n  input clk,\n  input rst,\n  input [31:0] execute,\n  output [31:0] res_memory\n);\n  assign res_memory = execute;\nendmodule\n\nmodule stagepipe5_writeback(\n  input clk,\n  input rst,\n  input [31:0] memory,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file ["}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [15:0] d1, d2, d3;\n  assign c0 = d1 + b0;\n  assign c1 = d2 + b1;\n  assign c2 = d3 + b2;\n  assign c3 = b3;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      d1 <= 16'b0;\n      d2 <= 16'b0;\n      d3 <= 16'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n      d1 <= a0;\n      d2 <= d1;\n      d3 <= d2;\n    end\n  end\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] d;\n  assign c = d + b;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      d <= 16'b0;\n    else\n      d <= a;\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetched_instr;\n    wire [4:0] target_reg;\n    wire [31:0] op1, op2, result;\n    wire [1:0] op_type;\n\n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n\n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .reg_file(reg_file),\n        .op1(op1),\n        .op2(op2),\n        .target_reg(target_reg),\n        .result(result),\n        .op_type(op_type)\n    );\n\n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .target_reg(target_reg),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [4:0] target_reg,\n    output [31:0] result,\n    output [1:0] op_type\n);\n    wire [4:0] rd;\n    wire [5:0] imm;\n    wire [4:0] rs1, rs2;\n    wire [31:0] op1_value, op2_value;\n    wire [31:0] add_result, sub_result;\n\n    assign {rd, op_type, imm} = fetched_instr;\n\n    assign op1 = (op_type == 2'b00) ? reg_file[rs1] : 32'b0;\n    assign op2 = (op_type == 2'b00) ? reg_file[rs2] : imm;\n\n    assign op1_value = op1;\n    assign op2_value = op2;\n\n    assign add_result = op1_value + op2_value;\n    assign sub_result = op1_value - op2_value;\n\n    assign result = (op_type == 2'b00) ? add_result : sub_result;\n    assign target_reg = rd;\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] target_reg,\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) out_reg_file <= 0;\n        else out_reg_file[target_reg] <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire        [9:0]       accum_data;\nwire        [1:0]       counter;\nwire                    valid_out_i;\n\ncounter_module  u_counter      (\n    .clk        (clk),\n    .rst_n      (rst_n),\n    .valid_in   (valid_in),\n    .counter    (counter)\n);\n\ndata_accumulator_module  u_data_accumulator (\n    .clk        (clk),\n    .rst_n      (rst_n),\n    .data_in    (data_in),\n    .counter    (counter),\n    .accum_data (accum_data)\n);\n\nvalid_output_module  u_valid_output (\n    .clk        (clk),\n    .rst_n      (rst_n),\n    .valid_in   (valid_in),\n    .valid_out  (valid_out_i),\n    .accum_data (accum_data)\n);\n\nassign data_out = accum_data;\nassign valid_out = valid_out_i;\n\nendmodule\n\nmodule counter_module (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [1:0]   counter\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (valid_in)\n        counter <= counter + 1;\nend\n\nendmodule\n\nmodule data_accumulator_module (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [1:0]   counter,\n    output reg  [9:0]   accum_data\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        accum_data <= 0;\n    else if (counter == 2'd3)\n        accum_data <= accum_data + data_in;\nend\n\nendmodule\n\nmodule valid_output_module (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input               valid_out_i,\n    input       [9:0]   accum_data,\n    output reg          valid_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out <= 0;\n    else if (valid_in)\n        valid_out <= valid_out_i;\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [15:0] abs_dividend;\nwire [15:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\nwire [3:0] count;\nwire [15:0] shift_reg;\n\nassign abs_dividend = (sign) ? -dividend : dividend;\nassign neg_divisor = (sign) ? -divisor : divisor;\n\n// Instantiate the submodules\n\n// Absolute Value Calculation\n\n// Negative Divisor Calculation\n\n// Division Control Logic\n\n// Result Management\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n\n    prep_dividend prep(\n        .input(A),\n        .output(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] input,\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n    always @(*) begin\n        dividend = {input[31:16], input[15:0]};\n        divisor = {input[31:16], 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n    reg [31:0] next_dividend;\n    reg [15:0] next_divisor;\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n    reg [31:0] next_remainder;\n    reg [31:0] next_quotient;\n    reg [31:0] next_odd;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        remainder = 32'b0;\n        quotient = 32'b0;\n        next_remainder = 32'b0;\n        next_quotient = 32'b0;\n        next_odd = 32'b0;\n        next_dividend = 32'b0;\n        next_divisor = 16'b0;\n    end\n\n    always @(posedge shifted_dividend[31] or posedge shifted_divisor[15]) begin\n        next_remainder = shifted_dividend;\n        next_quotient = quotient;\n        next_odd = remainder;\n        next_dividend = shifted_dividend;\n        next_divisor = shifted_divisor;\n        if (shifted_dividend[31]) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            remainder = shifted_divisor;\n            next_quotient = 1;\n        end\n        if (shifted_dividend[31] ^ shifted_divisor[15]) begin\n            next_quotient = next_quotient + 1;\n        end\n    end\n\n    always @(posedge next_quotient) begin\n        remainder = next_remainder;\n        quotient = next_quotient;\n        dividend = next_dividend;\n        divisor = next_divisor;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    wire [15:0] Q;\n    wire [7:0] R;\n    \n    div_control ctrl (\n        .dividend(A),\n        .divisor(B),\n        .quotient(Q),\n        .remainder(R)\n    );\n    \n    assign result = Q;\n    assign odd = R;\nendmodule\n\nmodule div_control (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    wire [15:0] temp;\n    \n    always @(*) begin\n        quotient = 0;\n        remainder = 0;\n        temp = dividend;\n        while (temp > 0) begin\n            if (temp[0])\n                remainder = remainder << 1 | 1;\n            else\n                remainder = remainder << 1;\n            temp = temp >> 1;\n            quotient = quotient << 1 | 1;\n        end\n        remainder = remainder >> 1;\n        quotient = quotient >> 1;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] carry_out;\nwire borrow_out;\n\n// 2's complement calculation\nassign B_comp = ~B + 1;\n\n// Subtraction operation\nadder_8bit adder_inst (\n    .A(A),\n    .B(B_comp),\n    .Cin(1'b0),\n    .D(D),\n    .Cout(carry_out),\n    .Bout(borrow_out)\n);\n\n// Output borrow\nassign B_out = borrow_out;\n\n// Full adder module\nmodule full_adder(A, B, Cin, sum, Cout);\ninput A, B, Cin;\noutput sum, Cout;\n\nwire C1, C2;\n\nxor xor1(sum, A, B);\nand and1(C1, A, B);\nand and2(C2, A, B);\nor or1(Cout, C1, C2, Cin);\n\nendmodule\n\n// Adder module\nmodule adder_8bit(A, B, Cin, D, Cout, Bout);\ninput [7:0] A, B;\ninput Cin;\noutput [7:0] D;\noutput Cout, Bout;\n\nwire [6:0] carry_out;\nwire [6:0] Bout_temp;\nwire [6:0] D_temp;\n\nfull_adder fa0 (.A(A[0]), .B(B[0]), .Cin(Cin), .sum(D_temp[0]), .Cout(carry_out[0]));\n\ngenvar i;\ngenerate\nfor (i = 0; i < 7; i = i + 1) begin : loop_block\n    full_adder fa (\n        .A(A[i + 1]),\n        .B(B[i + 1]),\n        .Cin(carry_out[i]),\n        .sum(D_temp[i + 1]),\n        .Cout(carry_out[i + 1])\n    );\nend\nendgenerate\n\nassign D = D_temp;\nassign Bout = Bout_temp;\n\n// Carry out\nassign Cout = carry_out[6];\n\n// Borrow out\nassign Bout_temp = carry_out[6:1];\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n    \n    wire [15:0] S1_out, S2_out;\n    \n    sub_16bit S1(A[15:0], B[15:0], S1_out, B_out);\n    sub_16bit S2(A[31:16], B[31:16], S2_out, B_out);\n    \n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n    \n    wire [7:0] S1_out, S2_out;\n    \n    sub_8bit S1(A[7:0], B[7:0], S1_out, B_out);\n    sub_8bit S2(A[15:8], B[15:8], S2_out, B_out);\n    \n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n    \n    wire [3:0] S1_out, S2_out;\n    \n    sub_4bit S1(A[3:0], B[3:0], S1_out, B_out);\n    sub_4bit S2(A[7:4], B[7:4], S2_out, B_out);\n    \n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n    \n    wire [1:0] S1_out, S2_out;\n    \n    sub_2bit S1(A[1:0], B[1:0], S1_out, B_out);\n    sub_2bit S2(A[3:2], B[3:2], S2_out, B_out);\n    \n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n    \n    wire C_out;\n    \n    sub_1bit S1(A[0], B[0], C_out, B_out);\n    sub_1bit S2(A[1], B[1], Diff[1], C_out);\n    \n    assign Diff[0] = C_out;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A, B;\n    output Diff;\n    output B_out;\n    \n    wire C_out;\n    \n    assign C_out = A ^ B;\n    assign Diff = A & B | C_out;\n    assign B_out = (A & ~B) | (~A & B);\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] D1, D2, D3;\n    wire [7:0] B1, B2;\n    wire C1, C2;\n\n    sub16bit sub0(.A(A[31:0]), .B(B[31:0]), .D(D1), .B_out(B1), .C_out(C1));\n    sub16bit sub1(.A(A[47:32]), .B(B[47:32]), .D(D2), .B_out(B2), .C_out(C2));\n    sub16bit sub2(.A(A[63:48]), .B(B[63:48]), .D(D3), .B_out(B_out), .C_out(1'b0));\n\nendmodule\n\nmodule sub16bit(A, B, D, B_out, C_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n    output C_out;\n\n    wire [7:0] D1, D2;\n    wire C1, C2;\n\n    sub8bit sub0(.A(A[7:0]), .B(B[7:0]), .D(D1), .B_out(B1), .C_out(C1));\n    sub8bit sub1(.A(A[15:8]), .B(B[15:8]), .D(D2), .B_out(B2), .C_out(C2));\n\n    assign D = {D2, D1};\n    assign B_out = (C2 & C1) | (C2 & (~C1 & B1));\n    assign C_out = (C2 & C1) | (~C2 & C1);\n\nendmodule\n\nmodule sub8bit(A, B, D, B_out, C_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n    output C_out;\n\n    wire [3:0] D1, D2;\n    wire C1, C2;\n\n    sub4bit sub0(.A(A[3:0]), .B(B[3:0]), .D(D1), .B_out(B1), .C_out(C1));\n    sub4bit sub1(.A(A[7:4]), .B(B[7:4]), .D(D2), .B_out(B2), .C_out(C2));\n\n    assign D = {D2, D1};\n    assign B_out = (C2 & C1) | (C2 & (~C1 & B1));\n    assign C_out = (C2 & C1) | (~C2 & C1);\n\nendmodule\n\nmodule sub4bit(A, B, D, B_out, C_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n    output C_out;\n\n    wire [1:0] D1, D2;\n    wire C1, C2;\n\n    sub2bit sub0(.A(A[1:0]), .B(B[1:0]), .D(D1), .B_out(B1), .C_out(C1));\n    sub2bit sub1(.A(A[3:2]), .B(B[3:2]), .D(D2), .B_out(B2), .C_out(C2));\n\n    assign D = {D2, D1};\n    assign B_out = (C2 & C1) | (C2 & (~C1 & B1));\n    assign C_out = (C2 & C1) | (~C2 & C1);\n\nendmodule\n\nmodule sub2bit(A, B, D, B_out, C_out);"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\nwire [3:0] borrow_out;\n\nsubmodule sub1(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(borrow_out[0]));\nsubmodule sub2(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(borrow_out[1]));\nsubmodule sub3(.A(A[5:4]), .B(B[5:4]), .D(D[5:4]), .B_out(borrow_out[2]));\nsubmodule sub4(.A(A[7:6]), .B(B[7:6]), .D(D[7:6]), .B_out(borrow_out[3]));\nassign B_out = ~|borrow_out;\n\nendmodule\n\nmodule submodule(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] a_neg, b_neg;\nwire [1:0] d_temp;\nwire carry_in;\n\nassign a_neg = ~A;\nassign b_neg = ~B;\nassign carry_in = 1;\n\nsub4_bit sub4(.A(a_neg), .B(b_neg), .D(d_temp), .B_out(carry_in));\nassign D = A - B - carry_in;\nassign B_out = carry_in;\n\nendmodule\n\nmodule sub4_bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] a_neg, b_neg;\nwire [1:0] d_temp;\nwire carry_in;\n\nassign a_neg = ~A;\nassign b_neg = ~B;\nassign carry_in = 1;\n\nsub3_bit sub3(.A(a_neg), .B(b_neg), .D(d_temp), .B_out(carry_in));\nassign D = A - B - carry_in;\nassign B_out = carry_in;\n\nendmodule\n\nmodule sub3_bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] a_neg, b_neg;\nwire [1:0] d_temp;\nwire carry_in;\n\nassign a_neg = ~A;\nassign b_neg = ~B;\nassign carry_in = 1;\n\nsub2_bit sub2(.A(a_neg), .B(b_neg), .D(d_temp), .B_out(carry_in));\nassign D = A - B - carry_in;\nassign B_out = carry_in;\n\nendmodule\n\nmodule sub2_bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] a_neg, b_neg;\nwire [1:0] d_temp;\nwire carry_in;\n\nassign a_neg = ~A;\nassign b_neg = ~B;\nassign carry_in = 1;\n\nsub1_bit sub1(.A(a_neg), .B(b_neg), .D(d_temp), .B_out(carry_in));\nassign D = A - B - carry_in;\nassign B_out = carry_in;\n\nendmodule\n\nmodule sub1_bit(A, B, D, B_out);\ninput [1:0] A, B;\noutput [1:0] D;\noutput B_out;\n\nwire [1:0] a_neg, b_neg;\nwire carry_in;\n\nassign a_neg = ~A;\nassign b_neg = ~B;\nassign carry_in = 1;\n\nassign D = A - B - carry_in;\nassign"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] A_minus_B;\n\n// Comparator Module\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .A_minus_B(A_minus_B)\n);\n\n// Carry Generation\nassign A_greater = ~A_minus_B[31];\nassign A_equal = ~(A_minus_B[31] ^ A_minus_B[30]);\nassign A_less = A_minus_B[30];\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output reg [31:0] A_minus_B // Result of A - B\n);\n\ninteger i;\n\nalways @(*) begin\n    A_minus_B = A - B;\nend\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire [32:1] A1,B1,S1,C1,A2,B2,S2,C2;\n    wire [16:1] C216,C217;\n\n    // 16 bit carry-lookahead adder for A,B\n    CLA1 CLA1_inst(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S1[16:1]),\n        .Cout(C1)\n    );\n\n    // 16 bit carry-lookahead adder for A,B\n    CLA1 CLA1_inst2(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(C1),\n        .S(S2[16:1]),\n        .Cout(C2)\n    );\n\n    assign C216 = {C1, 1'b0};\n    assign C217 = {C2, 1'b0};\n\n    // 16 bit carry-lookahead adder for A1,B1\n    CLA1 CLA1_inst3(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(C216),\n        .S(S1[16:1]),\n        .Cout(C217)\n    );\n\n    // 16 bit carry-lookahead adder for A2,B2\n    CLA1 CLA1_inst4(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C217),\n        .S(S2[16:1]),\n        .Cout(C32)\n    );\n\n    assign S = {S1, S2};\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n    wire [16:1] C1,C2;\n\n    // 8 bit carry-lookahead adder for A,B\n    CLA1_8 CLA1_8_inst(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Cin(Cin),\n        .S(S[8:1]),\n        .Cout(C1)\n    );\n\n    // 8 bit carry-lookahead adder for A,B\n    CLA1_8 CLA1_8_inst2(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Cin(C1),\n        .S(S[8:1]),\n        .Cout(C2)\n    );\n\n    // 4 bit carry-lookahead adder for A,B\n    CLA1_4 CLA1_4_inst(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Cin(C2),\n        .S(S[4:1]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule CLA1_8(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n    wire [8:1] C1,C2;\n\n    // 4 bit carry-lookahead adder for A,B\n    CLA1_4 CLA1_4_inst(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Cin(Cin),\n        .S(S[4:1]),\n        .Cout(C1)\n    );\n\n    // 4 bit carry-lookahead adder for A,B\n    CLA1_4 CLA"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c_out;\n\n    // Ripple carry adder for 4 bits\n    wire [3:0] sum_c;\n    wire [3:0] carry;\n    ripple_carry_adder rca1(a[3:0], b[3:0], cin, sum_c, carry);\n\n    // Carry select adder slice for 4 bits\n    wire [3:0] csa_slice1_sum;\n    wire [3:0] csa_slice1_cout;\n    carry_select_adder_4bit csa_slice1(sum_c, b[3:0], carry, csa_slice1_sum, csa_slice1_cout);\n\n    // Carry select adder slice for 4 bits\n    wire [3:0] csa_slice2_sum;\n    wire [3:0] csa_slice2_cout;\n    carry_select_adder_4bit csa_slice2(csa_slice1_sum, b[7:4], csa_slice1_cout, csa_slice2_sum, csa_slice2_cout);\n\n    // Carry select adder slice for 4 bits\n    wire [3:0] csa_slice3_sum;\n    wire [3:0] csa_slice3_cout;\n    carry_select_adder_4bit csa_slice3(csa_slice2_sum, b[11:8], csa_slice2_cout, csa_slice3_sum, csa_slice3_cout);\n\n    assign sum = {csa_slice3_sum, csa_slice2_sum, csa_slice1_sum};\n    assign cout = csa_slice3_cout;\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, carry);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output [3:0] carry;\n\n    wire [3:0] sum_tmp;\n    wire [3:0] carry_tmp;\n\n    full_adder fa0(a[0], b[0], cin, sum_tmp[0], carry_tmp[0]);\n    full_adder fa1(a[1], b[1], carry_tmp[0], sum_tmp[1], carry_tmp[1]);\n    full_adder fa2(a[2], b[2], carry_tmp[1], sum_tmp[2], carry_tmp[2]);\n    full_adder fa3(a[3], b[3], carry_tmp[2], sum_tmp[3], carry_tmp[3]);\n\n    assign sum = sum_tmp;\n    assign carry = carry_tmp;\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(a, b, carry_in, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input [1:0] carry_in;\n    output [3:0] sum;\n    output [1:0] cout;\n\n    wire [3:0] sum_tmp;\n    wire [1:0] carry_tmp;\n\n    full_adder fa0(a[0], b[0], carry_in[0], sum_tmp[0], carry_tmp[0]);\n    full_adder fa1(a[1], b[1], carry_tmp[0], sum_tmp[1], carry_tmp[1]);\n    full_adder fa2(a[2], b[2], carry_tmp[1], sum_tmp[2], carry_tmp[2]);\n    full_adder fa3(a[3], b[3], carry_tmp[2], sum_tmp[3], cout[1]);\n\n    assign sum = sum_tmp;\n"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [7:0] add8_inst1_out, add8_inst2_out;\n    wire [7:0] add8_inst1_co, add8_inst2_co;\n\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(add8_inst1_out),\n        .Co(add8_inst1_co)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(add8_inst1_co),\n        .y(add8_inst2_out),\n        .Co(add8_inst2_co)\n    );\n\n    assign y = {add8_inst2_out, add8_inst1_out};\n    assign Co = add8_inst2_co;\n\nendmodule\n\nmodule add8 (\n    input [7:0] a,\n    input [7:0] b,\n    input Cin,\n    output [7:0] y,\n    output Co\n);\n    wire [7:0] carry;\n\n    assign carry[0] = Cin;\n    assign y = a ^ b ^ carry[0];\n    assign Co = (a & b) | (carry[0] & (a ^ b));\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [7:0] cin_chain;\n\n    // Initialize the carry chain\n    assign cin_chain[0] = cin;\n\n    // Perform addition\n    adder FA0(.a(a[0]), .b(b[0]), .cin(cin_chain[0]), .sum(sum[0]), .cout(cin_chain[1]));\n    adder FA1(.a(a[1]), .b(b[1]), .cin(cin_chain[1]), .sum(sum[1]), .cout(cin_chain[2]));\n    adder FA2(.a(a[2]), .b(b[2]), .cin(cin_chain[2]), .sum(sum[2]), .cout(cin_chain[3]));\n    adder FA3(.a(a[3]), .b(b[3]), .cin(cin_chain[3]), .sum(sum[3]), .cout(cin_chain[4]));\n    adder FA4(.a(a[4]), .b(b[4]), .cin(cin_chain[4]), .sum(sum[4]), .cout(cin_chain[5]));\n    adder FA5(.a(a[5]), .b(b[5]), .cin(cin_chain[5]), .sum(sum[5]), .cout(cin_chain[6]));\n    adder FA6(.a(a[6]), .b(b[6]), .cin(cin_chain[6]), .sum(sum[6]), .cout(cin_chain[7]));\n    adder FA7(.a(a[7]), .b(b[7]), .cin(cin_chain[7]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nreg [3:0] ctrl;\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\n\n// Multiplier Unit\nreg [15:0] product;\n\n// Functional Module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl <= 0;\n        a_reg <= 0;\n        b_reg <= 0;\n        product <= 0;\n    end else begin\n        if (ctrl == 0) begin\n            // Reset control signals\n            ctrl <= 4;\n            a_reg <= ain;\n            b_reg <= bin;\n            product <= 0;\n        end else if (start) begin\n            // Shift the multiplier\n            ctrl <= ctrl - 1;\n            product <= product + (b_reg << ctrl);\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = (ctrl == 0);\n\nendmodule\n\nmodule multi_16bit_ctrl (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [3:0] ctrl,   // Control signal.\n    output reg [3:0] ctrl_out\n);\n\n// Functional Module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl_out <= 0;\n    end else begin\n        if (start) begin\n            ctrl_out <= ctrl;\n        end\n    end\nend\n\nendmodule\n\nmodule multi_16bit_reg (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_reg, // Register a with a data width of 16 bits.\n    output reg [15:0] b_reg  // Register b with a data width of 16 bits.\n);\n\n// Functional Module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\nendmodule\n\nmodule multi_16bit_mul (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product  // Product output with a data width of 32 bits.\n);\n\nreg [3:0] ctrl;\n\n// Functional Module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl <= 0;\n        product <= 0;\n    end else begin\n        if (start) begin\n            ctrl <= 4;\n            product <= 0;\n        end else if (ctrl != 0) begin\n            // Shift the multiplier\n            ctrl <= ctrl - 1;\n            product <= product + (bin << ctrl);\n        end\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (up_down)\n            count <= count + 1;\n        else\n            count <= count - 1;\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] transition;\n    wire [7:0] init;\n\n    initial_state initial (\n        .init(init)\n    );\n\n    state_transition transit (\n        .transition(transition)\n        , .clk(clk)\n    );\n\n    assign out = reset ? init : transition;\n\nendmodule\n\nmodule initial_state (\n    output reg [7:0] init\n);\n    initial begin\n        init = 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire [7:0] transition,\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= transition;\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count_out;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else if (valid_count)\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count_out;\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0]         next_Q;\n    wire [63:0]         current_Q;\n    \n    // Register module\n    wire [63:0]         reg_Q;\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(reg_Q)\n    );\n    \n    // Logic module\n    wire [1:0] next_state, current_state;\n    JC_logic logic_inst(\n        .Q(current_Q),\n        .next_Q(next_Q)\n    );\n    \n    // Output\n    assign Q = reg_Q;\n    \nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    reg [63:0] Q_reg;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_reg <= 64'b0;\n        else\n            Q_reg <= Q;\n    end\n    \n    assign Q = Q_reg;\nendmodule\n\nmodule JC_logic(\n    input [63:0] Q,\n    output [63:0] next_Q\n);\n    assign next_Q = {Q[62:0], Q[63]};\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire clk_div_50, clk_div_10, clk_div_1;\n\nclk_div_2 clk_div_50_inst (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(clk_div_50)\n);\n\nclk_div_10 clk_div_10_inst (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(clk_div_10)\n);\n\nclk_div_100 clk_div_1_inst (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(clk_div_1)\n);\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [1:0] cnt;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        cnt <= 0;\n    else if (cnt == 1)\n        CLK_out <= ~CLK_out;\n    else\n        cnt <= cnt + 1;\nend\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [3:0] cnt;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        cnt <= 0;\n    else if (cnt == 4) begin\n        CLK_out <= ~CLK_out;\n        cnt <= 0;\n    end else\n        cnt <= cnt + 1;\nend\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [6:0] cnt;\n\nalways @(posedge CLK_in or posedge RST) begin\n    if (RST)\n        cnt <= 0;\n    else if (cnt == 49) begin\n        CLK_out <= ~CLK_out;\n        cnt <= 0;\n    end else\n        cnt <= cnt + 1;\nend\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n    \n    wire clk_div_3_5;\n    wire clk_div_4_5;\n    wire clk_div_4_0;\n    wire clk_div_3_0;\n    \n    wire clk_div_4_5_neg;\n    wire clk_div_3_5_neg;\n    wire clk_div_4_0_neg;\n    wire clk_div_3_0_neg;\n    \n    assign clk_div = clk_div_4_0 | clk_div_3_0;\n    \n    assign clk_div_3_5 = ~clk_div_3_5_neg;\n    assign clk_div_4_5 = ~clk_div_4_5_neg;\n    assign clk_div_4_0 = ~clk_div_4_0_neg;\n    assign clk_div_3_0 = ~clk_div_3_0_neg;\n    \n    assign clk_div_3_5_neg = clk_div_4_5;\n    assign clk_div_4_5_neg = clk_div_4_0;\n    assign clk_div_4_0_neg = clk_div_3_0;\n    assign clk_div_3_0_neg = clk;\n    \n    \n    \n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div_3_5)\n    );\n    \n    \n    clk_average u_clk_average(\n        .clk(clk),\n        .clk_div(clk_div_4_5),\n        .clk_div_neg(clk_div_4_5_neg)\n    );\n    \n    \n    clk_adjustment u_clk_adjustment(\n        .clk(clk),\n        .clk_div(clk_div_3_5),\n        .clk_div_neg(clk_div_3_5_neg)\n    );\n    \nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    reg [1:0] counter;\n    \n    assign clk_div = (counter == 2'b10);\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 2'b00;\n        end else begin\n            if (counter == 2'b10) begin\n                counter <= 2'b00;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               clk_div,\n    input               clk_div_neg\n);\n    reg clk_div_4_5;\n    reg clk_div_3_5;\n    reg clk_div_3_0;\n    reg clk_div_4_0;\n    \n    always @(posedge clk) begin\n        clk_div_4_5 <= clk_div_neg;\n        clk_div_3_5 <= clk_div;\n        clk_div_4_0 <= clk_div_4_5;\n        clk_div_3_0 <= clk_div_3_5;\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               clk_div,\n    input               clk_div_neg\n);\n    reg clk_div_4_5_neg;\n    reg clk_div_3_5_neg;\n    reg clk_div_4_0_neg;\n    reg clk_div_3_0_neg;\n    \n    always @(negedge clk) begin\n        clk_div_4_5_neg <= clk_div_neg;\n        clk_div_3_5_neg <= clk_div;\n        clk_div_4_0_neg <= clk_div_4_5_neg;\n        clk_div_3_0_neg <= clk"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter(.clk(clk), .rst_n(rst_n), .clk_div(clk_div1));\n    neg_edge_counter u_neg_counter(.clk(clk), .rst_n(rst_n), .clk_div(clk_div2));\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV - 1:0] counter,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end\n        else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end\n        else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV - 1:0] counter,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end\n        else if (counter == NUM_DIV - 1) begin\n            counter <= 0;\n            clk_div <= 1;\n        end\n        else begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    localparam NUM_DIV = 4;\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter <= 0;\n        end else if (counter == (NUM_DIV - 1) / 2) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign clk_div = counter == 0;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            q <= 0;\n        end else if (q == (NUM_DIV - 1) / 2) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input div_en,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            clk_div <= 0;\n        end else if (div_en) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] tmp_r;\n    \n    // Submodule definitions\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(tmp_r)\n    );\n    \n    // Select the operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_inst.r :\n               (aluc == 6'b100001) ? addu_inst.r :\n               (aluc == 6'b100010) ? sub_inst.r :\n               (aluc == 6'b100011) ? subu_inst.r :\n               (aluc == 6'b100100) ? and_inst.r :\n               (aluc == 6'b100101) ? or_inst.r :\n               (aluc == 6'b100110) ? xor_inst.r :\n               (aluc == 6'b100111) ? nor_inst.r :\n               (aluc == 6'b101010) ? slt_inst.r :\n               (aluc == 6'b101011) ? sltu_inst.r :\n               (aluc == 6'b000000) ? sll_inst.r :\n               (aluc == 6'b000010) ? srl_inst.r :\n               (aluc == 6'b000011) ? sra_inst.r :\n               0;\n    \n    // Compute flags\n    assign zero = (tmp_r == 0) ? 1 : 0;\n    assign carry = (tmp_r[31] == 1) ? 1 : 0;\n    assign negative = (tmp_r[31] == 1) ? 1 : 0;\n    assign overflow = (tmp_r[31] == 0 && add_inst.r[31] == 1) ? 1 : 0;\n    assign flag = (aluc == 6'b101010 || aluc == 6'b101011) ? (tmp_r < b) ? 1 : 0 : 0;\n    \nendmodule\n\nmodule add(input [31:0] a, input [31:0] b"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n    wire [31:0] new_value;\n    \n    // Instantiate multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(multiplication_result)\n    );\n    \n    // Instantiate accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(current_value),\n        .new_value(new_value)\n    );\n    \n    // Connect multiplier submodule to accumulator submodule\n    assign multiplication_result = u_multiplier.result;\n    assign current_value = u_accumulator.current_value;\n    assign new_value = u_accumulator.new_value;\n    \n    // Connect accumulator submodule to output\n    assign c = u_accumulator.current_value;\nendmodule\n\n// Multiplier Submodule\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator Submodule\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output [31:0] current_value\n);\n    reg [31:0] current_value_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value_reg <= 0;\n        else\n            current_value_reg <= current_value_reg + new_value;\n    end\n    assign current_value = current_value_reg;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    assign ins1 = ins_p1.ins;\n    assign ad11 = ins_p1.ad1;\n    assign ad21 = ins_p1.ad2;\n\n    assign ins2 = ins_p2.ins;\n    assign ad12 = ins_p2.ad1;\n    assign ad22 = ins_p2.ad2;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1.ins <= 0;\n            ins_p1.ad1 <= 0;\n            ins_p1.ad2 <= 0;\n            ins_p2.ins <= 0;\n            ins_p2.ad1 <= 0;\n            ins_p2.ad2 <= 0;\n        end else begin\n            if (fetch == 2'b01)\n                ins_p1.ins <= data;\n            else if (fetch == 2'b10)\n                ins_p2.ins <= data;\n            else begin\n                ins_p1.ins <= ins_p1.ins;\n                ins_p1.ad1 <= ad11;\n                ins_p1.ad2 <= ad21;\n                ins_p2.ins <= ins_p2.ins;\n                ins_p2.ad1 <= ad12;\n                ins_p2.ad2 <= ad22;\n            end\n        end\n    end\n\n    instr_p1 ins_p1 (\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    instr_p2 ins_p2 (\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\nendmodule\n\nmodule instr_p1 (\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2,\n    input [7:0] data\n);\n    always @(*) begin\n        ins = data[7:5];\n        ad1 = data[4:0];\n        ad2 = data;\n    end\nendmodule\n\nmodule instr_p2 (\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2,\n    input [7:0] data\n);\n    always @(*) begin\n        ins = data[7:5];\n        ad1 = data[4:0];\n        ad2 = data;\n    end\nendmodule\n\nmodule submodule (\n    input [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ad1 = ins;\n    assign ad2 = ins;\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\nwire clk_en, clk_neg_en;\n\n// Counter\nwire [7:0] count;\ncounter counter_inst (\n    .clk(clk),\n    .enable(clk_en),\n    .freq(freq),\n    .count(count)\n);\n\n// Wave Generator\nwire [7:0] wave;\nwire [7:0] neg_count;\nassign neg_count = ~count;\nassign wave_out = wave[0];\nwave_generator wave_gen_inst (\n    .clk(clk),\n    .count(neg_count),\n    .freq(freq),\n    .wave(wave)\n);\n\n// Control\nassign clk_en = (freq != 0);\nassign clk_neg_en = (freq != 0);\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output [7:0] wave\n);\nreg [7:0] wave_reg;\nwire [7:0] neg_count;\nassign neg_count = ~count;\nassign wave = wave_reg;\nalways @(posedge clk) begin\n    if (neg_count[freq - 1]) begin\n        wave_reg <= ~wave_reg;\n    end\nend\nendmodule\n\nmodule counter (\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\nreg [7:0] count_reg;\nwire [7:0] neg_freq;\nassign neg_freq = ~freq;\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count_reg == neg_freq) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_reg + 1;\n        end\n    end\nend\nassign count = count_reg;\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire inc_dec;\n    wire [1:0] state;\n    wire [4:0] wave_reg;\n\n    // State Control Module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else if (inc_dec) begin\n            state <= state + 1;\n        end else begin\n            state <= state - 1;\n        end\n    end\n\n    assign inc_dec = (state == 2'b00) ? 1'b1 : (state == 2'b01) ? 1'b0 : 1'bx;\n\n    // Waveform Generation Module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            if (inc_dec) begin\n                wave_reg <= wave_reg + 5'd1;\n            end else begin\n                wave_reg <= wave_reg - 5'd1;\n            end\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    input inc_dec,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else if (inc_dec) begin\n            state <= state + 1;\n        end else begin\n            state <= state - 1;\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            if (inc_dec) begin\n                wave_reg <= wave_reg + 5'd1;\n            end else begin\n                wave_reg <= wave_reg - 5'd1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] dff_out [2:0];\n\n    // Instance of d flip-flops\n    my_dff8 u_dff0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_out[0])\n    );\n\n    my_dff8 u_dff1 (\n        .clk(clk),\n        .d(dff_out[0]),\n        .q(dff_out[1])\n    );\n\n    my_dff8 u_dff2 (\n        .clk(clk),\n        .d(dff_out[1]),\n        .q(dff_out[2])\n    );\n\n    // 4-to-1 multiplexer\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= dff_out[0];\n            2'b01: q <= dff_out[1];\n            2'b10: q <= dff_out[2];\n            2'b11: q <= d;\n            default: q <= 8'bx; // invalid case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire [2:0] qs;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(qs[0])\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(qs[0]),\n        .q(qs[1])\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(qs[1]),\n        .q(qs[2])\n    );\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] mux_out;\n    \n    assign mux_out = (ctrl[2]) ? (in << 2) : in;\n    \n    assign mux_out = (ctrl[1]) ? (mux_out << 1) : mux_out;\n    \n    assign mux_out = (ctrl[0]) ? (mux_out << 1) : mux_out;\n    \n    assign out = mux_out;\n    \n    /* 2-to-1 MUX */\n    module mux2X1 (sel, in0, in1, out);\n        input sel;\n        input in0, in1;\n        output out;\n        \n        assign out = sel ? in1 : in0;\n    endmodule\n    \nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  assign b1 = (rst) ? 0 : b0;\n\n  // PE0\n  pe pe0 (\n    .clk(clk),\n    .a0(a0),\n    .a1(a1),\n    .b0(b0),\n    .b1(b1),\n    .c0(pe0_out),\n    .c1(pe0_out) // no need to output pe0_out to pe1\n  );\n\n  // PE1\n  pe pe1 (\n    .clk(clk),\n    .a0(a1),\n    .a1(a1),\n    .b0(b0),\n    .b1(b1),\n    .c0(pe1_out),\n    .c1(pe1_out) // no need to output pe1_out to pe0\n  );\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  input [15:0] b1,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [31:0] c0_reg, c1_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c0_reg <= 0;\n      c1_reg <= 0;\n    end else begin\n      c0_reg <= a0 * b0;\n      c1_reg <= a1 * b1;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] pc_stage;\n  wire [4:0] next_pc_stage;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .next_pc(next_pc),\n    .instr_mem(instr_mem),\n    .pc_stage(pc_stage),\n    .next_pc_stage(next_pc_stage)\n  );\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .next_pc(next_pc)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .reg_file(reg_file),\n    .pc(pc),\n    .next_pc(next_pc)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .reg_file(reg_file),\n    .next_pc(next_pc)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [4:0] pc,\n  input [4:0] next_pc,\n  input [31:0] instr_mem [0:31],\n  output reg [4:0] pc_stage,\n  output reg [4:0] next_pc_stage,\n  output reg [31:0] alu_res\n);\n  reg [31:0] instr;\n  reg [4:0] rd;\n  reg [4:0] rs1;\n  reg [4:0] rs2;\n  reg [3:0] op;\n  wire [31:0] rs1_val;\n  wire [31:0] rs2_val;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_stage <= 0;\n      next_pc_stage <= 0;\n      alu_res <= 0;\n    end else begin\n      pc_stage <= pc;\n      next_pc_stage <= next_pc;\n      alu_res <= 0;\n      if (pc != next_pc) begin\n        instr <= instr_mem[pc];\n        op <= instr[6:2];\n        rs1 <= instr[19:15];\n        rs2 <= instr[24:20];\n        rd <= instr[11:7];\n        if (op == 4'b0000 || op == 4'b0001) begin\n          alu_res <= rs1_val + rs2_val;\n        end else if (op == 4'b0010 || op == 4'b0011) begin\n          alu_res <= rs1_val - rs2_val;\n        end\n      end\n    end\n  end\n\n  assign rs1_val = reg_file[rs1];\n  assign rs2_val = reg_file[rs2];\nendmodule\n"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  wire [31:0] pe0_out, pe1_out, pe2_out, pe3_out;\n\n  // Delayed values\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b0_reg <= 16'd0;\n      b1_reg <= 16'd0;\n      b2_reg <= 16'd0;\n      b3_reg <= 16'd0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  // Processing elements\n  systolic pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  systolic pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  systolic pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(pe2_out)\n  );\n\n  systolic pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(pe3_out)\n  );\n\n  // Pipeline connections\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n  assign c2 = pe2_out;\n  assign c3 = pe3_out;\n\nendmodule\n\nmodule systolic(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  wire [31:0] mult_out;\n\n  // Multiplication\n  assign mult_out = a * b;\n\n  // Accumulation\n  always @(posedge clk or posedge rst) begin\n    if(rst) c <= 32'd0;\n    else c <= c + mult_out;\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] instr, op1, op2, result;\nwire [4:0] rd, rt, rs;\nwire [5:0] funct;\nwire [31:0] pc;\n\nwire [31:0] next_pc;\nwire [31:0] next_instr;\nwire [31:0] next_op1;\nwire [31:0] next_op2;\nwire [31:0] next_result;\n\nwire [31:0] next_reg_file [0:31];\n\nassign out_reg_file = next_reg_file[rd];\n\nfetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(next_pc),\n    .next_instr(next_instr),\n    .next_op1(next_op1),\n    .next_op2(next_op2)\n);\n\nexecute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(next_instr),\n    .op1(next_op1),\n    .op2(next_op2),\n    .result(next_result)\n);\n\nwriteback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .result(next_result),\n    .reg_file(next_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] next_pc,\n    output [31:0] next_instr,\n    output [31:0] next_op1,\n    output [31:0] next_op2\n);\n\nreg [31:0] instr, op1, op2;\nreg [4:0] rd, rt, rs;\nreg [5:0] funct;\n\nassign next_pc = pc + 4;\nassign next_instr = instr_mem[pc / 4];\nassign next_op1 = reg_file[op1 / 4];\nassign next_op2 = reg_file[op2 / 4];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        instr <= 0;\n        op1 <= 0;\n        op2 <= 0;\n        rd <= 0;\n        rt <= 0;\n        rs <= 0;\n        funct <= 0;\n    end\n    else begin\n        instr <= next_instr;\n        op1 <= next_op1;\n        op2 <= next_op2;\n        rd <= next_instr[11:7];\n        rt <= next_instr[15:11];\n        rs <= next_instr[20:16];\n        funct <= next_instr[5:0];\n    end\nend\n\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nreg [31:0] temp_result;\n\nalways @(*) begin\n    case (instr[5:0])\n        6'b000000: temp_result = op1 + op2;\n        6'b100011: temp_result = op1 - op2;\n        default: temp_result = 0;\n    endcase\nend\n\nassign result = temp_result;\n\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31]\n);\n\nreg [31:0] temp_reg_file [0:31];\n\nalways @(posedge clk"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                      incr_out;\n    wire                      reset_out;\n\n    wire                      accu_done;\n    reg     [9:0]             accu_result;\n    reg                       accu_valid;\n\n    counter                   u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .incr_in(valid_in),\n        .reset_in(reset_out),\n        .count_out(incr_out),\n        .reset_out(reset_out)\n    );\n\n    data_accumulator           u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .incr_in(incr_out),\n        .data_out(accu_result),\n        .accu_done(accu_done)\n    );\n\n    valid_output               u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(accu_done),\n        .valid_out(valid_out)\n    );\n\n    assign data_out = accu_result;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               incr_in,\n    input               reset_in,\n    output reg          count_out,\n    output reg          reset_out\n);\n\n    reg                       count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            reset_out <= 1'b0;\n            count_out <= 1'b0;\n        end else begin\n            if (reset_in) begin\n                reset_out <= 1'b1;\n                count_out <= 1'b0;\n            end else if (incr_in) begin\n                count <= count + 1;\n                if (count == 4) begin\n                    count_out <= 1'b1;\n                end\n                reset_out <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               incr_in,\n    output reg  [9:0]   data_out,\n    output reg          accu_done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n            accu_done <= 1'b0;\n        end else if (incr_in) begin\n            data_out <= data_out + data_in;\n            accu_done <= 1'b1;\n        end else begin\n            accu_done <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n        end else begin\n            valid_out <= valid_in;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [15:0] res;\n    wire [7:0] abs_dividend, neg_divisor;\n\n    assign abs_dividend = (sign) ? -dividend : dividend;\n    assign neg_divisor = (sign) ? -divisor : divisor;\n\n    // Implement submodules\n    // For example, the submodule to calculate absolute value is:\n    // Verilog code:\n    // module abs_value(\n    //     input [7:0] value,\n    //     output [7:0] abs_value\n    // );\n    //     assign abs_value = (value < 0) ? -value : value;\n    // endmodule\n\n    // Verilog code:\n    // module neg_value(\n    //     input [7:0] value,\n    //     output [7:0] neg_value\n    // );\n    //     assign neg_value = (value < 0) ? value : -value;\n    // endmodule\n\n    // Verilog code:\n    // module divider_control(\n    //     input clk,\n    //     input rst,\n    //     input [7:0] abs_dividend,\n    //     input [7:0] neg_divisor,\n    //     output reg [2:0] counter,\n    //     output reg [7:0] shift_reg,\n    //     output reg [15:0] result,\n    //     output reg div_done\n    // );\n    //     always @(posedge clk or posedge rst) begin\n    //         if (rst) begin\n    //             counter <= 0;\n    //             shift_reg <= 0;\n    //             result <= 0;\n    //             div_done <= 0;\n    //         end else begin\n    //             if (counter == 0) begin\n    //                 shift_reg <= abs_dividend;\n    //             end else begin\n    //                 shift_reg <= {shift_reg[6:0], 1'b0};\n    //             end\n    //             if (counter == 7) begin\n    //                 div_done <= 1;\n    //             end else if (shift_reg[7]) begin\n    //                 counter <= counter + 1;\n    //                 result <= {result[14:0], shift_reg[7]};\n    //             end\n    //         end\n    //     end\n    // endmodule\n\n    // Verilog code:\n    // module result_management(\n    //     input clk,\n    //     input rst,\n    //     input div_done,\n    //     input opn_valid,\n    //     input res_ready,\n    //     input [15:0] result,\n    //     output reg res_valid,\n    //     output reg [15:0] res\n    // );\n    //     always @(posedge clk or posedge rst) begin\n    //         if (rst) begin\n    //             res_valid <= 0;\n    //             res <= 0;\n    //         end else begin\n    //             if (opn_valid & res_ready) begin\n    //                 res_valid <= 1;\n    //                 res <= result;\n    //             end else if (div_done) begin\n    //                 res_valid <= 0;\n    //             end\n    //         end\n    //     end\n    // endmodule\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n    wire [31:0] P; // 32-bit prepared dividend\n    wire [15:0] Q; // 16-bit prepared divisor\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .P(P),\n        .Q(Q)\n    );\n\n    // Perform division\n    div_operation div_operation_inst(\n        .P(P),\n        .Q(Q),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] P,  // 32-bit prepared dividend\n    output wire [15:0] Q   // 16-bit prepared divisor\n);\n    assign P = {A[31:16], 16'b0}; // Prepare dividend\n    assign Q = B;                  // Prepare divisor\nendmodule\n\nmodule div_operation(\n    input wire [31:0] P,  // 32-bit prepared dividend\n    input wire [15:0] Q,  // 16-bit prepared divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Initialize result and remainder\n    reg [31:0] r;\n    reg [31:0] q;\n    reg [31:0] d;\n    reg [31:0] c;\n    reg [31:0] e;\n\n    // Shift dividend\n    always @(*) begin\n        d = P;\n        c = 0;\n    end\n\n    // Compare with divisor\n    always @(*) begin\n        e = d[31:0] & Q;\n        if (e == 0) begin\n            c = c + 16'h0001;\n            d = {d[30:0], 1'b0};\n        end\n    end\n\n    // Shift dividend\n    always @(*) begin\n        d = {d[30:0], 1'b0};\n    end\n\n    // Compare with divisor\n    always @(*) begin\n        e = d[31:0] & Q;\n        if (e == 0) begin\n            c = c + 16'h0001;\n            d = {d[30:0], 1'b0};\n        end\n    end\n\n    // Shift dividend\n    always @(*) begin\n        d = {d[29:0], 1'b0};\n    end\n\n    // Compare with divisor\n    always @(*) begin\n        e = d[31:0] & Q;\n        if (e == 0) begin\n            c = c + 16'h0001;\n            d = {d[28:0], 1'b0};\n        end\n    end\n\n    // Shift dividend\n    always @(*) begin\n        d = {d[27:0], 1'b0};\n    end\n\n    // Compare with divisor\n    always @(*) begin\n        e = d[31:0] & Q;\n        if (e == 0) begin\n            c = c + 16'h0001;\n            d = {d[26:0], 1'b0};\n        end\n    end\n\n    // Shift dividend\n    always @(*) begin\n        d = {d[25:0], 1'b0};\n    end\n\n    // Compare with divisor\n    always @(*) begin\n        e = d[31:0] & Q;\n        if (e == 0) begin\n            c = c + 16'h0001;\n            d = {d[24:0], 1'b0};\n        end\n    end\n\n    // Shift dividend\n    always @(*) begin"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    div_control ctrl (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\nendmodule\n\n// Submodule for dividing two 16-bit numbers\nmodule div_control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n\n    // Temporary variables\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n\n    always @(*) begin\n        // Initialize results\n        result = 16'b0;\n        odd = 16'b0;\n\n        // Shift dividend\n        dividend = A;\n\n        // Loop for each bit in quotient\n        for (int i = 15; i >= 0; i--) begin\n            // Shift divisor\n            divisor = B << i;\n\n            // Compare with dividend\n            if (dividend >= divisor) begin\n                result[i] = 1;\n                dividend = dividend - divisor;\n            end else begin\n                result[i] = 0;\n            end\n        end\n\n        // Assign remainder\n        odd = dividend;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp, sum;\n    wire carry;\n\n    // Calculate complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform subtraction\n    assign {carry, sum} = adder_8bit(A, B_comp);\n\n    // Calculate borrow output\n    assign B_out = ~carry;\n\n    // Output difference\n    assign D = sum;\n\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, carry);\n    input [7:0] a, b;\n    input c_in;\n    output [7:0] sum;\n    output carry;\n\n    wire [6:0] carry_chain;\n\n    // Add the carry-in to all bits\n    assign {carry_chain, sum} = a + b + c_in;\n\n    // Calculate carry out\n    assign carry = carry_chain[7];\nendmodule\n\nmodule full_adder(a, b, c_in, sum, carry);\n    input a, b, c_in;\n    output sum, carry;\n\n    assign {carry, sum} = a + b + c_in;\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] Diff_16;\n    wire B_out_1;\n\n    sub_16bit s1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_1)\n    );\n\n    sub_16bit s2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] borrow;\n\n    genvar i;\n    generate\n        for (i = 0; i < 16; i = i + 1) begin\n            if (i == 0) begin\n                assign borrow[i] = 1'b1;\n            end else begin\n                assign borrow[i] = borrow[i - 1] ^ (A[i] ^ B[i]);\n            end\n        end\n    endgenerate\n\n    assign Diff = A - B - borrow;\n    assign B_out = borrow[15];\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] sub0_D, sub1_D;\n    wire B_out0, B_out1;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(sub0_D),\n        .B_out(B_out0)\n    );\n\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(sub1_D),\n        .B_out(B_out1)\n    );\n\n    assign D = {sub1_D, sub0_D};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] sub0_D, sub1_D;\n    wire B_out0, B_out1;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(sub0_D),\n        .B_out(B_out0)\n    );\n\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(sub1_D),\n        .B_out(B_out1)\n    );\n\n    assign D = {sub1_D, sub0_D};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] sub0_D, sub1_D;\n    wire B_out0, B_out1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(sub0_D),\n        .B_out(B_out0)\n    );\n\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(sub1_D),\n        .B_out(B_out1)\n    );\n\n    assign D = {sub1_D, sub0_D};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] sub0_D, sub1_D;\n    wire B_out0, B_out1;\n\n    sub_4bit sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(sub0_D),\n        .B_out(B_out0)\n    );\n\n    sub_4bit sub1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(sub1_D),\n        .B_out(B_out1)\n    );\n\n    assign D = {sub1_D, sub0_D};\n    assign B_out = B_out1 | B_out0;\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] sub0_D, sub1_D;\n    wire B_out0, B_out1;\n\n    sub_2bit sub0(\n        .A("}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [16:1] diff_B;\n    wire [3:1] B_out_BLS;\n\n    // 4-bit BLS\n    sub_4bit BLS_0 (.A(A[3:1]), .B(B[3:1]), .D(diff_B[3:1]), .B_out(B_out_BLS[1]));\n    sub_4bit BLS_1 (.A(A[7:4]), .B(B[7:4]), .D(diff_B[7:4]), .B_out(B_out_BLS[2]));\n    sub_4bit BLS_2 (.A(A[11:8]), .B(B[11:8]), .D(diff_B[11:8]), .B_out(B_out_BLS[3]));\n    sub_4bit BLS_3 (.A(A[15:12]), .B(B[15:12]), .D(diff_B[15:12]), .B_out(B_out_BLS[4]));\n\n    assign D = diff_B;\n    assign B_out = B_out_BLS[4];\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:1] A, B;\n    output [3:1] D;\n    output B_out;\n\n    wire [3:1] diff_B, borrow;\n\n    // Add the carry in\n    assign diff_B = A + B;\n    assign borrow = (A[3] ^ B[3]) ? 0 : 1;\n\n    // Borrow out\n    assign B_out = (A[3] & B[3]) | (diff_B[3] & borrow);\n\n    // Subtract the borrow\n    assign D = diff_B ^ borrow;\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] A_minus_B;\n    \n    // Instantiate subtractor_32bit module\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .A_minus_B(A_minus_B)\n    );\n    \n    assign A_greater = (A_minus_B != 0);\n    assign A_equal = !(A_minus_B[31] ^ A_minus_B[30] ^ A_minus_B[29] ^ A_minus_B[28] ^ A_minus_B[27] ^ A_minus_B[26] ^ A_minus_B[25] ^ A_minus_B[24] ^ A_minus_B[23] ^ A_minus_B[22] ^ A_minus_B[21] ^ A_minus_B[20] ^ A_minus_B[19] ^ A_minus_B[18] ^ A_minus_B[17] ^ A_minus_B[16] ^ A_minus_B[15] ^ A_minus_B[14] ^ A_minus_B[13] ^ A_minus_B[12] ^ A_minus_B[11] ^ A_minus_B[10] ^ A_minus_B[9] ^ A_minus_B[8] ^ A_minus_B[7] ^ A_minus_B[6] ^ A_minus_B[5] ^ A_minus_B[4] ^ A_minus_B[3] ^ A_minus_B[2] ^ A_minus_B[1] ^ A_minus_B[0]);\n    assign A_less = (A_minus_B[31]);\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] A_minus_B\n);\n    wire borrow_out;\n    \n    // Perform subtraction operation\n    full_adder_32bit fa_inst0(\n        .A(A[31]),\n        .B(B[31]),\n        .cin(1'b0),\n        .sum(A_minus_B[31]),\n        .carry_out(borrow_out)\n    );\n    \n    genvar i;\n    generate\n        for (i = 30; i >= 0; i = i - 1) begin : subtraction_loop\n            full_adder_32bit fa_inst(\n                .A(A[i]),\n                .B(B[i]),\n                .cin(borrow_out),\n                .sum(A_minus_B[i]),\n                .carry_out(borrow_out)\n            );\n        end\n    endgenerate\nendmodule\n\nmodule full_adder_32bit(\n    input A,\n    input B,\n    input cin,\n    output sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B + cin;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:0] C16;\n\n    // Instantiate the Carry-Lookahead Adder (CLA)\n    // for 16-bit addition\n    cla_16bit CLA1 (.A(A[16:1]), .B(B[16:1]), .S(S[16:1]), .Cout(C16));\n    cla_16bit CLA2 (.A(A[32:17]), .B(B[32:17]), .S(S[32:17]), .Cout(C32));\n\n    // Carry-in logic\n    assign C32 = C16[15] | (C16[15] & C16[14]);\nendmodule\n\nmodule cla_16bit(A,B,S,Cout);\n    input [15:1] A,B;\n    output [15:1] S;\n    output Cout;\n\n    wire [14:0] C;\n\n    // First carry-lookahead adder\n    cla_8bit CLA1 (.A(A[15:8]), .B(B[15:8]), .S(S[15:8]), .Cout(C[7]));\n    cla_8bit CLA2 (.A(A[14:7]), .B(B[14:7]), .S(S[14:7]), .Cout(C[6]));\n    cla_8bit CLA3 (.A(A[13:4]), .B(B[13:4]), .S(S[13:4]), .Cout(C[5]));\n    cla_8bit CLA4 (.A(A[12:3]), .B(B[12:3]), .S(S[12:3]), .Cout(C[4]));\n    cla_8bit CLA5 (.A(A[11:2]), .B(B[11:2]), .S(S[11:2]), .Cout(C[3]));\n    cla_8bit CLA6 (.A(A[10:1]), .B(B[10:1]), .S(S[10:1]), .Cout(C[2]));\n\n    // Carry-in logic\n    assign Cout = C[14] | (C[14] & C[13]);\nendmodule\n\nmodule cla_8bit(A,B,S,Cout);\n    input [8:1] A,B;\n    output [8:1] S;\n    output Cout;\n\n    wire [7:0] C;\n\n    // First carry-lookahead adder\n    cla_4bit CLA1 (.A(A[8:4]), .B(B[8:4]), .S(S[8:4]), .Cout(C[3]));\n    cla_4bit CLA2 (.A(A[7:3]), .B(B[7:3]), .S(S[7:3]), .Cout(C[2]));\n    cla_4bit CLA3 (.A(A[6:2]), .B(B[6:2]), .S(S[6:2]), .Cout(C[1]));\n    cla_4bit CLA4 (.A(A[5:1]), .B(B[5:1]), .S(S[5:1]), .Cout(C[0]));\n\n    // Carry-in logic\n    assign Cout = C[7] | (C[7] & C[6]);\nendmodule\n\nmodule cla_4bit(A,B,S,Cout);\n    input [4:1] A,B;\n    output [4:1] S;\n    output Cout;\n\n    wire [3:0] C;\n\n    // First carry-lookahead adder\n    cla_2bit CLA1 (.A(A[4:2]), .B(B[4:2]), .S(S[4:2]), .Cout(C[1]));\n    cla_2bit CLA2 (.A(A[3:1]),"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    \n    wire [3:0] sum1, sum2, sum3, sum4;\n    wire [3:0] carry1, carry2, carry3;\n    wire [3:0] carry2_in;\n    \n    // 4-bit ripple carry adder\n    rca rca1(.a(a), .b(b), .cin(cin), .sum(sum1), .cout(carry1));\n    \n    // 4-bit ripple carry adder for the next 4 bits\n    rca rca2(.a(a[3:0]), .b(b[3:0]), .cin(carry1), .sum(sum2), .cout(carry2));\n    \n    // 4-bit ripple carry adder for the next 4 bits\n    rca rca3(.a(a[3:0]), .b(b[3:0]), .cin(carry2), .sum(sum3), .cout(carry3));\n    \n    // 4-bit ripple carry adder for the last 4 bits\n    rca rca4(.a(a[3:0]), .b(b[3:0]), .cin(carry3), .sum(sum4), .cout(cout));\n    \n    // 4-bit carry select adder slice\n    csa_slice csa1(.a(a), .b(b), .cin(cin), .sum(sum1), .cout(carry2_in), .carry(carry1));\n    \n    // 4-bit carry select adder slice\n    csa_slice csa2(.a(a[3:0]), .b(b[3:0]), .cin(carry2_in), .sum(sum2), .cout(carry2), .carry(carry1));\n    \n    // 4-bit carry select adder slice\n    csa_slice csa3(.a(a[3:0]), .b(b[3:0]), .cin(carry2), .sum(sum3), .cout(carry3), .carry(carry1));\n    \n    // 4-bit carry select adder slice\n    csa_slice csa4(.a(a[3:0]), .b(b[3:0]), .cin(carry3), .sum(sum4), .cout(cout), .carry(carry1));\nendmodule\n\n// Carry select adder slice module\nmodule csa_slice(a, b, cin, sum, cout, carry);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    input [3:0] carry;\n    \n    wire [3:0] sum1, sum2, sum3;\n    wire [3:0] carry1, carry2;\n    \n    // 4-bit ripple carry adder for the first 4 bits\n    rca rca1(.a(a), .b(b), .cin(cin), .sum(sum1), .cout(carry1));\n    \n    // 4-bit ripple carry adder for the next 4 bits\n    rca rca2(.a(a[3:0]), .b(b[3:0]), .cin(carry1), .sum(sum2), .cout(carry2));\n    \n    // 4-bit ripple carry adder for the last 4 bits\n    rca rca3(.a(a[3:0]), .b(b[3:0]), .cin(carry2), .sum(sum3), .cout(cout));\n    \n    // 4-bit multiplexer to select the sum\n    wire [3:0] mux_sum;\n    assign mux_sum = {a[0], a[1], a[2], a[3]} ^ {b[0], b[1], b[2], b[3]};\n    assign sum = mux_sum ^ {sum1[0], sum2[0], sum3[0], 1'b0} ^ {sum1[1], sum2[1],"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_temp;\n    wire [7:0] y_temp;\n\n    // Instantiate the 8-bit adder\n    add8_inst1 add8_inst1_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_temp),\n        .Co(Co_temp)\n    );\n\n    add8_inst2 add8_inst2_inst (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp[7]),\n        .y(y[15:8]),\n        .Co(Co_temp[6])\n    );\n\n    assign Co = Co_temp[6];\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n```\n### 3. 16-bit 2's complement adder with carry-in, carry-out and 16-bit addend\n```verilog\n/*\n * Implement a module that adds two 16-bit 2's complement numbers with carry-in and carry-out.\n *\n * Inputs:\n *      a, b: 16-bit 2's complement addends\n *      Cin: carry-in bit\n * Outputs:\n *      y: 16-bit sum\n *      Co: carry-out bit\n *\n * Your task is to implement the 16-bit 2's complement adder.\n */\n\nmodule adder_2s_comp_16bit(\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [15:0] sum;\n    wire [15:0] a_2s_comp, b_2s_comp;\n\n    // Convert inputs to 2's complement\n    assign a_2s_comp = (~a) + 1;\n    assign b_2s_comp = (~b) + 1;\n\n    // Perform the addition\n    assign sum = a_2s_comp + b_2s_comp + Cin;\n\n    // Convert output to 2's complement\n    assign y = (~sum) + 1;\n    assign Co = sum[15];\n\nendmodule\n```\n### 4. 16-bit subtraction with carry-out and 16-bit minuend\n```verilog\n/*\n * Implement a module that subtracts two 16-bit 2's complement numbers with carry-out.\n *\n * Inputs:\n *      a, b: 16-bit 2's complement minuends\n * Outputs:\n *      y: 16-bit difference\n *      Co: carry-out bit\n *\n * Your task is to implement the 16-bit subtraction.\n */\n\nmodule subtractor_2s_comp_16bit(\n    input wire [15:0] a,\n    input wire [15:0] b,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [15:0] diff;\n    wire [15:0] a_2s_comp, b_2s_comp;\n\n    // Convert inputs to 2's complement\n    assign a_2s_comp = (~a) + "}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] carry;\n    wire [6:0] a1, b1, s1;\n    wire [5:0] a2, b2, s2;\n    wire [4:0] a3, b3, s3;\n    wire [3:0] a4, b4, s4;\n    wire [2:0] a5, b5, s5;\n    wire [1:0] a6, b6, s6;\n    wire [0:0] a7, b7, s7;\n    wire c0, c1, c2, c3, c4, c5, c6, c7;\n\n    fa FA0(\n        .a(a[0]), .b(b[0]), .cin(cin), \n        .sum(s1[0]), .cout(c0));\n    fa FA1(\n        .a(a[1]), .b(b[1]), .cin(c0), \n        .sum(s1[1]), .cout(c1));\n    fa FA2(\n        .a(a[2]), .b(b[2]), .cin(c1), \n        .sum(s1[2]), .cout(c2));\n    fa FA3(\n        .a(a[3]), .b(b[3]), .cin(c2), \n        .sum(s1[3]), .cout(c3));\n    fa FA4(\n        .a(a[4]), .b(b[4]), .cin(c3), \n        .sum(s1[4]), .cout(c4));\n    fa FA5(\n        .a(a[5]), .b(b[5]), .cin(c4), \n        .sum(s1[5]), .cout(c5));\n    fa FA6(\n        .a(a[6]), .b(b[6]), .cin(c5), \n        .sum(s1[6]), .cout(c6));\n    fa FA7(\n        .a(a[7]), .b(b[7]), .cin(c6), \n        .sum(s1[7]), .cout(c7));\n    \n    assign s1 = a1 + b1;\n    assign a1 = {a[1:0]};\n    assign b1 = {b[1:0]};\n    \n    assign s2 = a2 + b2 + c1;\n    assign a2 = {a1[2:0]};\n    assign b2 = {b1[2:0]};\n    \n    assign s3 = a3 + b3 + c2;\n    assign a3 = {a2[3:0]};\n    assign b3 = {b2[3:0]};\n    \n    assign s4 = a4 + b4 + c3;\n    assign a4 = {a3[4:0]};\n    assign b4 = {b3[4:0]};\n    \n    assign s5 = a5 + b5 + c4;\n    assign a5 = {a4[5:0]};\n    assign b5 = {b4[5:0]};\n    \n    assign s6 = a6 + b6 + c5;\n    assign a6 = {a5[6:0]};\n    assign b6 = {b5[6:0]};\n    \n    assign s7 = a7 + b7 + c6;\n    assign a7 = {a6[7:0]};\n    assign b7 = {b6[7:0]};\n    \n    assign sum = {s1, s2, s3, s4, s5, s6, s7};\n    assign cout = c7;\n    \nendmodule\n\nmodule fa(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [15:0] shift_count;\n    wire [31:0] product;\n\n    assign yout = product;\n    assign done = done_reg;\n\n    // Control Unit.\n    reg [31:0] shift_count_reg;\n    reg [31:0] product_reg;\n    reg done_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count_reg <= 0;\n            product_reg <= 0;\n            done_reg <= 0;\n        end else if (start) begin\n            shift_count_reg <= 16'd15;\n            product_reg <= 0;\n            done_reg <= 0;\n        end else begin\n            if (shift_count_reg != 0) begin\n                shift_count_reg <= shift_count_reg - 16'd1;\n            end else begin\n                done_reg <= 1;\n            end\n        end\n    end\n\n    // Register Unit.\n    reg [15:0] ain_reg;\n    reg [15:0] bin_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            ain_reg <= 0;\n            bin_reg <= 0;\n        end else begin\n            ain_reg <= ain;\n            bin_reg <= bin;\n        end\n    end\n\n    // Multiplier Unit.\n    reg [15:0] shift_reg;\n    reg [31:0] acc_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_reg <= 0;\n            acc_reg <= 0;\n        end else begin\n            shift_reg <= {shift_reg[14:0], ain_reg[shift_count_reg]};\n            acc_reg <= acc_reg + ({16'd0, shift_reg} * bin_reg);\n        end\n    end\n\nendmodule\n\n// Control Unit.\nmodule ctrl_unit (\n    input [31:0] shift_count,\n    input [31:0] product,\n    output [31:0] shift_count_reg,\n    output [31:0] product_reg,\n    output done\n);\n\n    always @(*) begin\n        shift_count_reg = shift_count;\n        product_reg = product;\n        done = (shift_count == 0);\n    end\n\nendmodule\n\n// Register Unit.\nmodule reg_unit (\n    input [15:0] ain,\n    input [15:0] bin,\n    input [31:0] shift_count,\n    input [31:0] product,\n    output [15:0] ain_reg,\n    output [15:0] bin_reg,\n    output [31:0] shift_count_reg,\n    output [31:0] product_reg\n);\n\n    always @(*) begin\n        ain_reg = ain;\n        bin_reg = bin;\n        shift_count_reg = shift_count;\n        product_reg = product;\n    end\n\nendmodule\n\n// Multiplier Unit.\nmodule mul_unit (\n    input [15:0] shift_count,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [31:0] product,\n    output [31:0] shift_reg,\n    output [31:0] acc_reg\n);\n\n    always @(*) begin\n        shift_reg = {shift_reg[14:0], ain[shift_count]};\n        acc_reg = acc_reg + ({16'd0, shift_reg} * bin);\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n    wire [15:0] addend;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(current_count)\n    );\n\n    assign count = current_count;\n\n    assign addend = up_down ? 16'h0001 : 16'hFFFF;\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    reg [15:0] count;\n    reg [15:0] next_count_internal;\n\n    always @(*) begin\n        if (reset) begin\n            count = 16'h0000;\n            next_count_internal = 16'h0000;\n        end else if (up_down) begin\n            count = count + 1;\n            next_count_internal = count + 1;\n        end else begin\n            count = count - 1;\n            next_count_internal = count - 1;\n        end\n    end\n\n    assign next_count = next_count_internal;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'h0000;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Initialize the ring counter with the least significant bit set to 1\n    ring_counter_init init (.clk(clk), .reset(reset), .out(out));\n\n    // Cyclic state transition\n    ring_counter_transition transition (.clk(clk), .reset(reset), .out(out));\n\nendmodule\n\n// Initialize the ring counter\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n    end\nendmodule\n\n// Cyclic state transition\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b0000_0001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n\nmodule main (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    ring_counter rc (.clk(clk), .reset(reset), .out(out));\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    // Instantiate the submodules\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= count + 1;\n    end\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 0;\n        else if (valid_count)\n            out <= count;\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    // JC_register instance\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q));\n\n    // JC_logic instance\n    JC_logic logic_inst(.Q(Q), .next_Q(next_Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) Q <= 64'b0;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         Q,\n    output [63:0]        next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire clk_div_50_clk, clk_div_10_clk, clk_div_1_clk;\n\nclk_div_2 clk_div_50 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_50), .clk_div_clk(clk_div_50_clk));\nclk_div_10 clk_div_10 (.CLK_in(clk_div_50_clk), .RST(RST), .CLK_out(CLK_10), .clk_div_clk(clk_div_10_clk));\nclk_div_100 clk_div_1 (.CLK_in(clk_div_10_clk), .RST(RST), .CLK_out(CLK_1), .clk_div_clk(clk_div_1_clk));\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output reg clk_div_clk\n);\n\nalways @(posedge CLK_in or posedge RST)\n    if (RST)\n        clk_div_clk <= 0;\n    else\n        clk_div_clk <= ~clk_div_clk;\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output reg clk_div_clk\n);\n\nreg [1:0] cnt;\n\nalways @(posedge CLK_in or posedge RST)\n    if (RST)\n        cnt <= 0;\n    else if (cnt == 3)\n        cnt <= 0;\n    else\n        cnt <= cnt + 1;\n\nassign CLK_out = cnt == 2;\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output reg clk_div_clk\n);\n\nreg [5:0] cnt;\n\nalways @(posedge CLK_in or posedge RST)\n    if (RST)\n        cnt <= 0;\n    else if (cnt == 49)\n        cnt <= 0;\n    else\n        cnt <= cnt + 1;\n\nassign CLK_out = cnt == 48;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\n    localparam MUL2_DIV_CLK = 7;\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj_neg;\n    wire clk_adj_pos;\n\n    counter u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_3)\n    );\n\n    clk_average u_clk_average(\n        .clk_avg(clk_3),\n        .clk_avg_4(clk_4),\n        .clk_avg_3(clk_avg)\n    );\n\n    clk_adjustment u_clk_adjustment(\n        .clk_avg_neg(clk_adj_neg),\n        .clk_avg_pos(clk_avg),\n        .clk_adj_neg(clk_adj_neg),\n        .clk_adj_pos(clk_adj_pos)\n    );\n\n    assign clk_div = clk_adj_pos | clk_adj_neg;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg          clk_div\n);\n\n    localparam MAX_COUNTER_VAL = MUL2_DIV_CLK - 1;\n\n    reg [4:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter >= MAX_COUNTER_VAL) begin\n                counter <= 0;\n                clk_div <= 1;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule clk_average(\n    input               clk_avg,\n    input               clk_avg_4,\n    input               clk_avg_3,\n    output reg          clk_avg_4_reg,\n    output reg          clk_avg_3_reg\n);\n\n    always @(posedge clk_avg) begin\n        clk_avg_4_reg <= clk_avg_4;\n        clk_avg_3_reg <= clk_avg_3;\n    end\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk_avg_neg,\n    input               clk_avg_pos,\n    output reg          clk_adj_neg_reg,\n    output reg          clk_adj_pos_reg\n);\n\n    always @(posedge clk_avg_neg or posedge clk_avg_pos) begin\n        if (clk_avg_neg) begin\n            clk_adj_neg_reg <= 1;\n            clk_adj_pos_reg <= 0;\n        end else if (clk_avg_pos) begin\n            clk_adj_pos_reg <= 1;\n            clk_adj_neg_reg <= 0;\n        end\n    end\n\nendmodule\n\nmodule counter_tb(\n    input               clk,\n    input               rst_n\n);\n\n    localparam MAX_COUNTER_VAL = MUL2_DIV_CLK - 1;\n\n    reg [4:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter >= MAX_COUNTER_VAL) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0;\n            clk_div <= 0;\n        end else if (counter < NUM_DIV - 1) begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end else begin\n            counter <= 4'b0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 4'b0;\n            clk_div <= 0;\n        end else if (counter < NUM_DIV - 1) begin\n            counter <= counter + 1;\n            clk_div <= 0;\n        end else begin\n            counter <= 4'b0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 2;\n\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n)\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == (NUM_DIV / 2 - 1))\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n\n    always @(posedge clk or negedge rst_n)\n        if (!rst_n)\n            clk_div <= 0;\n        else if (cnt == (NUM_DIV / 2 - 1))\n            clk_div <= ~clk_div;\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n)\n        if (!rst_n)\n            q <= 0;\n        else if (q == (NUM_DIV / 2 - 1))\n            q <= 0;\n        else\n            q <= q + 1;\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] cnt,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n)\n        if (!rst_n)\n            clk_div <= 0;\n        else if (cnt == (NUM_DIV / 2 - 1))\n            clk_div <= ~clk_div;\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire add_carry, sub_carry;\n    wire [31:0] sll_result, srl_result, sra_result;\n    wire [31:0] sllv_result, srlv_result, srav_result;\n    wire [31:0] slt_result, sltu_result;\n    wire [31:0] lui_result;\n\n    // Submodule instantiations\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry)\n    );\n\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry)\n    );\n\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result)\n    );\n\n    sll sll_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(sll_result)\n    );\n\n    srl srl_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(srl_result)\n    );\n\n    sra sra_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(sra_result)\n    );\n\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_result)\n    );\n\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(srlv_result)\n    );\n\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b[31:12]),\n        .r(lui_result)\n    );\n\n    // Output selection\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010)"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n\n    // Instantiating multiplier submodule\n    // You can use multiplier module code here\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(multiplication_result)\n    );\n\n    // Instantiating accumulator submodule\n    // You can use accumulator module code here\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .value_in(multiplication_result[31:0]),\n        .value_out(current_value)\n    );\n\n    assign c = current_value;\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] value_in,\n    output reg [31:0] value_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            value_out <= 0;\n        end else begin\n            value_out <= value_out + value_in;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1, ins2;\n    wire [4:0] ad11, ad12, ad21, ad22;\n    wire [1:0] op1, op2;\n\n    // Instruction registers for the first instruction\n    instr_p ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21),\n        .op(op1)\n    );\n\n    // Instruction registers for the second instruction\n    instr_p ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22),\n        .op(op2)\n    );\n\n    // Outputs\n    assign ins = (fetch == 2'b01) ? ins1[2:0] : (fetch == 2'b10) ? ins2[2:0] : ins_p1.ins;\n    assign ad1 = (fetch == 2'b01) ? ad11 : (fetch == 2'b10) ? ad12 : ins_p1.ad1;\n    assign ad2 = (fetch == 2'b01) ? ad21 : (fetch == 2'b10) ? ad22 : ins_p1.ad2;\n\nendmodule\n\n// Instruction register\nmodule instr_p (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2,\n    output reg [1:0] op\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n            op <= 0;\n        end else begin\n            ins <= data;\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n            op <= data[7:5];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n    \n    assign enable = (freq > 1);\n    counter counter_instance(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator wave_generator_instance(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n            wave_reg <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 0;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule signal_generator_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule signal_generator_waveform (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10000) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) begin\n                        state <= 2'b00;\n                    end\n                end\n                default: begin\n                    state <= 2'b00;\n                    wave_reg <= 0;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q_shift;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q_shift[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q_shift[0]),\n        .q(q_shift[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q_shift[1]),\n        .q(q_shift[2])\n    );\n\n    always @(posedge clk)\n    begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= q_shift[0];\n            2'b10: q <= q_shift[1];\n            2'b11: q <= q_shift[2];\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule\n\nmodule mux4to1 (\n    input [3:0] a,\n    input [1:0] sel,\n    output reg y\n);\n    always @(*)\n    begin\n        case (sel)\n            2'b00: y = a[0];\n            2'b01: y = a[1];\n            2'b10: y = a[2];\n            2'b11: y = a[3];\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2, q3;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n    wire [7:0] stage3_out;\n\n    mux2X1 mux0 (.sel(ctrl[2]), .in1(in), .in2(stage1_out), .out(stage2_out));\n    mux2X1 mux1 (.sel(ctrl[1]), .in1(stage2_out), .in2(stage3_out), .out(stage1_out));\n    mux2X1 mux2 (.sel(ctrl[0]), .in1(stage1_out), .in2(in), .out(stage3_out));\n\nendmodule\n\nmodule mux2X1 (sel, in1, in2, out);\n    input sel;\n    input [7:0] in1, in2;\n    output [7:0] out;\n\n    assign out = sel ? in1 : in2;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n\n  // PE0\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  // PE1\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  assign b1 = (rst) ? 0 : b0;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] ac;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      ac <= 0;\n    else\n      ac <= ac + a * b;\n  end\n\n  assign c = ac;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  wire [31:0] instr;\n  wire [31:0] rs1, rs2, rd, res;\n  wire [5:0] op;\n  \n  stagepipe5_submodule fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .pc(pc),\n    .instr(instr)\n  );\n  stagepipe5_submodule decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n  stagepipe5_submodule execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .op(op),\n    .rs1(rs1),\n    .rs2(rs2),\n    .res(res)\n  );\n  stagepipe5_submodule memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .res(res),\n    .pc(pc)\n  );\n  stagepipe5_submodule writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .res(res),\n    .res_reg_file(res_reg_file)\n  );\nendmodule\n\nmodule stagepipe5_submodule (\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] pc,\n  output [31:0] instr,\n  output [31:0] rs1,\n  output [31:0] rs2,\n  output [31:0] rd,\n  output [5:0] op\n);\n  assign pc = pc + 1;\n  assign instr = instr_mem[pc];\n  assign {op, rs2, rs1, rd} = instr;\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\nreg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\nwire [15:0] b0_next, b1_next, b2_next, b3_next;\nwire [31:0] c0_next, c1_next, c2_next, c3_next;\nwire [15:0] a_reg[0:3];\nwire [15:0] b_reg[0:3];\n\nassign c0 = c0_next;\nassign c1 = c1_next;\nassign c2 = c2_next;\nassign c3 = c3_next;\n\nalways @(posedge clk or posedge rst) begin\n  if(rst) begin\n    b0_reg <= 0;\n    b1_reg <= 0;\n    b2_reg <= 0;\n    b3_reg <= 0;\n  end else begin\n    b0_reg <= b0_next;\n    b1_reg <= b1_next;\n    b2_reg <= b2_next;\n    b3_reg <= b3_next;\n  end\nend\n\nassign b0_next = b0;\nassign b1_next = b0_reg;\nassign b2_next = b1_reg;\nassign b3_next = b2_reg;\n\ngenvar i;\ngenerate\n  for(i = 0; i < 4; i = i + 1) begin : pe\n    assign a_reg[i] = (i == 0) ? a0 : a_reg[i-1];\n    assign b_reg[i] = (i == 0) ? b0 : b_reg[i-1];\n\n    assign c_out[i] = a_reg[i] * b_reg[i];\n    assign c_next[i] = c_out[i] + c_reg[i];\n  end\nendgenerate\n\nassign c0_next = c_next[0];\nassign c1_next = c_next[1];\nassign c2_next = c_next[2];\nassign c3_next = c_next[3];\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n\nreg [31:0] c_reg;\nwire [31:0] c_next;\n\nassign c = c_next;\n\nalways @(posedge clk or posedge rst) begin\n  if(rst) begin\n    c_reg <= 0;\n  end else begin\n    c_reg <= c_next;\n  end\nend\n\nassign c_next = a * b + c_reg;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch_instr, exec_result;\n    wire [4:0] pc;\n\n    // stage 1\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .pc(pc),\n        .instr_mem(instr_mem),\n        .fetch_instr(fetch_instr)\n    );\n\n    // stage 2\n    execute execute (\n        .clk(clk),\n        .rst(rst),\n        .pc(pc),\n        .instr(fetch_instr),\n        .reg_file(reg_file),\n        .exec_result(exec_result)\n    );\n\n    // stage 3\n    writeback writeback (\n        .clk(clk),\n        .rst(rst),\n        .pc(pc),\n        .exec_result(exec_result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage (\n    input clk,\n    input rst,\n    input [4:0] pc,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetch_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            fetch_instr <= 0;\n        end\n        else begin\n            fetch_instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute (\n    input clk,\n    input rst,\n    input [4:0] pc,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] exec_result\n);\n    reg [5:0] op;\n    reg [4:0] rd;\n    reg [4:0] ra;\n    reg [4:0] rb;\n    reg [31:0] a;\n    reg [31:0] b;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            op <= 0;\n            rd <= 0;\n            ra <= 0;\n            rb <= 0;\n            a <= 0;\n            b <= 0;\n            result <= 0;\n        end\n        else begin\n            op <= instr[31:26];\n            rd <= instr[11:7];\n            ra <= instr[19:15];\n            rb <= instr[25:21];\n            a <= reg_file[ra];\n            b <= reg_file[rb];\n            case(op)\n                6'b000000: begin // add\n                    result = a + b;\n                end\n                6'b100011: begin // sub\n                    result = a - b;\n                end\n            endcase\n            exec_result <= result;\n        end\n    end\nendmodule\n\nmodule writeback (\n    input clk,\n    input rst,\n    input [4:0] pc,\n    input [31:0] exec_result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            out_reg_file <= 0;\n        end\n        else begin\n            reg_file[pc] <= exec_result;\n            out_reg_file <= reg_file[pc];\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire       [1:0]   counter_next_state;\nwire               counter_valid_out;\nwire       [9:0]   counter_data_out;\n\nwire               data_accumulator_valid_out;\nwire       [9:0]   data_accumulator_data_out;\n\nwire               valid_output_valid_out;\n\ncounter              u_counter        (\n    .clk                   (clk),\n    .rst_n                 (rst_n),\n    .valid_in              (valid_in),\n    .counter_next_state    (counter_next_state),\n    .counter_valid_out     (counter_valid_out),\n    .counter_data_out      (counter_data_out)\n);\n\ndata_accumulator      u_data_accumulator    (\n    .clk                   (clk),\n    .rst_n                 (rst_n),\n    .data_in               (data_in),\n    .counter_data_out      (counter_data_out),\n    .data_accumulator_valid_out (data_accumulator_valid_out),\n    .data_accumulator_data_out  (data_accumulator_data_out)\n);\n\nvalid_output          u_valid_output    (\n    .clk                   (clk),\n    .rst_n                 (rst_n),\n    .counter_valid_out     (counter_valid_out),\n    .data_accumulator_valid_out (data_accumulator_valid_out),\n    .valid_out             (valid_output_valid_out)\n);\n\nassign valid_out = valid_output_valid_out;\nassign data_out = data_accumulator_data_out;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   counter_next_state,\n    output              counter_valid_out,\n    output reg  [9:0]   counter_data_out\n);\n\nparameter IDLE = 2'b00;\nparameter COUNT = 2'b01;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_next_state <= IDLE;\n        counter_data_out <= 10'h0;\n    end else begin\n        case (counter_next_state)\n            IDLE: begin\n                if (valid_in) begin\n                    counter_next_state <= COUNT;\n                end else begin\n                    counter_next_state <= IDLE;\n                end\n            end\n            COUNT: begin\n                counter_next_state <= COUNT;\n                if (counter_next_state == COUNT) begin\n                    counter_data_out <= counter_data_out + data_in;\n                end\n            end\n        endcase\n    end\nend\n\nassign counter_valid_out = (counter_next_state == COUNT);\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              data_accumulator_valid_out,\n    output reg  [9:0]   data_accumulator_data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_accumulator_data_out <= 10'h0;\n    end else begin\n        if (valid_in) begin\n            data_accumulator_data_out <= data_in + data_accumulator_data_out;\n        end\n    end\nend\n\nassign data_accumulator_valid_out = valid_in;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               counter_valid_out,\n    input               data_accumulator_valid_out,\n\n    output              valid_out\n);\n\nreg               data_out_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\n\n// absolute value calculator\nabs_value abs_dividend_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\n// negative divisor calculator\nneg_value neg_divisor_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .divisor(divisor),\n    .result(neg_divisor)\n);\n\n// division control logic\ndivider_control ctrl_inst(\n    .clk(clk),\n    .rst(rst),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .counter(ctrl_inst.counter),\n    .done(ctrl_inst.done)\n);\n\n// result management\nresult_management res_mgmt_inst(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(ctrl_inst.counter),\n    .done(ctrl_inst.done),\n    .result(result),\n    .res_valid(res_valid)\n);\n\nendmodule\n\n//------------------------------------------------\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,    \n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) result <= 8'b0;\n    else if(sign) result <= -dividend;\n    else result <= dividend;\nend\n\nendmodule\n\n//------------------------------------------------\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,    \n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) result <= 8'b0;\n    else if(sign) result <= -divisor;\n    else result <= divisor;\nend\n\nendmodule\n\n//------------------------------------------------\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    output reg [2:0] counter,\n    output reg done\n);\n\nreg [7:0] shift_reg;\nwire [7:0] shifted_dividend;\n\nassign shifted_dividend = {dividend[6:0], 1'b0};\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        shift_reg <= 8'b0;\n        counter <= 3'b0;\n        done <= 1'b0;\n    end\n    else begin\n        case(counter)\n            3'b000: begin\n                shift_reg <= shifted_dividend;\n                counter <= 3'b010;\n            end\n            3'b010: begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                if(shift_reg[7]) counter <= 3'b100;\n                else counter <= 3'b010;\n            end\n            3'b100: begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                if(shift_reg[7]) counter <= 3'b110;\n                else counter <= 3'b100;\n            end\n            3'b110: begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                counter <= 3'b000;\n                done <= 1'b1;\n            end\n            default: counter <= 3'b000;\n        endcase\n    end\nend\n\nendmodule\n\n//------------------------------------------------\n\nmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Module prep_dividend\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Module div_operation\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    div_operation div_operation_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [31:0] divisor\n);\n    always @* begin\n        dividend = {A[31:0], 16'b0};\n        divisor = {B, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @* begin\n        quotient = 32'b0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    wire [15:0] dividend = A;\n    wire [7:0] divisor = B;\n    \n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    \n    control_unit ctrl (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n    \n    assign result = quotient;\n    assign odd = remainder;\n    \nendmodule\n\nmodule control_unit (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [2:0] shift;\n    reg [7:0] temp;\n    \n    always @(*) begin\n        shift = 0;\n        quotient = 0;\n        remainder = 0;\n        \n        while (shift < 16) begin\n            if (dividend[shift] == 1) begin\n                temp = dividend >> shift;\n                if (temp >= divisor) begin\n                    quotient = quotient + (1 << shift);\n                    dividend = dividend - (divisor << shift);\n                end\n            end\n            \n            shift = shift + 1;\n        end\n        \n        remainder = dividend;\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n\n    full_adder fa0(A[0], B_comp[0], 1'b0, D[0], carry);\n    full_adder fa1(A[1], B_comp[1], carry, D[1], carry);\n    full_adder fa2(A[2], B_comp[2], carry, D[2], carry);\n    full_adder fa3(A[3], B_comp[3], carry, D[3], carry);\n    full_adder fa4(A[4], B_comp[4], carry, D[4], carry);\n    full_adder fa5(A[5], B_comp[5], carry, D[5], carry);\n    full_adder fa6(A[6], B_comp[6], carry, D[6], carry);\n    full_adder fa7(A[7], B_comp[7], carry, D[7], B_out);\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule adder_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n\n    full_adder fa0(A[0], B_comp[0], 1'b0, D[0], carry);\n    full_adder fa1(A[1], B_comp[1], carry, D[1], carry);\n    full_adder fa2(A[2], B_comp[2], carry, D[2], carry);\n    full_adder fa3(A[3], B_comp[3], carry, D[3], carry);\n    full_adder fa4(A[4], B_comp[4], carry, D[4], carry);\n    full_adder fa5(A[5], B_comp[5], carry, D[5], carry);\n    full_adder fa6(A[6], B_comp[6], carry, D[6], carry);\n    full_adder fa7(A[7], B_comp[7], carry, D[7], B_out);\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] B_low, B_high;\n    wire [15:0] Diff_low, Diff_high;\n    wire B_out_low, B_out_high;\n\n    assign B_low = B[15:0];\n    assign B_high = B[31:16];\n\n    sub_16bit S1(A[15:0], B_low, Diff_low, B_out_low);\n    sub_16bit S2(A[31:16], B_high, Diff_high, B_out_high);\n\n    assign Diff[15:0] = Diff_low;\n    assign Diff[31:16] = Diff_high;\n    assign B_out = B_out_high;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] A_low, B_low;\n    wire [7:0] Diff_low;\n    wire B_out_low;\n\n    assign A_low = A[7:0];\n    assign B_low = B[7:0];\n\n    sub_8bit S1(A_low, B_low, Diff_low, B_out_low);\n\n    assign Diff = {Diff_low, B_out_low};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] A_low, B_low;\n    wire [3:0] Diff_low;\n    wire B_out_low;\n\n    assign A_low = A[3:0];\n    assign B_low = B[3:0];\n\n    sub_4bit S1(A_low, B_low, Diff_low, B_out_low);\n\n    assign Diff = {Diff_low, B_out_low};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] A_low, B_low;\n    wire [1:0] Diff_low;\n    wire B_out_low;\n\n    assign A_low = A[1:0];\n    assign B_low = B[1:0];\n\n    sub_2bit S1(A_low, B_low, Diff_low, B_out_low);\n\n    assign Diff = {Diff_low, B_out_low};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0:0] A_low, B_low;\n    wire [0:0] Diff_low;\n    wire B_out_low;\n\n    assign A_low = A[0];\n    assign B_low = B[0];\n\n    sub_1bit S1(A_low, B_low, Diff_low, B_out_low);\n\n    assign Diff = {Diff_low, B_out_low};\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;\n    input B;\n    output Diff;\n    output B_out;\n\n    assign Diff = A ^ B;\n    assign B_out = ~(A & B);\n\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] A16[3:0];\n    wire [15:0] B16[3:0];\n    wire [15:0] D16[3:0];\n    wire [7:0] B8[15:0];\n\n    genvar i;\n\n    for (i = 0; i < 4; i = i + 1)\n        assign A16[i] = A[i*16 +: 16];\n    for (i = 0; i < 4; i = i + 1)\n        assign B16[i] = B[i*16 +: 16];\n\n    for (i = 0; i < 16; i = i + 1)\n        assign B8[i] = B16[i/2][i%2*8 +: 8];\n\n    for (i = 0; i < 4; i = i + 1) begin\n        sub_16bit sub0 (\n            .A(A16[i]),\n            .B(B16[i]),\n            .D(D16[i]),\n            .B_out(B_out)\n        );\n    end\n\n    assign D = {D16[3], D16[2], D16[1], D16[0]};\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] A8[2:0];\n    wire [7:0] B8[2:0];\n\n    genvar j;\n\n    for (j = 0; j < 3; j = j + 1)\n        assign A8[j] = A[j*8 +: 8];\n    for (j = 0; j < 3; j = j + 1)\n        assign B8[j] = B[j*8 +: 8];\n\n    for (j = 0; j < 2; j = j + 1) begin\n        sub_8bit sub0 (\n            .A(A8[j]),\n            .B(B8[j]),\n            .D(D[j*8 +: 8]),\n            .B_out(B_out)\n        );\n    end\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] A4[1:0];\n    wire [3:0] B4[1:0];\n\n    genvar k;\n\n    for (k = 0; k < 2; k = k + 1)\n        assign A4[k] = A[k*4 +: 4];\n    for (k = 0; k < 2; k = k + 1)\n        assign B4[k] = B[k*4 +: 4];\n\n    for (k = 0; k < 1; k = k + 1) begin\n        sub_4bit sub0 (\n            .A(A4[k]),\n            .B(B4[k]),\n            .D(D[k*4 +: 4]),\n            .B_out(B_out)\n        );\n    end\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] A2[1:0];\n    wire [1:0] B2[1:0];\n\n    genvar l;\n\n    for (l = 0; l < 2; l = l + 1)\n        assign A2[l] = A"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n    \n    wire [15:0] borrow;\n    \n    bls_16bit_24bit_1 bls1(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow));\n    bls_16bit_24bit_1 bls2(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow));\n    bls_16bit_24bit_1 bls3(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow));\n    bls_16bit_24bit_1 bls4(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow));\n    \n    assign B_out = borrow[0];\nendmodule\n\nmodule bls_16bit_24bit_1(A, B, D, borrow);\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output borrow;\n    \n    wire [16:1] diff, borrow_in;\n    assign diff = A - B;\n    assign borrow_in = diff[16] ? 1'b1 : 1'b0;\n    \n    bls_24bit_16bit_1 bls1(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow_in));\nendmodule\n\nmodule bls_24bit_16bit_1(A, B, D, borrow);\n    input [24:1] A;\n    input [16:1] B;\n    output [24:1] D;\n    output borrow;\n    \n    wire [24:1] diff, borrow_in;\n    assign diff = A - B;\n    assign borrow_in = diff[24] ? 1'b1 : 1'b0;\n    \n    bls_16bit_24bit_1 bls1(.A(A[24:1]), .B(B[16:1]), .D(D[24:1]), .borrow(borrow_in));\nendmodule\n\nmodule bls_16bit_24bit_1(A, B, D, borrow);\n    input [16:1] A;\n    input [16:1] B;\n    output [24:1] D;\n    output borrow;\n    \n    wire [16:1] diff, borrow_in;\n    assign diff = A - B;\n    assign borrow_in = diff[16] ? 1'b1 : 1'b0;\n    \n    bls_24bit_16bit_1 bls1(.A(A[16:1]), .B(B[16:1]), .D(D[16:1]), .borrow(borrow_in));\nendmodule\n\nmodule bls_24bit_16bit_1(A, B, D, borrow);\n    input [24:1] A;\n    input [16:1] B;\n    output [24:1] D;\n    output borrow;\n    \n    wire [24:1] diff, borrow_in;\n    assign diff = A - B;\n    assign borrow_in = diff[24] ? 1'b1 : 1'b0;\n    \n    bls_16bit_24bit_1 bls1(.A(A[24:1]), .B(B[16:1]), .D(D[24:1]), .borrow(borrow_in));\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] sub_result;\n\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .result(sub_result)\n);\n\nassign A_greater = (sub_result == 0);\nassign A_equal = (sub_result == 0) && (A != B);\nassign A_less = (sub_result != 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\nwire [31:0] B_neg;\n\nassign B_neg = ~B + 1'b1;\n\nassign result = A + B_neg;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] S16[15:1];\n    wire C16[15:1];\n\n    CLA1 CLA1(.A(A[16:1]),.B(B[16:1]),.S(S16[1]),.C(C16[1]));\n    CLA1 CLA2(.A(A[32:16]),.B(B[32:16]),.S(S16[2]),.C(C16[2]));\n    assign S[16:1] = S16[1] + S16[2];\n    assign C32 = C16[1] | C16[2];\nendmodule\n\nmodule CLA1(A,B,S,C);\n    input [15:1] A,B;\n    output [15:1] S;\n    output C;\n\n    wire [8:1] C1[8:1];\n    wire [8:1] C2[8:1];\n\n    CLA_16bit CLA16(.A(A),.B(B),.S(S),.C(C1[1]),.C2(C2[1]));\n    assign C = C1[1] | C2[1];\n\n    CLA_16bit CLA17(.A(A),.B(B),.S(S),.C(C1[2]),.C2(C2[2]));\n    assign C = C1[2] | C2[2];\n\n    CLA_16bit CLA18(.A(A),.B(B),.S(S),.C(C1[3]),.C2(C2[3]));\n    assign C = C1[3] | C2[3];\n\n    CLA_16bit CLA19(.A(A),.B(B),.S(S),.C(C1[4]),.C2(C2[4]));\n    assign C = C1[4] | C2[4];\n\n    CLA_16bit CLA20(.A(A),.B(B),.S(S),.C(C1[5]),.C2(C2[5]));\n    assign C = C1[5] | C2[5];\n\n    CLA_16bit CLA21(.A(A),.B(B),.S(S),.C(C1[6]),.C2(C2[6]));\n    assign C = C1[6] | C2[6];\n\n    CLA_16bit CLA22(.A(A),.B(B),.S(S),.C(C1[7]),.C2(C2[7]));\n    assign C = C1[7] | C2[7];\n\n    CLA_16bit CLA23(.A(A),.B(B),.S(S),.C(C1[8]),.C2(C2[8]));\n    assign C = C1[8] | C2[8];\nendmodule\n\nmodule CLA_16bit(A,B,S,C,C2);\n    input [15:1] A,B;\n    output [15:1] S;\n    output C,C2;\n\n    wire [4:1] C1[4:1];\n    wire [4:1] C22[4:1];\n\n    CLA_8bit CLA8(.A(A),.B(B),.S(S),.C(C1[1]),.C2(C22[1]));\n    assign C = C1[1] | C22[1];\n\n    CLA_8bit CLA9(.A(A),.B(B),.S(S),.C(C1[2]),.C2(C22[2]));\n    assign C = C1[2] | C22[2];\n\n    CLA_8bit CLA10(.A(A),.B(B),.S(S),.C(C1[3]),"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum_slice[0]),\n        .cout(carry[0])\n    );\n    ripple_carry_adder rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum_slice[1]),\n        .cout(carry[1])\n    );\n    ripple_carry_adder rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum_slice[2]),\n        .cout(carry[2])\n    );\n    ripple_carry_adder rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum_slice[3]),\n        .cout(carry[3])\n    );\n\n    // 4-bit carry select adder slices\n    carry_select_adder_4bit csa1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(carry[0]),\n        .sum(sum_slice[0]),\n        .cout(carry[0])\n    );\n    carry_select_adder_4bit csa2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[1]),\n        .sum(sum_slice[1]),\n        .cout(carry[1])\n    );\n    carry_select_adder_4bit csa3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[2]),\n        .sum(sum_slice[2]),\n        .cout(carry[2])\n    );\n    carry_select_adder_4bit csa4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[3]),\n        .sum(sum_slice[3]),\n        .cout(carry[3])\n    );\n\n    assign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n\n    assign cout = carry[3];\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] Co_0;\n    wire [7:0] Co_1;\n    wire [7:0] Co_2;\n\n    // Instantiate 8-bit adder for the first 8 bits.\n    add8_inst1 adder_0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .Co(Co_0),\n        .y(y[7:0])\n    );\n    // Instantiate 8-bit adder for the last 8 bits.\n    add8_inst2 adder_1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_0),\n        .Co(Co_1),\n        .y(y[15:8])\n    );\n    // Connect the 8-bit adders for the two 8-bit inputs.\n    assign Co = Co_2;\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] Co_xor;\n    wire [7:0] Co_and;\n\n    xor xor0 (\n        .a(a),\n        .b(b),\n        .y(Co_xor)\n    );\n    and and0 (\n        .a(Co_xor),\n        .b(Cin),\n        .y(Co_and)\n    );\n    or or0 (\n        .a(Co_and),\n        .b(a),\n        .y(y)\n    );\n    assign Co = Co_and[7];\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] Co_xor;\n    wire [7:0] Co_and;\n\n    xor xor0 (\n        .a(a),\n        .b(b),\n        .y(Co_xor)\n    );\n    and and0 (\n        .a(Co_xor),\n        .b(Cin),\n        .y(Co_and)\n    );\n    or or0 (\n        .a(Co_and),\n        .b(a),\n        .y(y)\n    );\n    assign Co = Co_and[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] carry;\n    adder FA0(a[0], b[0], cin, sum[0], carry[0]);\n    adder FA1(a[1], b[1], carry[0], sum[1], carry[1]);\n    adder FA2(a[2], b[2], carry[1], sum[2], carry[2]);\n    adder FA3(a[3], b[3], carry[2], sum[3], carry[3]);\n    adder FA4(a[4], b[4], carry[3], sum[4], carry[4]);\n    adder FA5(a[5], b[5], carry[4], sum[5], carry[5]);\n    adder FA6(a[6], b[6], carry[5], sum[6], carry[6]);\n    adder FA7(a[7], b[7], carry[6], sum[7], cout);\n    \nendmodule\n\nmodule adder(\n    input a, b, cin, \n    output sum, cout);\n    \n    assign {cout, sum} = a + b + cin;\n    \nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nwire [3:0] shift_cnt; // Shift counter for the multiplier.\nreg [15:0] a, b; // Registers for the multiplicand and multiplier.\nreg [31:0] p; // Register for the product.\n\n// Control Unit\ncontrol_unit ctrl_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .done(done)\n);\n\n// Register Unit\nreg_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .ain(ain),\n    .bin(bin),\n    .a(a),\n    .b(b)\n);\n\n// Multiplier Unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .a(a),\n    .b(b),\n    .p(p),\n    .shift_cnt(shift_cnt)\n);\n\n// Output Assignment\nassign yout = p;\n\nendmodule\n\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg done\n);\n\nreg [3:0] shift_cnt;\nreg [31:0] p;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_cnt <= 0;\n        done <= 0;\n    end else begin\n        if (start) begin\n            shift_cnt <= 4;\n            p <= 0;\n        end else if (shift_cnt > 0) begin\n            shift_cnt <= shift_cnt - 1;\n        end else begin\n            done <= 1;\n        end\n    end\nend\n\nendmodule\n\nmodule reg_unit (\n    input clk,\n    input rst_n,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] p,\n    input [3:0] shift_cnt\n);\n\nreg [31:0] p_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        p_reg <= 0;\n    end else begin\n        p_reg <= 0;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        p <= 0;\n    end else begin\n        if (shift_cnt > 0) begin\n            p <= p_reg;\n        end else begin\n            p <= p_reg;\n        end\n    end\nend\n\nalways @(*) begin\n    if (a[shift_cnt]) begin\n        p_reg <= p_reg + b;\n    end else begin\n        p_reg <= p_reg;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n    wire [15:0] current_count;\n\n    counter_logic u_counter_logic (\n        .current_count(current_count),\n        .next_count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .current_count(current_count),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    assign next_count = up_down ? current_count + 1 : current_count - 1;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n    wire [7:0] next_out;\n    wire [2:0] next_state;\n\n    // Submodule for initialization\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out),\n        .next_out(next_out),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] out,\n    output reg [7:0] next_out,\n    output reg [2:0] next_state\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_out <= 8'b0000_0001;\n            next_state <= 3'b001;\n        end else begin\n            if (out == 8'b1111_1111) begin\n                next_out <= 8'b0000_0001;\n                next_state <= 3'b001;\n            end else if (out == 8'b0000_0001) begin\n                next_out <= 8'b0000_0010;\n                next_state <= 3'b010;\n            end else if (out == 8'b0000_0010) begin\n                next_out <= 8'b0000_0100;\n                next_state <= 3'b100;\n            end else if (out == 8'b0000_0100) begin\n                next_out <= 8'b0000_1000;\n                next_state <= 3'b000;\n            end else if (out == 8'b0000_1000) begin\n                next_out <= 8'b0001_0000;\n                next_state <= 3'b100;\n            end else if (out == 8'b0001_0000) begin\n                next_out <= 8'b0010_0000;\n                next_state <= 3'b010;\n            end else if (out == 8'b0010_0000) begin\n                next_out <= 8'b0100_0000;\n                next_state <= 3'b001;\n            end else begin\n                next_out <= 8'b1111_1111;\n                next_state <= 3'b111;\n            end\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\nwire [3:0] count;\n\ncounter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count(count)\n);\n\noutput_register u_output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .out(count),\n    .output_out(out)\n);\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end else if (valid_count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] output_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        output_out <= 4'b0000;\n    end else if (valid_count) begin\n        output_out <= count;\n    end\nend\n\nendmodule\n\n```"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_Q;\n\nJC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(next_Q));\nJC_logic logic_inst(.clk(clk), .Q(Q), .next_Q(next_Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        Q <= 64'b0;\n    else\n        Q <= Q;\nend\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input [63:0]        Q,\n    input [63:0]        next_Q\n);\n\nalways @(posedge clk) begin\n    Q <= next_Q;\nend\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_in;\n\n    assign clk_in = CLK_in;\n\n    clk_div clk_div_2 (\n        .CLK_in(clk_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(clk_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    clk_div clk_div_100 (\n        .CLK_in(clk_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            cnt <= 0;\n        else if (cnt == 3'b111)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else if (cnt == 3'b111)\n            CLK_out <= ~CLK_out;\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n    parameter MUL2_DIV_CLK = 7;\n    \n    wire [3:0] clk_int;\n    assign clk_int = {2'b11, 1'b0}; // 3.5x division\n    \n    // Counter Submodule\n    reg [7:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == 2**(MUL2_DIV_CLK+1))\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n    \n    // Clock Average Generator Submodule\n    reg [1:0] clk_int_4;\n    reg [1:0] clk_int_3;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_int_4 <= 0;\n            clk_int_3 <= 0;\n        end else if (cnt == 2**(MUL2_DIV_CLK+1)-1) begin\n            clk_int_4 <= clk_int_4 + 1;\n            clk_int_3 <= clk_int_3 + 1;\n        end\n    end\n    \n    // Clock Adjustment Submodule\n    wire [1:0] clk_int_n;\n    assign clk_int_n[1:0] = clk_int_4 ^ clk_int_3;\n    \n    // Output\n    assign clk_div = clk_int_n[1] | clk_int_n[0];\n    \nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [7:0]  cnt\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == 2**8-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [1:0]         clk_int,\n    output reg          clk_avg\n);\n    reg [1:0] clk_avg_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_avg_reg <= 0;\n        else if (clk_int == 2'b11)\n            clk_avg_reg <= clk_int;\n        else\n            clk_avg_reg <= clk_avg_reg;\n    end\n    assign clk_avg = clk_avg_reg[1];\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [1:0]         clk_int_n,\n    output reg [1:0]    clk_int_p\n);\n    reg [1:0] clk_int_p_reg;\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_int_p_reg <= 0;\n        else\n            clk_int_p_reg <= clk_int_n;\n    end\n    assign clk_int_p = clk_int_p_reg;\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1, clk_div2;\n\npos_edge_counter u_pos_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end else if (count == NUM_DIV - 1) begin\n        count <= 0;\n        clk_div <= 1;\n    end else begin\n        count <= count + 1;\n        clk_div <= 0;\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end else if (count == NUM_DIV - 1) begin\n        count <= 0;\n        clk_div <= 1;\n    end else begin\n        count <= count + 1;\n        clk_div <= 0;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    reg [3:0] counter;\n    reg clk_div_reg;\n\n    assign clk_div = clk_div_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            counter <= 0;\n        else if (counter == NUM_DIV / 2 - 1)\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_reg <= 0;\n        else if (counter == NUM_DIV / 2 - 1)\n            clk_div_reg <= ~clk_div_reg;\n    end\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 0;\n        else\n            q <= q + 1;\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div,\n    output reg clk_div_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div_out <= 0;\n        else\n            clk_div_out <= clk_div;\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] r_add, r_addu, r_sub, r_subu, r_and, r_or, r_xor, r_nor;\n    wire [31:0] r_slt, r_sltu, r_sll, r_srl, r_sra, r_sllv, r_srlv, r_srav;\n    wire [31:0] r_lui;\n\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(r_add)\n    );\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(r_addu)\n    );\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(r_sub)\n    );\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(r_subu)\n    );\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(r_and)\n    );\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(r_or)\n    );\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(r_xor)\n    );\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(r_nor)\n    );\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(r_slt)\n    );\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(r_sltu)\n    );\n    sll sll_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(r_sll)\n    );\n    srl srl_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(r_srl)\n    );\n    sra sra_inst(\n        .a(a),\n        .b(b[4:0]),\n        .r(r_sra)\n    );\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(r_sllv)\n    );\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(r_srlv)\n    );\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(r_srav)\n    );\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(r_lui)\n    );\n\n    assign r = (aluc == 6'b000000) ? r_add :\n               (aluc == 6'b000001) ? r_addu :\n               (aluc == 6'b000010) ? r_sub :\n               (aluc == 6'b000011) ? r_subu :\n               (aluc == 6'b000100) ? r_and :\n               (aluc == 6'b000101) ? r_or :\n               (aluc == 6'b000110) ? r_xor :\n               (aluc == 6'b000111) ? r_nor :\n               (aluc == 6'b001010) ? r_slt :\n               (aluc == 6'b001011) ? r_sltu :\n               (aluc == 6'b000000) ? r_sll :\n               (aluc == 6'b000010) ? r_srl :\n               (aluc == 6'b000011) ? r_s"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n    wire [31:0] multiplier_result;\n    wire [31:0] accumulator_result;\n\n    // Multiplier Submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .product(multiplier_result)\n    );\n\n    // Accumulator Submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(accumulator_result),\n        .new_value(multiplier_result),\n        .output(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output reg [31:0] output\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            output <= 0;\n        else\n            output <= current_value + new_value;\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] op;\n    wire [4:0] ra, rb;\n    wire [7:0] d;\n\n    submodule ins_p1 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output [2:0] ins,\n        output [4:0] ra,\n        output [7:0] d\n    );\n        reg [7:0] instr;\n        always @(posedge clk or negedge rst) begin\n            if (!rst) instr <= 0;\n            else instr <= data;\n        end\n        assign ins = instr[7:5];\n        assign ra = instr[4:0];\n        assign d = instr[7:0];\n    endmodule\n\n    submodule ins_p2 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output [2:0] ins,\n        output [7:0] d\n    );\n        reg [7:0] instr;\n        always @(posedge clk or negedge rst) begin\n            if (!rst) instr <= 0;\n            else instr <= data;\n        end\n        assign ins = instr[7:5];\n        assign d = instr[7:0];\n    endmodule\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1.ins <= 0;\n            ins_p1.ra <= 0;\n            ins_p1.d <= 0;\n            ins_p2.ins <= 0;\n            ins_p2.d <= 0;\n        end else begin\n            if (fetch == 2'b01) ins_p1.d <= data;\n            else if (fetch == 2'b10) ins_p2.d <= data;\n        end\n    end\n\n    assign ins = fetch == 2'b01 ? ins_p1.ins : ins_p2.ins;\n    assign ad1 = fetch == 2'b01 ? ins_p1.ra : ins_p2.ra;\n    assign ad2 = fetch == 2'b01 ? ins_p1.d : ins_p2.d;\n\nendmodule\n\nmodule submodule (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ra,\n    output [7:0] d\n);\n    reg [7:0] instr;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) instr <= 0;\n        else instr <= data;\n    end\n    assign ins = instr[7:5];\n    assign ra = instr[4:0];\n    assign d = instr[7:0];\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n\n    counter counter_inst (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wave_generator_inst (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1)\n                count <= 0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count >= freq / 2);\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n                default: ;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output [1:0] state\n);\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                2'b00: state_reg <= 2'b01;\n                2'b01: state_reg <= 2'b10;\n                2'b10: state_reg <= 2'b00;\n                default: ;\n            endcase\n        end\n    end\n\n    assign state = state_reg;\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: ;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\nwire [2:0] s;\nwire [7:0] d_delayed;\n\nmy_dff8 u0 (\n    .clk(clk),\n    .d(d),\n    .q(d_delayed[0])\n);\n\nmy_dff8 u1 (\n    .clk(clk),\n    .d(d_delayed[0]),\n    .q(d_delayed[1])\n);\n\nmy_dff8 u2 (\n    .clk(clk),\n    .d(d_delayed[1]),\n    .q(d_delayed[2])\n);\n\nassign s = {3{sel[1]}} | {2{sel[0]}};\n\nalways @(posedge clk) begin\n    q <= d_delayed[s];\nend\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule mux4to1_8bit (\n    input [1:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output [7:0] q\n);\n\nassign q = sel[1] ? (sel[0] ? d3 : d2) : (sel[0] ? d1 : d0);\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] stage0, stage1, stage2, stage3, stage4, stage5, stage6, stage7;\n\n    // Stage 0\n    assign stage0 = {in[3:0], in[7:4]};\n    assign stage1 = (ctrl[2]) ? {stage0[1:0], stage0[3:2]} : stage0;\n    assign stage2 = (ctrl[1]) ? {stage1[1:0], stage1[3:2]} : stage1;\n    assign stage3 = (ctrl[0]) ? {stage2[1:0], stage2[3:2]} : stage2;\n\n    // Stage 1\n    assign stage4 = {stage3[2:0], stage3[7:4]};\n    assign stage5 = (ctrl[2]) ? {stage4[1:0], stage4[3:2]} : stage4;\n    assign stage6 = (ctrl[1]) ? {stage5[1:0], stage5[3:2]} : stage5;\n    assign stage7 = (ctrl[0]) ? {stage6[1:0], stage6[3:2]} : stage6;\n\n    assign out = stage7;\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input sel;\n    input in0, in1;\n    output out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [31:0] pe0_out, pe1_out;\n\n  // First PE\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  // Second PE\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(pe1_out),\n    .out(pe1_out)\n  );\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] out\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 0;\n    else\n      out <= a * b + out;\n  end\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  wire [31:0] fetch_out;\n  wire [31:0] decode_out;\n  wire [31:0] execute_out;\n  wire [31:0] memory_out;\n  wire [31:0] writeback_out;\n  wire [31:0] pc_out;\n\n  wire [31:0] reg_file_read_out [0:31];\n  wire [31:0] pc_read_out;\n\n  stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc_out(pc_read_out)\n  );\n\n  assign pc_read_out = pc_out + 4;\n\n  stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_in(fetch_out),\n    .reg_file_read_out(reg_file_read_out),\n    .decode_out(decode_out)\n  );\n\n  stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_in(decode_out),\n    .execute_out(execute_out)\n  );\n\n  stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_in(execute_out),\n    .memory_out(memory_out)\n  );\n\n  stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_in(memory_out),\n    .reg_file_read_out(reg_file_read_out),\n    .writeback_out(writeback_out),\n    .res_reg_file(res_reg_file)\n  );\n\n  assign res_reg_file = writeback_out;\n  assign pc_out = pc_read_out;\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc_in,\n  output [31:0] pc_out,\n  output [31:0] instr_out\n);\n\n  assign instr_out = instr_mem[pc_in];\n  assign pc_out = pc_in + 4;\n\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  wire [31:0] p0, p1, p2, p3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n  \n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n  \n  assign p0 = {b0, 16'b0} * a0;\n  assign p1 = {b1, 16'b0} * a1;\n  assign p2 = {b2, 16'b0} * a2;\n  assign p3 = {b3, 16'b0} * a3;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 16'b0;\n      b1_reg <= 16'b0;\n      b2_reg <= 16'b0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1;\n      b2_reg <= b2;\n    end\n  end\n  \n  assign c0 = p0;\n  assign c1 = p1;\n  assign c2 = p2;\n  assign c3 = p3;\n  \nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] p\n);\n  reg [15:0] a_reg, b_reg;\n  \n  assign p = {b_reg, 16'b0} * a_reg;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      a_reg <= 16'b0;\n      b_reg <= 16'b0;\n    end else begin\n      a_reg <= a;\n      b_reg <= b;\n    end\n  end\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\n    wire [31:0] fetch_instr;\n    wire [31:0] execute_result;\n    wire [4:0] rd;\n    wire [31:0] operand_a;\n    wire [31:0] operand_b;\n    wire [1:0] opcode;\n\n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetch_instr(fetch_instr)\n    );\n\n    execute_stage execute(\n        .clk(clk),\n        .rst(rst),\n        .instr(fetch_instr),\n        .reg_file(reg_file),\n        .execute_result(execute_result),\n        .rd(rd)\n    );\n\n    writeback_stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .execute_result(execute_result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetch_instr\n);\n    assign fetch_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] execute_result,\n    output [4:0] rd\n);\n    wire [31:0] operand_a;\n    wire [31:0] operand_b;\n    wire [1:0] opcode;\n\n    assign opcode = instr[31:30];\n    assign rd = instr[24:20];\n    assign operand_a = instr[15:0];\n    assign operand_b = instr[25:0];\n\n    always @(*) begin\n        case (opcode)\n            2'b01: execute_result = operand_a + operand_b;\n            2'b10: execute_result = operand_a - operand_b;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] execute_result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    wire [4:0] rd;\n    wire [31:0] rd_value;\n\n    assign rd = execute_result[24:20];\n    assign rd_value = execute_result;\n\n    always @(*) begin\n        out_reg_file = reg_file[rd];\n        out_reg_file = rd_value;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire [1:0] cnt;\nwire [9:0] sum;\n\n// Counter Module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .cnt_out(cnt)\n);\n\n// Data Accumulator Module\ndata_accumulator u_data_accumulator (\n    .clk(clk),\n    .rst_n(rst_n),\n    .data_in(data_in),\n    .sum_out(sum)\n);\n\n// Valid Output Module\nvalid_output u_valid_output (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cnt_in(cnt),\n    .valid_out(valid_out)\n);\n\n// Connect the outputs of counter, data accumulator, and valid output\nassign data_out = sum;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg  [1:0]   cnt\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt <= 0;\n    else if (valid_in)\n        cnt <= cnt + 1;\nend\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n\n    output reg  [9:0]   sum\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        sum <= 0;\n    else\n        sum <= sum + data_in;\nend\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [1:0]   cnt,\n\n    output reg          valid_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out <= 0;\n    else if (cnt == 2)\n        valid_out <= 1;\n    else if (cnt == 3)\n        valid_out <= 0;\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n\n    // Absolute Value Calculation\n    abs_value abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .in_value(dividend),\n        .out_value(abs_dividend)\n    );\n\n    // Negate Divisor\n    neg_value neg_divisor_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .in_value(divisor),\n        .out_value(neg_divisor)\n    );\n\n    // Divider Control Logic\n    divider_control ctrl_inst(\n        .clk(clk),\n        .rst(rst),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg)\n    );\n\n    // Result Management\n    result_management res_mgmt_inst(\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .valid(opn_valid),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\n    // Registers for the division process\n    reg [7:0] shift_reg;\n    reg [2:0] counter;\n\n    // Output values\n    assign quotient = shift_reg[7:0];\n    assign remainder = shift_reg[15:8];\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] in_value,\n    output reg [7:0] out_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_value <= 0;\n        else if (sign)\n            out_value <= -in_value;\n        else\n            out_value <= in_value;\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] in_value,\n    output reg [7:0] out_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_value <= 0;\n        else if (sign)\n            out_value <= in_value;\n        else\n            out_value <= -in_value;\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire valid,   \n    output reg [2:0] counter,   \n    output reg [15:0] shift_reg\n);\n\n    reg [7:0] temp_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n        end else begin\n            if (valid) begin\n                counter <= 3;\n                shift_reg <= {dividend, 8'b0};\n                temp_reg <= divisor;\n            end else if (counter != 0) begin\n                counter <= counter - 1;\n                temp_reg <= temp_reg << 1;\n                if (shift_reg[0] == 1)\n                    shift_reg <= shift_reg + temp_reg;\n            end\n        end\n    end\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [2:0] counter,\n    input wire valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    always @(posedge cl"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Submodule for preparing the dividend and divisor\n    prep_dividend prep(\n        .dividend(A),\n        .divisor(B),\n        .result_prep(result),\n        .remainder_prep(odd)\n    );\n\n    // Submodule for performing division\n    div_operation div(\n        .dividend(result),\n        .divisor(B),\n        .quotient(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] result_prep,\n    output wire [31:0] remainder_prep\n);\n    assign result_prep = {dividend[15:0], 16'b0}; // Prepare 32-bit dividend\n    assign remainder_prep = {divisor[15:0], 16'b0}; // Prepare 32-bit divisor\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output wire [31:0] quotient,\n    output wire [31:0] remainder\n);\n    assign quotient = dividend >> divisor; // Perform division\n    assign remainder = dividend % divisor; // Compute remainder\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [7:0] divisor;\n    wire [7:0] rem;\n    wire [3:0] i;\n\n    assign temp = A;\n    assign divisor = B;\n    assign rem = 0;\n\n    for (i = 0; i < 16; i = i + 1) begin\n        if (temp[15:8] >= divisor) begin\n            temp = temp - divisor;\n            result[15:8] = i;\n            rem[15:8] = temp[15:8];\n        end\n        temp = {temp[14:0], 1'b0};\n    end\n\n    for (i = 0; i < 8; i = i + 1) begin\n        if (temp[7:0] >= divisor) begin\n            temp = temp - divisor;\n            result[7:0] = i;\n            rem[7:0] = temp[7:0];\n        end\n        temp = {temp[6:0], 1'b0};\n    end\n\n    assign odd = rem;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] i,\n    output reg [15:0] temp,\n    output reg [7:0] rem,\n    output reg [15:0] result,\n    output reg [7:0] shift_div\n);\n\n    always @(*) begin\n        temp = dividend;\n        shift_div = divisor;\n        rem = 0;\n        i = 0;\n\n        while (temp >= divisor) begin\n            temp = temp - divisor;\n            result[15:8] = i;\n            rem[15:8] = temp[15:8];\n            i = i + 1;\n            temp = {temp[14:0], 1'b0};\n        end\n\n        while (temp >= divisor) begin\n            temp = temp - divisor;\n            result[7:0] = i;\n            rem[7:0] = temp[7:0];\n            i = i + 1;\n            temp = {temp[6:0], 1'b0};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_not = ~B;\n    wire [7:0] sum;\n    wire carry_in;\n    wire borrow_out;\n\n    adder_8bit adder_inst(.A(A), .B(B_not), .C(1'b0), .D(D), .C_out(carry_in), .B_out(borrow_out));\n    assign B_out = ~borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, C, D, C_out, B_out);\n    input [7:0] A, B;\n    input C;\n    output [7:0] D;\n    output C_out, B_out;\n\n    wire [7:0] carry;\n\n    full_adder FA0 (.A(A[0]), .B(B[0]), .C(C), .S(D[0]), .C_out(carry[0]));\n    full_adder FA1 (.A(A[1]), .B(B[1]), .C(carry[0]), .S(D[1]), .C_out(carry[1]));\n    full_adder FA2 (.A(A[2]), .B(B[2]), .C(carry[1]), .S(D[2]), .C_out(carry[2]));\n    full_adder FA3 (.A(A[3]), .B(B[3]), .C(carry[2]), .S(D[3]), .C_out(carry[3]));\n    full_adder FA4 (.A(A[4]), .B(B[4]), .C(carry[3]), .S(D[4]), .C_out(carry[4]));\n    full_adder FA5 (.A(A[5]), .B(B[5]), .C(carry[4]), .S(D[5]), .C_out(carry[5]));\n    full_adder FA6 (.A(A[6]), .B(B[6]), .C(carry[5]), .S(D[6]), .C_out(carry[6]));\n    full_adder FA7 (.A(A[7]), .B(B[7]), .C(carry[6]), .S(D[7]), .C_out(C_out));\n\n    assign B_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C, S, C_out);\n    input A, B, C;\n    output S, C_out;\n\n    assign S = A ^ B ^ C;\n    assign C_out = (A & B) | (C & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire B1, B2;\n\n    // Instantiating 16-bit subtractor blocks\n    sub_16bit S1_inst(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1),\n        .B_out(B1)\n    );\n    sub_16bit S2_inst(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2),\n        .B_out(B2)\n    );\n\n    assign Diff = {S2, S1};\n    assign B_out = B1 | B2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S0, S1;\n    wire C_out;\n\n    // Instantiating 8-bit subtractor blocks\n    sub_8bit S0_inst(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S0),\n        .B_out(C_out)\n    );\n    sub_8bit S1_inst(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S1),\n        .B_out(C_out)\n    );\n\n    assign Diff = {S1, S0};\n    assign B_out = C_out;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S0, S1, S2, S3;\n    wire C_out;\n\n    // Instantiating 4-bit subtractor blocks\n    sub_4bit S0_inst(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S0),\n        .B_out(C_out)\n    );\n    sub_4bit S1_inst(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S1),\n        .B_out(C_out)\n    );\n    sub_4bit S2_inst(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Diff(S2),\n        .B_out(C_out)\n    );\n    sub_4bit S3_inst(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Diff(S3),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S3, S2, S1, S0};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S0, S1, S2;\n    wire C_out;\n\n    // Instantiating 2-bit subtractor blocks\n    sub_2bit S0_inst(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S0),\n        .B_out(C_out)\n    );\n    sub_2bit S1_inst(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S1),\n        .B_out(C_out)\n    );\n    sub_2bit S2_inst(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n    wire [31:0] B_lower, B_upper;\n    wire [15:0] B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper;\n    wire [7:0] B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper,\n               B_upper_lower_lower, B_upper_lower_upper, B_upper_upper_lower, B_upper_upper_upper;\n    wire [31:0] B_lower_lower_D, B_lower_upper_D, B_upper_lower_D, B_upper_upper_D;\n\n    sub_32_bit sub0(A[63:32], B[63:32], D[63:32], B_upper);\n    sub_32_bit sub1(A[31:0], B[31:0], D[31:0], B_lower);\n\n    sub_16_bit sub00(B_lower, B_upper, B_lower_lower, B_lower_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D, B_lower_upper_D);\n    sub_16_bit sub01(B_lower, B_upper, B_lower_lower, B_lower_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D, B_lower_upper_D);\n    sub_16_bit sub10(B_lower, B_upper, B_lower_lower, B_lower_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D, B_lower_upper_D);\n    sub_16_bit sub11(B_lower, B_upper, B_lower_lower, B_lower_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D, B_lower_upper_D);\n\n    sub_8_bit sub000(B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D[7:0], B_lower_upper_D[7:0]);\n    sub_8_bit sub001(B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D[15:8], B_lower_upper_D[15:8]);\n    sub_8_bit sub010(B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D[23:16], B_lower_upper_D[23:16]);\n    sub_8_bit sub011(B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper, B_lower_lower_lower, B_lower_lower_upper, B_lower_upper_lower, B_lower_upper_upper, B_lower_lower_D[31:24], B_lower_upper_D[31:24]);\n    sub_8_bit sub100(B_lower_lower, B_lower_upper, B_upper_lower, B_upper_upper, B_lower_lower_lower, B_lower_lower_upper,"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] B_out_bls;\n\n// Implement 4-bit full subtractor\nwire [3:0] A_bls[0:3];\nwire [3:0] B_bls[0:3];\nwire [3:0] D_bls[0:3];\n\ngenvar i;\ngenerate\n    for (i = 0; i < 4; i = i + 1) begin : full_subtractor\n        assign A_bls[i] = A[i*4 +: 4];\n        assign B_bls[i] = B[i*4 +: 4];\n        assign D_bls[i] = A_bls[i] - B_bls[i] - (i == 0 ? 1'b0 : B_out_bls[i-1]);\n        assign B_out_bls[i] = (D_bls[i] == 4'b0000) ? 1'b0 : 1'b1;\n    end\nendgenerate\n\n// Combine outputs of 4 full subtractors to get 16-bit difference\nassign D = {D_bls[3], D_bls[2], D_bls[1], D_bls[0]};\nassign B_out = B_out_bls[3];\n\nendmodule\n\n// Subtractor module\nmodule subtractor_4bit(A, B, B_out, D);\ninput [3:0] A;\ninput [3:0] B;\noutput B_out;\noutput [3:0] D;\n\nwire [3:0] A_minus_B;\nwire [3:0] D_minus_B;\n\nassign A_minus_B = A - B;\nassign D_minus_B = A_minus_B - (A_minus_B[3] ? 1'b1 : 1'b0);\nassign B_out = (D_minus_B == 4'b0000) ? 1'b0 : 1'b1;\nassign D = D_minus_B;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] subtraction_result;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .subtraction_result(subtraction_result),\n        .borrow(borrow)\n    );\n\n    assign A_greater = borrow;\n    assign A_equal = (~|subtraction_result);\n    assign A_less = ~borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] subtraction_result,\n    output borrow\n);\n    wire [31:0] temp;\n    wire [31:0] borrow_in;\n\n    assign borrow_in = ~(A[0] & B[0]);\n\n    genvar i;\n    generate\n        for (i = 0; i < 32; i = i + 1) begin: bit_level_comparison\n            assign subtraction_result[i] = A[i] ^ B[i] ^ borrow_in[i];\n            assign borrow[i] = (~(A[i] & B[i]) & (A[i] ^ B[i]));\n        end\n    endgenerate\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:0] C15[3:0];\nwire C16,C17,C18,C19;\n\n\nCLA1 CLA1(A[15:0],B[15:0],C15[0],C16);\nCLA1 CLA2(A[15:0],B[15:0],C15[1],C17);\nCLA1 CLA3(A[15:0],B[15:0],C15[2],C18);\nCLA1 CLA4(A[15:0],B[15:0],C15[3],C19);\n\nassign S[15:0] = A[15:0]^B[15:0];\nassign S[16] = C16;\nassign S[17] = C17;\nassign S[18] = C18;\nassign S[19] = C19;\nassign C32 = C16^C17^C18^C19;\n\nendmodule\n\n\nmodule CLA1(A,B,C15,C16);\ninput [15:0] A,B;\noutput [15:0] C15;\noutput C16;\n\nwire [15:0] C14;\nwire C13,C12;\n\n\nCLA1 CLA1(A,B,C14,C13);\nCLA1 CLA2(A,B,C14,C12);\n\nassign C15 = A^B^C14;\nassign C16 = C13^C12;\n\nendmodule\n\n\nmodule CLA1(A,B,C15,C16);\ninput [15:0] A,B;\noutput [15:0] C15;\noutput C16;\n\nwire C13,C12;\n\nassign C15 = A^B;\nassign C16 = A&B;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] sum_slices[3:0];\n    wire [3:0] cout_slices[3:0];\n    wire [3:0] carry;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder_4bit rca1(a[3:0], b[3:0], cin, sum_slices[0], cout_slices[0]);\n    ripple_carry_adder_4bit rca2(a[7:4], b[7:4], cout_slices[0], sum_slices[1], cout_slices[1]);\n    ripple_carry_adder_4bit rca3(a[11:8], b[11:8], cout_slices[1], sum_slices[2], cout_slices[2]);\n    ripple_carry_adder_4bit rca4(a[15:12], b[15:12], cout_slices[2], sum, cout);\n\n    // 4-bit carry select adder slices\n    carry_select_adder_4bit csa_slice1(sum_slices[0], cout_slices[0], cin, sum_slices[1]);\n    carry_select_adder_4bit csa_slice2(sum_slices[1], cout_slices[1], cin, sum_slices[2]);\n    carry_select_adder_4bit csa_slice3(sum_slices[2], cout_slices[2], cin, sum_slices[3]);\n\n    // Multiplexers to select between sum and carry\n    assign sum = {sum_slices[3][3:0], sum_slices[2][3:0], sum_slices[1][3:0], sum_slices[0][3:0]};\n    assign carry = {cout_slices[3][3:0], cout_slices[2][3:0], cout_slices[1][3:0], cout_slices[0][3:0]};\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n\n    assign cout = carry[3];\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(sum_slice, cout_slice, cin, sum);\n    input [3:0] sum_slice;\n    input [3:0] cout_slice;\n    input cin;\n    output [3:0] sum;\n    assign {cout_slice[0], sum_slice[0]} = {cout_slice[0], sum_slice[0]} + {1'b0, cin};\n    assign {cout_slice[1], sum_slice[1]} = {cout_slice[1], sum_slice[1]} + {cout_slice[0], cin};\n    assign {cout_slice[2], sum_slice[2]} = {cout_slice[2], sum_slice"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n\n    add8_inst1 add8_1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n\n    add8_inst2 add8_2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\n    add8_inst3 add8_3 (\n        .a(y[7:0]),\n        .b(y[15:8]),\n        .Cin(carry[1]),\n        .y(y),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n\n    assign {Co, sum} = a + b + Cin;\n\n    assign y = sum;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n\n    assign {Co, sum} = a + b + Cin;\n\n    assign y = sum;\nendmodule\n\nmodule add8_inst3 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n\n    assign {Co, sum} = a + b + Cin;\n\n    assign y = sum;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [6:0] s0, s1, s2, s3, s4, s5, s6;\n    wire c0, c1, c2, c3, c4, c5, c6;\n    wire c7, c8, c9, c10, c11, c12, c13, c14;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(s0), .cout(c0));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(s1), .cout(c1));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(s2), .cout(c2));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(s3), .cout(c3));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c3), .sum(s4), .cout(c4));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c4), .sum(s5), .cout(c5));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c5), .sum(s6), .cout(c6));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c6), .sum(sum[7:0]), .cout(cout));\n    \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\nwire [3:0] sc_reg;\nwire [31:0] product_reg;\nwire [3:0] product_bit;\n\n// Control Unit\ncontrol_unit ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .sc(sc_reg)\n);\n\n// Register Unit\nreg_unit reg_unit (\n    .clk(clk),\n    .rst_n(rst_n),\n    .start(start),\n    .ain(ain),\n    .bin(bin),\n    .sc(sc_reg),\n    .product_reg(product_reg)\n);\n\n// Multiplier Unit\nmultiplier_unit mul_unit (\n    .clk(clk),\n    .ain(ain),\n    .bin(bin),\n    .sc(sc_reg),\n    .product_bit(product_bit)\n);\n\n// Output Assignment\nassign yout = product_reg;\nassign done = start ? 1'b0 : product_bit[0];\n\nendmodule\n\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output [3:0] sc     // Shift count output.\n);\n\nreg [3:0] sc_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        sc_reg <= 4'b0;\n    else if (start)\n        sc_reg <= 4'b0;\n    else\n        sc_reg <= sc_reg + 1;\nend\n\nassign sc = sc_reg;\n\nendmodule\n\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [3:0] sc,     // Shift count input.\n    output [31:0] product_reg, // Output product register.\n    output [3:0] product_bit    // Output product bit.\n);\n\nreg [31:0] product;\nreg [3:0] sc_reg;\nreg [3:0] product_bit_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        begin\n            product <= 32'b0;\n            sc_reg <= 4'b0;\n            product_bit_reg <= 4'b0;\n        end\n    else if (start)\n        begin\n            product <= 32'b0;\n            sc_reg <= 4'b0;\n            product_bit_reg <= 4'b0;\n        end\n    else\n        begin\n            sc_reg <= sc;\n            product <= {product[30:0], 1'b0};\n            if (sc == 4'b1111)\n                begin\n                    product_reg <= product;\n                    product_bit_reg <= 4'b1;\n                end\n        end\nend\n\nassign product_reg = product;\nassign product_bit = product_bit_reg;\n\nendmodule\n\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [3:0] sc,     // Shift count input.\n    output [3:0] product_bit    // Output product bit.\n);\n\nwire [31:0] product;\nwire [3:0] product_bit_reg;\nwire [3:0] shift_reg;\n\nassign shift_reg = {ain[31:0] >> sc[0], ain[31:0"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\nwire [15:0] current_count;\n\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .current_count(current_count),\n    .next_count(next_count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .current_count(current_count),\n    .next_count(next_count),\n    .count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        next_count <= 16'b0;\n    end else begin\n        if (up_down) begin\n            next_count <= current_count + 1;\n        end else begin\n            next_count <= current_count - 1;\n        end\n    end\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    submodule init = init_submodule(out);\n    submodule transition = transition_submodule(clk, reset, out);\n\nendmodule\n\nmodule init_submodule (\n    output reg [7:0] out\n);\n    always @ (0) begin\n        out = 8'b0000_0001;\n    end\nendmodule\n\nmodule transition_submodule (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] cnt_out;\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .cnt_out(cnt_out)\n    );\n\n    // Instantiate output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(cnt_out),\n        .out_reg(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] cnt_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (cnt_out == 4'd11) begin\n                cnt_out <= 4'b0000;\n            end else begin\n                cnt_out <= cnt_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] out,\n    output reg [3:0] out_reg\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!valid_count) begin\n            out_reg <= out;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_Q;\n\n    JC_register reg_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    JC_logic logic_inst(\n        .Q(Q),\n        .next_Q(next_Q)\n    );\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n        else\n            Q <= Q + 64'b1;\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0]         Q,\n    input [63:0]         next_Q,\n    output reg [63:0]    Q_out\n);\n    always @(*) begin\n        Q_out = Q[0] ? next_Q : {1'b0, Q[63:1]};\n    end\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire clk_in_p;\n\nassign clk_in_p = CLK_in & ~RST;\n\nclk_div clk_div_50 (\n    .clk_in(clk_in_p),\n    .clk_out(CLK_50)\n);\n\nclk_div clk_div_10 (\n    .clk_in(clk_in_p),\n    .clk_out(CLK_10)\n);\n\nclk_div clk_div_1 (\n    .clk_in(clk_in_p),\n    .clk_out(CLK_1)\n);\n\nendmodule\n\nmodule clk_div (\n    input clk_in,\n    output reg clk_out\n);\n\nalways @(posedge clk_in)\n    clk_out <= ~clk_out;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_tmp;\nwire clk_div_tmp_2;\n\n// Counter Submodule\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_tmp)\n);\n\n// Clock Average Generator Submodule\nclk_average u_clk_average(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_avg(clk_div_tmp_2)\n);\n\n// Clock Adjustment Submodule\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_adjusted(clk_div_tmp)\n);\n\n// Fractional Clock Output\nassign clk_div = clk_div_tmp | clk_div_tmp_2;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        count <= 0;\n    end else begin\n        count <= count + 1'b1;\n    end\nend\n\nassign clk_div = (count == MUL2_DIV_CLK);\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    output              clk_div_avg\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg [MUL2_DIV_CLK:0] count;\nreg clk_div_avg_i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        count <= 0;\n        clk_div_avg_i <= 0;\n    end else begin\n        count <= count + 1'b1;\n        if(count == MUL2_DIV_CLK) begin\n            count <= 0;\n            clk_div_avg_i <= ~clk_div_avg_i;\n        end\n    end\nend\n\nassign clk_div_avg = clk_div_avg_i;\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_div_adjusted,\n    output              clk_div_adjusted_2\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nreg clk_div_adjusted_2_i;\n\nalways @(negedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        clk_div_adjusted_2_i <= 0;\n    end else begin\n        clk_div_adjusted_2_i <= clk_div_adjusted_2_i ^ clk_div_adjusted;\n    end\nend\n\nassign clk_div_adjusted_2 = clk_div_adjusted_2_i;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n\n    wire pos_clk, neg_clk;\n    wire [NUM_DIV - 1:0] pos_counter, neg_counter;\n    wire [NUM_DIV - 2:0] pos_clk_div, neg_clk_div;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(pos_counter)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(neg_counter)\n    );\n\n    assign pos_clk = pos_counter[NUM_DIV - 1];\n    assign neg_clk = neg_counter[NUM_DIV - 2];\n\n    assign pos_clk_div = pos_counter[NUM_DIV - 2:0];\n    assign neg_clk_div = neg_counter[NUM_DIV - 2:0];\n\n    assign clk_div = pos_clk | neg_clk;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV):0] counter_out\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter_out <= 0;\n        end else begin\n            counter_out <= counter_out + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV):0] counter_out\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            counter_out <= 0;\n        end else begin\n            counter_out <= counter_out + 1;\n        end\n    end\nendmodule\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n\n    wire [3:0] counter;\n\n    reg [3:0] q_counter;\n    reg [3:0] d_counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q_counter <= 0;\n        end else begin\n            q_counter <= d_counter;\n        end\n    end\n\n    assign counter = q_counter;\n\n    assign clk_div = (counter == (NUM_DIV / 2 - 1));\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            d_counter <= 0;\n        end else if (counter == (NUM_DIV / 2 - 1)) begin\n            d_counter <= 0;\n        end else begin\n            d_counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n    reg [3:0] q_next;\n    reg [3:0] d;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q_next <= 0;\n        end else begin\n            q_next <= q + 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 0;\n        end else if (q_next == (NUM_DIV / 2 - 1)) begin\n            q <= 0;\n        end else begin\n            q <= q_next;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (counter == (NUM_DIV / 2 - 1)) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, sub_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r, sll_r, srl_r, sra_r, sllv_r, srlv_r, srav_r, lui_r;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .carry(add_carry),\n        .zero(add_zero),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_r),\n        .carry(add_carry),\n        .zero(add_zero),\n        .overflow(add_overflow),\n        .flag(add_flag)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_r),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .overflow(sub_overflow),\n        .flag(sub_flag)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_r),\n        .carry(and_carry),\n        .zero(and_zero),\n        .overflow(and_overflow),\n        .flag(and_flag)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_r),\n        .carry(or_carry),\n        .zero(or_zero),\n        .overflow(or_overflow),\n        .flag(or_flag)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_r),\n        .carry(xor_carry),\n        .zero(xor_zero),\n        .overflow(xor_overflow),\n        .flag(xor_flag)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_r),\n        .carry(nor_carry),\n        .zero(nor_zero),\n        .overflow(nor_overflow),\n        .flag(nor_flag)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_r),\n"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [63:0] result;\nwire [31:0] current_value;\n\n// Instantiate the multiplier and accumulator\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .result(result)\n);\naccumulator u_accumulator(\n    .current_value(current_value),\n    .result(result)\n);\n\n// Connect the multiplier and accumulator outputs\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input [31:0] current_value,\n    input [63:0] result,\n    output [31:0] out\n);\n    reg [31:0] current_value_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value_reg <= 0;\n        else\n            current_value_reg <= current_value_reg + result[31:0];\n    end\n\n    assign out = current_value_reg;\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n    wire [7:0] ad1_p1;\n    wire [7:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad(ad1_p1)\n    );\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad(ad1_p2)\n    );\n\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n    assign ins = (fetch == 2'b01) ? ins1[7:5] : ins2[7:5];\n\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad <= 0;\n        end else begin\n            ins <= data;\n            ad <= data[4:0];\n        end\n    end\nendmodule\n\n```\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    \n    // Counter Module\n    counter counter_inst(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n    \n    // Wave Generator Module\n    wave_generator wave_generator_inst(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n    \nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output [7:0] count\n);\n    reg [7:0] cnt_reg;\n    \n    always @(posedge clk)\n    begin\n        if (enable == 1'b1)\n        begin\n            if (cnt_reg == freq - 1)\n                cnt_reg <= 0;\n            else\n                cnt_reg <= cnt_reg + 1;\n        end\n    end\n    \n    assign count = cnt_reg;\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output wave_out\n);\n    reg wave_reg;\n    \n    always @(posedge clk)\n    begin\n        if (count == freq - 1)\n            wave_reg <= 0;\n        else\n            wave_reg <= 1;\n    end\n    \n    assign wave_out = wave_reg;\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n\n    wire state;\n    wire [1:0] state_next;\n    wire [4:0] wave_next;\n\n    // State Control Module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state_curr(state),\n        .state_next(state_next)\n    );\n\n    // Waveform Generation Module\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave_curr(wave),\n        .wave_next(wave_next)\n    );\n\n    assign wave = wave_next;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    input state_curr,\n    output reg [1:0] state_next\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_next <= 2'b00;\n        end else begin\n            case (state_curr)\n                2'b00: state_next <= 2'b01;\n                2'b01: state_next <= 2'b00;\n                default: state_next <= state_curr;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input state,\n    input [4:0] wave_curr,\n    output reg [4:0] wave_next\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_next <= 5'b00000;\n        end else begin\n            case (state)\n                1'b0: wave_next <= wave_curr + 1;\n                1'b1: wave_next <= wave_curr - 1;\n                default: wave_next <= wave_curr;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] q0, q1, q2;\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n    always @(posedge clk)\n        case (sel)\n            2'b00: q <= q0;\n            2'b01: q <= q1;\n            2'b10: q <= q2;\n            2'b11: q <= d;\n        endcase\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk)\n        q <= d;\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out, stage2_out, stage3_out;\n    wire sel1, sel2, sel3;\n\n    mux2X1 mux1 (in[0], in[1], ctrl[0], sel1);\n    mux2X1 mux2 (in[2], in[3], ctrl[1], sel2);\n    mux2X1 mux3 (in[4], in[5], ctrl[2], sel3);\n\n    assign stage1_out = sel1 ? {stage3_out[6:4], in[3:0]} : in;\n    assign stage2_out = sel2 ? {stage1_out[5:3], stage3_out[3:1]} : stage1_out;\n    assign stage3_out = sel3 ? {stage2_out[4:2], stage1_out[1:0]} : stage2_out;\n\n    assign out = stage3_out;\nendmodule\n\nmodule mux2X1 (a, b, sel, y);\n    input a, b, sel;\n    output y;\n    assign y = sel ? b : a;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n\n  // PE0\n  wire [31:0] pe0_out;\n  assign pe0_out = a0 * b0;\n\n  // PE1\n  wire [31:0] pe1_out;\n  assign pe1_out = a1 * b1;\n\n  // Update b1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n\n  reg [15:0] b_reg;\n\n  assign out = a * b_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b_reg <= 0;\n    else\n      b_reg <= b;\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  wire [31:0] next_instr;\n  wire [31:0] alu_res;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  wire [31:0] pc;\n  reg [31:0] next_pc;\n\n  fetch_stage fetch_stage_inst(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_instr(next_instr)\n  );\n\n  decode_stage decode_stage_inst(\n    .clk(clk),\n    .rst(rst),\n    .instr(next_instr),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op)\n  );\n\n  execute_stage execute_stage_inst(\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[rs1]),\n    .rs2(reg_file[rs2]),\n    .op(op),\n    .alu_res(alu_res)\n  );\n\n  memory_stage memory_stage_inst(\n    .clk(clk),\n    .rst(rst),\n    .alu_res(alu_res),\n    .res_reg_file(res_reg_file)\n  );\n\n  writeback_stage writeback_stage_inst(\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .res_reg_file(res_reg_file)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      next_pc <= 0;\n    else\n      next_pc <= pc + 1;\n  end\n\n  assign pc = next_pc;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] next_instr\n);\n  reg [31:0] next_instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      next_instr_reg <= 0;\n    else\n      next_instr_reg <= instr_mem[pc];\n  end\n\n  assign next_instr = next_instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {rs2, rs1, rd, op} = instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_res_reg <= 0;\n    else if (op == 6'b000000)\n      alu_res_reg <= rs1 + rs2;\n    else if (op == 6'b000100)\n      alu_res_reg <= rs1 - rs2;\n    else\n      alu_res_reg <= 0;\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  wire [15:0] c1_next, c2_next, c3_next;\n\n  reg [31:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  assign c0 = a0 * b0;\n  assign c1_next = a1 * b1;\n  assign c2_next = a2 * b2;\n  assign c3_next = a3 * b3;\n\n  always @(posedge clk)\n  begin\n    c1_reg <= c1_next;\n    c2_reg <= c2_next;\n    c3_reg <= c3_next;\n  end\n\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] c_reg;\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetched_instr, op1, op2, result;\n    wire [4:0] dest;\n    \n    // Instance of fetch_stage\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr),\n        .dest(dest)\n    );\n    \n    // Instance of execute_stage\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result)\n    );\n    \n    // Instance of writeback_stage\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .dest(dest),\n        .out_reg_file(out_reg_file)\n    );\n    \n    // Instance of pipeline registers\n    reg [31:0] pc;\n    \nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetched_instr,\n    output [4:0] dest\n);\n    // Fetch instruction from instruction memory\n    assign fetched_instr = instr_mem[pc];\n    \n    // Destination register is specified in the instruction\n    assign dest = fetched_instr[15:11];\n    \nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n    // Decode instruction\n    wire [5:0] opcode = instr[31:26];\n    wire [4:0] dest = instr[15:11];\n    \n    // Read operands from register file\n    assign op1 = instr[31:26] == 6'b000000 ? 32'b0 : reg_file[instr[25:21]];\n    assign op2 = instr[31:26] == 6'b000000 ? 32'b0 : reg_file[instr[20:16]];\n    \n    // Calculate result\n    assign result = opcode == 6'b000000 ? op1 + op2 : op1 - op2;\n    \nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] dest,\n    output [31:0] out_reg_file\n);\n    // Write result back to register file\n    assign out_reg_file = result;\n    \nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire               valid_out_i;\n    wire       [9:0]   data_out_i;\n\n    counter u_counter (.clk(clk), .rst_n(rst_n), .valid_in(valid_in), .valid_out(valid_out_i));\n\n    data_accumulator u_data_accumulator (.clk(clk), .rst_n(rst_n), .valid_in(valid_in), .data_in(data_in), .data_out(data_out_i));\n\n    valid_output u_valid_output (.clk(clk), .rst_n(rst_n), .valid_in(valid_in), .valid_out(valid_out_i), .data_out(data_out));\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_out\n);\n    reg          [1:0]  count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n            if (count == 2) begin\n                valid_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end else if (valid_in) begin\n            data_out <= data_out + data_in;\n        end\n    end\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input               valid_out_i,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n    reg          [9:0]  data_out_i;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n            data_out_i <= 0;\n            valid_out_i <= 0;\n        end else begin\n            valid_out <= valid_out_i;\n            data_out <= data_out_i;\n            data_out_i <= data_out_i + 1;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor_mod;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    abs_value abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(dividend),\n        .output(abs_dividend)\n    );\n\n    neg_value neg_divisor_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(divisor),\n        .output(neg_divisor_mod)\n    );\n\n    div_ctrl div_ctrl_inst(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .divisor(neg_divisor_mod),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    result_mgmt res_mgmt_inst(\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            output <= 8'd0;\n        end else begin\n            output <= (sign) ? -input : input;\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            output <= 8'd0;\n        end else begin\n            output <= (sign) ? ~input + 1 : input;\n        end\n    end\n\nendmodule\n\nmodule div_ctrl(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [3:0] counter;\n    reg [15:0] shift_reg;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 16'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid) begin\n            counter <= 4'd0;\n            shift_reg <= {8'd0, divisor};\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (counter < 4'd15) begin\n            counter <= counter + 4'd1;\n            shift_reg <= {shift_reg[14:0], shift_reg[15]};\n            temp_quotient <= quotient;\n            temp_remainder <= remainder;\n            if (shift_reg[15]) begin\n                temp_quotient <= temp_quotient + 16'd1;\n                temp_remainder <= temp_remainder - divisor;\n            end\n            quotient <= temp_quotient;\n            remainder <= temp_remainder;\n        end\n    end\n\nendmodule\n\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [15"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend, divisor;\n\n    prep_dividend prep(\n        .A(A),\n        .B(B),\n        .prep_dividend(dividend),\n        .prep_divisor(divisor)\n    );\n\n    div_operation div(\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] prep_dividend,\n    output reg [15:0] prep_divisor\n);\n    assign prep_dividend = {A[31:16], 16'b0};\n    assign prep_divisor = {B, 16'b0};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    reg [31:0] temp_dividend, temp_divisor, temp_remainder;\n    reg [15:0] temp_shift;\n\n    always @(*) begin\n        temp_dividend = dividend;\n        temp_divisor = divisor;\n        temp_shift = 0;\n        temp_remainder = 0;\n        result = 0;\n        odd = 0;\n\n        while (temp_dividend >= temp_divisor) begin\n            temp_dividend = temp_dividend - temp_divisor;\n            temp_shift = temp_shift + 1;\n        end\n\n        result = {24'b0, temp_shift};\n        odd = temp_dividend;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] tmp_quotient;\n    reg [15:0] tmp_remainder;\n    reg [3:0] count;\n\n    always @(*) begin\n        dividend = A;\n        divisor = B;\n        tmp_quotient = 0;\n        tmp_remainder = 0;\n        count = 0;\n    end\n\n    // Algorithm:\n    // 1. Shift dividend to the right to make room for the divisor.\n    // 2. Compare the rightmost bits of the dividend with the divisor.\n    // 3. If divisor matches, increment quotient and subtract from dividend.\n    // 4. If divisor does not match, shift divisor right and repeat step 2.\n    // 5. Repeat steps 2-4 until all bits in the dividend have been compared.\n    // 6. Final result is the quotient.\n\n    always @(dividend or divisor) begin\n        if (dividend[15:8] == divisor) begin\n            tmp_quotient[15:8] = count;\n            tmp_remainder[15:8] = dividend[7:0];\n            dividend[15:8] = 0;\n            count = count + 1;\n        end else begin\n            dividend[15:8] = dividend[15:8] >> 1;\n        end\n    end\n\n    always @(count) begin\n        quotient = tmp_quotient;\n        remainder = tmp_remainder;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_inv;\n    wire [7:0] sum;\n\n    assign B_inv = ~B;\n\n    adder_8bit adder_inst(A, B_inv, sum);\n    assign D = ~sum;\n    assign B_out = ~(A[7] ^ B[7]) & sum[7];\nendmodule\n\nmodule adder_8bit(A, B, sum);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] sum;\n\n    wire [7:0] carry;\n\n    full_adder FA0(.a(A[0]), .b(B[0]), .c(carry[0]), .sum(sum[0]));\n    full_adder FA1(.a(A[1]), .b(B[1]), .c(carry[1]), .sum(sum[1]));\n    full_adder FA2(.a(A[2]), .b(B[2]), .c(carry[2]), .sum(sum[2]));\n    full_adder FA3(.a(A[3]), .b(B[3]), .c(carry[3]), .sum(sum[3]));\n    full_adder FA4(.a(A[4]), .b(B[4]), .c(carry[4]), .sum(sum[4]));\n    full_adder FA5(.a(A[5]), .b(B[5]), .c(carry[5]), .sum(sum[5]));\n    full_adder FA6(.a(A[6]), .b(B[6]), .c(carry[6]), .sum(sum[6]));\n    full_adder FA7(.a(A[7]), .b(B[7]), .c(carry[7]), .sum(sum[7]));\n\n    assign carry[0] = 1'b0;\nendmodule\n\nmodule full_adder(a, b, c, sum);\n    input a, b, c;\n    output sum;\n\n    assign sum = a ^ b ^ c;\n    assign c = (a & b) | (b & c) | (a & c);\nendmodule\n"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1, S2;\n    wire carry_out_1, carry_out_2;\n\n    // Instance of 16-bit subtractor\n    // 1st subtractor\n    sub_16bit S1_inst16bit(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1),\n        .carry_out(carry_out_1)\n    );\n\n    // 2nd subtractor\n    sub_16bit S2_inst16bit(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2),\n        .carry_out(carry_out_2)\n    );\n\n    // Output\n    assign Diff = {S2, S1};\n    assign B_out = carry_out_2 | carry_out_1;\n\nendmodule\n\n// 16-bit subtractor\nmodule sub_16bit(A, B, Diff, carry_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output carry_out;\n\n    wire [15:0] sum;\n    wire carry_in;\n\n    assign carry_in = 0;\n\n    // Full adder structure\n    // Adder logic\n    assign sum = A ^ B ^ carry_in;\n    assign carry_out = (A & B) | (B & carry_in) | (carry_in & A);\n\n    // Output\n    assign Diff = sum;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] A0, A1, B0, B1, D0, D1;\n    wire [7:0] A00, A01, A10, A11, B00, B01, B10, B11, D00, D01, D10, D11;\n    wire [1:0] B_out_wire;\n\n    sub_32bit sub0(A[63:32], B[63:32], D[63:32], B_out_wire[1:0]);\n    sub_32bit sub1(A[31:0], B[31:0], D[31:0], B_out_wire[1:0]);\n\n    assign A0 = A[63:32];\n    assign A1 = A[31:0];\n    assign B0 = B[63:32];\n    assign B1 = B[31:0];\n    assign D0 = D[63:32];\n    assign D1 = D[31:0];\n\n    sub_16bit sub00(A0, B0, D0, B_out_wire[1]);\n    sub_16bit sub01(A0, B1, D0, B_out_wire[0]);\n    sub_16bit sub10(A1, B0, D1, B_out_wire[1]);\n    sub_16bit sub11(A1, B1, D1, B_out_wire[0]);\n\n    assign A00 = A0[15:8];\n    assign A01 = A0[7:0];\n    assign A10 = A1[15:8];\n    assign A11 = A1[7:0];\n    assign B00 = B0[15:8];\n    assign B01 = B0[7:0];\n    assign B10 = B1[15:8];\n    assign B11 = B1[7:0];\n    assign D00 = D0[15:8];\n    assign D01 = D0[7:0];\n    assign D10 = D1[15:8];\n    assign D11 = D1[7:0];\n\n    sub_8bit sub000(A00, B00, D00);\n    sub_8bit sub001(A00, B01, D01);\n    sub_8bit sub010(A01, B00, D00);\n    sub_8bit sub011(A01, B01, D01);\n    sub_8bit sub100(A10, B00, D10);\n    sub_8bit sub101(A10, B01, D11);\n    sub_8bit sub110(A11, B00, D10);\n    sub_8bit sub111(A11, B01, D11);\n\n    assign B_out = B_out_wire[1] | B_out_wire[0];\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [7:0] A0, A1, B0, B1, D0, D1;\n    wire [3:0] B_out_wire;\n\n    sub_16bit sub0(A[31:16], B[31:16], D[31:16], B_out_wire[3:2]);\n    sub_16bit sub1(A[15:0], B[15:0], D[15:0], B_out_wire[1:0]);\n\n    assign A0 = A[31:24];\n    assign A1 = A[23:16];\n   "}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [1:0] B_out_sub1, B_out_sub2, B_out_sub3, B_out_sub4;\n\n    // Instantiate full subtractor blocks\n    full_subtractor sub1(A[1:0], B[1:0], D[1:0], B_out_sub1);\n    full_subtractor sub2(A[3:2], B[3:2], D[3:2], B_out_sub2);\n    full_subtractor sub3(A[5:4], B[5:4], D[5:4], B_out_sub3);\n    full_subtractor sub4(A[7:6], B[7:6], D[7:6], B_out_sub4);\n\n    assign B_out = B_out_sub4[0];\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input [1:0] A, B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_sub1, B_out_sub2;\n\n    // Instantiate 2-bit full subtractor block\n    full_subtractor_2 BL_sub(A, B, D, B_out_sub1);\n\n    // Instantiate carry look-ahead adder\n    carry_look_ahead_adder CLA_sub(D, B_out_sub1, 0, B_out_sub2);\n\n    assign B_out = B_out_sub2[0];\nendmodule\n\nmodule full_subtractor_2(A, B, D, B_out);\n    input [1:0] A, B;\n    output [1:0] D;\n    output B_out;\n\n    wire [1:0] B_out_sub1, B_out_sub2;\n\n    // Instantiate 2-bit full subtractor block\n    full_subtractor_2 BL_sub(A, B, D, B_out_sub1);\n\n    // Instantiate carry look-ahead adder\n    carry_look_ahead_adder CLA_sub(D, B_out_sub1, 0, B_out_sub2);\n\n    assign B_out = B_out_sub2[0];\nendmodule\n\nmodule carry_look_ahead_adder(A, B, C_in, D, C_out);\n    input [1:0] A, B;\n    input C_in;\n    output [1:0] D;\n    output C_out;\n\n    wire C_out_sub1, C_out_sub2;\n\n    // Instantiate 2-bit full adder block\n    full_adder FA_sub(A[0], B[0], C_in, D[0], C_out_sub1);\n    full_adder FA_sub(A[1], B[1], C_out_sub1, D[1], C_out_sub2);\n\n    assign C_out = C_out_sub2;\nendmodule\n\nmodule full_adder(A, B, C_in, D, C_out);\n    input A, B, C_in;\n    output D, C_out;\n\n    wire C_out_sub1;\n\n    // Instantiate 2-bit half adder block\n    half_adder HA_sub(A, B, C_out_sub1);\n\n    // Instantiate 2-bit full adder block\n    full_adder FA_sub(C_out_sub1, C_in, 1'b0, D, C_out);\nendmodule\n\nmodule half_adder(A, B, C_out);\n    input A, B;\n    output C_out;\n\n    wire C_out_sub1, C_out_sub2;\n\n    // Instantiate 2-bit XOR gate\n    xor2 XOR_sub(A, B, C_out_sub1);\n\n    // Instantiate 2-bit OR"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff;  // Difference between A and B\n    wire borrow;       // Borrow flag\n\n    subtractor_32bit sub_inst(.A(A), .B(B), .diff(diff), .borrow(borrow));\n\n    assign A_greater = (diff == 0) ? 1'b0 : 1'b1;\n    assign A_equal = (diff == 0) ? 1'b1 : 1'b0;\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow // Borrow flag\n);\n    wire [31:0] A_not, B_not;\n    wire [31:0] A_minus_B;\n    wire [31:0] A_minus_B_not;\n\n    assign A_not = ~A;\n    assign B_not = ~B;\n    assign A_minus_B = A_not + B_not;\n    assign A_minus_B_not = ~A_minus_B;\n\n    assign diff = A_minus_B;\n    assign borrow = A_minus_B_not[31];\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C;\n    wire [15:1] G;\n    wire [15:1] P;\n\n    wire C4;\n\n    wire [15:1] C1,C2,C3;\n\n    assign C1 = C4 ? 16'b0 : C;\n    assign C2 = C4 ? C : 16'b0;\n    assign C3 = C4 ? 16'b0 : C;\n\n    cla_16bit CLA1(.A(A[15:1]),.B(B[15:1]),.Cin(1'b0),.G(G[15:1]),.P(P[15:1]),.Cout(C1[15]),.Gout(G[15]),.Pout(P[15]));\n    cla_16bit CLA2(.A(A[14:1]),.B(B[14:1]),.Cin(C1[15]),.G(G[14:1]),.P(P[14:1]),.Cout(C2[14]),.Gout(G[14]),.Pout(P[14]));\n    cla_16bit CLA3(.A(A[13:1]),.B(B[13:1]),.Cin(C2[14]),.G(G[13:1]),.P(P[13:1]),.Cout(C3[13]),.Gout(G[13]),.Pout(P[13]));\n    cla_16bit CLA4(.A(A[12:1]),.B(B[12:1]),.Cin(C3[13]),.G(G[12:1]),.P(P[12:1]),.Cout(C4),.Gout(G[12]),.Pout(P[12]));\n\n    assign C32 = C4;\n    assign S[15:1] = P + G;\n    assign S[14:1] = C1 + C2 + P[14:1];\n    assign S[13:1] = C2 + C3 + P[13:1];\n    assign S[12:1] = C3 + C4 + P[12:1];\nendmodule\n\nmodule cla_16bit(A,B,Cin,G,P,Cout,Gout,Pout);\n    input [15:1] A;\n    input [15:1] B;\n    input Cin;\n    output [15:1] G;\n    output [15:1] P;\n    output Cout;\n    output [15:1] Gout;\n    output [15:1] Pout;\n\n    wire [15:1] C;\n    wire [15:1] G1,G2,G3;\n    wire [15:1] P1,P2,P3;\n\n    assign G1 = Cin ? 16'b0 : G;\n    assign G2 = Cin ? G : 16'b0;\n    assign G3 = Cin ? 16'b0 : G;\n\n    cla_8bit CLA1(.A(A[7:0]),.B(B[7:0]),.Cin(1'b0),.G(G1[7:0]),.P(P1[7:0]),.Cout(C[7]),.Gout(G1[7:0]),.Pout(P1[7:0]));\n    cla_8bit CLA2(.A(A[6:0]),.B(B[6:0]),.Cin(C[7]),.G(G2[6:0]),.P(P2[6:0]),.Cout(C[6]),.Gout(G2[6:0]),.Pout(P2[6:0]));\n    cla_8bit CLA3(.A(A[5:0]),.B(B[5:0]),.Cin(C["}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carrys;\n    wire [15:0] sums;\n\n    ripple_carry_adder_4bit rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carrys[0]), .sum(sums[3:0]));\n    ripple_carry_adder_4bit rca2(.a(a[7:4]), .b(b[7:4]), .cin(carrys[0]), .cout(carrys[1]), .sum(sums[7:4]));\n    ripple_carry_adder_4bit rca3(.a(a[11:8]), .b(b[11:8]), .cin(carrys[1]), .cout(carrys[2]), .sum(sums[11:8]));\n    ripple_carry_adder_4bit rca4(.a(a[15:12]), .b(b[15:12]), .cin(carrys[2]), .cout(carrys[3]), .sum(sums[15:12]));\n\n    assign sum = sums;\n    assign cout = carrys[3];\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [15:0] sum_slice1, sum_slice2, sum_slice3;\n    wire [3:0] carrys;\n\n    ripple_carry_adder_4bit rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(carrys[0]), .sum(sum_slice1[3:0]));\n    ripple_carry_adder_4bit rca2(.a(a[7:4]), .b(b[7:4]), .cin(carrys[0]), .cout(carrys[1]), .sum(sum_slice1[7:4]));\n    ripple_carry_adder_4bit rca3(.a(a[11:8]), .b(b[11:8]), .cin(carrys[1]), .cout(carrys[2]), .sum(sum_slice1[11:8]));\n    ripple_carry_adder_4bit rca4(.a(a[15:12]), .b(b[15:12]), .cin(carrys[2]), .cout(carrys[3]), .sum(sum_slice1[15:12]));\n\n    carry_select_adder_4bit csa_slice1(.a(sum_slice1[3:0]), .b(sum_slice1[7:4]), .cin(cin), .sum(sum_slice2[3:0]), .cout(carrys[0]));\n    carry_select_adder_4bit csa_slice2(.a(sum_slice1[11:8]), .b(sum_slice1[15:12]), .cin(carrys[1]), .sum(sum_slice2[11:8]), .cout(carrys[1]));\n    carry_select_adder_4bit csa_slice3(.a(sum_slice2[3:0]), .b(sum_slice2[15:12]), .cin(carrys[2]), .sum(sum_slice3[3:0]), .cout(carrys[2]));\n    carry_select_adder_4bit csa_slice4(.a(sum_slice3[7:4]), .b(sum_slice3[15:12]), .cin(carrys[3]), .sum(sum_slice3[11:8]), .cout(cout));\n\n    assign sum = sum_slice3;\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, cout, sum);\n   "}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] C;\n    wire [7:0] G;\n    wire [7:0] P;\n\n    // 8-bit adder instantiations\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .Co(C[0]),\n        .y(P[0]),\n        .G(G[0])\n    );\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(C[0]),\n        .Co(C[1]),\n        .y(P[1]),\n        .G(G[1])\n    );\n\n    // Carry-out calculation\n    assign Co = C[1];\n\n    // Output calculation\n    assign y = {P[1], P[0]} ^ {G[1], G[0]} ^ {1'b0, Cin};\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire Co,\n    output wire [7:0] y,\n    output wire [7:0] G\n);\n    wire [7:0] P;\n\n    assign Co = (a[0] & b[0]) | (a[0] & G[0]) | (b[0] & G[0]);\n    assign P = a ^ b ^ {1'b0, Cin};\n    assign y = P;\n    assign G = a & b;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire Co,\n    output wire [7:0] y,\n    output wire [7:0] G\n);\n    wire [7:0] P;\n\n    assign Co = (a[7] & b[7]) | (a[7] & G[7]) | (b[7] & G[7]);\n    assign P = a ^ b ^ {1'b0, Cin};\n    assign y = P;\n    assign G = a & b;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [2:0] carry;\n    \n    fa FA0(\n        .a(a[0]), \n        .b(b[0]), \n        .cin(cin), \n        .sum(sum[0]), \n        .cout(carry[0]));\n    \n    fa FA1(\n        .a(a[1]), \n        .b(b[1]), \n        .cin(carry[0]), \n        .sum(sum[1]), \n        .cout(carry[1]));\n    \n    fa FA2(\n        .a(a[2]), \n        .b(b[2]), \n        .cin(carry[1]), \n        .sum(sum[2]), \n        .cout(carry[2]));\n    \n    fa FA3(\n        .a(a[3]), \n        .b(b[3]), \n        .cin(carry[2]), \n        .sum(sum[3]), \n        .cout(carry[3]));\n    \n    fa FA4(\n        .a(a[4]), \n        .b(b[4]), \n        .cin(carry[3]), \n        .sum(sum[4]), \n        .cout(carry[4]));\n    \n    fa FA5(\n        .a(a[5]), \n        .b(b[5]), \n        .cin(carry[4]), \n        .sum(sum[5]), \n        .cout(carry[5]));\n    \n    fa FA6(\n        .a(a[6]), \n        .b(b[6]), \n        .cin(carry[5]), \n        .sum(sum[6]), \n        .cout(carry[6]));\n    \n    fa FA7(\n        .a(a[7]), \n        .b(b[7]), \n        .cin(carry[6]), \n        .sum(sum[7]), \n        .cout(cout));\n\nendmodule\n\nmodule fa(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control unit\nreg [15:0] count;\nreg [1:0] state;\nreg done_reg;\n\n// Register unit\nreg [15:0] a;\nreg [15:0] b;\n\n// Multiplier unit\nreg [31:0] product;\n\n// Control unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        state <= 2'b00;\n        done_reg <= 1'b0;\n    end else begin\n        case (state)\n            2'b00: begin // Reset\n                count <= 0;\n                state <= 2'b01;\n            end\n            2'b01: begin // Start\n                count <= 16'h1000;\n                state <= 2'b10;\n            end\n            2'b10: begin // Shift and accumulate\n                if (count == 0) begin\n                    state <= 2'b01;\n                end else begin\n                    count <= count - 1;\n                    if (a[count]) begin\n                        product <= product + b;\n                    end\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\n// Output assignment\nassign yout = product;\nassign done = done_reg;\n\n// Register unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else begin\n        if (start) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\nend\n\n// Multiplier unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0;\n    end else begin\n        if (start) begin\n            product <= 0;\n        end else begin\n            if (count == 0) begin\n                done_reg <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule\n\nmodule ctrl_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [15:0] count, // Shift count register.\n    output reg done      // Chip output flag signal.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        done <= 1'b0;\n    end else begin\n        if (start) begin\n            count <= 16'h1000;\n            done <= 1'b0;\n        end else begin\n            if (count == 0) begin\n                done <= 1'b1;\n            end else begin\n                count <= count - 1;\n            end\n        end\n    end\nend\n\nendmodule\n\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a, // Register a.\n    output reg [15:0] b  // Register b.\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else begin\n        if (start) begin\n            a <= ain;\n            b <= bin;\n        end\n    end\nend\n\nendmodule\n\nmodule mul_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand)"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\n\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .next_count(next_count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        next_count <= 0;\n    else begin\n        if (up_down)\n            next_count <= next_count + 1;\n        else\n            next_count <= next_count - 1;\n    end\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 0;\n    else\n        count <= next_count;\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    ring_counter_init init (\n        .reset(reset),\n        .out(out)\n    );\n\n    ring_counter_transition transition (\n        .clk(clk),\n        .out(out)\n    );\nendmodule\n\nmodule ring_counter_init (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out = 8'b0000_0001;\n    end\nendmodule\n\nmodule ring_counter_transition (\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= (out == 8'b1111_1110) ? 8'b0000_0001 : out << 1;\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\nwire [3:0] count;\n\ncounter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count(count)\n);\n\noutput_register u_output_register (\n    .rst_n(rst_n),\n    .valid_count(valid_count),\n    .count(count),\n    .out(out)\n);\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        out <= 0;\n    end else if (valid_count) begin\n        out <= count;\n    end\nend\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end else if (valid_count) begin\n        if (count == 4'd11) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_Q;\n\n// Instantiate the register module\nJC_register reg_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(next_Q)\n);\n\n// Instantiate the logic module\nJC_logic logic_inst(\n    .Q(Q),\n    .next_Q(next_Q)\n);\n\nendmodule\n\n// Register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 64'b0;\nend\n\nendmodule\n\n// Logic module\nmodule JC_logic(\n    input [63:0]        Q,\n    input [63:0]        next_Q\n);\n\nalways @(*) begin\n    Q[0] = Q[63];\n    Q[63:1] = next_Q[62:0];\nend\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_in_p, clk_in_n;\n    wire clk_50_p, clk_50_n, clk_10_p, clk_10_n, clk_1_p, clk_1_n;\n\n    // Instantiate frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(clk_in_p),\n        .CLK_out(clk_50_p)\n    );\n    clk_div clk_div_10 (\n        .CLK_in(clk_in_p),\n        .CLK_out(clk_10_p)\n    );\n    clk_div clk_div_1 (\n        .CLK_in(clk_in_p),\n        .CLK_out(clk_1_p)\n    );\n\n    // Generate inverted clock signals\n    not n0 (\n        .out(clk_in_n),\n        .in(CLK_in)\n    );\n    not n1 (\n        .out(clk_in_p),\n        .in(CLK_in)\n    );\n    not n2 (\n        .out(clk_50_n),\n        .in(clk_50_p)\n    );\n    not n3 (\n        .out(clk_10_n),\n        .in(clk_10_p)\n    );\n    not n4 (\n        .out(clk_1_n),\n        .in(clk_1_p)\n    );\n\n    // Output clock signals\n    assign CLK_50 = RST ? 1'b0 : clk_50_p;\n    assign CLK_10 = RST ? 1'b0 : clk_10_p;\n    assign CLK_1 = RST ? 1'b0 : clk_1_p;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    output CLK_out\n);\n    reg [3:0] counter;\n    always @(posedge CLK_in) begin\n        if (counter == 4) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    assign CLK_out = counter[3];\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [2:0] clk_div_int;\n\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_out(clk_div_int)\n);\n\nclk_average u_clk_average(\n    .clk(clk),\n    .clk_div_in(clk_div_int[2:0]),\n    .clk_out(clk_div_int[1:0])\n);\n\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .clk_div_in(clk_div_int[1:0]),\n    .clk_out(clk_div_int[0])\n);\n\nassign clk_div = clk_div_int[0] | clk_div_int[1:0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [2:0]    clk_div_out\n);\n    reg [7:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div_out <= 0;\n        end else if (cnt == (MUL2_DIV_CLK - 1)) begin\n            cnt <= 0;\n            clk_div_out <= clk_div_out + 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input [2:0]         clk_div_in,\n    output reg [1:0]    clk_out\n);\n    reg [1:0] cnt;\n    always @(posedge clk or posedge clk_div_in[2]) begin\n        if (clk_div_in[2]) begin\n            cnt <= 0;\n            clk_out <= 0;\n        end else if (cnt == 3) begin\n            cnt <= 0;\n            clk_out <= clk_out | 1;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input [1:0]         clk_div_in,\n    output reg          clk_out\n);\n    reg [1:0] cnt;\n    always @(negedge clk or posedge clk_div_in[1]) begin\n        if (clk_div_in[1]) begin\n            cnt <= 0;\n            clk_out <= 0;\n        end else if (cnt == 2) begin\n            cnt <= 0;\n            clk_out <= ~clk_out;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] cnt_reg;\n    reg clk_div;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_reg <= 0;\n        else if (cnt_reg < NUM_DIV - 1)\n            cnt_reg <= cnt_reg + 1;\n        else\n            cnt_reg <= 0;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (cnt_reg == NUM_DIV - 1)\n            clk_div <= 1;\n        else\n            clk_div <= 0;\n    end\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] cnt_reg;\n    reg clk_div;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_reg <= 0;\n        else if (cnt_reg < NUM_DIV - 1)\n            cnt_reg <= cnt_reg + 1;\n        else\n            cnt_reg <= 0;\n    end\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (cnt_reg == NUM_DIV - 1)\n            clk_div <= 1;\n        else\n            clk_div <= 0;\n    end\n\nendmodule\n\n"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 4;\n    reg [3:0] counter;\n    wire clk_div_i;\n    assign clk_div = clk_div_i;\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n)\n            counter <= 0;\n        else begin\n            if(counter == (NUM_DIV/2 - 1))\n                counter <= 0;\n            else\n                counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule freq_divbyeven_submodule(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4;\n    reg [3:0] counter;\n    wire clk_div_i;\n    assign clk_div_i = counter == (NUM_DIV/2 - 1);\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n)\n            counter <= 0;\n        else begin\n            if(counter == (NUM_DIV/2 - 1))\n                counter <= 0;\n            else\n                counter <= counter + 1;\n        end\n    end\nendmodule\n\n\n"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\n    wire [31:0] r_add, r_sub, r_and, r_or, r_xor, r_nor;\n    wire [31:0] r_sll, r_srl, r_sra;\n    wire [31:0] r_slt, r_sltu, r_lui;\n\n    // Addition\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(r_add)\n    );\n\n    // Subtraction\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(r_sub)\n    );\n\n    // Logical operations\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(r_and)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(r_or)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(r_xor)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(r_nor)\n    );\n\n    // Shift operations\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(r_sll)\n    );\n\n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(r_srl)\n    );\n\n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(r_sra)\n    );\n\n    // Bitwise operations\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(r_slt)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(r_sltu)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(r_lui)\n    );\n\n    // Assign outputs\n    assign r = (aluc == 6'b100000) ? r_add :\n               (aluc == 6'b100001) ? r_add :\n               (aluc == 6'b100010) ? r_sub :\n               (aluc == 6'b100011) ? r_sub :\n               (aluc == 6'b100100) ? r_and :\n               (aluc == 6'b100101) ? r_or :\n               (aluc == 6'b100110) ? r_xor :\n               (aluc == 6'b100111) ? r_nor :\n               (aluc == 6'b000000) ? r_sll :\n               (aluc == 6'b000010) ? r_srl :\n               (aluc == 6'b000011) ? r_sra :\n               (aluc == 6'b000100) ? r_sll :\n               (aluc == 6'b000110) ? r_srl :\n               (aluc == 6'b000111) ? r_sra :\n               (aluc == 6'b101010) ? r_slt :\n               (aluc == 6'b101011) ? r_sltu :\n               (aluc == 6'b001111) ? r_lui : 32'b0;\n\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n\n    assign carry = (r_add[31] == 1'b1) ? 1'b1 : 1'b0;\n\n    assign negative = (r[31] == 1'"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] a_mult;\nwire [63:0] mult_result;\nwire [31:0] current_value;\n\n// Instantiate the multiplier module\nmultiplier u_multiplier(\n    .clk(clk),\n    .rst(rst),\n    .a(a),\n    .b(b),\n    .c(a_mult)\n);\n\n// Instantiate the accumulator module\naccumulator u_accumulator(\n    .clk(clk),\n    .rst(rst),\n    .current_value(current_value),\n    .new_value(mult_result[31:0]),\n    .result(c)\n);\n\nassign current_value = rst ? 32'h00000000 : (current_value + mult_result[31:0]);\nassign mult_result = a * b;\n\nendmodule\n\n// Instantiate the pe module\npe u_pe(\n    .clk(clk),\n    .rst(rst),\n    .a(a),\n    .b(b),\n    .c(c)\n);\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n    wire [4:0] ad1_p1;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p1;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for fetched instruction from RAM/ROM\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instruction register for fetched instruction from register\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output from the two registers\n    assign ins = {ins2[7:5], ins1[7:5]};\n    assign ad1 = ad1_p2[4:0] | ad1_p1[4:0];\n    assign ad2 = ad2_p2 | ad2_p1;\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data;\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\nwire clk_enable;\nwire [7:0] count;\n\ncounter counter_instance (\n    .clk(clk),\n    .enable(clk_enable),\n    .freq(freq),\n    .count(count)\n);\n\nwave_generator wave_generator_instance (\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nassign clk_enable = freq != 0;\n\nendmodule\n\nmodule counter (\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (enable) begin\n        if (count == (freq - 1))\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk) begin\n    wave_out <= (count % freq) == 0;\nend\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire [1:0] state;\n    reg [4:0] wave_reg;\n    \n    // State control module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else if (state == 2'b00 && wave_reg == 5'b00000)\n            state <= 2'b01;\n        else if (state == 2'b01 && wave_reg == 5'b11111)\n            state <= 2'b00;\n    end\n    \n    // Waveform generation module\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_reg <= 5'b00000;\n        else if (state == 2'b00)\n            wave_reg <= wave_reg + 1;\n        else if (state == 2'b01)\n            wave_reg <= wave_reg - 1;\n    end\n    \n    assign wave = wave_reg;\n    \nendmodule\n\nmodule wave_gen (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'b00000;\n        else if (wave == 5'b11111)\n            wave <= 5'b00000;\n        else if (wave == 5'b00000)\n            wave <= 5'b11111;\n    end\nendmodule\n"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] delay;\n    wire [1:0] sel_delay;\n\n    // 8-bit D flip-flop\n    my_dff8 u0 (.clk(clk), .d(d[0]), .q(delay[0]));\n    my_dff8 u1 (.clk(clk), .d(delay[0]), .q(delay[1]));\n    my_dff8 u2 (.clk(clk), .d(delay[1]), .q(delay[2]));\n    my_dff8 u3 (.clk(clk), .d(delay[2]), .q(delay[3]));\n\n    // 4-to-1 multiplexer\n    assign sel_delay = {delay[sel], d};\n\n    always @(posedge clk)\n        q <= sel_delay;\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage0_out, stage1_out, stage2_out;\n\n    mux2X1 mux_ctrl0 (.sel(ctrl[2]), .in0(in), .in1(stage0_out), .out(stage1_out));\n    mux2X1 mux_ctrl1 (.sel(ctrl[1]), .in0(stage1_out), .in1(stage2_out), .out(stage2_out));\n    mux2X1 mux_ctrl2 (.sel(ctrl[0]), .in0(stage2_out), .in1(in), .out(out));\n\n    assign stage0_out = in;\n    assign stage2_out = in;\n\n    // Implementing a 2-to-1 multiplexer\n    module mux2X1 (sel, in0, in1, out);\n        input sel;\n        input [7:0] in0, in1;\n        output [7:0] out;\n        assign out = sel ? in1 : in0;\n    endmodule\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n  wire [15:0] pe0_b0, pe1_b0, pe1_b1;\n\n  // PE0\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .b1(b1),\n    .pe_out(pe0_out)\n  );\n\n  assign pe0_b0 = b0;\n\n  // PE1\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(pe1_b0),\n    .b1(pe1_b1),\n    .pe_out(pe1_out)\n  );\n\n  assign pe1_b0 = b0;\n  assign pe1_b1 = b1;\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] b1,\n  output [31:0] pe_out\n);\n\n  reg [15:0] a_reg, b_reg, b1_reg;\n  reg [31:0] pe_out_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      a_reg <= 0;\n      b_reg <= 0;\n      b1_reg <= 0;\n      pe_out_reg <= 0;\n    end else begin\n      a_reg <= a;\n      b_reg <= b;\n      b1_reg <= b1;\n      pe_out_reg <= a_reg * b_reg + a_reg * b1_reg;\n    end\n  end\n\n  assign pe_out = pe_out_reg;\n\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_out;\n  wire [4:0] pc;\n\n  stage fetch_stage(.clk(clk), .rst(rst), .pc(pc), .instr_mem(instr_mem), .fetched(alu_out));\n  stage decode_stage(.clk(clk), .rst(rst), .instr_mem(alu_out), .reg_file(reg_file), .pc(pc), .execute(alu_out));\n  stage execute_stage(.clk(clk), .rst(rst), .execute(alu_out), .reg_file(reg_file), .result(alu_out));\n  stage memory_stage(.clk(clk), .rst(rst), .result(alu_out), .reg_file(reg_file), .alu_out(alu_out));\n  stage writeback_stage(.clk(clk), .rst(rst), .result(alu_out), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output reg [31:0] fetched,\n  output [31:0] result,\n  output [31:0] alu_out,\n  input [31:0] reg_file [0:31]\n);\n  reg [31:0] fetch_result;\n  wire [31:0] decoded_instr;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      fetch_result <= 0;\n    end else begin\n      fetch_result <= instr_mem[pc];\n    end\n  end\n\n  assign decoded_instr = fetch_result;\n  assign alu_out = fetched;\n  assign result = alu_out;\n\n  assign fetched = decoded_instr;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [4:0] pc,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] fetched\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      fetched <= 0;\n    end else begin\n      fetched <= instr_mem[pc];\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem,\n  input [31:0] reg_file [0:31],\n  input [4:0] pc,\n  output reg [31:0] execute,\n  output [31:0] alu_out\n);\n  reg [31:0] opcode;\n  reg [31:0] rs1;\n  reg [31:0] rs2;\n  reg [31:0] rd;\n  reg [5:0] funct;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      execute <= 0;\n    end else begin\n      opcode <= instr_mem[15:0];\n      rs1 <= instr_mem[20:15];\n      rs2 <= instr_mem[25:20];\n      rd <= instr_mem[11:7];\n      funct <= instr_mem[5:0];\n      execute <= {rs1, rs2, rd, funct};\n    end\n  end\n\n  assign alu_out = execute;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] execute,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] result\n);\n  wire [31:0] rs1_value, rs2_value;\n\n  assign rs1_value = reg_file[execute[20:15]];\n  assign rs2_value = reg_file["}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b1_reg, b2_reg, b3_reg;\n  assign b1 = b1_reg;\n  assign b2 = b2_reg;\n  assign b3 = b3_reg;\n\n  // Instantiate PEs\n  // pe0\n  pe pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  // pe1\n  pe pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  // pe2\n  pe pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  // pe3\n  pe pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  // Update b1, b2, b3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b1_reg <= b0;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] accumulator;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      accumulator <= 0;\n    end else begin\n      accumulator <= accumulator + (a * b);\n    end\n  end\n  assign c = accumulator;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\n\n// Fetch stage\n\nstagepipe3_submodule fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .out_instr(fetched_instr)\n);\n\n// Execute stage\n\nstagepipe3_submodule execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr(fetched_instr),\n    .reg_file(reg_file),\n    .result(result)\n);\n\n// Writeback stage\n\nstagepipe3_submodule writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .result(result),\n    .out_reg_file(out_reg_file)\n);\n\nendmodule\n\n// Stage pipe 3 submodule definition\n\nmodule stagepipe3_submodule(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    // Instruction decoding logic\n\n    // Fetch stage logic\n    wire [4:0] rs, rt, rd;\n    wire [5:0] funct;\n    assign {rs, rt, rd, funct} = instr;\n\n    // Execute stage logic\n    wire [31:0] op1, op2;\n    assign op1 = reg_file[rs];\n    assign op2 = reg_file[rt];\n    assign result = (funct == 6'b000000) ? op1 + op2 : op1 - op2;\n\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire [3:0] cnt_out;\nwire [9:0] accu_out;\n\n// Counter Module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .cnt_out(cnt_out)\n);\n\n// Data Accumulator Module\ndata_accu u_data_accumulator (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .data_in(data_in),\n    .accu_out(accu_out)\n);\n\n// Valid Output Module\nvalid_out_reg u_valid_output (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cnt_out(cnt_out),\n    .valid_out(valid_out)\n);\n\n// Output ports\nassign data_out = accu_out;\n\nendmodule\n\n// Counter Module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   cnt_out\n);\n\nreg [3:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_next <= 0;\n    else if (valid_in)\n        cnt_next <= cnt_next + 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_out <= 0;\n    else\n        cnt_out <= cnt_next;\nend\n\nendmodule\n\n// Data Accumulator Module\nmodule data_accu (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accu_out\n);\n\nreg [3:0] cnt_next;\nreg [9:0] accu_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        accu_next <= 0;\n    else if (valid_in)\n        accu_next <= accu_next + data_in;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_next <= 0;\n    else\n        cnt_next <= cnt_next + 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        accu_out <= 0;\n    else if (cnt_next == 4)\n        accu_out <= accu_next;\nend\n\nendmodule\n\n// Valid Output Module\nmodule valid_out_reg (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   cnt_out,\n    output reg          valid_out\n);\n\nreg [3:0] cnt_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        valid_out <= 0;\n    else if (cnt_next == 4)\n        valid_out <= 1;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        cnt_next <= 0;\n    else\n        cnt_next <= cnt_out;\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n    wire [15:0] abs_dividend;\n    wire [15:0] neg_divisor_mod;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    \n    // calculate absolute value of dividend and divisor\n    abs_value abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(dividend),\n        .output(abs_dividend)\n    );\n    neg_value neg_divisor_mod_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(divisor),\n        .output(neg_divisor_mod)\n    );\n    \n    // divide absolute values\n    divider_control div_ctrl(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .abs_dividend(abs_dividend),\n        .neg_divisor_mod(neg_divisor_mod),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n    \n    // create result\n    assign result = {remainder, quotient};\n    \n    // manage result validity\n    result_management res_mgmt(\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .result_valid(res_valid),\n        .result(result)\n    );\n    \nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [15:0] output\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            output <= 0;\n        else\n            output <= sign ? -input : input;\n    end\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [15:0] output\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            output <= 0;\n        else\n            output <= sign ? ~input + 1 : ~input;\n    end\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [15:0] abs_dividend,\n    input wire [15:0] neg_divisor_mod,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n    reg [2:0] counter;\n    reg [2:0] shift;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_neg_divisor_mod;\n    reg [15:0] temp_quotient;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift <= 0;\n            shifted_dividend <= 0;\n            shifted_neg_divisor_mod <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (opn_valid && !rst) begin\n            counter <= 3;\n            shift <= 0;\n            shifted_dividend <= abs_dividend;\n            shifted_neg_divisor_mod <= neg_divisor_mod;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (counter > 0) begin\n            counter <= counter - 1;\n            shift <= shift + 1;\n            shifted_dividend <= shifted_dividend >> 1;\n            shifted_neg_divisor_mod <= shifted_neg_divisor_mod >> 1;\n            temp_quotient <= shifted_dividend - shifted_neg_divisor_mod;\n            quotient <= (temp_"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Prepare dividend and divisor\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_operation_inst(\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [15:0] divisor   // 16-bit divisor\n);\n    always @(*) begin\n        dividend = {32'b0, A};\n        divisor = B;\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    // Internal variables\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_dividend;\n    reg [15:0] temp_divisor;\n\n    // Calculate the quotient and remainder\n    always @(*) begin\n        // Shift dividend and divisor\n        shifted_dividend = dividend >> 1;\n        shifted_divisor = {divisor, 16'b0};\n\n        quotient = 0;\n        remainder = dividend;\n\n        // Loop to divide the dividend by divisor\n        for (int i = 0; i < 32; i++) begin\n            // Shift dividend\n            temp_dividend = shifted_dividend;\n            shifted_dividend = {shifted_dividend[30:0], 1'b0};\n\n            // Shift divisor\n            temp_divisor = shifted_divisor;\n            shifted_divisor = {shifted_divisor[14:0], 1'b0};\n\n            // Compare divisor with dividend\n            if (temp_dividend >= temp_divisor) begin\n                quotient[i] = 1;\n                remainder = remainder - temp_divisor;\n            end else begin\n                quotient[i] = 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_quo;\n    wire [15:0] temp_rem;\n\n    control_unit ctrl (\n        .dividend(A),\n        .divisor(B),\n        .remainder(temp_rem),\n        .quotient(temp_quo)\n    );\n\n    assign result = temp_quo;\n    assign odd = temp_rem;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] dividend,\n    input wire [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_shifted;\n    reg [15:0] temp_bit;\n    reg [3:0] i;\n\n    always @(*) begin\n        temp_divisor = divisor;\n        temp_dividend = dividend;\n        temp_shifted = {1'b0, dividend[15:1]};\n        temp_bit = {1'b0, dividend[15:1]};\n        quotient = 0;\n        remainder = dividend;\n\n        for (i = 0; i < 16; i = i + 1) begin\n            temp_shifted = temp_shifted << 1;\n            temp_bit = temp_bit << 1;\n\n            if (temp_bit[15:8] == temp_divisor) begin\n                temp_shifted[15] = 1;\n                temp_bit[15] = 0;\n            end\n\n            if (temp_shifted[15]) begin\n                quotient[15-i] = 1;\n                temp_shifted[15] = 0;\n            end\n\n            if (temp_shifted[15] == 0) begin\n                remainder = remainder << 1;\n                remainder[0] = temp_bit[0];\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire borrow;\n\nassign B_comp = ~B + 1;\nassign {borrow, sum} = adder_8bit(A, B_comp);\nassign D = sum;\nassign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, C);\ninput [7:0] A, B;\noutput [7:0] C;\nwire [7:0] sum;\nwire carry;\n\nassign {carry, sum} = full_adder(A[0], B[0], 1'b0);\nassign C[0] = sum;\nassign {carry, sum} = full_adder(A[1], B[1], carry);\nassign C[1] = sum;\nassign {carry, sum} = full_adder(A[2], B[2], carry);\nassign C[2] = sum;\nassign {carry, sum} = full_adder(A[3], B[3], carry);\nassign C[3] = sum;\nassign {carry, sum} = full_adder(A[4], B[4], carry);\nassign C[4] = sum;\nassign {carry, sum} = full_adder(A[5], B[5], carry);\nassign C[5] = sum;\nassign {carry, sum} = full_adder(A[6], B[6], carry);\nassign C[6] = sum;\nassign {carry, sum} = full_adder(A[7], B[7], carry);\nassign C[7] = sum;\n\nendmodule\n\nmodule full_adder(A, B, C, S, C_out);\ninput A, B, C;\noutput S, C_out;\n\nassign S = A ^ B ^ C;\nassign C_out = (A & B) | (B & C) | (C & A);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] A1, B1, Diff1, B_out1;\n    wire [31:0] A2, B2, Diff2, B_out2;\n\n    sub_16bit S1(A[15:0], B[15:0], Diff1, B_out1);\n    sub_16bit S2(A[31:16], B[31:16], Diff2, B_out2);\n\n    assign Diff[15:0] = Diff1;\n    assign Diff[31:16] = Diff2;\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] B1;\n\n    sub_8bit S1(A[7:0], B[7:0], Diff[7:0], B1);\n    sub_8bit S2(A[15:8], B[15:8], Diff[15:8], B_out);\n\n    assign B_out = B1;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [7:0] B1;\n\n    sub_4bit S1(A[3:0], B[3:0], Diff[3:0], B1);\n    sub_4bit S2(A[7:4], B[7:4], Diff[7:4], B_out);\n\n    assign B_out = B1;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [3:0] B1;\n\n    sub_2bit S1(A[1:0], B[1:0], Diff[1:0], B1);\n    sub_2bit S2(A[3:2], B[3:2], Diff[3:2], B_out);\n\n    assign B_out = B1;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [1:0] B1;\n\n    sub_1bit S1(A[0], B[0], Diff[0], B1[0]);\n    sub_1bit S2(A[1], B[1], Diff[1], B1[1]);\n\n    assign B_out = B1;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A, B;\n    output Diff;\n    output B_out;\n\n    assign Diff = A ^ B;\n    assign B_out = (~A & B) | (A & ~B);\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [63:0] D_sub0, D_sub1;\n    wire B_out_sub0, B_out_sub1;\n\n    // Instantiate submodule sub0\n    submodule sub0(\n        .A(A[63:32]), .B(B[63:32]), .D(D_sub0), .B_out(B_out_sub0)\n    );\n\n    // Instantiate submodule sub1\n    submodule sub1(\n        .A(A[31:0]), .B(B[31:0]), .D(D_sub1), .B_out(B_out_sub1)\n    );\n\n    assign D = {D_sub1[31:0], D_sub0[31:0]};\n    assign B_out = B_out_sub1;\nendmodule\n\nmodule submodule(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [31:0] D_sub0, D_sub1;\n    wire B_out_sub0, B_out_sub1;\n\n    // Instantiate submodule sub0\n    submodule_2 sub0(\n        .A(A[15:8]), .B(B[15:8]), .D(D_sub0), .B_out(B_out_sub0)\n    );\n\n    // Instantiate submodule sub1\n    submodule_2 sub1(\n        .A(A[7:0]), .B(B[7:0]), .D(D_sub1), .B_out(B_out_sub1)\n    );\n\n    assign D = {D_sub1[7:0], D_sub0[7:0]};\n    assign B_out = B_out_sub1;\nendmodule\n\nmodule submodule_2(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] D_sub0, D_sub1;\n    wire B_out_sub0, B_out_sub1;\n\n    // Instantiate submodule sub0\n    submodule_3 sub0(\n        .A(A[3:0]), .B(B[3:0]), .D(D_sub0), .B_out(B_out_sub0)\n    );\n\n    // Instantiate submodule sub1\n    submodule_3 sub1(\n        .A(A[3:0]), .B(B[3:0]), .D(D_sub1), .B_out(B_out_sub1)\n    );\n\n    assign D = {D_sub1[3:0], D_sub0[3:0]};\n    assign B_out = B_out_sub1;\nendmodule\n\nmodule submodule_3(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] D_sub0, D_sub1;\n    wire B_out_sub0, B_out_sub1;\n\n    // Instantiate submodule sub0\n    submodule_4 sub0(\n        .A(A[1:0]), .B(B[1:0]), .D(D_sub0), .B_out(B_out_sub0)\n    );\n\n    // Instantiate submodule sub1\n    submodule_4 sub1(\n        .A(A[1:0]), .B(B[1:0]), .D(D_sub1), .B_out(B_out_sub1)\n    );\n\n    assign D = {D_sub1[1:0], D_sub0[1:0]};\n    assign B_out = B_out_sub1;\nendmodule\n\nmodule submodule_4(A, B, D, B_out);\n    input [1:"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A, B;\noutput [16:1] D;\noutput B_out;\n\nwire [3:0] B_in;\nwire [3:0] B_out_temp;\nwire [3:0] B_out_temp2;\n\nwire B_out_temp3;\n\nwire [3:0] D_temp;\n\n\n\nsubtractor_4bit sub1(A[16:1], B[16:1], D_temp, B_in);\nsubtractor_4bit sub2(A[12:4], B[12:4], D_temp[12:4], B_in[3:0]);\nsubtractor_4bit sub3(A[8:8], B[8:8], D_temp[8:8], B_in[2:0]);\nsubtractor_4bit sub4(A[4:4], B[4:4], D_temp[4:4], B_in[1:0]);\n\nassign B_out = B_out_temp3;\nassign D = D_temp;\n\nendmodule\n\nmodule subtractor_4bit(A, B, D, B_out);\ninput [4:1] A, B;\noutput [4:1] D;\noutput B_out;\n\nwire [2:0] B_out_temp;\n\nassign D[4:1] = A[4:1] - B[4:1];\nassign B_out_temp[2:0] = (~(B[4:1] ^ A[4:1])) & (A[4:1] ^ D[4:1]);\nassign B_out = B_out_temp[2];\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff != 0) & (~borrow);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [31:0] C16[1:2];\n    wire [15:0] S16[1:2];\n\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n    // Instance of CLA\n\n    assign C32 = C16[2][15];\n\n    assign S[32:1] = {S16[2][15:0],S16[1][15:0]};\n\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [15:0] A,B;\n    input Cin;\n    output [15:0] S;\n    output Cout;\n\n    wire [14:0] G,P;\n    wire [15:0] X;\n\n    assign X = A ^ B;\n    assign G = A & B;\n    assign P = X | (A & B);\n    assign S = P ^ Cin;\n    assign Cout = (P & Cin) | (G & Cin);\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [15:0] A,B;\n    input Cin;\n    output [15:0] S;\n    output Cout;\n\n    wire [14:0] G,P;\n    wire [15:0] X;\n\n    assign X = A ^ B;\n    assign G = A & B;\n    assign P = X | (A & B);\n    assign S = P ^ Cin;\n    assign Cout = (P & Cin) | (G & Cin);\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3;\n\n    // ripple carry adder for first 4 bits\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c1)\n    );\n\n    // ripple carry adder for second 4 bits\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1[0]),\n        .sum(sum[7:4]),\n        .cout(c2[0])\n    );\n\n    // ripple carry adder for third 4 bits\n    ripple_carry_adder_4bit rca3(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c2[0]),\n        .sum(sum[11:8]),\n        .cout(c2[1])\n    );\n\n    // ripple carry adder for fourth 4 bits\n    ripple_carry_adder_4bit rca4(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c2[1]),\n        .sum(sum[15:12]),\n        .cout(c3[0])\n    );\n\n    // carry select adder for carry-out of the fourth 4-bit ripple carry adder\n    carry_select_adder_4bit csa1(\n        .a(c1[0]),\n        .b(c2[0]),\n        .cin(c3[0]),\n        .sum(c3[1]),\n        .cout(cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] c;\n\n    full_adder_4bit fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c[0])\n    );\n\n    full_adder_4bit fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c[0]),\n        .sum(sum[1]),\n        .cout(c[1])\n    );\n\n    full_adder_4bit fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c[1]),\n        .sum(sum[2]),\n        .cout(c[2])\n    );\n\n    full_adder_4bit fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c[2]),\n        .sum(sum[3]),\n        .cout(c[3])\n    );\n\n    assign cout = c[3];\nendmodule\n\nmodule full_adder_4bit(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign {sum, cout} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n\n    wire [1:0] carry;\n\n    // 8-bit full adder instantiation\n    add8_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n    add8_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    // Final carry out\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Bit-wise adder\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [1:0] c1, c2, c3, c4, c5, c6, c7, c8;\n\n    // Instantiate bit-level full adders for each bit\n    FA FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1[0]));\n    FA FA1(.a(a[1]), .b(b[1]), .cin(c1[0]), .sum(sum[1]), .cout(c1[1]));\n    FA FA2(.a(a[2]), .b(b[2]), .cin(c1[1]), .sum(sum[2]), .cout(c2[0]));\n    FA FA3(.a(a[3]), .b(b[3]), .cin(c2[0]), .sum(sum[3]), .cout(c2[1]));\n    FA FA4(.a(a[4]), .b(b[4]), .cin(c2[1]), .sum(sum[4]), .cout(c3[0]));\n    FA FA5(.a(a[5]), .b(b[5]), .cin(c3[0]), .sum(sum[5]), .cout(c3[1]));\n    FA FA6(.a(a[6]), .b(b[6]), .cin(c3[1]), .sum(sum[6]), .cout(c4[0]));\n    FA FA7(.a(a[7]), .b(b[7]), .cin(c4[0]), .sum(sum[7]), .cout(c4[1]));\n    \n    // Final carry-out\n    assign cout = c4[1];\n    \nendmodule\n\nmodule FA (\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit.\nreg [7:0] shift_cnt;\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        shift_cnt <= 0;\n    else if (start)\n        shift_cnt <= 8;\n    else if (shift_cnt)\n        shift_cnt <= shift_cnt - 1;\nend\n\n// Register Unit.\nreg [15:0] a, b;\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\n// Multiplier Unit.\nreg [31:0] product;\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        product <= 0;\n    else if (start) begin\n        product <= a << shift_cnt;\n        product[shift_cnt +: 16] <= product[shift_cnt +: 16] + b;\n    end\nend\n\n// Output Assignment.\nassign yout = product;\nassign done = !start;\n\nendmodule\n\nmodule ctrl (\n    input clk,      // Chip clock signal.\n    input rst_n,    // Active-low reset signal.\n    input start,    // Chip enable signal.\n    output [7:0] shift_cnt  // Output shift count.\n);\n\nreg [7:0] shift_cnt_r;\n\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        shift_cnt_r <= 0;\n    else if (start)\n        shift_cnt_r <= 8;\n    else if (shift_cnt_r)\n        shift_cnt_r <= shift_cnt_r - 1;\nend\n\nassign shift_cnt = shift_cnt_r;\n\nendmodule\n\nmodule reg_unit (\n    input clk,      // Chip clock signal.\n    input rst_n,    // Active-low reset signal.\n    input start,    // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a,   // Output a (multiplicand) with a data width of 16 bits.\n    output reg [15:0] b    // Output b (multiplier) with a data width of 16 bits.\n);\n\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a <= 0;\n        b <= 0;\n    end else begin\n        a <= ain;\n        b <= bin;\n    end\nend\n\nendmodule\n\nmodule mul_unit (\n    input clk,      // Chip clock signal.\n    input rst_n,    // Active-low reset signal.\n    input start,    // Chip enable signal.\n    input [15:0] a,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product  // Product output with a data width of 32 bits.\n);\n\nreg [15:0] shifted_b;\n\nalways @ (posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        product <= 0;\n    else if (start) begin\n        shifted_b <= b << 1;\n        product[15:0] <= a;\n        product[31:16] <= product[31:16] + shifted_b[15:0];\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    reg [15:0] count_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count_reg <= 0;\n        else\n            count_reg <= up_down ? count_reg + 1 : count_reg - 1;\n    end\n\n    assign count = count_reg;\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count_out <= 0;\n        else\n            count_out <= count;\n    end\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] next_state;\n\n    initial begin\n        out = 8'b0000_0001;\n    end\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= next_state;\n        end\n    end\n\nendmodule\n\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule ring_counter_transition (\n    input wire [7:0] state,\n    input wire clk,\n    output reg [7:0] next_state\n);\n    always @ (posedge clk) begin\n        if (state == 8'b1111_1111) begin\n            next_state <= 8'b0000_0001;\n        end else begin\n            next_state <= state >> 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= (count == 4'd11) ? 4'b0000 : count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(next_Q));\n    JC_logic logic_inst(.clk(clk), .rst_n(rst_n), .Q(Q), .next_Q(next_Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 64'b0;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            next_Q <= 64'b0;\n        else\n            next_Q <= Q ^ (Q << 1);\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Generate 50MHz clock\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    // Generate 10MHz clock\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    // Generate 1MHz clock\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n            CLK_out <= ~CLK_out;\n            if (counter == 4) begin\n                counter <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n            CLK_out <= ~CLK_out;\n            if (counter == 49) begin\n                counter <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [7:0] clk_count;\nwire [7:0] clk_div_4, clk_div_3;\n\n// Counter Submodule\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_count(clk_count)\n);\n\n// Clock Average Generator Submodule\nclk_average u_clk_average(\n    .clk_count(clk_count),\n    .clk_div_4(clk_div_4),\n    .clk_div_3(clk_div_3)\n);\n\n// Clock Adjustment Submodule\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .clk_div_4(clk_div_4),\n    .clk_div_3(clk_div_3),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Counter Submodule\n//------------------------------------------------------------------------------\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [7:0]    clk_count\n);\n\nlocalparam MAX_COUNT = 8'hFF;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_count <= 0;\n    end else if (clk_count < MAX_COUNT) begin\n        clk_count <= clk_count + 1;\n    end\nend\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Clock Average Generator Submodule\n//------------------------------------------------------------------------------\nmodule clk_average(\n    input [7:0]         clk_count,\n    output reg [7:0]    clk_div_4,\n    output reg [7:0]    clk_div_3\n);\n\nlocalparam CLK_PERIOD_4 = 24;\nlocalparam CLK_PERIOD_3 = 18;\n\nalways @(clk_count) begin\n    if (clk_count % CLK_PERIOD_4 == 0) begin\n        clk_div_4 <= 1;\n    end else begin\n        clk_div_4 <= 0;\n    end\n    \n    if (clk_count % CLK_PERIOD_3 == 0) begin\n        clk_div_3 <= 1;\n    end else begin\n        clk_div_3 <= 0;\n    end\nend\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Clock Adjustment Submodule\n//------------------------------------------------------------------------------\nmodule clk_adjustment(\n    input               clk,\n    input [7:0]         clk_div_4,\n    input [7:0]         clk_div_3,\n    output reg          clk_div\n);\n\nalways @(posedge clk) begin\n    clk_div <= clk_div_3 | clk_div_4;\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1, clk_div2;\n\npos_edge_counter u_pos_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter < NUM_DIV - 1) begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div = (counter == NUM_DIV - 1);\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nreg [3:0] counter;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n    end else if (counter < NUM_DIV - 1) begin\n        counter <= counter + 1;\n    end\nend\n\nassign clk_div = (counter == NUM_DIV - 1);\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\nparameter NUM_DIV = 10;\n\nwire [3:0] counter;\nwire [3:0] counter_next;\n\nreg [3:0] counter_reg;\n\nassign counter = counter_reg;\nassign clk_div = counter == (NUM_DIV / 2 - 1);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter_reg <= 0;\n    else\n        counter_reg <= counter_next;\nend\n\nassign counter_next = (counter == (NUM_DIV / 2 - 1)) ? 0 : counter + 1;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input clk_div,\n    output reg out\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        out <= 0;\n    else\n        out <= ~out;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter <= 0;\n    else if (counter == (2 - 1))\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] r_add, r_sub, r_and, r_or, r_xor, r_nor;\n    wire carry_add, carry_sub, carry_and, carry_or, carry_xor, carry_nor;\n    wire overflow_add, overflow_sub, overflow_and, overflow_or, overflow_xor, overflow_nor;\n    wire [31:0] r_slt, r_sltu;\n    wire flag_slt, flag_sltu;\n\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(r_add),\n        .carry(carry_add)\n    );\n\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(r_add),\n        .carry(carry_add)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(r_sub),\n        .carry(carry_sub)\n    );\n\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(r_sub),\n        .carry(carry_sub)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(r_and),\n        .carry(carry_and)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(r_or),\n        .carry(carry_or)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(r_xor),\n        .carry(carry_xor)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(r_nor),\n        .carry(carry_nor)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(r_slt),\n        .overflow(overflow_slt)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(r_sltu),\n        .overflow(overflow_sltu)\n    );\n\n    assign {overflow, r} = (aluc == 6'b101010) ? r_slt : (aluc == 6'b101011) ? r_sltu : (aluc == 6'b000000) ? {31'b0, (a << b)} : (aluc == 6'b000010) ? {31'b0, (a >> b)} : (aluc == 6'b000011) ? {31'b0, (a >>> b)} : (aluc == 6'b000100) ? {31'b0, (a << b)} : (aluc == 6'b000110) ? {31'b0, (a >> b)} : (aluc == 6'b000111) ? {31'b0, (a >>> b)} : (aluc == 6'b100000) ? r_add : (aluc == 6'b100001) ? r_add : (aluc == 6'b100010) ? r_sub : (aluc == 6'b100011) ? r_sub : (aluc == 6'b100100) ? r_and : (aluc == 6'b100101) ? r_or : (aluc == 6'b100110) ? r_xor : (aluc == 6'b100111) ? r_nor : 32'b0;\n    assign {zero, carry, negative} = (aluc == 6'b101010) ? {1'b0, carry_add, (r"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\nwire [31:0] mult_result;\nwire [31:0] current_value;\n\n// Multiplier\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .m(mult_result)\n);\n\n// Accumulator\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .m(mult_result),\n    .current_value(current_value)\n);\n\n// Output\nassign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] m\n);\nassign m = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] m,\n    output reg [31:0] current_value\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        current_value <= 0;\n    else\n        current_value <= current_value + m[31:0];\nend\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [4:0] ad1_p1, ad2_p1;\n    wire [7:0] ins_p1, ad1_p2, ad2_p2;\n\n    // Instr_p1\n    ins_reg ins_p1_m (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n    // Instr_p2\n    ins_reg ins_p2_m (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            if (fetch[0]) begin\n                ins <= ins_p1;\n                ad1 <= ad1_p1;\n                ad2 <= ad2_p1;\n            end else if (fetch[1]) begin\n                ins <= ins_p2;\n                ad1 <= ad1_p2;\n                ad2 <= ad2_p2;\n            end else begin\n                ins <= ins;\n                ad1 <= ad1;\n                ad2 <= ad2;\n            end\n        end\n    end\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 0;\n            ad1_reg <= 0;\n            ad2_reg <= 0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n\n    wire [7:0] count;\n    wire enable;\n\n    wire [7:0] freq_inv;\n    assign freq_inv = (freq == 0) ? 0 : (8'hFF / freq);\n\n    counter cnt(.clk(clk), .enable(enable), .freq(freq_inv), .count(count));\n    wave_generator wg(.clk(clk), .count(count), .freq(freq), .wave_out(wave_out));\n    assign enable = (freq != 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count == (freq - 1)) begin\n            wave_out <= 1;\n        end else begin\n            wave_out <= 0;\n        end\n    end\nendmodule\n"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state_reg, state_next;\n    reg [4:0] wave_reg, wave_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            state_reg <= state_next;\n            wave_reg <= wave_next;\n        end\n    end\n\n    always @(*) begin\n        case (state_reg)\n            2'b00: begin\n                wave_next = wave_reg + 1;\n                if (wave_next == 5'b10000)\n                    state_next = 2'b01;\n                else\n                    state_next = 2'b00;\n            end\n            2'b01: begin\n                wave_next = wave_reg - 1;\n                if (wave_next == 5'b00000)\n                    state_next = 2'b10;\n                else\n                    state_next = 2'b01;\n            end\n            2'b10: begin\n                wave_next = wave_reg + 1;\n                if (wave_next == 5'b10000)\n                    state_next = 2'b00;\n                else\n                    state_next = 2'b10;\n            end\n            default: begin\n                wave_next = wave_reg;\n                state_next = state_reg;\n            end\n        endcase\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n    reg [4:0] wave_reg, wave_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b00000;\n        end else begin\n            wave_reg <= wave_next;\n        end\n    end\n\n    always @(*) begin\n        case (wave_reg)\n            5'b00000: wave_next = 5'b00001;\n            5'b00001: wave_next = 5'b00010;\n            5'b00010: wave_next = 5'b00011;\n            5'b00011: wave_next = 5'b00100;\n            5'b00100: wave_next = 5'b00101;\n            5'b00101: wave_next = 5'b00110;\n            5'b00110: wave_next = 5'b00111;\n            5'b00111: wave_next = 5'b01000;\n            5'b01000: wave_next = 5'b01001;\n            5'b01001: wave_next = 5'b01010;\n            5'b01010: wave_next = 5'b01011;\n            5'b01011: wave_next = 5'b01100;\n            5'b01100: wave_next = 5'b01101;\n            5'b01101: wave_next = 5'b01110;\n            5'b01110: wave_next = 5'b01111;\n            5'b01111: wave_next = 5'b10000;\n            5'b10000: wave_next = 5'b10001;\n            5'b10001: wave_next = 5'b10010;\n            5'b10010: wave_next = 5'b10011;\n            5'b10011: wave_"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] u0, u1, u2;\n\n    my_dff8 u0_inst (\n        .clk(clk),\n        .d(d[0]),\n        .q(u0)\n    );\n\n    my_dff8 u1_inst (\n        .clk(clk),\n        .d(u0),\n        .q(u1)\n    );\n\n    my_dff8 u2_inst (\n        .clk(clk),\n        .d(u1),\n        .q(u2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= u2;\n            2'b01: q <= u1;\n            2'b10: q <= u0;\n            2'b11: q <= d;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux4to1 (\n    input [1:0] sel,\n    input [3:0] in,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q0, q1, q2;\n\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    wire [7:0] mux3_out;\n    \n    // 1st stage\n    wire [3:0] sel;\n    assign sel[3:0] = {ctrl[2], ctrl[1], ctrl[0], 1'b0};\n    \n    mux2X1 mux1 (.in1(in), .in2(mux1_out), .sel(sel), .out(mux2_out));\n    \n    // 2nd stage\n    mux2X1 mux2 (.in1(mux2_out), .in2(mux3_out), .sel(sel), .out(mux3_out));\n    \n    // 3rd stage\n    mux2X1 mux3 (.in1(mux3_out), .in2(mux3_out), .sel(sel), .out(out));\nendmodule\n\nmodule mux2X1 (in1, in2, sel, out);\n    input [7:0] in1, in2;\n    input [3:0] sel;\n    output [7:0] out;\n    \n    assign out = sel[3] ? in2 : in1;\n    assign out = sel[2] ? (sel[1] ? out[7:4] : out[3:0]) : out;\n    assign out = sel[1] ? (sel[0] ? out[7:4] : out[3:0]) : out;\n    assign out = sel[0] ? out[7:4] : out[3:0];\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n\n  wire [15:0] b1;\n  reg [31:0] c0_reg, c1_reg;\n  reg [15:0] b0_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      c0_reg <= 0;\n      c1_reg <= 0;\n      b0_reg <= 0;\n    end else begin\n      c0_reg <= b0_reg * a0;\n      c1_reg <= b1 * a1;\n      b0_reg <= b0;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      c_reg <= 0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] fetched_instr;\n  wire [31:0] decoded_instr;\n  wire [31:0] executed_result;\n  wire [31:0] memory_result;\n  wire [31:0] writeback_result;\n  wire [31:0] pc;\n  wire [4:0] rd;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [3:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .fetched_instr(fetched_instr)\n  );\n  decode_stage decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .decoded_instr(decoded_instr)\n  );\n  execute_stage execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .decoded_instr(decoded_instr),\n    .reg_file(reg_file),\n    .executed_result(executed_result)\n  );\n  memory_stage memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .executed_result(executed_result),\n    .memory_result(memory_result)\n  );\n  writeback_stage writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .memory_result(memory_result),\n    .writeback_result(writeback_result)\n  );\n\n  // Connect pipeline stages\n  assign pc = fetch_stage.pc;\n  assign rd = decode_stage.rd;\n  assign rs1 = decode_stage.rs1;\n  assign rs2 = decode_stage.rs2;\n  assign op = decode_stage.op;\n  assign res_reg_file[rd] = writeback_stage.writeback_result;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] fetched_instr\n);\n  reg [31:0] next_pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      next_pc <= 0;\n    else\n      next_pc <= pc + 1;\n  end\n\n  assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [31:0] decoded_instr\n);\n  reg [31:0] decoded_instr_reg;\n  reg [31:0] pc;\n  reg [4:0] rd;\n  reg [4:0] rs1;\n  reg [4:0] rs2;\n  reg [3:0] op;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      decoded_instr_reg <= 0;\n      pc <= 0;\n      rd <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      op <= 0;\n    end else begin\n      rd <= fetched_instr[11:7];\n      rs1 <= fetched_instr[19:15];\n      rs2 <= fetched_instr[24:20];\n      op <= fetched_instr[31:27];\n      decoded_instr_reg <= {fetched_instr[31], fetched_instr[7], fetched_instr[30:25], fetched_instr[11:8], 1'b0, fetched_instr[4:0]};\n      pc <= pc + 1;\n    end\n  end\n\n  assign dec"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0;\n      b2_reg <= b0;\n    end\n  end\n\n  PE pe0(a0, b0, c0);\n  PE pe1(a1, b1, c1);\n  PE pe2(a2, b2, c2);\n  PE pe3(a3, b3, c3);\nendmodule\n\nmodule PE(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] pc;\n    wire [31:0] op1, op2, op3;\n    wire [4:0] rd;\n    wire [3:0] funct;\n    wire [31:0] instr;\n    wire [31:0] res;\n\n    stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .pc(pc),\n        .instr(instr)\n    );\n\n    stage execute(\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .op1(op1),\n        .op2(op2),\n        .op3(op3),\n        .rd(rd),\n        .funct(funct),\n        .res(res)\n    );\n\n    stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .res(res),\n        .rd(rd),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output reg [31:0] pc,\n    output reg [31:0] instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            pc <= 0;\n            instr <= 0;\n        end else begin\n            instr <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    input [31:0] pc,\n    output reg [31:0] instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            instr <= 0;\n        end else begin\n            instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] op3,\n    output reg [4:0] rd,\n    output reg [3:0] funct,\n    output reg [31:0] res\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            op3 <= 0;\n            rd <= 0;\n            funct <= 0;\n            res <= 0;\n        end else begin\n            op1 <= reg_file[instr[25:21]];\n            op2 <= reg_file[instr[20:16]];\n            op3 <= instr[15:0];\n            rd <= instr[11:7];\n            funct <= instr[5:0];\n            if(funct == 0) begin\n                res <= op1 + op2;\n            end else if(funct == 1) begin\n                res <= op1 - op2;\n            end else begin\n                res <= op1 + op2;\n            end\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] res,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            out_reg_file <= 0;\n        end else"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                    valid_input;\n    wire      [7:0]         data_accumulator;\n    wire                    ready_for_output;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .valid_output(ready_for_output)\n    );\n\n    data_accumulator u_data_accumulator (\n        .valid_input(valid_input),\n        .data_input(data_in),\n        .data_output(data_accumulator)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_input(valid_input),\n        .ready_for_output(ready_for_output),\n        .valid_output(valid_out),\n        .data_output(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg          valid_output\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            valid_output <= 0;\n        end else if (valid_in) begin\n            if (count == 2) begin\n                valid_output <= 1;\n            end\n            count <= count + 1;\n        end else begin\n            count <= 0;\n            valid_output <= 0;\n        end\n    end\nendmodule\n\nmodule data_accumulator (\n    input               valid_input,\n    input       [7:0]   data_input,\n    output reg  [7:0]   data_output\n);\n\n    always @(posedge valid_input) begin\n        data_output <= data_output + data_input;\n    end\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_input,\n    input               ready_for_output,\n    output reg          valid_output,\n    output reg  [9:0]   data_output\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_output <= 0;\n            data_output <= 0;\n        end else if (valid_input) begin\n            if (ready_for_output) begin\n                valid_output <= 1;\n                data_output <= data_output[7:0];\n            end\n        end else begin\n            valid_output <= 0;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    assign result = quotient | remainder;\n\n    // Absolute value calculation\n    abs_value abs_dividend(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .data_in(dividend),\n        .data_out(remainder)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .data_in(divisor),\n        .data_out(quotient)\n    );\n\n    // Division control logic\n    divider_control ctrl(\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result management\n    result_management res_mgmt(\n        .clk(clk),\n        .rst(rst),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= data_in;\n        else if (sign)\n            data_out <= ~data_in + 1;\n        else\n            data_out <= data_in;\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= data_in;\n        else if (sign)\n            data_out <= ~data_in + 1;\n        else\n            data_out <= data_in;\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] quotient_out,\n    output reg [15:0] remainder_out\n);\n\n    reg [3:0] ctr;\n    reg [15:0] shift_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            begin\n                ctr <= 0;\n                shift_reg <= 0;\n            end\n        else if (opn_valid)\n            begin\n                ctr <= 4'd1;\n                shift_reg <= {quotient[15], remainder[15], quotient[14:8], remainder[7:0]};\n            end\n        else if (!res_ready)\n            begin\n                ctr <= ctr + 4'd1;\n                shift_reg <= {shift_reg[15], shift_reg[14], shift_reg[13], shift_reg[12], shift_reg[11], shift_reg[10], shift_reg[9], shift_reg[8], shift_reg[7], shift_reg[6], shift_reg[5], shift_reg[4], shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]};\n            end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            begin\n                quotient_out <= 0;\n                remainder_out <= 0;\n            end\n        else if (ctr == 4'd16)\n            begin\n                quotient_out <= shift_reg[15:8];\n                remainder_out <= shift_reg["}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    // Instantiate submodules\n    prep_dividend prep_dividend_inst(\n        .A(A),\n        .B(B),\n        .A_prep(A_prep),\n        .B_prep(B_prep)\n    );\n\n    div_op div_op_inst(\n        .A_prep(A_prep),\n        .B_prep(B_prep),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [63:0] A_prep, // 64-bit prepared dividend\n    output wire [15:0] B_prep  // 16-bit prepared divisor\n);\n    // Change bit widths to 64-bit\n    assign A_prep = {A, 28'd0};\n    assign B_prep = {B, 16'd0};\nendmodule\n\nmodule div_op(\n    input wire [63:0] A_prep, // 64-bit prepared dividend\n    input wire [15:0] B_prep,  // 16-bit prepared divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    wire [63:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    wire [5:0] i;\n\n    // Shift dividend\n    assign dividend = A_prep >> 16;\n\n    // Initialize quotient and remainder\n    assign quotient = 32'd0;\n    assign remainder = 32'd0;\n\n    // Compare and update quotient and remainder\n    for (i = 0; i < 32; i = i + 1) begin\n        if (dividend >= B_prep) begin\n            dividend = dividend - B_prep;\n            quotient = quotient + (1 << i);\n        end\n    end\n\n    // Remainder calculation\n    assign remainder = dividend;\n\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Control unit\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n    reg [15:0] dividend, quotient, remainder;\n\n    // Dividend shifter\n    always @(*) begin\n        dividend = A;\n    end\n\n    // Division algorithm\n    always @(*) begin\n        quotient = 0;\n        remainder = 0;\n        for (int i = 15; i >= 0; i--) begin\n            remainder = remainder << 1;\n            remainder[0] = dividend[15];\n            dividend = dividend << 1;\n            if (remainder >= B) begin\n                remainder = remainder - B;\n                quotient = quotient << 1;\n                quotient[0] = 1;\n            end\n        end\n    end\n\n    // Output ports\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [6:0] carry;\n\nassign B_comp = ~B + 1;\n\nadder_8bit adder_inst(\n    .A(A),\n    .B(B_comp),\n    .D(D),\n    .carry_out(carry)\n);\n\nassign B_out = carry[6];\n\nendmodule\n\nmodule adder_8bit(A, B, D, carry_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput [6:0] carry_out;\n\nwire [6:0] carry;\n\nfull_adder FA0 (.A(A[0]), .B(B[0]), .Cin(0), .Sum(D[0]), .Cout(carry[0]));\nfull_adder FA1 (.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(D[1]), .Cout(carry[1]));\nfull_adder FA2 (.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(D[2]), .Cout(carry[2]));\nfull_adder FA3 (.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(D[3]), .Cout(carry[3]));\nfull_adder FA4 (.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(D[4]), .Cout(carry[4]));\nfull_adder FA5 (.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(D[5]), .Cout(carry[5]));\nfull_adder FA6 (.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(D[6]), .Cout(carry[6]));\nfull_adder FA7 (.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(D[7]), .Cout(carry_out[6]));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\ninput A, B, Cin;\noutput Sum, Cout;\n\nassign Sum = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1_out, S2_out;\n\n    // Replace the placeholders with instantiation of the missing modules\n    // sub_16bit\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out()\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out()\n    );\n\n    // Concatenate the outputs to form the difference\n    assign Diff = {S2_out, S1_out};\nendmodule\n\n// Placeholder for missing module\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [15:0] D;\n\n    assign D = A - B;\n    assign Diff = D;\n    assign B_out = (D[15] == 1) ? 1 : 0;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub_32bit sub0(\n    .A(A[31:0]), .B(B[31:0]), .D(sub0_D), .B_out(sub0_B_out)\n);\nsub_32bit sub1(\n    .A(A[63:32]), .B(B[63:32]), .D(sub1_D), .B_out(sub1_B_out)\n);\n\nassign D = {sub1_D, sub0_D};\nassign B_out = sub1_B_out | sub0_B_out;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub_16bit sub0(\n    .A(A[15:0]), .B(B[15:0]), .D(sub0_D), .B_out(sub0_B_out)\n);\nsub_16bit sub1(\n    .A(A[31:16]), .B(B[31:16]), .D(sub1_D), .B_out(sub1_B_out)\n);\n\nassign D = {sub1_D, sub0_D};\nassign B_out = sub1_B_out | sub0_B_out;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub_8bit sub0(\n    .A(A[7:0]), .B(B[7:0]), .D(sub0_D), .B_out(sub0_B_out)\n);\nsub_8bit sub1(\n    .A(A[15:8]), .B(B[15:8]), .D(sub1_D), .B_out(sub1_B_out)\n);\n\nassign D = {sub1_D, sub0_D};\nassign B_out = sub1_B_out | sub0_B_out;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire C1, C2, B_out_int;\n\nfull_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(D[0]), .Cout(C1));\nfull_adder FA1(.A(A[1]), .B(B[1]), .Cin(C1), .Sum(D[1]), .Cout(C2));\nfull_adder FA2(.A(A[2]), .B(B[2]), .Cin(C2), .Sum(D[2]), .Cout(C1));\nfull_adder FA3(.A(A[3]), .B(B[3]), .Cin(C1), .Sum(D[3]), .Cout(C2));\nfull_adder FA4(.A(A[4]), .B(B[4]), .Cin(C2), .Sum(D[4]), .Cout(C1));\nfull_adder FA5(.A(A[5]), .B(B[5]), .Cin(C1), .Sum(D[5]), .Cout(C2));\nfull_adder FA6(.A(A[6]), .B(B[6]), .Cin(C2), .Sum(D[6]), .Cout(C1));\n"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A;\n    input [16:1] B;\n    output [16:1] D;\n    output B_out;\n    \n    wire [3:1] B_sub;\n    wire B_sub_out;\n    wire B_out_sub;\n    \n    // Instance of 4-bit full subtractor block for A[3:0]\n    full_subtractor_4bit fs_A(\n        .A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_sub)\n    );\n    \n    // Instance of 4-bit full subtractor block for A[7:4]\n    full_subtractor_4bit fs_A_7_4(\n        .A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(B_sub_out)\n    );\n    \n    // Instance of 4-bit full subtractor block for A[11:8]\n    full_subtractor_4bit fs_A_11_8(\n        .A(A[11:8]), .B(B[11:8]), .D(D[11:8]), .B_out(B_sub_out)\n    );\n    \n    // Instance of 4-bit full subtractor block for A[15:12]\n    full_subtractor_4bit fs_A_15_12(\n        .A(A[15:12]), .B(B[15:12]), .D(D[15:12]), .B_out(B_sub_out)\n    );\n    \n    // Instance of 4-bit full subtractor block for B[3:0]\n    full_subtractor_4bit fs_B_3_0(\n        .A(B[3:0]), .B(A[3:0]), .D(D[3:0]), .B_out(B_out_sub)\n    );\n    \n    // Instance of 4-bit full subtractor block for B[7:4]\n    full_subtractor_4bit fs_B_7_4(\n        .A(B[7:4]), .B(A[7:4]), .D(D[7:4]), .B_out(B_out_sub)\n    );\n    \n    // Instance of 4-bit full subtractor block for B[11:8]\n    full_subtractor_4bit fs_B_11_8(\n        .A(B[11:8]), .B(A[11:8]), .D(D[11:8]), .B_out(B_out_sub)\n    );\n    \n    // Instance of 4-bit full subtractor block for B[15:12]\n    full_subtractor_4bit fs_B_15_12(\n        .A(B[15:12]), .B(A[15:12]), .D(D[15:12]), .B_out(B_out_sub)\n    );\n    \n    // Instance of 4-bit full subtractor block for B_sub\n    full_subtractor_4bit fs_B_sub(\n        .A(B_sub), .B(B_out_sub), .D(B_out), .B_out(1'b0)\n    );\n    \nendmodule\n\nmodule full_subtractor_4bit(A, B, D, B_out);\n    input [3:1] A;\n    input [3:1] B;\n    output [3:1] D;\n    output B_out;\n    \n    wire [4:2] C_out;\n    wire [4:2] D_out;\n    wire C_in;\n    \n    // Instance of the Borrow-Lookahead Subtractor (BLS)\n    bls BLS(\n        .A(A), .B(B), .C_out(C_out), .D_out(D_out), .C_in(C_in)\n    );\n    \n    assign D = D_out;\n    assign"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n\n    wire [31:0] sum;\n\n    assign {borrow, sum} = A + B;\n    assign diff = (borrow) ? A - B : sum;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n    \n    wire [15:0] S16 [1:2];\n    wire C16 [1:2];\n\n    // Instantiate 16-bit CLA\n    CLA1 CLA1(.A(A[31:16]), .B(B[31:16]), .S(S16[1]), .C(C16[1]));\n    CLA2 CLA2(.A(A[15:0]), .B(B[15:0]), .S(S16[2]), .C(C16[2]));\n\n    // Add 16-bit CLA outputs\n    assign S[31:16] = S16[1] + S16[2];\n    assign C32 = C16[1] | C16[2];\n\nendmodule\n\nmodule CLA1(A,B,S,C);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] S;\n    output C;\n\n    wire [15:0] G;\n    wire [14:0] P;\n    wire [14:0] G_B;\n    wire [14:0] P_B;\n\n    // Generate partial carry\n    assign G[14:0] = A[14:0] & B[14:0];\n    assign P[14:0] = A[14:0] ^ B[14:0];\n\n    // Prefix sum\n    assign S[14:0] = P[14:0] + G[14:0];\n\n    // Generate carry\n    assign G_B[13:0] = G[13:0] | P[14:1];\n    assign P_B[13:0] = P[13:0] ^ P[14:1];\n    assign C = |G_B[13:0] | P_B[13:0];\n\nendmodule\n\nmodule CLA2(A,B,S,C);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] S;\n    output C;\n\n    wire [15:0] G;\n    wire [14:0] P;\n    wire [14:0] G_B;\n    wire [14:0] P_B;\n\n    // Generate partial carry\n    assign G[14:0] = A[14:0] & B[14:0];\n    assign P[14:0] = A[14:0] ^ B[14:0];\n\n    // Prefix sum\n    assign S[14:0] = P[14:0] + G[14:0];\n\n    // Generate carry\n    assign G_B[13:0] = G[13:0] | P[14:1];\n    assign P_B[13:0] = P[13:0] ^ P[14:1];\n    assign C = |G_B[13:0] | P_B[13:0];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] cin_slice;\n    wire [3:0] sum_slice;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : carry_select_adder_slices\n            ripple_carry_adder_4bit rca1(.a(a[4*i +: 4]), .b(b[4*i +: 4]), .cin(cin_slice[i]), .sum(sum_slice[i]), .cout(cin_slice[i+1]));\n        end\n    endgenerate\n\n    assign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n    assign cout = cin_slice[3];\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] sum_slice;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : ripple_carry_adder_slices\n            full_adder fa(.a(a[i]), .b(b[i]), .cin(cin), .sum(sum_slice[i]), .cout(cout));\n        end\n    endgenerate\n\n    assign sum = sum_slice;\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] sum_slice, carry_slice;\n\n    genvar i;\n    generate\n        for (i = 0; i < 3; i = i + 1) begin : carry_select_slices\n            full_adder fa(.a(a[i]), .b(b[i]), .cin(carry_slice[i]), .sum(sum_slice[i]), .cout(carry_slice[i+1]));\n        end\n    endgenerate\n\n    assign sum = {sum_slice[2:0], cin};\n    assign cout = carry_slice[3];\nendmodule\n\nmodule carry_select_adder_3bit(a, b, cin, sum, cout);\n    input [2:0] a, b;\n    input cin;\n    output [2:0] sum;\n    output cout;\n\n    wire [2:0] sum_slice, carry_slice;\n\n    genvar i;\n    generate\n        for (i = 0; i < 2; i = i + 1) begin : carry_select_slices\n            full_adder fa(.a(a[i]), .b(b[i]), .cin(carry_slice[i]), .sum(sum_slice[i]), .cout(carry_slice[i+1]));\n        end\n    endgenerate\n\n    assign sum = {sum_slice[1:0], cin};\n    assign cout = carry_slice[2];\nendmodule\n\nmodule carry_select_adder_2bit(a, b, cin, sum, cout);\n    input [1:0] a, b;\n    input cin;\n    output [1:0] sum;\n    output cout;\n\n    wire [1:0] sum_slice, carry_slice;\n\n    genvar i;\n    generate\n        for (i = 0; i < 1; i = i + 1) begin : carry_select_slices\n            full_adder fa(.a(a[i]), .b(b[i]), .cin(carry_slice[i]), .sum(sum_slice"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] y0, y1, y2, y3, y4, y5, y6, y7;\n    wire Co0, Co1, Co2, Co3, Co4, Co5, Co6, Co7;\n\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y0),\n        .Co(Co0)\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co0),\n        .y(y1),\n        .Co(Co1)\n    );\n    add8 add8_inst3 (\n        .a(a[15:8]),\n        .b(b[7:0]),\n        .Cin(Co1),\n        .y(y2),\n        .Co(Co2)\n    );\n    add8 add8_inst4 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co2),\n        .y(y3),\n        .Co(Co3)\n    );\n    add8 add8_inst5 (\n        .a(a[15:8]),\n        .b(b[7:0]),\n        .Cin(Co3),\n        .y(y4),\n        .Co(Co4)\n    );\n    add8 add8_inst6 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co4),\n        .y(y5),\n        .Co(Co5)\n    );\n    add8 add8_inst7 (\n        .a(a[15:8]),\n        .b(b[7:0]),\n        .Cin(Co5),\n        .y(y6),\n        .Co(Co6)\n    );\n    add8 add8_inst8 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co6),\n        .y(y7),\n        .Co(Co7)\n    );\n\n    assign y = {y7, y6, y5, y4, y3, y2, y1, y0};\n    assign Co = Co7;\nendmodule\n\nmodule add8(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] C;\n    assign C = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\n    assign y = a ^ b ^ C;\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n\n    wire [6:0] carry;\n    wire [7:0] sum_bit;\n\n    adder FA0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum_bit[0]),\n        .cout(carry[0])\n    );\n    adder FA1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum_bit[1]),\n        .cout(carry[1])\n    );\n    adder FA2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum_bit[2]),\n        .cout(carry[2])\n    );\n    adder FA3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum_bit[3]),\n        .cout(carry[3])\n    );\n    adder FA4 (\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum_bit[4]),\n        .cout(carry[4])\n    );\n    adder FA5 (\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum_bit[5]),\n        .cout(carry[5])\n    );\n    adder FA6 (\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum_bit[6]),\n        .cout(carry[6])\n    );\n    adder FA7 (\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum_bit[7]),\n        .cout(cout)\n    );\n\n    assign sum = sum_bit;\nendmodule\n\nmodule adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nwire [3:0] shift_count;\nreg [3:0] shift_count_reg;\nwire [3:0] shift_count_next;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count_reg <= 4'b0000;\n    end else begin\n        shift_count_reg <= shift_count_next;\n    end\nend\n\nalways @(*) begin\n    case (shift_count_reg)\n        4'b0000: shift_count_next = start ? 4'b0001 : 4'b0000;\n        4'b0001: shift_count_next = 4'b0010;\n        4'b0010: shift_count_next = 4'b0100;\n        4'b0100: shift_count_next = 4'b1000;\n        4'b1000: shift_count_next = 4'b0000;\n        default: shift_count_next = 4'bxxxx;\n    endcase\nend\n\nwire [15:0] product;\n\n// Register Unit\nreg [15:0] multiplicand;\nreg [15:0] multiplier;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        multiplicand <= 16'b0000000000000000;\n        multiplier <= 16'b0000000000000000;\n    end else begin\n        if (start) begin\n            multiplicand <= ain;\n            multiplier <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [31:0] product_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product_reg <= 32'b00000000000000000000000000000000;\n    end else begin\n        case (shift_count_reg)\n            4'b0000: product_reg <= product_reg;\n            4'b0001: product_reg <= product_reg + (multiplier << 0);\n            4'b0010: product_reg <= product_reg + (multiplier << 1);\n            4'b0100: product_reg <= product_reg + (multiplier << 2);\n            4'b1000: product_reg <= product_reg + (multiplier << 3);\n            default: product_reg <= 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;\n        endcase\n    end\nend\n\nassign yout = product_reg;\nassign done = shift_count_reg == 4'b1000;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [3:0] shift_count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 4'b0000;\n    end else begin\n        if (start) begin\n            shift_count <= 4'b0001;\n        end\n    end\nend\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] multiplicand,\n    output reg [15:0] multiplier\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        multiplicand <= 16'b0000000000000000;\n        multiplier <= 16'b0000000000000000;\n    end else begin"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\nwire [15:0] current_count;\n\n// counter_logic\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .current_count(current_count),\n    .next_count(next_count)\n);\n\n// counter_register\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .current_count(current_count),\n    .count(count)\n);\n\nendmodule\n\n// counter_logic\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output wire [15:0] next_count\n);\n\nassign next_count = up_down ? current_count + 1 : current_count - 1;\n\nendmodule\n\n// counter_register\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    input wire [15:0] current_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    // Instantiate submodules\n    initial_state init (\n        .reset(reset),\n        .out(out)\n    );\n    transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(out)\n    );\n\nendmodule\n\n// Initial state\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\n\nendmodule\n\n// State transition\nmodule transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= (out == 8'b1111_1110) ? 8'b0000_0001 : out << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n\n    wire [3:0] count_out;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'b1111) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!valid_count) begin\n            out <= count_out;\n        end else begin\n            out <= out;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\n    wire [63:0] next_Q;\n\n    JC_register reg_inst(.clk(clk), .rst_n(rst_n), .Q(Q), .next_Q(next_Q));\n\n    JC_logic logic_inst(.Q(Q), .next_Q(next_Q));\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n)\n    begin\n        if (!rst_n)\n            next_Q <= 64'b0;\n        else\n            next_Q <= Q;\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]         Q,\n    input [63:0]         next_Q,\n    output [63:0]        next_Q\n);\n\n    always @(*)\n    begin\n        next_Q[0] = Q[63];\n        next_Q[63:1] = Q[62:0];\n    end\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire CLK_50_en, CLK_10_en, CLK_1_en;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50),\n        .en(CLK_50_en)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10),\n        .en(CLK_10_en)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1),\n        .en(CLK_1_en)\n    );\n\n    assign CLK_50_en = 1;\n    assign CLK_10_en = 1;\n    assign CLK_1_en = 1;\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out,\n    input en\n);\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else if (en) begin\n            if (cnt == 2'b10) begin\n                cnt <= 0;\n                CLK_out <= ~CLK_out;\n            end else\n                cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out,\n    input en\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else if (en) begin\n            if (cnt == 3'b100) begin\n                cnt <= 0;\n                CLK_out <= ~CLK_out;\n            end else\n                cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out,\n    input en\n);\n    reg [4:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else if (en) begin\n            if (cnt == 5'b10010) begin\n                cnt <= 0;\n                CLK_out <= ~CLK_out;\n            end else\n                cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [2:0] cnt_value;\n\nassign clk_div = clk_div_int0 | clk_div_int1;\n\nwire clk_div_int0, clk_div_int1;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_value(cnt_value)\n);\n\nclk_average u_clk_average(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_value(cnt_value),\n    .clk_div(clk_div_int0)\n);\n\nclk_adjustment u_clk_adjustment(\n    .clk_div(clk_div_int1)\n);\n\nor gate_or (\n    .a(clk_div_int0),\n    .b(clk_div_int1),\n    .out(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [2:0]    count_value\n);\n\nlocalparam MUL2_DIV_CLK = 7;\n\nparameter MAX_CNT = 2'b111;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_value <= 0;\n    end else if (count_value == MAX_CNT) begin\n        count_value <= 0;\n    end else begin\n        count_value <= count_value + 1'b1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [2:0]         clk_value,\n    output              clk_div\n);\n\nlocalparam MUL2_DIV_CLK = 7;\n\nreg [2:0] clk_div_value;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div_value <= 0;\n    end else begin\n        clk_div_value <= clk_value;\n    end\nend\n\nassign clk_div = (clk_div_value == 3'b111);\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk_div,\n    output reg          clk_div_int0,\n    output reg          clk_div_int1\n);\n\nalways @(negedge clk_div) begin\n    clk_div_int0 <= ~clk_div;\n    clk_div_int1 <= clk_div;\nend\n\nendmodule\n\nmodule or(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a | b;\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n\n    // Two submodules for counting the edges\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR to combine the clock edges\n    assign clk_div = clk_div1 | clk_div2;\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] count = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    reg [3:0] count = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == NUM_DIV - 1) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 4;\n\n    reg [3:0] cnt_div = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt_div <= 0;\n        else if (cnt_div == (NUM_DIV / 2 - 1))\n            cnt_div <= 0;\n        else\n            cnt_div <= cnt_div + 1;\n    end\n\n    assign clk_div = cnt_div == (NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule u_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 0;\n        else if (q == (NUM_DIV / 2 - 1))\n            q <= 0;\n        else\n            q <= q + 1;\n    end\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (q == (NUM_DIV / 2 - 1))\n            clk_div <= ~clk_div;\n    end\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\nwire [31:0] sll_result, srl_result, sra_result;\nwire [31:0] slt_result, sltu_result;\nwire [31:0] add_result_carry, sub_result_carry;\nwire [31:0] sll_carry, srl_carry, sra_carry;\nwire [31:0] slt_result_carry, sltu_result_carry;\nwire [31:0] slt_result_negative, sltu_result_negative;\nwire [31:0] slt_result_overflow, sltu_result_overflow;\n\n// ADD\nadd add_inst(\n    .a(a),\n    .b(b),\n    .r(add_result),\n    .carry(add_result_carry)\n);\n\n// SUB\nsub sub_inst(\n    .a(a),\n    .b(b),\n    .r(sub_result),\n    .carry(sub_result_carry)\n);\n\n// AND\nand and_inst(\n    .a(a),\n    .b(b),\n    .r(and_result)\n);\n\n// OR\nor or_inst(\n    .a(a),\n    .b(b),\n    .r(or_result)\n);\n\n// XOR\nxor xor_inst(\n    .a(a),\n    .b(b),\n    .r(xor_result)\n);\n\n// NOR\nnor nor_inst(\n    .a(a),\n    .b(b),\n    .r(nor_result)\n);\n\n// SLL\nsll sll_inst(\n    .a(a),\n    .b(b),\n    .r(sll_result),\n    .carry(sll_carry)\n);\n\n// SRL\nsrl srl_inst(\n    .a(a),\n    .b(b),\n    .r(srl_result),\n    .carry(srl_carry)\n);\n\n// SRA\nsra sra_inst(\n    .a(a),\n    .b(b),\n    .r(sra_result),\n    .carry(sra_carry)\n);\n\n// SLT\nslt slt_inst(\n    .a(a),\n    .b(b),\n    .r(slt_result),\n    .carry(slt_result_carry),\n    .negative(slt_result_negative),\n    .overflow(slt_result_overflow)\n);\n\n// SLTU\nsltu sltu_inst(\n    .a(a),\n    .b(b),\n    .r(sltu_result),\n    .carry(sltu_result_carry),\n    .negative(sltu_result_negative),\n    .overflow(sltu_result_overflow)\n);\n\n// LUI\nlui lui_inst(\n    .a(a),\n    .b(b),\n    .r(r)\n);\n\n// Select the operation\nassign r = (aluc == 6'b100000) ? add_result :\n           (aluc == 6'b100001) ? add_result :\n           (aluc == 6'b100010) ? sub_result :\n           (aluc == 6'b100011) ? sub_result :\n           (aluc == 6'b100100) ? and_result :\n           (aluc == 6'b100101) ? or_result :\n           (aluc == 6'b100110) ? xor_result :\n           (aluc == 6'b100111) ? nor_result :\n           (aluc == 6'b101010) ? slt_result :\n           (aluc == 6'b101011) ? sltu_result :\n           (aluc == "}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\nwire [31:0] mult_result;\n\n// Instantiate the multiplication module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiate the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .accumulated_value(c)\n);\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] accumulated_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulated_value <= 0;\n        end else begin\n            accumulated_value <= accumulated_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n\nwire [4:0] ad1_out;\nwire [7:0] ad2_out;\n\n// 3-bit opcode or operation\n// 5-bit register address\n// 8-bit data\n\n// Forwarding to submodules\nwire [2:0] ins1;\nwire [2:0] ins2;\nwire [4:0] ad11;\nwire [4:0] ad12;\nwire [7:0] ad21;\nwire [7:0] ad22;\n\n// Submodule 1\nins_reg ins_p1 (\n    .clk(clk),\n    .rst(rst),\n    .data(data),\n    .ins(ins1),\n    .ad1(ad11),\n    .ad2(ad21)\n);\n\n// Submodule 2\nins_reg ins_p2 (\n    .clk(clk),\n    .rst(rst),\n    .data(data),\n    .ins(ins2),\n    .ad1(ad12),\n    .ad2(ad22)\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        ins <= 3'b0;\n        ad1 <= 5'b0;\n        ad2 <= 8'b0;\n    end else begin\n        ins <= (fetch == 2'b01) ? ins_p1 : ins_p2;\n        ad1 <= (fetch == 2'b01) ? ad11 : ad12;\n        ad2 <= (fetch == 2'b01) ? ad21 : ad22;\n    end\nend\n\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_reg;\nreg [4:0] ad1_reg;\nreg [7:0] ad2_reg;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        ins_reg <= 3'b0;\n        ad1_reg <= 5'b0;\n        ad2_reg <= 8'b0;\n    end else begin\n        ins_reg <= data[7:5];\n        ad1_reg <= data[4:0];\n        ad2_reg <= data;\n    end\nend\n\nassign ins = ins_reg;\nassign ad1 = ad1_reg;\nassign ad2 = ad2_reg;\n\nendmodule\n\nmodule ins_reg_ram (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_reg;\nreg [4:0] ad1_reg;\nreg [7:0] ad2_reg;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        ins_reg <= 3'b0;\n        ad1_reg <= 5'b0;\n        ad2_reg <= 8'b0;\n    end else begin\n        ins_reg <= data[7:5];\n        ad1_reg <= data[4:0];\n        ad2_reg <= data;\n    end\nend\n\nassign ins = ins_reg;\nassign ad1 = ad1_reg;\nassign ad2 = ad2_reg;\n\nendmodule\n\nmodule ins_reg_rom (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins_reg;\nreg [4:0] ad1_reg;\nreg [7:0] ad2_reg;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        ins_reg <= 3'b0;\n        ad1_reg <="}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    \n    counter #(.INIT_VAL(0), .MAX_COUNT(freq - 1)) cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter # (\n    parameter INIT_VAL = 0,\n    parameter MAX_COUNT = 0\n) (\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == MAX_COUNT)\n                count <= INIT_VAL;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire [1:0] state;\n    \n    // Instantiate submodules\n    state_controller state_inst (.clk(clk), .rst_n(rst_n), .state(state));\n    waveform_generator wave_inst (.clk(clk), .rst_n(rst_n), .wave(wave), .state(state));\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave,\n    input [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'd0;\n        else begin\n            if (state == 2'd0)\n                wave <= wave + 1;\n            else\n                wave <= wave - 1;\n        end\n    end\nendmodule\n\nmodule state_controller (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'd0;\n        else begin\n            if (state == 2'd1)\n                state <= 2'd0;\n            else\n                state <= 2'd1;\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] outs [0:3];\n    wire [7:0] dff_outs [0:3];\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff_outs[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff_outs[0]),\n        .q(dff_outs[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff_outs[1]),\n        .q(dff_outs[2])\n    );\n\n    assign outs[0] = d;\n    assign outs[1] = dff_outs[0];\n    assign outs[2] = dff_outs[1];\n    assign outs[3] = dff_outs[2];\n\n    always @(posedge clk)\n        q <= outs[sel];\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n    always @(*)\n        case (sel)\n            2'b00: out = in;\n            2'b01: out = in << 1;\n            2'b10: out = in << 2;\n            2'b11: out = in << 3;\n        endcase\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [2:0] sel;\n    wire [7:0] shifted_output;\n\n    assign sel = {ctrl[2], ctrl[1], ctrl[0]};\n\n    // Shift by 4\n    mux2X1 mux2X1_0 (\n        .sel(sel[2]),\n        .in0(in),\n        .in1(8'b0),\n        .out(shifted_in)\n    );\n    mux2X1 mux2X1_1 (\n        .sel(sel[1]),\n        .in0(shifted_in),\n        .in1(shifted_in),\n        .out(shifted_output)\n    );\n\n    // Shift by 2\n    mux2X1 mux2X1_2 (\n        .sel(sel[1]),\n        .in0(shifted_output),\n        .in1(shifted_output),\n        .out(shifted_in)\n    );\n    mux2X1 mux2X1_3 (\n        .sel(sel[0]),\n        .in0(shifted_in),\n        .in1(shifted_in),\n        .out(shifted_output)\n    );\n\n    // Shift by 1\n    mux2X1 mux2X1_4 (\n        .sel(sel[0]),\n        .in0(shifted_output),\n        .in1(shifted_output),\n        .out(shifted_in)\n    );\n    mux2X1 mux2X1_5 (\n        .sel(sel[0]),\n        .in0(shifted_in),\n        .in1(shifted_in),\n        .out(out)\n    );\nendmodule\n\nmodule mux2X1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  reg [31:0] b1;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule pe (\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    b1 <= b;\n  end\n\n  assign c = a * b + b1;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [1:0] op;\n  wire [31:0] alu_res;\n  wire [4:0] pc;\n\n  // Define pipeline registers\n  reg [31:0] fetch_reg [0:31];\n  reg [31:0] decode_reg [0:31];\n  reg [31:0] execute_reg [0:31];\n  reg [31:0] memory_reg [0:31];\n  reg [31:0] writeback_reg [0:31];\n\n  // Instantiate pipeline stages\n  fetch_stage f_s(.clk(clk), .rst(rst), .instr_mem(instr_mem), .reg_file(reg_file), .pc(pc), .instr(instr));\n  decode_stage d_s(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage e_s(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op), .alu_res(alu_res));\n  memory_stage m_s(.clk(clk), .rst(rst), .alu_res(alu_res), .memory_reg(memory_reg));\n  writeback_stage w_s(.clk(clk), .rst(rst), .alu_res(alu_res), .writeback_reg(writeback_reg));\n\n  // Connect pipeline registers to pipeline stages\n  assign fetch_reg[pc] = instr;\n  assign decode_reg[pc] = fetch_reg[pc];\n  assign execute_reg[pc] = decode_reg[pc];\n  assign memory_reg[pc] = execute_reg[pc];\n  assign writeback_reg[pc] = memory_reg[pc];\n\n  assign res_reg_file[rd] = writeback_reg[rd];\n\n  // Increment pc\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  input [4:0] pc,\n  output reg [31:0] instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      instr <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [1:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[25:21];\n      rs2 <= instr[20:16];\n      rd <= instr[15:11];\n      op <= instr[31:30];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [1:0] op,\n  output reg [31:0] alu_res\n);\n  always @(posedge clk or posedge"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  wire [15:0] b1, b2, b3;\n\n  // Delayed versions of inputs\n  reg [15:0] b0_reg = 0;\n  reg [15:0] b1_reg = 0;\n  reg [15:0] b2_reg = 0;\n  reg [15:0] b3_reg = 0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  // Instantiate Processing Elements\n  pe pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  pe pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  pe pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n  pe pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\n// Processing Element\nmodule pe(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = $signed(a) * $signed(b);\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    \n    wire [31:0] instr;\n    wire [4:0] rd, rs1, rs2;\n    wire [5:0] op;\n    wire [31:0] out_execute;\n    wire [31:0] result;\n    \n    // Instruction Fetch\n    stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .reg_file(reg_file),\n        .instr(instr)\n    );\n    \n    // Instruction Execution\n    stage execute (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .reg_file(reg_file),\n        .result(out_execute)\n    );\n    \n    // Instruction Writeback\n    stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(out_execute),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n    \n    // Intermediate Results\n    assign op = instr[31:27];\n    assign rd = instr[24:20];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign result = out_execute;\n    \nendmodule\n\nmodule stage (\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out\n);\n    \n    reg [31:0] instr;\n    reg [31:0] out_reg_file [0:31];\n    \n    always @(posedge clk or posedge rst)\n        if(rst)\n            instr <= 32'b0;\n        else\n            instr <= instr_mem[0];\n            \n    always @(posedge clk or posedge rst)\n        if(rst)\n            out_reg_file <= 32'b0;\n        else\n            out_reg_file <= reg_file;\n            \n    assign out = instr;\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire                count_done;\n    wire        [7:0]   data_accumulated;\n\n    // Counter Module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_done(count_done),\n        .valid_in(valid_in)\n    );\n\n    // Data Accumulator Module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_accumulated(data_accumulated)\n    );\n\n    // Valid Output Module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_done(count_done),\n        .valid_out(valid_out),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg          count_done,\n    input               valid_in\n);\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            count_done <= 0;\n        end else if (valid_in && cnt != 2) begin\n            cnt <= cnt + 1;\n            count_done <= 0;\n        end else if (valid_in && cnt == 2) begin\n            cnt <= 0;\n            count_done <= 1;\n        end\n    end\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [7:0]   data_accumulated\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accumulated <= 0;\n        end else if (valid_in) begin\n            data_accumulated <= data_accumulated + data_in;\n        end\n    end\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               count_done,\n    output reg          valid_out,\n    output reg  [9:0]   data_out\n);\n    reg [9:0] acc_data;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n            data_out <= 0;\n            acc_data <= 0;\n        end else if (count_done) begin\n            valid_out <= 1;\n            data_out <= acc_data;\n            acc_data <= 0;\n        end else if (count_done == 0) begin\n            valid_out <= 0;\n            data_out <= 0;\n        end else if (valid_in) begin\n            acc_data <= acc_data + data_in;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [3:0] counter;\nwire [1:0] state;\n\nassign abs_dividend = (sign) ? ~dividend + 1 : dividend;\nassign neg_divisor = (sign) ? ~divisor + 1 : divisor;\n\n// Instantiation of submodules\n\nabs_value abs_dividend_inst(\n    .clk(clk),\n    .rst(rst),\n    .input_value(dividend),\n    .output_value(abs_dividend)\n);\n\nneg_value neg_divisor_inst(\n    .clk(clk),\n    .rst(rst),\n    .input_value(divisor),\n    .output_value(neg_divisor)\n);\n\ndivider_control div_ctrl_inst(\n    .clk(clk),\n    .rst(rst),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .state(state)\n);\n\nresult_management res_mgmt_inst(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .state(state),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] input_value,\n    output reg [7:0] output_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output_value <= 0;\n    else\n        output_value <= (input_value[7]) ? ~input_value + 1 : input_value;\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] input_value,\n    output reg [7:0] output_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output_value <= 0;\n    else\n        output_value <= (input_value[7]) ? ~input_value + 1 : ~input_value;\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [1:0] state\n);\n\nreg [3:0] quotient;\nreg [3:0] remainder;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        state <= 0;\n    end else begin\n        case (state)\n            2'b00: begin\n                counter <= 0;\n                shift_reg <= dividend;\n                state <= 1;\n            end\n            2'b01: begin\n                remainder <= shift_reg[7:0];\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                counter <= counter + 1;\n                if (counter == 4) begin\n                    state <= 2;\n                end\n            end\n            2'b10: begin\n                quotient <= counter;\n                state <= 3;\n            end\n            2'b11: begin\n                shift_reg <= {shift_reg[6:0], remainder[7]};\n                state <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [3:0] counter,\n    input wire [1:0] state"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n    wire [31:0] divisor;\n    wire [31:0] dividend;\n\n    prep_dividend prep_inst(.A(A), .B(B), .divisor(divisor), .dividend(dividend));\n    div_operation div_inst(.divisor(divisor), .dividend(dividend), .quotient(result), .remainder(odd));\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] divisor, // 32-bit divisor\n    output reg [31:0] dividend // 32-bit dividend\n);\n    always @(*) begin\n        // Adjusting the divisor's width\n        divisor = {16'b0, B};\n        // Adjusting the dividend's width\n        dividend = {A, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] divisor, // 32-bit divisor\n    input wire [31:0] dividend, // 32-bit dividend\n    output reg [31:0] quotient, // 32-bit quotient\n    output reg [31:0] remainder // 32-bit remainder\n);\n    integer i;\n    reg [31:0] shifted_divisor;\n    reg [31:0] shifted_dividend;\n\n    always @(*) begin\n        // Shift the divisor and dividend\n        shifted_divisor = divisor << 16;\n        shifted_dividend = dividend << 16;\n\n        // Initialize the quotient and remainder\n        quotient = 0;\n        remainder = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                quotient[31 - i] = 1;\n            end else begin\n                quotient[31 - i] = 0;\n            end\n            shifted_divisor = shifted_divisor >> 1;\n        end\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Control unit\n    div_ctrl ctrl (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\n// Control unit module\nmodule div_ctrl (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n    // Temporary variables\n    wire [15:0] dividend;\n    wire [7:0] divisor;\n    wire [7:0] shift;\n\n    // Assign inputs\n    assign dividend = A;\n    assign divisor = B;\n\n    // Shift dividend and compare with divisor\n    always @(*) begin\n        shift = 8'b0;\n        result = 16'b0;\n        odd = 16'b0;\n\n        while (shift < 16) begin\n            if (dividend[7:0] >= divisor) begin\n                result = result + 1;\n                dividend = dividend - divisor;\n                odd = odd + 1 << shift;\n            end\n\n            shift = shift + 1;\n            dividend = dividend << 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] sum;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n    assign {carry, sum} = adder_8bit(A, B_comp);\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, sum, carry);\n    input [7:0] A;\n    input [7:0] B;\n    input C_in;\n    output [7:0] sum;\n    output carry;\n\n    wire [6:0] carry_out;\n    wire [7:0] B_comp;\n\n    assign B_comp = ~B + 1;\n    assign carry_out = full_adder(A[0], B_comp[0], C_in);\n    assign sum = {carry_out[6:0], A[1:0]};\n    assign carry = carry_out[6];\nendmodule\n\nmodule full_adder(A, B, C_in, sum, carry);\n    input A, B, C_in;\n    output sum, carry;\n\n    assign sum = A ^ B ^ C_in;\n    assign carry = (A & B) | (B & C_in) | (C_in & A);\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] A_16, B_16, Diff_16, B_out_16;\n\n    sub16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n    sub16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] A_8, B_8, Diff_8, B_out_8;\n\n    sub8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n    sub8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff[7:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] A_4, B_4, Diff_4, B_out_4;\n\n    sub4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n    sub4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff[3:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] A_2, B_2, Diff_2, B_out_2;\n\n    sub2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff_2),\n        .B_out(B_out_2)\n    );\n    sub2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff[1:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub2bit(A, B, Diff, B_out);\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0:0] A_1, B_1, Diff_1, B_out_1;\n\n    sub1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff[0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub1bit(A, B, Diff, B_out);\n    input A, B;\n    output Diff;\n    output B_out;\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] D_sub0, D_sub1;\n    wire B_out0, B_out1;\n\n    sub_32bit sub0(.A(A[31:0]), .B(B[31:0]), .D(D_sub0), .B_out(B_out0));\n    sub_32bit sub1(.A(A[63:32]), .B(B[63:32]), .D(D_sub1), .B_out(B_out1));\n\n    assign D = {D_sub1, D_sub0};\n    assign B_out = B_out1;\n\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [7:0] D_sub0, D_sub1;\n    wire B_out0, B_out1;\n\n    sub_16bit sub0(.A(A[15:0]), .B(B[15:0]), .D(D_sub0), .B_out(B_out0));\n    sub_16bit sub1(.A(A[31:16]), .B(B[31:16]), .D(D_sub1), .B_out(B_out1));\n\n    assign D = {D_sub1, D_sub0};\n    assign B_out = B_out1;\n\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [3:0] D_sub0, D_sub1;\n    wire B_out0, B_out1;\n\n    sub_8bit sub0(.A(A[7:0]), .B(B[7:0]), .D(D_sub0), .B_out(B_out0));\n    sub_8bit sub1(.A(A[15:8]), .B(B[15:8]), .D(D_sub1), .B_out(B_out1));\n\n    assign D = {D_sub1, D_sub0};\n    assign B_out = B_out1;\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [1:0] D_sub0, D_sub1;\n    wire B_out0, B_out1;\n\n    sub_4bit sub0(.A(A[3:0]), .B(B[3:0]), .D(D_sub0), .B_out(B_out0));\n    sub_4bit sub1(.A(A[7:4]), .B(B[7:4]), .D(D_sub1), .B_out(B_out1));\n\n    assign D = {D_sub1, D_sub0};\n    assign B_out = B_out1;\n\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [0:0] D_sub0, D_sub1;\n    wire B_out0, B_out1;\n\n    sub_2bit sub0(.A(A[1:0]), .B(B[1:0]), .D(D_sub0), .B_out(B_out0));\n    sub_2bit sub1(.A(A[3:2]), .B(B[3:2]), .D(D_sub1), .B_out(B_out1));"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\n\nwire [4:1] c;\nwire [4:1] b;\nwire [4:1] d;\n\nwire [3:1] b_out;\n\nsub4bit sub1(A[1:4], B[1:4], d[1:4], b[1:4], c[1:4]);\nsub4bit sub2(A[5:8], B[5:8], d[5:8], b[5:8], c[1:4]);\nsub4bit sub3(A[9:12], B[9:12], d[9:12], b[5:8], c[1:4]);\nsub4bit sub4(A[13:16], B[13:16], D[13:16], b_out[1:4], c[1:4]);\n\nassign B_out = b_out[1] | b_out[2] | b_out[3];\nendmodule\n\nmodule sub4bit(A, B, D, B_out, c);\ninput [3:1] A;\ninput [3:1] B;\noutput [3:1] D;\noutput B_out;\ninput [3:1] c;\n\nwire [2:1] b_out;\n\nsub3bit sub1(A, B, D[0:2], b_out[0:2], c);\nsub3bit sub2(A[3:3], B[3:3], D[3:3], b_out[2:2], c);\n\nassign B_out = b_out[0] | b_out[1];\nendmodule\n\nmodule sub3bit(A, B, D, B_out, c);\ninput A;\ninput B;\noutput D;\noutput B_out;\ninput c;\n\nwire b_out;\n\nsub2bit sub1(A, B, D, b_out, c);\nsub2bit sub2(A[3:3], B[3:3], D[3:3], b_out, c);\n\nendmodule\n\nmodule sub2bit(A, B, D, B_out, c);\ninput A;\ninput B;\noutput D;\noutput B_out;\ninput c;\n\nwire b_out;\n\nsub1bit sub1(A, B, D, b_out, c);\nsub1bit sub2(A[3:3], B[3:3], D[3:3], b_out, c);\n\nendmodule\n\nmodule sub1bit(A, B, D, B_out, c);\ninput A;\ninput B;\noutput D;\noutput B_out;\ninput c;\n\nwire b_out;\n\nassign B_out = B ^ A;\nassign D = B_out ? 0 : A;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] diff;\n    wire borrow;\n\n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_greater = (diff != 0) && ~borrow;\n    assign A_equal = (diff == 0) && ~borrow;\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // 32-bit difference\n    output borrow        // Carry out (borrow)\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15,S16;\n    wire C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16;\n\n    CLA1 CLA11 (.A(A[1:1]),.B(B[1:1]),.Cin(1'b0),.S(S1[1:1]),.Cout(C1));\n    CLA1 CLA12 (.A(A[2:2]),.B(B[2:2]),.Cin(C1),.S(S2[1:1]),.Cout(C2));\n    CLA1 CLA13 (.A(A[3:3]),.B(B[3:3]),.Cin(C2),.S(S3[1:1]),.Cout(C3));\n    CLA1 CLA14 (.A(A[4:4]),.B(B[4:4]),.Cin(C3),.S(S4[1:1]),.Cout(C4));\n    CLA1 CLA15 (.A(A[5:5]),.B(B[5:5]),.Cin(C4),.S(S5[1:1]),.Cout(C5));\n    CLA1 CLA16 (.A(A[6:6]),.B(B[6:6]),.Cin(C5),.S(S6[1:1]),.Cout(C6));\n\n    CLA1 CLA17 (.A(A[7:7]),.B(B[7:7]),.Cin(C6),.S(S7[1:1]),.Cout(C7));\n    CLA1 CLA18 (.A(A[8:8]),.B(B[8:8]),.Cin(C7),.S(S8[1:1]),.Cout(C8));\n    CLA1 CLA19 (.A(A[9:9]),.B(B[9:9]),.Cin(C8),.S(S9[1:1]),.Cout(C9));\n    CLA1 CLA20 (.A(A[10:10]),.B(B[10:10]),.Cin(C9),.S(S10[1:1]),.Cout(C10));\n    CLA1 CLA21 (.A(A[11:11]),.B(B[11:11]),.Cin(C10),.S(S11[1:1]),.Cout(C11));\n    CLA1 CLA22 (.A(A[12:12]),.B(B[12:12]),.Cin(C11),.S(S12[1:1]),.Cout(C12));\n\n    CLA1 CLA23 (.A(A[13:13]),.B(B[13:13]),.Cin(C12),.S(S13[1:1]),.Cout(C13));\n    CLA1 CLA24 (.A(A[14:14]),.B(B[14:14]),.Cin(C13),.S(S14[1:1]),.Cout(C14));\n    CLA1 CLA25 (.A(A[15:15]),.B(B[15:15]),.Cin(C14),.S(S15[1:1]),.Cout(C15));\n    CLA1 CLA26 (.A(A[16:16]),.B(B[16:16]),.Cin(C15),.S(S16[1:1]),.Cout(C16));\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\nwire [3:0] carry;\n\nwire [3:0] s0, s1, s2;\nwire [3:0] c0, c1, c2;\n\n// Ripple carry adder for each 4-bit section\nwire [3:0] rc_sum;\nwire rc_cout;\n\nfull_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(rc_sum[0]), .cout(rc_cout));\nfull_adder FA1 (.a(a[1]), .b(b[1]), .cin(rc_cout), .sum(rc_sum[1]), .cout(c0[0]));\nfull_adder FA2 (.a(a[2]), .b(b[2]), .cin(c0[0]), .sum(rc_sum[2]), .cout(c0[1]));\nfull_adder FA3 (.a(a[3]), .b(b[3]), .cin(c0[1]), .sum(rc_sum[3]), .cout(c0[2]));\n\nfull_adder FA4 (.a(a[4]), .b(b[4]), .cin(c0[2]), .sum(rc_sum[4]), .cout(c1[0]));\nfull_adder FA5 (.a(a[5]), .b(b[5]), .cin(c1[0]), .sum(rc_sum[5]), .cout(c1[1]));\nfull_adder FA6 (.a(a[6]), .b(b[6]), .cin(c1[1]), .sum(rc_sum[6]), .cout(c1[2]));\nfull_adder FA7 (.a(a[7]), .b(b[7]), .cin(c1[2]), .sum(rc_sum[7]), .cout(c1[3]));\n\nfull_adder FA8 (.a(a[8]), .b(b[8]), .cin(c1[3]), .sum(rc_sum[8]), .cout(c2[0]));\nfull_adder FA9 (.a(a[9]), .b(b[9]), .cin(c2[0]), .sum(rc_sum[9]), .cout(c2[1]));\nfull_adder FA10 (.a(a[10]), .b(b[10]), .cin(c2[1]), .sum(rc_sum[10]), .cout(c2[2]));\nfull_adder FA11 (.a(a[11]), .b(b[11]), .cin(c2[2]), .sum(rc_sum[11]), .cout(c2[3]));\n\nfull_adder FA12 (.a(a[12]), .b(b[12]), .cin(c2[3]), .sum(rc_sum[12]), .cout(c2[4]));\nfull_adder FA13 (.a(a[13]), .b(b[13]), .cin(c2[4]), .sum(rc_sum[13]), .cout(c2[5]));\nfull_adder FA14 (.a(a[14]), .b(b[14]), .cin(c2[5]), .sum(rc_sum[14]), .cout(c2[6]));\nfull_adder FA15 (.a(a[15]), .b(b[15]), .cin(c2[6]), .sum(rc_sum[15]), .cout(cout));\n\nassign sum = rc_sum;\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\nwire [3:0] s0, s1, s2;\nwire [3:0] c0, c1, c2;\n\n// 4-bit Carry-Select Adder Slice\nwire [3:0] cs_sum;\nwire cs_cout;\n\ncarry_"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [1:0] carry;\n    wire [7:0] adder_input;\n\n    // Instantiate 8-bit adders for the 16-bit adder\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry[0])\n    );\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[0]),\n        .y(y[15:8]),\n        .Co(carry[1])\n    );\n\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    // Full adder logic\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : full_adder_loop\n            assign sum[i] = a[i] ^ b[i] ^ Cin;\n            assign carry[i] = (a[i] & b[i]) | (a[i] & Cin) | (b[i] & Cin);\n        end\n    endgenerate\n\n    assign y = sum;\n    assign Co = carry[7];\nendmodule\n\nmodule add8_inst1 (\n    .a(a),\n    .b(b),\n    .Cin(Cin),\n    .y(y),\n    .Co(Co)\n);\nendmodule\n\nmodule add8_inst2 (\n    .a(a),\n    .b(b),\n    .Cin(Cin),\n    .y(y),\n    .Co(Co)\n);\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] s0, s1, s2, s3, s4, s5, s6, s7;\n    wire c0, c1, c2, c3, c4, c5, c6, c7;\n    \n    adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(s0), .cout(c0));\n    adder FA1(.a(a[1]), .b(b[1]), .cin(c0), .sum(s1), .cout(c1));\n    adder FA2(.a(a[2]), .b(b[2]), .cin(c1), .sum(s2), .cout(c2));\n    adder FA3(.a(a[3]), .b(b[3]), .cin(c2), .sum(s3), .cout(c3));\n    adder FA4(.a(a[4]), .b(b[4]), .cin(c3), .sum(s4), .cout(c4));\n    adder FA5(.a(a[5]), .b(b[5]), .cin(c4), .sum(s5), .cout(c5));\n    adder FA6(.a(a[6]), .b(b[6]), .cin(c5), .sum(s6), .cout(c6));\n    adder FA7(.a(a[7]), .b(b[7]), .cin(c6), .sum(s7), .cout(c7));\n    \n    assign sum = {s7, s6, s5, s4, s3, s2, s1, s0};\n    assign cout = c7;\n    \nendmodule\n\nmodule adder(\n    input a, b, cin,\n    output sum, cout);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Control Unit\nwire [3:0] ctrl;\nreg [3:0] ctrl_r;\nreg [3:0] ctrl_n;\n\n// Register Unit\nwire [15:0] a, b;\nreg [15:0] a_r, b_r;\n\n// Multiplier Unit\nwire [31:0] product;\nreg [31:0] product_r;\nreg [31:0] product_n;\n\n// Output Assignment\nassign yout = product;\nassign done = done_n;\n\n// Control Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl_r <= 0;\n        done_r <= 0;\n    end else begin\n        ctrl_r <= ctrl_n;\n        done_r <= done_n;\n    end\nend\n\nalways @(*) begin\n    ctrl_n = ctrl_r;\n    if (start) ctrl_n = 4'd0;\n    else if (ctrl_r != 4'd0) ctrl_n = ctrl_r + 4'd1;\nend\n\nassign done_n = (ctrl_n == 4'd15);\n\n// Register Unit\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_r <= 16'd0;\n        b_r <= 16'd0;\n    end else begin\n        a_r <= ain;\n        b_r <= bin;\n    end\nend\n\n// Multiplier Unit\nalways @(*) begin\n    product_n = 32'd0;\n    if (ctrl_n == 4'd0) product_n = a_r * b_r;\n    else if (ctrl_n == 4'd1) product_n = {a_r[15], a_r[15:1]};\n    else if (ctrl_n == 4'd2) product_n = {a_r[15], a_r[15:2]};\n    else if (ctrl_n == 4'd3) product_n = {a_r[15], a_r[15:3]};\n    else if (ctrl_n == 4'd4) product_n = {a_r[15], a_r[15:4]};\n    else if (ctrl_n == 4'd5) product_n = {a_r[15], a_r[15:5]};\n    else if (ctrl_n == 4'd6) product_n = {a_r[15], a_r[15:6]};\n    else if (ctrl_n == 4'd7) product_n = {a_r[15], a_r[15:7]};\n    else if (ctrl_n == 4'd8) product_n = {a_r[15], a_r[15:8]};\n    else if (ctrl_n == 4'd9) product_n = {a_r[15], a_r[15:9]};\n    else if (ctrl_n == 4'd10) product_n = {a_r[15], a_r[15:10]};\n    else if (ctrl_n == 4'd11) product_n = {a_r[15], a_r[15:11]};\n    else if (ctrl_n == 4'd12) product_n = {a_r[15], a_r[15:12]};\n    else if (ctrl_n == 4'd13) product_n = {a_r[15], a_r[15:13]};\n    else if (ctrl_n == 4'd14) product_n = {a_r[15], a_r[15:14]};\n    else if (ctrl_n == 4'd15) product_n = {a_r[15], a_r[15:15]};\nend\n\nalways @(posedge clk or negedge rst_n"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .count(count),\n        .next_count(next_count),\n        .up_down(up_down)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count),\n        .next_count(next_count)\n    );\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = count + (up_down ? 1 : -1);\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    input wire [15:0] next_count\n);\n    reg [15:0] current_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\n    assign count = current_count;\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] temp_out;\n    wire [7:0] temp_init;\n    wire [7:0] temp_transition;\n\n    // Instantiate submodules\n    initial_state initial_inst (\n        .init(temp_init)\n    );\n    state_transition transition_inst (\n        .init(temp_init),\n        .transition(temp_transition)\n    );\n\n    // Interconnect\n    assign temp_out = temp_init;\n    assign temp_init = transition_inst;\n\nendmodule\n\n// Initial state module\nmodule initial_state (\n    output reg [7:0] init\n);\n    initial begin\n        init = 8'b0000_0001;\n    end\nendmodule\n\n// State transition module\nmodule state_transition (\n    input [7:0] init,\n    output reg [7:0] transition\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition <= init;\n        end else begin\n            transition <= {transition[6:0], transition[7]};\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] counter_out;\n\n    // Instantiate counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(counter_out)\n    );\n\n    // Instantiate output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .data_in(counter_out)\n    );\nendmodule\n\n// Counter logic\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count) begin\n            if (out == 4'd11)\n                out <= 4'b0000;\n            else\n                out <= out + 1;\n        end\n    end\nendmodule\n\n// Output register\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] data_in\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= data_in;\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_Q;\n\n    // Register module\n    reg [63:0] Q_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_reg <= 64'b0;\n        end else begin\n            Q_reg <= next_Q;\n        end\n    end\n\n    // Logic module\n    wire [1:0] next_LSB;\n    assign next_LSB = Q_reg[0:1] ^ {Q_reg[1], Q_reg[0]};\n    assign next_Q = Q_reg ^ {next_LSB, next_LSB, 63'b0};\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    input [63:0]         D,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= D;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input [63:0] Q,\n    output [1:0] next_LSB\n);\n    assign next_LSB = Q[0:1] ^ {Q[1], Q[0]};\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n    wire clk_50, clk_10, clk_1;\n\n    // Submodule instantiation\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) CLK_out <= 1'b0;\n        else CLK_out <= ~CLK_out;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) count <= 2'd0;\n        else begin\n            if (count == 2'd3) CLK_out <= ~CLK_out;\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) count <= 7'd0;\n        else begin\n            if (count == 7'd49) CLK_out <= ~CLK_out;\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire [5:0] clk_div_int;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_int)\n);\n\nclk_average u_clk_average(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_int[4:3]),\n    .clk_out(clk_div)\n);\n\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div_int[2:1]),\n    .clk_out(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [5:0]    clk_div\n);\n\nparameter LIMIT = 64;\n\nreg [5:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end else if (count >= LIMIT) begin\n        clk_div <= clk_div + 1;\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [1:0]         clk_div,\n    output reg          clk_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_out <= 0;\n    end else if (clk_div == 2) begin\n        clk_out <= 1;\n    end else if (clk_div == 1) begin\n        clk_out <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [1:0]         clk_div,\n    output reg          clk_out\n);\n\nreg clk_out_int;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_out_int <= 0;\n        clk_out <= 0;\n    end else if (clk_div == 2) begin\n        clk_out_int <= ~clk_out_int;\n        clk_out <= clk_out_int;\n    end else if (clk_div == 1) begin\n        clk_out_int <= ~clk_out_int;\n        clk_out <= clk_out_int;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 5;\n\nwire clk_div1;\nwire clk_div2;\n\npos_edge_counter u_pos_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter u_neg_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end\n    else if (count == NUM_DIV - 1) begin\n        count <= 0;\n        clk_div <= ~clk_div;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 5;\n\nreg [3:0] count;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        clk_div <= 0;\n    end\n    else if (count == NUM_DIV - 1) begin\n        count <= 0;\n        clk_div <= ~clk_div;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 2;\n\nwire clk_div_int;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_int(clk_div_int)\n);\n\nclk_divider u_clk_divider(\n    .clk(clk_div_int),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q,\n    output clk_div_int\n);\n\nparameter NUM_DIV = 2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 0;\n    end else begin\n        if (q == (NUM_DIV / 2 - 1)) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\n\nassign clk_div_int = (q == (NUM_DIV / 2 - 1));\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    output reg clk_div\n);\n\nalways @(posedge clk) begin\n    clk_div <= ~clk_div;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n\nwire [31:0] add_out;\nwire [31:0] addu_out;\nwire [31:0] sub_out;\nwire [31:0] subu_out;\nwire [31:0] and_out;\nwire [31:0] or_out;\nwire [31:0] xor_out;\nwire [31:0] nor_out;\nwire [31:0] slt_out;\nwire [31:0] sltu_out;\nwire [31:0] sll_out;\nwire [31:0] srl_out;\nwire [31:0] sra_out;\nwire [31:0] sllv_out;\nwire [31:0] srlv_out;\nwire [31:0] srav_out;\nwire [31:0] lui_out;\n\n// submodules\nadd add_inst(.a(a), .b(b), .r(add_out));\nadd addu_inst(.a(a), .b(b), .r(addu_out));\nsub sub_inst(.a(a), .b(b), .r(sub_out));\nsub subu_inst(.a(a), .b(b), .r(subu_out));\nand and_inst(.a(a), .b(b), .r(and_out));\nor or_inst(.a(a), .b(b), .r(or_out));\nxor xor_inst(.a(a), .b(b), .r(xor_out));\nnor nor_inst(.a(a), .b(b), .r(nor_out));\nslt slt_inst(.a(a), .b(b), .r(slt_out));\nsltu sltu_inst(.a(a), .b(b), .r(sltu_out));\nsll sll_inst(.a(a), .b(b), .r(sll_out));\nsrl srl_inst(.a(a), .b(b), .r(srl_out));\nsra sra_inst(.a(a), .b(b), .r(sra_out));\nsllv sllv_inst(.a(a), .b(b), .r(sllv_out));\nsrlv srlv_inst(.a(a), .b(b), .r(srlv_out));\nsrav srav_inst(.a(a), .b(b), .r(srav_out));\nlui lui_inst(.a(a), .b(b), .r(lui_out));\n\n// output\nassign r = (aluc == 6'b100000) ? add_out :\n           (aluc == 6'b100001) ? addu_out :\n           (aluc == 6'b100010) ? sub_out :\n           (aluc == 6'b100011) ? subu_out :\n           (aluc == 6'b100100) ? and_out :\n           (aluc == 6'b100101) ? or_out :\n           (aluc == 6'b100110) ? xor_out :\n           (aluc == 6'b100111) ? nor_out :\n           (aluc == 6'b101010) ? slt_out :\n           (aluc == 6'b101011) ? sltu_out :\n           (aluc == 6'b000000) ? sll_out :\n           (aluc == 6'b000010) ? srl_out :\n           (aluc == 6'b000011) ? sra_out :\n           (aluc == 6'b000100) ? sllv_out :\n           (aluc == 6'b000110) ? srlv_out :\n           (aluc == 6'b000111) ? srav_out :\n           (aluc == 6'b00"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] multiplication_result;\n    wire [31:0] current_value;\n    wire [31:0] new_value;\n\n    // Instantiate the multiplier submodule\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(multiplication_result)\n    );\n\n    // Instantiate the accumulator submodule\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .current_value(current_value),\n        .new_value(new_value)\n    );\n\n    assign c = new_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n\n    assign result = a * b;\n\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output [31:0] result\n);\n\n    reg [31:0] current_value_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value_reg <= 0;\n        end else begin\n            current_value_reg <= current_value_reg + new_value;\n        end\n    end\n\n    assign result = current_value_reg;\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    ins_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    ins_reg ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\nendmodule\n\nmodule ins_reg (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [7:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 0;\n            ad1_reg <= 0;\n            ad2_reg <= 0;\n        end else begin\n            ins_reg <= data;\n            ad1_reg <= data[4:0];\n            ad2_reg <= data[7:0];\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ins = data[7:5];\n    assign ad1 = data[4:0];\n    assign ad2 = data[7:0];\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ins = data[7:5];\n    assign ad1 = data[4:0];\n    assign ad2 = data[7:0];\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n\n    // Instantiate counter and wave_generator modules.\n    counter cnt(\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n    wave_generator wg(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count % freq == 0) begin\n            wave_out <= 1'b1;\n        end else begin\n            wave_out <= 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule signal_generator_state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule signal_generator_waveform_generator (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'd0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (wave_reg == 5'd31) begin\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (wave_reg == 5'd0) begin\n                        state <= 2'b00;\n                    end\n                end\n            endcase\n            case (state)\n                2'b00: wave_reg <= wave_reg + 1;\n                2'b01: wave_reg <= wave_reg - 1;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= q0;\n            2'b01: q <= q1;\n            2'b10: q <= q2;\n            default: q <= d;\n        endcase\n    end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q1, q2, q3;\n\n    my_dff dff1 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff dff2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff dff3 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    \n    wire [7:0] shifted_input;\n    wire [3:0] sel;\n    \n    // Stage 1: Shift 4 positions\n    assign sel[3:2] = ctrl[2:1];\n    assign shifted_input[7:4] = (sel[3] & in[7:4]) | (sel[2] & in[3:0]);\n    assign shifted_input[3:0] = (sel[3] & in[3:0]) | (sel[2] & in[7:4]);\n    \n    // Stage 2: Shift 2 positions\n    assign sel[1:0] = ctrl[1:0];\n    assign shifted_input[7:2] = (sel[1] & shifted_input[7:4]) | (sel[0] & shifted_input[3:0]);\n    assign shifted_input[1:0] = (sel[1] & shifted_input[3:2]) | (sel[0] & shifted_input[7:4]);\n    \n    // Stage 3: Shift 1 position\n    assign shifted_input[0] = (ctrl[0] & shifted_input[7]) | (ctrl[1] & shifted_input[3]) | (ctrl[2] & shifted_input[1]);\n    \n    assign out = shifted_input;\nendmodule\n\nmodule mux2X1(in1, in2, sel, out);\n    input in1, in2;\n    input sel;\n    output out;\n    \n    assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [31:0] b1;\n\n  assign c0 = pe0.c;\n  assign c1 = pe1.c;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] acc;\n  always @(posedge clk) begin\n    if (rst)\n      acc <= 0;\n    else\n      acc <= acc + a * b;\n  end\n\n  assign c = acc;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] pc;\n  wire [31:0] alu_result;\n  wire [31:0] mem_result;\n  wire [31:0] rd;\n  wire [4:0] rs1, rs2;\n  wire [5:0] op;\n\n  wire [31:0] pipeline_reg[4:0];\n\n  assign pc = pipeline_reg[0];\n  assign alu_result = pipeline_reg[1];\n  assign mem_result = pipeline_reg[2];\n  assign rd = pipeline_reg[3];\n  assign rs1 = pipeline_reg[4][5:0];\n  assign rs2 = pipeline_reg[4][11:6];\n  assign op = pipeline_reg[4][15:12];\n\n  // Pipeline stage 1: fetch\n  stagefetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .res_pc(pipeline_reg[0])\n  );\n\n  // Pipeline stage 2: decode\n  stagedecode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr(instr_mem[pc]),\n    .rs1(rs1),\n    .rs2(rs2),\n    .rd(rd),\n    .op(op),\n    .res_alu_result(pipeline_reg[1])\n  );\n\n  // Pipeline stage 3: execute\n  stageexecute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .rs1(rs1),\n    .rs2(rs2),\n    .op(op),\n    .alu_result(alu_result),\n    .res_mem_result(pipeline_reg[2])\n  );\n\n  // Pipeline stage 4: memory\n  stagememory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .mem_result(mem_result),\n    .res_mem_result(pipeline_reg[3])\n  );\n\n  // Pipeline stage 5: writeback\n  stagewriteback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .rd(rd),\n    .mem_result(mem_result),\n    .res_reg_file(pipeline_reg[4])\n  );\n\n  // Pipeline register file\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      for (integer i = 0; i < 5; i = i + 1) begin\n        pipeline_reg[i] <= 32'h0;\n      end\n    end else begin\n      pipeline_reg[0] <= pc;\n      pipeline_reg[1] <= alu_result;\n      pipeline_reg[2] <= mem_result;\n      pipeline_reg[3] <= pipeline_reg[2];\n      pipeline_reg[4] <= pipeline_reg[3];\n    end\n  end\nendmodule\n\nmodule stagefetch(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem[0:31],\n  output [31:0] res_pc\n);\n  assign res_pc = pc + 1;\nendmodule\n\nmodule stagedecode(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [5:0] op,\n  output [31:0] res_alu_result\n);\n  assign {rs1, rs2, op} = instr;\n  assign res_alu_result = 32'h0;\nendmodule\n\nmodule stageexecute(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [5:0] op,\n  input [31:0] alu_result,\n "}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0, c1, c2, c3;\n  always @(posedge clk) begin\n    if (rst) begin\n      c0 <= 0;\n      c1 <= 0;\n      c2 <= 0;\n      c3 <= 0;\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      c0 <= c0 + a0*b0;\n      c1 <= c1 + a1*b1;\n      c2 <= c2 + a2*b2;\n      c3 <= c3 + a3*b3;\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  // PE1\n  pe pe1(.clk(clk), .a(a1), .b(b1), .c(c1));\n  pe pe2(.clk(clk), .a(a2), .b(b2), .c(c2));\n  pe pe3(.clk(clk), .a(a3), .b(b3), .c(c3));\nendmodule\n\nmodule pe(\n  input clk,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [15:0] b_reg;\n  always @(posedge clk) begin\n    b_reg <= b;\n  end\n  assign c = a * b_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] instr_fetched;\n    wire [4:0] rd, rs1, rs2;\n    wire [5:0] opcode;\n    wire [31:0] result;\n\n    fetch_stage fetch(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .instr_fetched(instr_fetched)\n    );\n\n    execute_stage execute(\n        .clk(clk),\n        .rst(rst),\n        .instr_fetched(instr_fetched),\n        .reg_file(reg_file),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .opcode(opcode),\n        .result(result)\n    );\n\n    writeback_stage writeback(\n        .clk(clk),\n        .rst(rst),\n        .rd(rd),\n        .result(result),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\n    reg [31:0] pc;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] instr_fetched\n);\n    assign instr_fetched = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_fetched,\n    input [31:0] reg_file [0:31],\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [5:0] opcode,\n    output [31:0] result\n);\n    assign {opcode, rd, rs1, rs2} = instr_fetched;\n    assign result = (opcode == 6'b000000) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] rd,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    assign out_reg_file = result;\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\nwire [3:0]  data_in_ready;\nwire [9:0]  data_in_accum;\n\ndata_accumulator #(\n    .ACCUM_WIDTH (10)\n) u_data_accumulator (\n    .clk         (clk),\n    .rst_n       (rst_n),\n    .data_in     (data_in),\n    .valid_in    (valid_in),\n    .data_in_ready (data_in_ready),\n    .data_in_accum (data_in_accum)\n);\n\nvalid_output #(\n    .ACCUM_WIDTH (10)\n) u_valid_output (\n    .clk         (clk),\n    .rst_n       (rst_n),\n    .data_in_ready (data_in_ready),\n    .data_in_accum (data_in_accum),\n    .valid_out   (valid_out),\n    .data_out    (data_out)\n);\n\nendmodule\n\nmodule data_accumulator #(\n    parameter ACCUM_WIDTH = 10\n) (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output reg  [3:0]  data_in_ready,\n    output reg  [ACCUM_WIDTH - 1:0] data_in_accum\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_in_ready <= 0;\n        data_in_accum <= 0;\n    end else if (valid_in) begin\n        data_in_accum <= data_in_accum + data_in;\n        data_in_ready <= data_in_ready + 1;\n    end\nend\n\nendmodule\n\nmodule valid_output #(\n    parameter ACCUM_WIDTH = 10\n) (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in_ready,\n    input      [ACCUM_WIDTH - 1:0] data_in_accum,\n\n    output reg           valid_out,\n    output reg  [ACCUM_WIDTH - 1:0] data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        valid_out <= 0;\n        data_out <= 0;\n    end else if (data_in_ready == 4) begin\n        valid_out <= 1;\n        data_out <= data_in_accum;\n    end\nend\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] quotient;\nwire [7:0] remainder;\n\n// Instantiate the submodules.\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(dividend),\n    .output(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(divisor),\n    .output(neg_divisor)\n);\n\ndivider_control divider_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .divisor(neg_divisor),\n    .remainder(remainder),\n    .quotient(quotient),\n    .valid(res_valid)\n);\n\nresult_management result_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .ready(res_ready),\n    .valid(res_valid),\n    .output(result)\n);\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Submodules\n//------------------------------------------------------------------------------\n\n// Absolute value calculation\nmodule abs_value (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else if (sign)\n        output <= ~input + 1;\n    else\n        output <= input;\nend\n\nendmodule\n\n//------------------------------------------------------------------------------\n\n// Negative value calculation\nmodule neg_value (\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else if (sign)\n        output <= ~input + 1;\n    else\n        output <= input;\nend\n\nendmodule\n\n//------------------------------------------------------------------------------\n\n// Division control logic\nmodule divider_control (\n    input wire clk,\n    input wire rst,\n    input wire [7:0] divisor,\n    output reg [7:0] remainder,\n    output reg [7:0] quotient,\n    output reg valid\n);\n\nreg [3:0] counter;\nreg [7:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        valid <= 0;\n    end else begin\n        remainder <= 0;\n        quotient <= 0;\n        if (valid) begin\n            if (counter < 8) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                quotient <= quotient >> 1;\n                remainder <= remainder + divisor;\n            end else begin\n                valid <= 0;\n            end\n        end else if (remainder >= divisor) begin\n            valid <= 1;\n            remainder <= remainder - divisor;\n            shift_reg <= {1'b1, shift_reg[7:1]};\n        end\n    end\nend\n\nendmodule\n\n//------------------------------------------------------------------------------\n\n// Result management module\nmodule result_management (\n    input wire clk,\n    input wire rst,\n    input wire ready,\n    input wire valid,\n    output reg [15:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else if (ready)\n        output <= 0;\n    else if (valid)\n        output <= {remainder, quotient};\nend\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // prep_dividend\n    prep_dividend prep_dividend_instance(\n        .in(A),\n        .out(dividend)\n    );\n\n    // div_operation\n    div_operation div_operation_instance(\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] in,\n    output reg [31:0] out\n);\n    always @(*) begin\n        out[31:16] = in[31:16];\n        out[15:0] = in[15:0];\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    reg [31:0] shifted;\n    reg [4:0] i;\n\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        for (i = 1; i < 32; i = i + 1) begin\n            remainder = remainder << 1;\n            if (remainder[31]) begin\n                remainder = remainder - divisor;\n                quotient[31-i] = 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    // Instantiate the control unit\n    div_control ctrl (.A(A), .B(B), .result(result), .odd(odd));\n\nendmodule\n\nmodule div_control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n    reg [15:0] tmp_A;          // Temporary dividend\n    reg [7:0] tmp_B;           // Temporary divisor\n    reg [7:0] shifted_B;       // Shifted divisor\n    reg [7:0] shifted_B_neg;   // Shifted divisor with sign\n    reg [7:0] shifted_A;       // Shifted dividend\n    reg [7:0] shifted_A_neg;   // Shifted dividend with sign\n    reg [7:0] carry;           // Carry out\n    reg [7:0] borrow;          // Borrow\n    reg [7:0] tmp_rem;         // Temporary remainder\n    reg [7:0] tmp_quot;        // Temporary quotient\n    reg [7:0] tmp_quot_neg;    // Temporary quotient with sign\n\n    // Control logic\n    always @(*) begin\n        // Shift divisor\n        shifted_B = {B[6:0], 1'b0};\n        shifted_B_neg = {~B[6:0], 1'b1};\n\n        // Initialize\n        tmp_A = A;\n        tmp_B = B;\n        tmp_rem = 0;\n        tmp_quot = 0;\n        borrow = 1;\n        carry = 0;\n\n        // Shift dividend and borrow\n        for (int i = 0; i < 16; i = i + 1) begin\n            shifted_A = {tmp_A[14:0], 1'b0};\n            shifted_A_neg = {~tmp_A[14:0], 1'b1};\n\n            // Compare and update borrow\n            if (shifted_A_neg >= shifted_B_neg) begin\n                borrow = 1;\n            end else begin\n                borrow = 0;\n            end\n\n            // Update quotient and remainder\n            if (borrow == 1) begin\n                tmp_quot = tmp_quot + 1;\n                tmp_rem = tmp_rem + 1;\n            end\n            tmp_rem = tmp_rem + carry;\n            tmp_quot = tmp_quot + carry;\n            carry = shifted_A[0];\n            tmp_A = tmp_A >> 1;\n        end\n\n        // Update odd\n        if (odd[0] == 1) begin\n            odd = tmp_rem;\n        end\n\n        // Update result\n        if (tmp_quot_neg[15] == 0) begin\n            result = tmp_quot;\n        end else begin\n            result = ~tmp_quot + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\ninput [7:0] A, B;\noutput [7:0] D;\noutput B_out;\n\nwire [7:0] B_comp;\nwire [7:0] sum;\nwire borrow;\n\nassign B_comp = ~B + 1;\n\nadder_8bit adder_inst(.A(A), .B(B_comp), .sum(sum), .borrow(borrow));\nassign D = sum;\nassign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, sum, borrow);\ninput [7:0] A, B;\noutput [7:0] sum;\noutput borrow;\n\nwire [7:0] carry;\nwire [7:0] b_comp;\n\nassign b_comp = ~B + 1;\nassign {borrow, sum} = A + b_comp;\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] A1, B1, Diff1, B_out1;\n\n    sub_16bit S1(A[15:0], B[15:0], Diff1, B_out1);\n    sub_16bit S2(A[31:16], B[31:16], Diff[31:16], B_out);\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] A1, B1, Diff1, B_out1;\n\n    sub_8bit S1(A[7:0], B[7:0], Diff1, B_out1);\n    sub_8bit S2(A[15:8], B[15:8], Diff[15:8], B_out);\n    sub_8bit S3(A[7:0], B[15:8], Diff[7:0], B_out1);\n    sub_8bit S4(A[15:8], B[7:0], Diff[15:8], B_out);\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] A1, B1, Diff1, B_out1;\n\n    sub_4bit S1(A[3:0], B[3:0], Diff1, B_out1);\n    sub_4bit S2(A[7:4], B[7:4], Diff[7:4], B_out);\n    sub_4bit S3(A[3:0], B[7:4], Diff[3:0], B_out1);\n    sub_4bit S4(A[7:4], B[3:0], Diff[7:4], B_out);\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] A1, B1, Diff1, B_out1;\n\n    sub_2bit S1(A[1:0], B[1:0], Diff1, B_out1);\n    sub_2bit S2(A[3:2], B[3:2], Diff[3:2], B_out);\n    sub_2bit S3(A[1:0], B[3:2], Diff[1:0], B_out1);\n    sub_2bit S4(A[3:2], B[1:0], Diff[3:2], B_out);\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire [0:0] A1, B1, Diff1, B_out1;\n\n    assign Diff1 = A[0] ^ B[0];\n    assign B_out1 = A[0] & B[0];\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [15:0] D0, D1, D2, D3;\n    wire B0, B1, B2, B3;\n\n    sub_32bit sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n    sub_32bit sub1(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D1),\n        .B_out(B1)\n    );\n    sub_16bit sub2(\n        .A(D0),\n        .B(B0),\n        .D(D2),\n        .B_out(B2)\n    );\n    sub_16bit sub3(\n        .A(D1),\n        .B(B1),\n        .D(D3),\n        .B_out(B3)\n    );\n    sub_8bit sub4(\n        .A(D2),\n        .B(B2),\n        .D(D3[7:0]),\n        .B_out(B3)\n    );\n    sub_8bit sub5(\n        .A(D3[15:8]),\n        .B(B3),\n        .D(D3[15:8]),\n        .B_out(B3)\n    );\n    assign D = {D3[15:8], D3[7:0]};\n    assign B_out = B3;\nendmodule\n\nmodule sub_32bit(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [7:0] D0, D1;\n    wire B0, B1;\n\n    sub_16bit sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n    sub_16bit sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D1),\n        .B_out(B1)\n    );\n    sub_8bit sub2(\n        .A(D0),\n        .B(B0),\n        .D(D0),\n        .B_out(B0)\n    );\n    sub_8bit sub3(\n        .A(D1),\n        .B(B1),\n        .D(D1),\n        .B_out(B1)\n    );\n    assign D = {D1, D0};\n    assign B_out = B1;\nendmodule\n\nmodule sub_16bit(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] D0, D1;\n    wire B0, B1;\n\n    sub_8bit sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D0),\n        .B_out(B0)\n    );\n    sub_8bit sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D1),\n        .B_out(B1)\n    );\n    sub_8bit sub2(\n        .A(D0),\n        .B(B0),\n        .D(D0),\n        .B_out(B0)\n    );\n    sub_8bit sub3(\n        .A(D1),\n        .B(B1),\n        .D(D1),\n        .B_out(B1)\n    );\n    assign D"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\ninput [16:1] A;\ninput [16:1] B;\noutput [16:1] D;\noutput B_out;\nwire [1:0] b_out;\nwire [3:0] c_out;\nwire [15:1] D_out;\n\nfull_subtractor_4bit u_full_subtractor_0(\n    .A(A[1:0]),\n    .B(B[1:0]),\n    .C_out(c_out[0]),\n    .B_out(b_out[0])\n);\n\nfull_subtractor_4bit u_full_subtractor_1(\n    .A(A[3:2]),\n    .B(B[3:2]),\n    .C_out(c_out[1]),\n    .B_out(b_out[1])\n);\n\nfull_subtractor_4bit u_full_subtractor_2(\n    .A(A[7:4]),\n    .B(B[7:4]),\n    .C_out(c_out[2]),\n    .B_out(b_out[2])\n);\n\nfull_subtractor_4bit u_full_subtractor_3(\n    .A(A[11:8]),\n    .B(B[11:8]),\n    .C_out(c_out[3]),\n    .B_out(b_out[3])\n);\n\nfull_subtractor_4bit u_full_subtractor_4(\n    .A(A[15:12]),\n    .B(B[15:12]),\n    .C_out(c_out[3]),\n    .B_out(b_out[3])\n);\n\nassign B_out = c_out[0] & c_out[1] & c_out[2] & c_out[3];\nassign D = D_out;\n\nendmodule\n\nmodule full_subtractor_4bit(A, B, C_out, B_out);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] C_out;\noutput B_out;\n\nassign {B_out, C_out} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\n// Local signals\nwire [31:0] A_B;\nwire borrow;\nwire [31:0] A_B_minus_1;\n\n// Subtractor instantiation\nsubtractor_32bit subtractor (\n    .A(A),\n    .B(B),\n    .subtrahend(A_B),\n    .borrow_out(borrow),\n    .result(A_B_minus_1)\n);\n\n// Determine if A is greater than, equal to, or less than B\nassign A_greater = borrow & (A_B_minus_1 != 0);\nassign A_equal = ~borrow & (A_B_minus_1 == 0);\nassign A_less = ~borrow & (A_B_minus_1 != 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,        // First 32-bit input operand\n    input [31:0] B,        // Second 32-bit input operand\n    input [31:0] subtrahend,\n    output borrow,         // Borrow out\n    output [31:0] result   // Result of subtraction\n);\n\nassign {borrow, result} = A - B - subtrahend;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A;\ninput [32:1] B;\noutput [32:1] S;\noutput C32;\nwire [32:1] CLA1_C,CLA2_C;\nwire CLA1_CO,CLA2_CO;\n\nCLA CLA1(A[16:1],B[16:1],S[16:1],C32,CLA1_C,CLA1_CO);\nCLA CLA2(A[32:17],B[32:17],S[32:17],CLA1_CO,CLA2_C,CLA2_CO);\n\nassign C32 = CLA2_CO;endmodule\n\nmodule CLA(A,B,S,Cin,Cout,CO);\ninput [15:1] A;\ninput [15:1] B;\ninput Cin;\noutput [15:1] S;\noutput Cout;\noutput CO;\n\nwire [16:1] P,G;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    // 4-bit ripple carry adder\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum_slice[0]),\n        .cout(carry[0])\n    );\n\n    // 4-bit carry select adder\n    carry_select_adder_4bit csa1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum_slice[1]),\n        .cout(carry[1])\n    );\n\n    // 4-bit carry select adder\n    carry_select_adder_4bit csa2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum_slice[2]),\n        .cout(carry[2])\n    );\n\n    // 4-bit carry select adder\n    carry_select_adder_4bit csa3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum_slice[3]),\n        .cout(carry[3])\n    );\n\n    assign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_4bit(a, b, cin, sum, cout);\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n    wire [3:0] sum_slice;\n\n    ripple_carry_adder_4bit rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum_slice[0]),\n        .cout(carry[0])\n    );\n\n    ripple_carry_adder_4bit rca2(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum_slice[1]),\n        .cout(carry[1])\n    );"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n\n    // Instantiate 8 adder submodules\n    // Instance name: add8_inst1\n    // Instance name: add8_inst2\n    // Instance name: add8_inst3\n    // ...\n    // Instance name: add8_inst16\n    // Use adder_8bit to implement the adder logic\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] carry;\n\n    // Instantiate 4 adder submodules\n    // Instance name: add4_inst1\n    // Instance name: add4_inst2\n    // Instance name: add4_inst3\n    // Instance name: add4_inst4\n    // Use adder_4bit to implement the adder logic\n\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire [1:0] carry;\n\n    // Instantiate 2 adder submodules\n    // Instance name: add2_inst1\n    // Instance name: add2_inst2\n    // Use adder_2bit to implement the adder logic\n\nendmodule\n\nmodule adder_2bit (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    // 2-bit adder logic\n    // ...\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [6:0] carry;\n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\nassign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n    wire [15:0] a, b;\n    wire [31:0] p;\n    wire [4:0] cnt;\n    wire start_i, start_p;\n\n    // Control Unit\n    control_unit ctrl_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .start_i(start_i),\n        .start_p(start_p)\n    );\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start_i(start_i),\n        .start_p(start_p),\n        .ain(ain),\n        .bin(bin),\n        .a(a),\n        .b(b)\n    );\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .cnt(cnt),\n        .p(p)\n    );\n    // Output Assignment\n    assign yout = p;\n    assign done = ctrl_unit.done;\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg start_i,\n    output reg start_p\n);\n    reg [4:0] cnt;\n    reg done;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 5'd0;\n            start_i <= 1'b0;\n            start_p <= 1'b0;\n            done <= 1'b0;\n        end else if (start) begin\n            start_i <= 1'b1;\n            start_p <= 1'b1;\n        end else if (cnt == 5'd15) begin\n            start_i <= 1'b0;\n            start_p <= 1'b0;\n            done <= 1'b1;\n        end else begin\n            start_i <= start_i;\n            start_p <= start_p;\n            done <= done;\n        end\n        cnt <= cnt + 5'd1;\n    end\nendmodule\n\n// Register Unit\nmodule reg_unit (\n    input clk,\n    input rst_n,\n    input start_i,\n    input start_p,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] a,\n    output reg [15:0] b\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 16'd0;\n            b <= 16'd0;\n        end else if (start_i) begin\n            a <= ain;\n            b <= bin;\n        end else begin\n            a <= a;\n            b <= b;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [4:0] cnt,\n    output reg [31:0] p\n);\n    always @(posedge clk) begin\n        p <= p + ((b >> cnt) * (a << cnt));\n    end\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\n    // Define submodules\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .next_count(count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] next_count\n);\n\n    // Update next_count based on up_down signal\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            if (up_down) begin\n                next_count <= next_count + 1;\n            end else begin\n                next_count <= next_count - 1;\n            end\n        end\n    end\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count\n);\n\n    // Register for count\n    reg [15:0] current_count;\n\n    // Update current_count on clk\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= count;\n        end\n    end\n\n    // Output count\n    assign count = current_count;\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n    submodule init (\n        input wire reset,\n        output reg [7:0] out\n    );\n        always @(posedge reset) begin\n            out <= 8'b0000_0001;\n        end\n    endmodule\n\n    submodule transition (\n        input wire clk,\n        output reg [7:0] out\n    );\n        always @(posedge clk) begin\n            out <= out >> 1;\n        end\n    endmodule\n\n    initial begin\n        out = 8'b0000_0001;\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= out >> 1;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count_out;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else if (valid_count)\n            if (count_out == 4'd11)\n                count_out <= 4'b0000;\n            else\n                count_out <= count_out + 1;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count_out;\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n    wire [63:0] next_Q;\n\n    // Instantiate the register and logic modules\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end\n    end\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\nendmodule\n"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\nwire CLK_50_int, CLK_10_int, CLK_1_int;\n\nclk_div_2 clk_div_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(CLK_50_int)\n);\n\nclk_div_10 clk_div_10 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(CLK_10_int)\n);\n\nclk_div_100 clk_div_1 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .CLK_out(CLK_1_int)\n);\n\nassign CLK_50 = CLK_50_int;\nassign CLK_10 = CLK_10_int;\nassign CLK_1 = CLK_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [1:0] count;\n\nalways @ (posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        count <= 2'b0;\n        CLK_out <= 0;\n    end\n    else if (count == 2'b0) begin\n        count <= 2'b1;\n        CLK_out <= 1;\n    end\n    else begin\n        count <= 2'b0;\n        CLK_out <= 0;\n    end\nend\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [2:0] count;\n\nalways @ (posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        count <= 3'b000;\n        CLK_out <= 0;\n    end\n    else if (count == 3'b000) begin\n        count <= 3'b001;\n        CLK_out <= 1;\n    end\n    else if (count == 3'b001) begin\n        count <= 3'b010;\n        CLK_out <= 0;\n    end\n    else if (count == 3'b010) begin\n        count <= 3'b011;\n        CLK_out <= 1;\n    end\n    else if (count == 3'b011) begin\n        count <= 3'b100;\n        CLK_out <= 0;\n    end\n    else if (count == 3'b100) begin\n        count <= 3'b101;\n        CLK_out <= 1;\n    end\n    else if (count == 3'b101) begin\n        count <= 3'b110;\n        CLK_out <= 0;\n    end\n    else if (count == 3'b110) begin\n        count <= 3'b111;\n        CLK_out <= 1;\n    end\n    else if (count == 3'b111) begin\n        count <= 3'b000;\n        CLK_out <= 1;\n    end\nend\n\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n\nreg [5:0] count;\n\nalways @ (posedge CLK_in or posedge RST) begin\n    if (RST) begin\n        count <= 6'b000000;\n        CLK_out <= 0;\n    end\n    else if (count == 6'b000000) begin\n        count <= 6'b000001;\n        CLK_out <= 1;\n    end\n    else if (count == 6'b000001) begin\n        count <= 6'b000010;\n        CLK_out <="}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7; // 3.5x division\n\nwire [7:0] count;\nwire [1:0] clk_div_2;\n\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count)\n);\n\nclk_average u_clk_average (\n    .clk(count),\n    .clk_div(clk_div_2)\n);\n\nclk_adjustment u_clk_adjustment (\n    .clk(clk),\n    .clk_div(clk_div_2),\n    .clk_div_2(clk_div_2)\n);\n\nassign clk_div = clk_div_2[0] | clk_div_2[1];\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg [7:0]    count\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nparameter COUNT_LIMIT = (MUL2_DIV_CLK * 2) - 1;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n    end else begin\n        count <= (count >= COUNT_LIMIT) ? 0 : count + 1;\n    end\nend\n\nendmodule\n\nmodule clk_average (\n    input               clk,\n    input [7:0]         count,\n    output reg          clk_div\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk) begin\n    clk_div <= (count % (MUL2_DIV_CLK * 2)) < MUL2_DIV_CLK;\nend\n\nendmodule\n\nmodule clk_adjustment (\n    input               clk,\n    input [1:0]         clk_div,\n    output reg [1:0]    clk_div_2\n);\n\nparameter MUL2_DIV_CLK = 7;\n\nalways @(posedge clk) begin\n    clk_div_2 <= {clk_div_2[0], ~clk_div};\nend\n\nendmodule"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n    wire [NUM_DIV-1:0] pos_counter, neg_counter;\n\n    // Instantiate the counter modules\n    pos_edge_counter u_pos_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(pos_counter)\n    );\n\n    neg_edge_counter u_neg_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(neg_counter)\n    );\n\n    assign clk_div1 = (pos_counter == NUM_DIV-1) ? 1 : 0;\n    assign clk_div2 = (neg_counter == NUM_DIV-1) ? 1 : 0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV-1:0] count_out\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (count_out == NUM_DIV-1)\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [NUM_DIV-1:0] count_out\n);\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (count_out == NUM_DIV-1)\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n    localparam NUM_DIV = 4;\n    reg [3:0] counter;\n    wire clk_div_en;\n\n    counter_submodule u_counter(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .count(counter)\n    );\n\n    clock_divider_submodule u_clk_divider(\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div_en(clk_div_en),\n        .clk_div(clk_div)\n    );\nendmodule\n\nmodule counter_submodule(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (clk_div_en) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clock_divider_submodule(\n    input clk,\n    input rst_n,\n    input clk_div_en,\n    output reg clk_div\n);\n    reg toggle;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            toggle <= 0;\n            clk_div <= 0;\n        end else if (clk_div_en) begin\n            if (toggle) begin\n                clk_div <= ~clk_div;\n            end\n            toggle <= ~toggle;\n        end\n    end\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_r, addu_r, sub_r, subu_r, and_r, or_r, xor_r, nor_r, slt_r, sltu_r;\n    wire [31:0] sll_r, srl_r, sra_r;\n    wire [31:0] sllv_r, srlv_r, srav_r;\n    wire [31:0] lui_r;\n    wire [31:0] l_r;\n\n    add add_module(\n        .a(a),\n        .b(b),\n        .r(add_r)\n    );\n\n    addu addu_module(\n        .a(a),\n        .b(b),\n        .r(addu_r)\n    );\n\n    sub sub_module(\n        .a(a),\n        .b(b),\n        .r(sub_r)\n    );\n\n    subu subu_module(\n        .a(a),\n        .b(b),\n        .r(subu_r)\n    );\n\n    and and_module(\n        .a(a),\n        .b(b),\n        .r(and_r)\n    );\n\n    or or_module(\n        .a(a),\n        .b(b),\n        .r(or_r)\n    );\n\n    xor xor_module(\n        .a(a),\n        .b(b),\n        .r(xor_r)\n    );\n\n    nor nor_module(\n        .a(a),\n        .b(b),\n        .r(nor_r)\n    );\n\n    slt slt_module(\n        .a(a),\n        .b(b),\n        .r(slt_r)\n    );\n\n    sltu sltu_module(\n        .a(a),\n        .b(b),\n        .r(sltu_r)\n    );\n\n    sll sll_module(\n        .a(a),\n        .b(b),\n        .r(sll_r)\n    );\n\n    srl srl_module(\n        .a(a),\n        .b(b),\n        .r(srl_r)\n    );\n\n    sra sra_module(\n        .a(a),\n        .b(b),\n        .r(sra_r)\n    );\n\n    sllv sllv_module(\n        .a(a),\n        .b(b),\n        .r(sllv_r)\n    );\n\n    srlv srlv_module(\n        .a(a),\n        .b(b),\n        .r(srlv_r)\n    );\n\n    srav srav_module(\n        .a(a),\n        .b(b),\n        .r(srav_r)\n    );\n\n    lui lui_module(\n        .a(a),\n        .b(b),\n        .r(lui_r)\n    );\n\n    assign l_r = {b[11:0], 12'b0};\n\n    assign r = (aluc == 6'b100000) ? add_r :\n               (aluc == 6'b100001) ? addu_r :\n               (aluc == 6'b100010) ? sub_r :\n               (aluc == 6'b100011) ? subu_r :\n               (aluc == 6'b100100) ? and_r :\n               (aluc == 6'b100101) ? or_r :\n               (aluc == 6'b100110) ? xor_r :\n               (aluc == 6'b100111) ? nor_r :\n               (aluc == 6'b101010) ? slt_r :\n               (aluc == 6'b101011) ? sltu_r :\n               (aluc == 6'b000000) ?"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] m = m1 * m2;\n    wire [31:0] a1 = a, b1 = b;\n    wire [31:0] m1, m2;\n    reg [31:0] current_value = 0;\n\n    // Instantiate submodules\n    multiplier ml(\n        .a(a1),\n        .b(b1),\n        .m(m1)\n    );\n\n    accumulator al(\n        .a(m1),\n        .rst(rst),\n        .clk(clk),\n        .current_value(current_value)\n    );\n\n    // Connect the submodules\n    assign m2 = ml.result;\n    assign c = current_value;\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] m\n);\n\n    assign m = a * b;\n\nendmodule\n\nmodule accumulator(\n    input [31:0] a,\n    input rst,\n    input clk,\n    output reg [31:0] current_value\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + a;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n\n    wire [7:0] ins1, ins2;\n\n    // Two submodules to handle different instruction sources.\n    instr_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad(ad1)\n    );\n\n    instr_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad(ad2)\n    );\n\n    assign ins = {ins_p1.ins, ins_p2.ins};\n\nendmodule\n\nmodule instr_p1 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad <= 5'b0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\n\nendmodule\n\nmodule instr_p2 (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [7:0] ad\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'b0;\n            ad <= 8'b0;\n        end else if (fetch) begin\n            ins <= data;\n            ad <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\nwire [7:0] count;\nwire [7:0] next_count;\n\nwire [7:0] cnt;\nwire [7:0] wg;\n\ncounter counter(\n    .clk(clk),\n    .enable(1'b1),\n    .freq(freq),\n    .count(count)\n);\nwave_generator wave_generator(\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n);\n\nassign next_count = (count == (freq - 1)) ? 0 : (count + 1);\n\nalways @(posedge clk)\n    begin\n        cnt <= next_count;\n        wg <= next_count;\n    end\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\nalways @(posedge clk)\n    if (enable)\n        count <= count + 1;\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\nalways @(posedge clk)\n    wave_out <= (count % (freq * 2)) > (freq / 2);\n\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    reg [1:0] state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n            wave_reg <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: begin\n                    wave_reg <= wave_reg + 1;\n                    if (wave_reg == 5'b10001) state <= 2'b01;\n                end\n                2'b01: begin\n                    wave_reg <= wave_reg - 1;\n                    if (wave_reg == 5'b00000) state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    assign wave = wave_reg;\nendmodule\n\nmodule state_control_module (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule waveform_generator_module (\n    input clk,\n    input rst_n,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            wave <= wave + 1;\n        end\n    end\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n    wire [7:0] f1, f2, f3;\n    \n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(f1)\n    );\n    \n    my_dff8 u1 (\n        .clk(clk),\n        .d(f1),\n        .q(f2)\n    );\n    \n    my_dff8 u2 (\n        .clk(clk),\n        .d(f2),\n        .q(f3)\n    );\n    \n    always @(*) begin\n        case (sel)\n            2'b00: q = f3;\n            2'b01: q = f2;\n            2'b10: q = f1;\n            2'b11: q = d;\n            default: q = 8'bx;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            2'b00: out = in[0];\n            2'b01: out = in[1];\n            2'b10: out = in[2];\n            2'b11: out = in[3];\n            default: out = 8'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n\n    wire q1, q2, q3;\n\n    // Create 3 instances of D flip-flop module\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q2),\n        .q(q3)\n    );\n\n    // Connect the outputs of the last D flip-flop\n    // to the output port of the shift register\n    assign q = q3;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3, stage4;\n\n    // Stage 1\n    mux2X1 mux1 (stage1, in[3:0], in[7:4], ctrl[0]);\n\n    // Stage 2\n    mux2X1 mux2 (stage2, stage1[1:0], stage1[3:2], ctrl[1]);\n\n    // Stage 3\n    mux2X1 mux3 (stage3, stage2[1:0], stage2[3:2], ctrl[2]);\n\n    // Stage 4\n    mux2X1 mux4 (stage4, stage3[1:0], stage3[3:2], ctrl[2]);\n\n    assign out = stage4;\nendmodule\n\nmodule mux2X1 (out, in1, in2, sel);\n    input [1:0] in1, in2;\n    input sel;\n    output [1:0] out;\n\n    assign out[0] = sel ? in2[0] : in1[0];\n    assign out[1] = sel ? in2[1] : in1[1];\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n\n  assign b1 = (rst) ? 16'b0 : b0;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  wire [31:0] p;\n\n  assign p = a * b;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + p;\n  end\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n\n  wire [31:0] alu_result;\n  wire [31:0] pc_reg;\n  wire [31:0] pc_next;\n\n  stage pipe_stages(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file),\n    .alu_result(alu_result),\n    .pc_reg(pc_reg),\n    .pc_next(pc_next)\n  );\n\n  assign pc_reg[31:0] = 0;\n  assign pc_next[31:0] = pc_reg[31:0] + 4;\n\n  fetch_stage fetch_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc_reg(pc_reg),\n    .pc_next(pc_next)\n  );\n\n  decode_stage decode_stage(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .alu_result(alu_result)\n  );\n\n  execute_stage execute_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result)\n  );\n\n  writeback_stage writeback_stage(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file)\n  );\n\nendmodule\n\nmodule stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31],\n  output [31:0] alu_result,\n  output [31:0] pc_reg,\n  output [31:0] pc_next\n);\n\n  wire [4:0] op_code;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n  wire [31:0] rs1_val;\n  wire [31:0] rs2_val;\n  wire [31:0] result;\n\n  assign pc_reg[31:0] = 0;\n  assign pc_next[31:0] = pc_reg[31:0] + 4;\n\n  assign alu_result[31:0] = 0;\n  assign result[31:0] = 0;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op_code[4:0] <= 0;\n      rs1[4:0] <= 0;\n      rs2[4:0] <= 0;\n      rd[4:0] <= 0;\n      rs1_val[31:0] <= 0;\n      rs2_val[31:0] <= 0;\n      result[31:0] <= 0;\n      alu_result[31:0] <= 0;\n    end else begin\n      op_code[4:0] <= instr_mem[pc_reg[31:0]][31:28];\n      rs1[4:0] <= instr_mem[pc_reg[31:0]][24:20];\n      rs2[4:0] <= instr_mem[pc_reg[31:0]][19:15];\n      rd[4:0] <= instr_mem[pc_reg[31:0]][11:7];\n      rs1_val[31:0] <= reg_file[rs1[4:0]][31:0];\n      rs2_val[31:0] <="}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n\n  wire [15:0] b1;\n  wire [15:0] b2;\n  wire [15:0] b3;\n  reg [15:0] b0_reg;\n  reg [15:0] b1_reg;\n  reg [15:0] b2_reg;\n  reg [15:0] b3_reg;\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 16'b0;\n      b1_reg <= 16'b0;\n      b2_reg <= 16'b0;\n      b3_reg <= 16'b0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b1_reg;\n      b2_reg <= b2_reg;\n      b3_reg <= b3_reg;\n    end\n  end\n\n  systolic_array pe0(\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  systolic_array pe1(\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  systolic_array pe2(\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  systolic_array pe3(\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule systolic_array(\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n\n  assign c = a * b;\n\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .out(fetch_out)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .opcode(fetch_out[6:0]),\n        .rs(fetch_out[11:7]),\n        .rt(fetch_out[15:11]),\n        .rd(fetch_out[20:16]),\n        .shamt(fetch_out[25:21]),\n        .funct(fetch_out[31:26]),\n        .reg_file(reg_file),\n        .out(execute_out)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .rd(fetch_out[20:16]),\n        .out(execute_out),\n        .reg_file(reg_file),\n        .out_reg_file(writeback_out)\n    );\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] out\n);\n    reg [5:0] pc;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 32'b0;\n            pc <= 0;\n        end else begin\n            out <= instr_mem[pc];\n            pc <= pc + 1;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [5:0] opcode,\n    input [4:0] rs,\n    input [4:0] rt,\n    input [5:0] rd,\n    input [5:0] shamt,\n    input [5:0] funct,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 32'b0;\n        end else begin\n            case (funct)\n                6'b100000: out <= reg_file[rs] + reg_file[rt];\n                6'b100010: out <= reg_file[rs] - reg_file[rt];\n                default: out <= reg_file[rd];\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] rd,\n    input [31:0] out,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 32'b0;\n        end else begin\n            reg_file[rd] <= out;\n            out_reg_file <= out;\n        end\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [1:0] cnt_out;\n    wire [9:0] accu_out;\n    wire [9:0] accu_in;\n\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .cnt_out(cnt_out)\n    );\n\n    data_accumulator u_data_accumulator (\n        .data_in(data_in),\n        .cnt_in(cnt_out),\n        .accu_out(accu_out)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .accu_out(accu_out),\n        .valid_out(valid_out)\n    );\n\n    assign accu_in = (cnt_out == 2'b01) ? accu_out + data_in : accu_out;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [1:0]   cnt_out\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 2'b00;\n        else if (valid_in)\n            cnt <= cnt + 1;\n    end\n\n    assign cnt_out = cnt;\n\nendmodule\n\nmodule data_accumulator (\n    input       [7:0]   data_in,\n    input       [1:0]   cnt_in,\n    output reg  [9:0]   accu_out\n);\n\n    always @(*) begin\n        case (cnt_in)\n            2'b00: accu_out = data_in;\n            2'b01: accu_out = accu_out + data_in;\n            default: ;\n        endcase\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [9:0]   accu_out,\n    output reg          valid_out\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 1'b0;\n        else begin\n            case (cnt)\n                2'b00: valid_out <= 1'b0;\n                2'b01: valid_out <= 1'b1;\n                default: ;\n            endcase\n            if (accu_out != 10'd0)\n                cnt <= cnt + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\n\n// Instantiate submodules\nabs_value abs_dividend_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(dividend),\n    .output(abs_dividend)\n);\n\nneg_value neg_divisor_inst(\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .input(divisor),\n    .output(neg_divisor)\n);\n\ndivider_control div_ctrl_inst(\n    .clk(clk),\n    .rst(rst),\n    .abs_dividend(abs_dividend),\n    .neg_divisor(neg_divisor),\n    .result(result)\n);\n\nresult_management res_mgmt_inst(\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .result(result)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else\n        output <= sign ? -input : input;\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        output <= 0;\n    else\n        output <= sign ? input : -input;\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [15:0] result\n);\n\nreg [7:0] shift_reg;\nreg [3:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        shift_reg <= 0;\n        count <= 0;\n        result <= 0;\n    end else begin\n        count <= count + 1;\n        shift_reg <= {shift_reg[6:0], abs_dividend[7]};\n        result <= {result[14:0], shift_reg[7]};\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        result <= 0;\n    end else begin\n        res_valid <= opn_valid;\n        if (opn_valid && res_ready)\n            result <= result;\n    end\nend\n\nendmodule"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n    wire [31:0] dividend, divisor;\n\n    // Prepare dividend and divisor to match the\n    // size of the dividend and divisor.\n    prep_dividend prep(\n        .in_A(A),\n        .in_B(B),\n        .out_dividend(dividend),\n        .out_divisor(divisor)\n    );\n\n    // Perform division.\n    div_operation div(\n        .in_dividend(dividend),\n        .in_divisor(divisor),\n        .out_result(result),\n        .out_odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] in_A,\n    input wire [15:0] in_B,\n    output wire [31:0] out_dividend,\n    output wire [31:0] out_divisor\n);\n    // Prepare dividend and divisor to match the\n    // size of the dividend and divisor.\n    assign out_dividend = {in_A, 16'b0};\n    assign out_divisor = {in_B, 16'b0};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] in_dividend,\n    input wire [31:0] in_divisor,\n    output wire [31:0] out_result,\n    output wire [31:0] out_odd\n);\n    // Perform division.\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n\n    // Shift dividend and compare with divisor.\n    genvar i;\n    generate\n        for (i = 0; i < 32; i = i + 1) begin: shift_loop\n            always @* begin\n                quotient[i] = remainder[i];\n                remainder[i] = {remainder[i], 1'b0};\n            end\n            always @* begin\n                remainder[i] = in_dividend[i] ^ in_divisor[31 - i];\n            end\n        end\n    endgenerate\n\n    // Assign output signals.\n    assign out_result = quotient;\n    assign out_odd = remainder;\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n    wire [15:0] quot;\n    wire [15:0] rem;\n\n    // Connect input ports to control unit\n    div_control ctrl (.A(A), .B(B), .result(result), .odd(odd));\nendmodule\n\nmodule div_control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,        // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n    wire [15:0] temp;\n\n    // Initialize temporary variables\n    assign temp = {16'd0, A};\n    assign result = 16'd0;\n    assign odd = 16'd0;\n\n    // Perform division\n    always @(*) begin\n        if (temp[15:8] >= B) begin\n            result[15:8] = temp[15:8] - B;\n            odd[15:8] = 16'd0;\n            temp[15:8] = temp[15:8] + 1;\n        end else begin\n            result[15:8] = 8'd0;\n            odd[15:8] = temp[15:8];\n            temp[15:8] = temp[15:8] + 1;\n        end\n\n        if (temp[7:0] >= B) begin\n            result[7:0] = temp[7:0] - B;\n            odd[7:0] = 16'd0;\n            temp[7:0] = temp[7:0] + 1;\n        end else begin\n            result[7:0] = 8'd0;\n            odd[7:0] = temp[7:0];\n            temp[7:0] = temp[7:0] + 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire carry;\n\n    assign B_comp = ~B + 1;\n\n    adder_8bit adder_inst(.A(A), .B(B_comp), .C_in(1'b0), .D(D), .C_out(carry));\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, C_out);\n    input [7:0] A, B;\n    input C_in;\n    output [7:0] D;\n    output C_out;\n\n    wire [7:0] sum;\n    wire carry_out;\n\n    full_adder fa0(.a(A[0]), .b(B[0]), .c_in(C_in), .sum(D[0]), .c_out(carry_out));\n    full_adder fa1(.a(A[1]), .b(B[1]), .c_in(carry_out), .sum(D[1]), .c_out(carry_out));\n    full_adder fa2(.a(A[2]), .b(B[2]), .c_in(carry_out), .sum(D[2]), .c_out(carry_out));\n    full_adder fa3(.a(A[3]), .b(B[3]), .c_in(carry_out), .sum(D[3]), .c_out(carry_out));\n    full_adder fa4(.a(A[4]), .b(B[4]), .c_in(carry_out), .sum(D[4]), .c_out(carry_out));\n    full_adder fa5(.a(A[5]), .b(B[5]), .c_in(carry_out), .sum(D[5]), .c_out(carry_out));\n    full_adder fa6(.a(A[6]), .b(B[6]), .c_in(carry_out), .sum(D[6]), .c_out(carry_out));\n    full_adder fa7(.a(A[7]), .b(B[7]), .c_in(carry_out), .sum(D[7]), .c_out(C_out));\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A, B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] A1, B1, Diff1, B_out1;\n    wire [15:0] A2, B2, Diff2, B_out2;\n\n    subtractor_16bit S1(A[31:16], B[31:16], Diff1, B_out1);\n    subtractor_16bit S2(A[15:0], B[15:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule subtractor_16bit(A, B, Diff, B_out);\n    input [15:0] A, B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] A1, B1, Diff1, B_out1;\n    wire [7:0] A2, B2, Diff2, B_out2;\n\n    subtractor_8bit S1(A[15:8], B[15:8], Diff1, B_out1);\n    subtractor_8bit S2(A[7:0], B[7:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule subtractor_8bit(A, B, Diff, B_out);\n    input [7:0] A, B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] A1, B1, Diff1, B_out1;\n    wire [3:0] A2, B2, Diff2, B_out2;\n\n    subtractor_4bit S1(A[7:4], B[7:4], Diff1, B_out1);\n    subtractor_4bit S2(A[3:0], B[3:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule subtractor_4bit(A, B, Diff, B_out);\n    input [3:0] A, B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] A1, B1, Diff1, B_out1;\n    wire [1:0] A2, B2, Diff2, B_out2;\n\n    subtractor_2bit S1(A[3:2], B[3:2], Diff1, B_out1);\n    subtractor_2bit S2(A[1:0], B[1:0], Diff2, B_out2);\n\n    assign Diff = {Diff2, Diff1};\n    assign B_out = B_out1 | B_out2;\nendmodule\n\nmodule subtractor_2bit(A, B, Diff, B_out);\n    input [1:0] A, B;\n    output [1:0] Diff;\n    output B_out;\n\n    wire C, G, P, C_out;\n\n    assign C = (A[0] & ~B[0]) | (~A[0] & B[0]);\n    assign G = A[0] ^ B[0];\n    assign P = A[1] ^ B[1];\n    assign Diff = {C ^ P, G ^ P};\n    assign B_out = C;\nendmodule"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n    \n    wire [31:0] B1, B2, B3, B4;\n    wire [15:0] B5, B6, B7, B8;\n    wire [7:0] B9, B10, B11, B12;\n    wire B13, B14, B15, B16;\n    wire B17, B18, B19, B20;\n    wire B21, B22, B23, B24;\n    wire B25, B26, B27, B28;\n    wire B29, B30, B31, B32;\n    wire B33, B34, B35, B36;\n    wire B37, B38, B39, B40;\n    wire B41, B42, B43, B44;\n    wire B45, B46, B47, B48;\n    wire B49, B50, B51, B52;\n    wire B53, B54, B55, B56;\n    wire B57, B58, B59, B60;\n    wire B61, B62, B63;\n    \n    sub16bit sub0(.A(A[31:0]), .B(B[31:0]), .D(B1), .B_out(B2));\n    sub16bit sub1(.A(A[47:32]), .B(B[47:32]), .D(B3), .B_out(B4));\n    sub16bit sub2(.A(A[63:48]), .B(B[63:48]), .D(B5), .B_out(B6));\n    \n    sub8bit sub3(.A(B1), .B(B2), .D(B7), .B_out(B8));\n    sub8bit sub4(.A(B3), .B(B4), .D(B9), .B_out(B10));\n    sub8bit sub5(.A(B5), .B(B6), .D(B11), .B_out(B12));\n    sub8bit sub6(.A(B7), .B(B8), .D(B13), .B_out(B14));\n    sub8bit sub7(.A(B9), .B(B10), .D(B15), .B_out(B16));\n    sub8bit sub8(.A(B11), .B(B12), .D(B17), .B_out(B18));\n    sub8bit sub9(.A(B13), .B(B14), .D(B19), .B_out(B20));\n    sub8bit sub10(.A(B15), .B(B16), .D(B21), .B_out(B22));\n    sub8bit sub11(.A(B17), .B(B18), .D(B23), .B_out(B24));\n    sub8bit sub12(.A(B19), .B(B20), .D(B25), .B_out(B26));\n    sub8bit sub13(.A(B21), .B(B22), .D(B27), .B_out(B28));\n    sub8bit sub14(.A(B23), .B(B24), .D(B29), .B_out(B30));\n    sub8bit sub15(.A(B25), .B(B26), .D(B31), .B_out(B32));\n    sub8bit sub16(.A(B27), .B(B28), .D(B33), .B_out(B34));\n    sub8bit sub17(.A(B29), .B(B30), .D(B3"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n    wire [4:1] A_bls[3:1], B_bls[3:1], B_out_bls[3:1];\n    wire [4:1] B_in[4:1];\n    \n    assign B_in[1] = B[1:1];\n    assign B_in[2] = B[5:1];\n    assign B_in[3] = B[9:1];\n    assign B_in[4] = B[13:1];\n    \n    bls_1bit sub1 (.A(A[1:1]), .B(B_in[1]), .B_out(B_out_bls[1]));\n    bls_1bit sub2 (.A(A[5:1]), .B(B_in[2]), .B_out(B_out_bls[2]));\n    bls_1bit sub3 (.A(A[9:1]), .B(B_in[3]), .B_out(B_out_bls[3]));\n    bls_1bit sub4 (.A(A[13:1]), .B(B_in[4]), .B_out(B_out_bls[4]));\n    \n    assign D[1:1] = B_out_bls[1];\n    assign D[5:1] = B_out_bls[2] + B_out_bls[1];\n    assign D[9:1] = B_out_bls[3] + B_out_bls[2] + B_out_bls[1];\n    assign D[13:1] = B_out_bls[4] + B_out_bls[3] + B_out_bls[2] + B_out_bls[1];\n    \n    assign B_out = B_out_bls[4] + B_out_bls[3] + B_out_bls[2] + B_out_bls[1];\nendmodule\n\nmodule bls_1bit(A, B, B_out);\n    input A, B;\n    output B_out;\n    wire carry_in;\n    \n    assign carry_in = 1'b0;\n    \n    full_subtractor_4bit sub(A, B, carry_in, B_out);\nendmodule\n\nmodule full_subtractor_4bit(A, B, carry_in, B_out);\n    input [3:1] A, B;\n    input carry_in;\n    output [3:1] B_out;\n    wire [3:1] borrow;\n    \n    assign borrow[1] = carry_in;\n    assign borrow[2] = borrow[1] ^ A[1];\n    assign borrow[3] = borrow[2] ^ A[2];\n    assign B_out[1:3] = B - borrow[1:3];\n    assign B_out[4] = borrow[3];\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n    wire [31:0] sub_result;\n\n    // Instantiate the submodule for the subtraction\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result)\n    );\n\n    // Comparison logic\n    assign A_greater = ~sub_result[31] && sub_result; // If borrow is low and result is non-zero\n    assign A_equal = ~sub_result[31] && !sub_result;  // If borrow is low and result is zero\n    assign A_less = sub_result[31];                    // If borrow is high\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    wire [31:0] borrow;\n\n    assign {borrow, result} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C1;\n    wire [31:1] C2;\n\n    // Instance of 16-bit CLA\n    CLA1 CLA1(\n        .A(A[1:16]),\n        .B(B[1:16]),\n        .Cin(1'b0),\n        .Sum(S[1:16]),\n        .Cout(C1[1])\n    );\n\n    // Instance of 16-bit CLA\n    CLA2 CLA2(\n        .A(A[16:32]),\n        .B(B[16:32]),\n        .Cin(C1[16]),\n        .Sum(S[16:32]),\n        .Cout(C2[1])\n    );\n\n    assign C32 = C2[32];\nendmodule\n\nmodule CLA1(\n    input [15:1] A,\n    input [15:1] B,\n    input Cin,\n    output [15:1] Sum,\n    output Cout\n);\n    wire [16:1] G;\n    wire [16:1] P;\n    wire [16:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = G | {Cin, P[16:1]};\n\n    assign Sum = P ^ C;\n    assign Cout = C[16];\nendmodule\n\nmodule CLA2(\n    input [31:1] A,\n    input [31:1] B,\n    input Cin,\n    output [31:1] Sum,\n    output Cout\n);\n    wire [32:1] G;\n    wire [32:1] P;\n    wire [32:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = G | {Cin, P[32:1]};\n\n    assign Sum = P ^ C;\n    assign Cout = C[32];\nendmodule"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] rca1_sum, rca2_sum, rca3_sum;\nwire [2:0] csa_sum;\nwire [2:0] csa_carry;\nwire [3:0] rca_carry;\nwire [3:0] rca_sum;\n\n// 4-bit ripple carry adder\nwire [3:0] rca_a, rca_b, rca_cin;\nassign rca_a = a[3:0];\nassign rca_b = b[3:0];\nassign rca_cin = {1'b0, cin};\n\nripple_carry_adder rca1(.a(rca_a), .b(rca_b), .cin(rca_cin), .sum(rca1_sum), .cout(rca_carry[0]));\nripple_carry_adder rca2(.a(rca_a), .b(rca_b), .cin(rca_carry[0]), .sum(rca2_sum), .cout(rca_carry[1]));\nripple_carry_adder rca3(.a(rca_a), .b(rca_b), .cin(rca_carry[1]), .sum(rca3_sum), .cout(rca_carry[2]));\n\n// 4-bit carry select adder\nwire [3:0] csa_a, csa_b, csa_cin;\nassign csa_a = {a[7:4], rca1_sum};\nassign csa_b = {b[7:4], rca2_sum};\nassign csa_cin = {rca3_sum, cin};\n\ncarry_select_adder csa1(.a(csa_a), .b(csa_b), .cin(csa_cin), .sum(csa_sum), .carry(csa_carry[0]));\ncarry_select_adder csa2(.a(csa_a), .b(csa_b), .cin(csa_carry[0]), .sum(csa_sum), .carry(csa_carry[1]));\ncarry_select_adder csa3(.a(csa_a), .b(csa_b), .cin(csa_carry[1]), .sum(csa_sum), .carry(csa_carry[2]));\n\nassign rca_sum = {rca3_sum, rca2_sum, rca1_sum};\nassign sum = {csa_sum, rca_sum};\nassign cout = rca_carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nassign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder(a, b, cin, sum, carry);\ninput [3:0] a, b;\ninput [1:0] cin;\noutput [3:0] sum;\noutput [1:0] carry;\n\nwire [1:0] c1, c2;\nassign {c1, c2} = cin;\n\nassign sum = a ^ b ^ {c1, c2};\nassign carry[0] = (a & b) | (c1 & (a ^ b)) | (c2 & (a & b));\nassign carry[1] = (a & b & c1) | (a & c2) | (b & c2);\n\nendmodule"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry_in;\n    wire [7:0] carry_out;\n    wire [7:0] sum;\n    wire [7:0] y_i;\n    wire [7:0] Co_i;\n\n    assign carry_in = {Cin, 1'b0};\n\n    add8_inst1 add8_inst1_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(carry_in[0]),\n        .y(y_i),\n        .Co(Co_i)\n    );\n\n    assign y = {y_i, y[15:8]};\n    assign Co = Co_i[7];\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] carry_in;\n    wire [7:0] carry_out;\n    wire [7:0] sum;\n\n    assign carry_in = {Cin, 1'b0};\n    assign {carry_out, y} = a + b + carry_in;\n    assign Co = carry_out[7];\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] FA_cout;\n    \n    fa FA0(\n        .a(a[0]), .b(b[0]), .cin(cin), \n        .sum(sum[0]), .cout(FA_cout[0])\n    );\n    fa FA1(\n        .a(a[1]), .b(b[1]), .cin(FA_cout[0]), \n        .sum(sum[1]), .cout(FA_cout[1])\n    );\n    fa FA2(\n        .a(a[2]), .b(b[2]), .cin(FA_cout[1]), \n        .sum(sum[2]), .cout(FA_cout[2])\n    );\n    fa FA3(\n        .a(a[3]), .b(b[3]), .cin(FA_cout[2]), \n        .sum(sum[3]), .cout(FA_cout[3])\n    );\n    fa FA4(\n        .a(a[4]), .b(b[4]), .cin(FA_cout[3]), \n        .sum(sum[4]), .cout(FA_cout[4])\n    );\n    fa FA5(\n        .a(a[5]), .b(b[5]), .cin(FA_cout[4]), \n        .sum(sum[5]), .cout(FA_cout[5])\n    );\n    fa FA6(\n        .a(a[6]), .b(b[6]), .cin(FA_cout[5]), \n        .sum(sum[6]), .cout(FA_cout[6])\n    );\n    fa FA7(\n        .a(a[7]), .b(b[7]), .cin(FA_cout[6]), \n        .sum(sum[7]), .cout(cout)\n    );\nendmodule\n\nmodule fa(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n    wire [15:0] m_in;\n    wire [15:0] p_out;\n\n    assign m_in = start ? bin : ain;\n\n    control_unit ctrl_unit (.clk(clk), .rst_n(rst_n), .start(start), .done(done));\n\n    register_unit reg_unit (.clk(clk), .rst_n(rst_n), .start(start), .ain(ain), .bin(bin), .m_in(m_in), .p_out(p_out));\n\n    multiplier_unit mul_unit (.clk(clk), .start(start), .p_out(p_out), .m_in(m_in), .yout(yout));\n\nendmodule\n\n// Control unit.\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg done\n);\n\n    reg [15:0] shift_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 16;\n            done <= 0;\n        end else if (shift_count == 0) begin\n            done <= 1;\n        end else begin\n            shift_count <= shift_count - 1;\n            done <= 0;\n        end\n    end\n\nendmodule\n\n// Register unit.\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [15:0] m_in,\n    output reg [31:0] p_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            p_out <= 0;\n        end else if (start) begin\n            p_out <= m_in;\n        end else begin\n            p_out <= p_out + (bin << shift_count);\n        end\n    end\n\nendmodule\n\n// Multiplier unit.\nmodule multiplier_unit (\n    input clk,\n    input start,\n    input [31:0] p_out,\n    input [15:0] m_in,\n    output reg [31:0] yout\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            yout <= 0;\n        end else if (start) begin\n            yout <= m_in;\n        end else begin\n            if (m_in[0] == 1)\n                yout <= yout + p_out;\n            m_in <= m_in >> 1;\n            p_out <= p_out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);", "raw_response": "\n\nwire [15:0] next_count;\n\n// Instantiate counter logic module\ncounter_logic u_counter_logic (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(next_count)\n);\n\n// Instantiate counter register module\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(next_count),\n    .count_out(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 0;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_out <= 0;\n    end else begin\n        count_out <= count;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);", "raw_response": "\n\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate state initialization submodule\n    ring_counter_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate state transition submodule\n    ring_counter_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    assign out = transition_out;\n\nendmodule\n\nmodule ring_counter_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule ring_counter_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] transition_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            transition_out <= init_out;\n        end else begin\n            transition_out <= {transition_out[6:0], transition_out[7]};\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);", "raw_response": "\n    wire [3:0] count;\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count)\n    );\n\n    // Instantiate output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_in(count),\n        .out(out)\n    );\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_in,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_in;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);", "raw_response": "\n\nwire [63:0] next_Q;\nwire [63:0] cur_Q;\n\n// Instantiate the register and logic modules\nJC_register reg_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(cur_Q)\n);\n\nJC_logic logic_inst(\n    .cur_Q(cur_Q),\n    .next_Q(next_Q)\n);\n\n// Assign the next Q value\nassign Q = next_Q;\n\nendmodule\n\n// Instantiate the Johnson Counter module\nJC_counter jc_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .Q(Q)\n);\n\nendmodule\n\n// Implement the logic module\nmodule JC_logic(\n    input [63:0] cur_Q,\n    output [63:0] next_Q\n);\n\n// Calculate the next state\nassign next_Q = cur_Q ^ (cur_Q >> 1);\n\nendmodule\n\n// Implement the register module\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        Q <= 64'b0;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);", "raw_response": "\n\n    wire clk_50_w, clk_10_w, clk_1_w;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_w)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_w)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_w)\n    );\n\n    assign CLK_50 = clk_50_w;\n    assign CLK_10 = clk_10_w;\n    assign CLK_1 = clk_1_w;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else if (counter == 1) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else if (counter == 3) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else if (counter == 49) begin\n            CLK_out <= ~CLK_out;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);", "raw_response": "\n\nparameter MUL2_DIV_CLK = 7;\n\nwire clk_div_2x;\nwire clk_div_3x;\n\nclk_counter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_en(1'b1),\n    .count_limit(MUL2_DIV_CLK),\n    .count_out(clk_div_3x)\n);\n\nclk_average u_clk_average(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_in(clk_div_3x),\n    .clk_out(clk_div_2x)\n);\n\nclk_adjustment u_clk_adjustment(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_in(clk_div_2x),\n    .clk_out(clk_div)\n);\n\nassign clk_div = clk_div_3x | clk_div_2x;\n\nendmodule\n\nmodule clk_counter(\n    input               clk,\n    input               rst_n,\n    input               count_en,\n    input [7:0]         count_limit,\n    output reg          count_out\n);\n\nreg [7:0] count;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (count_en) begin\n        count <= count + 1;\n        if (count == count_limit)\n            count_out <= ~count_out;\n    end\nend\n\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input               clk_in,\n    output reg          clk_out\n);\n\nreg [1:0] clk_state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_state <= 2'b00;\n    else begin\n        case (clk_state)\n            2'b00: begin\n                clk_out <= 0;\n                clk_state <= 2'b01;\n            end\n            2'b01: begin\n                clk_out <= clk_in;\n                clk_state <= 2'b10;\n            end\n            2'b10: begin\n                clk_out <= 1;\n                clk_state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input               clk_in,\n    output reg          clk_out\n);\n\nreg [1:0] clk_state;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n)\n        clk_state <= 2'b00;\n    else begin\n        case (clk_state)\n            2'b00: begin\n                clk_out <= 0;\n                clk_state <= 2'b01;\n            end\n            2'b01: begin\n                clk_out <= ~clk_in;\n                clk_state <= 2'b10;\n            end\n            2'b10: begin\n                clk_out <= 1;\n                clk_state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule\n"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\n    parameter NUM_DIV = 5;\n\n    wire [$clog2(NUM_DIV)-1:0] u_pos_counter;\n    wire [$clog2(NUM_DIV)-1:0] u_neg_counter;\n\n    pos_edge_counter u_pos_counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .q(u_pos_counter)\n    );\n\n    neg_edge_counter u_neg_counter_inst(\n        .clk(clk),\n        .rst_n(rst_n),\n        .q(u_neg_counter)\n    );\n\n    assign clk_div = u_pos_counter[NUM_DIV-1] | u_neg_counter[NUM_DIV-1];\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV)-1:0] q\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [$clog2(NUM_DIV)-1:0] q\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= 0;\n        end else begin\n            q <= q - 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);", "raw_response": "\n\nparameter NUM_DIV = 8;\n\nwire clk_div_i;\n\ncounter u_counter(\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div_o(clk_div_i)\n);\n\nclk_divider u_clk_divider(\n    .clk(clk),\n    .clk_div_i(clk_div_i),\n    .clk_div_o(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count,\n    output clk_div_o\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n)\n        count <= 0;\n    else if (count == NUM_DIV / 2 - 1)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\nassign clk_div_o = (count == NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input clk_div_i,\n    output reg clk_div_o\n);\n\nalways @(posedge clk or negedge clk_div_i) begin\n    if (~clk_div_i)\n        clk_div_o <= 1'b1;\n    else\n        clk_div_o <= 1'b0;\nend\n\nendmodule"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);", "raw_response": "\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n    wire [31:0] xor_out;\n    wire [31:0] nor_out;\n    wire [31:0] slt_out;\n    wire [31:0] sltu_out;\n    wire [31:0] sll_out;\n    wire [31:0] srl_out;\n    wire [31:0] sra_out;\n    wire [31:0] sllv_out;\n    wire [31:0] srlv_out;\n    wire [31:0] srav_out;\n    wire [31:0] lui_out;\n\n    // Select the operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_out :\n               (aluc == 6'b100001) ? add_out :\n               (aluc == 6'b100010) ? sub_out :\n               (aluc == 6'b100011) ? sub_out :\n               (aluc == 6'b100100) ? and_out :\n               (aluc == 6'b100101) ? or_out :\n               (aluc == 6'b100110) ? xor_out :\n               (aluc == 6'b100111) ? nor_out :\n               (aluc == 6'b101010) ? slt_out :\n               (aluc == 6'b101011) ? sltu_out :\n               (aluc == 6'b000000) ? sll_out :\n               (aluc == 6'b000010) ? srl_out :\n               (aluc == 6'b000011) ? sra_out :\n               (aluc == 6'b000100) ? sllv_out :\n               (aluc == 6'b000110) ? srlv_out :\n               (aluc == 6'b000111) ? srav_out :\n               (aluc == 6'b001111) ? lui_out : 0;\n    assign zero = |r;\n    assign carry = add_out[31] | sub_out[31];\n    assign negative = r[31];\n    assign overflow = |(~a[31] & ~b[31] & r[31]) | (a[31] & b[31] & ~r[31]);\n    assign flag = (aluc == 6'b101010) ? slt_out[31] : (aluc == 6'b101011) ? sltu_out[31] : 0;\n\n    // Perform operations based on aluc\n    add add_inst(.a(a), .b(b), .r(add_out));\n    addu addu_inst(.a(a), .b(b), .r(sub_out));\n    sub sub_inst(.a(a), .b(b), .r(sub_out));\n    and and_inst(.a(a), .b(b), .r(and_out));\n    or or_inst(.a(a), .b(b), .r(or_out));\n    xor xor_inst(.a(a), .b(b), .r(xor_out));\n    nor nor_inst(.a(a), .b(b), .r(nor_out));\n    slt slt_inst(.a(a), .b(b), .r(slt_out));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_out));\n    sll sll_inst(.a(a), .b(b), .r(sll_out));\n    srl srl_inst(.a(a), ."}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);", "raw_response": "\n\n    wire [63:0] result;\n\n    multiplier u_multiplier(\n        .a(a),\n        .b(b),\n        .result(result)\n    );\n\n    accumulator u_accumulator(\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .current_value(c)\n    );\n\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + result[31:0];\n    end\nendmodule"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);", "raw_response": "\n\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    // Submodule 1: Instruction Fetching from Register\n    ins_fetch ins_p1 (.clk(clk), .rst(rst), .fetch(fetch[0]), .data(data), .ins(ins1));\n\n    // Submodule 2: Instruction Fetching from RAM/ROM\n    ins_fetch ins_p2 (.clk(clk), .rst(rst), .fetch(fetch[1]), .data(data), .ins(ins2));\n\n    assign ins = {ins_p1.ins, ins_p2.ins};\n    assign ad1 = ins_p1.ad1;\n    assign ad2 = ins_p2.ad2;\n\nendmodule\n\nmodule ins_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 8'b0;\n        else if (fetch == 1)\n            ins <= data;\n    end\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ad1 <= 5'b0;\n        else if (fetch == 1)\n            ad1 <= data[4:0];\n    end\n\nendmodule"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);", "raw_response": "\n    wire [7:0] count;\n    wire enable;\n    \n    counter counter_inst(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator wave_generator_inst(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n    \n    assign enable = (freq > 0);\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        wave_out <= (count % (freq * 2)) < (freq / 2);\n    end\nendmodule"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);", "raw_response": "\n    wire inc_dec = state_inst.state;\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_reg <= 5'b0;\n        else if (inc_dec)\n            wave_reg <= wave_reg + 1;\n        else\n            wave_reg <= wave_reg - 1;\n    end\n\n    assign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output state\n);\n    reg [1:0] state_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state_reg <= 2'b00;\n        else begin\n            case (state_reg)\n                2'b00: state_reg <= 2'b01;\n                2'b01: state_reg <= 2'b10;\n                default: state_reg <= 2'b00;\n            endcase\n        end\n    end\n\n    assign state = state_reg[1];\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n    reg [4:0] wave_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave_reg <= 5'b0;\n        else begin\n            if (wave_reg == 5'b0)\n                wave_reg <= 5'b1;\n            else\n                wave_reg <= 5'b0;\n        end\n    end\n\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);", "raw_response": "\n\n    wire [7:0] shifted_d;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(shifted_d[0])\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(shifted_d[0]),\n        .q(shifted_d[1])\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(shifted_d[1]),\n        .q(shifted_d[2])\n    );\n\n    my_dff8 u3 (\n        .clk(clk),\n        .d(shifted_d[2]),\n        .q(shifted_d[3])\n    );\n\n    my_dff8 u4 (\n        .clk(clk),\n        .d(shifted_d[3]),\n        .q(shifted_d[4])\n    );\n\n    my_dff8 u5 (\n        .clk(clk),\n        .d(shifted_d[4]),\n        .q(shifted_d[5])\n    );\n\n    my_dff8 u6 (\n        .clk(clk),\n        .d(shifted_d[5]),\n        .q(shifted_d[6])\n    );\n\n    my_dff8 u7 (\n        .clk(clk),\n        .d(shifted_d[6]),\n        .q(shifted_d[7])\n    );\n\n    assign q = sel[1] ? (sel[0] ? shifted_d[3] : shifted_d[2]) : (sel[0] ? shifted_d[1] : shifted_d[0]);\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule my_mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg q\n);\n    always @(*) begin\n        case (sel)\n            2'b00: q = in[0];\n            2'b01: q = in[1];\n            2'b10: q = in[2];\n            2'b11: q = in[3];\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);", "raw_response": "\n    wire q0, q1, q2;\n\n    // Instance of D flip-flop\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    // Instance of D flip-flop\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    // Instance of D flip-flop\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);", "raw_response": "\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1_out, stage2_out, stage3_out;\n\n    // Shift the input by 4 positions\n    mux2X1 MUX4 (stage1_out, in, in >> 4, ctrl[2]);\n    mux2X1 MUX3 (stage2_out, stage1_out, stage1_out >> 2, ctrl[1]);\n    mux2X1 MUX2 (stage3_out, stage2_out, stage2_out >> 1, ctrl[0]);\n\n    assign out = stage3_out;\n\n    // 2-to-1 multiplexer\n    module mux2X1 (out, sel, in1, in2);\n        input sel;\n        input [7:0] in1, in2;\n        output [7:0] out;\n\n        assign out = sel ? in2 : in1;\n    endmodule\nendmodule"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);", "raw_response": "\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // PE0\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  // PE1\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delaying b0 to b1\n  reg [15:0] b0_reg;\n  always @(posedge clk)\n    b0_reg <= rst ? 16'b0 : b0;\n  assign b1 = b0_reg;\n\n  // Output\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n\n// PE logic\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  reg [31:0] acc;\n\n  always @(posedge clk) begin\n    if (rst)\n      acc <= 32'b0;\n    else\n      acc <= acc + a * b;\n  end\n\n  assign out = acc;\nendmodule"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);", "raw_response": "\n  wire [31:0] alu_result;\n  wire [4:0] pc;\n\n  // Instantiate 5 pipeline stages\n  fetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .next_pc(pc + 1)\n  );\n\n  decode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .alu_result(alu_result)\n  );\n\n  execute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result)\n  );\n\n  writeback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [4:0] pc,\n  output reg [4:0] next_pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 5'h0;\n      next_pc <= 5'h0;\n    end else begin\n      pc <= next_pc;\n      next_pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [4:0] pc,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 32'h0;\n    end else begin\n      alu_result <= instr_mem[pc];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      // Do nothing\n    end else begin\n      // Do something\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      // Do nothing\n    end else begin\n      // Do something\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 32'h0;\n    end else begin\n      res_reg_file <= reg_file;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);", "raw_response": "\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [15:0] b1, b2, b3;\n  \n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\n  // PE0\n  always @(posedge clk) begin\n    if(rst) begin\n      b0_reg <= 16'b0;\n      c0_reg <= 32'b0;\n    end\n    else begin\n      b0_reg <= b0;\n      c0_reg <= a0 * b0;\n    end\n  end\n\n  // PE1\n  always @(posedge clk) begin\n    if(rst) begin\n      b1_reg <= 16'b0;\n      c1_reg <= 32'b0;\n    end\n    else begin\n      b1_reg <= b1;\n      c1_reg <= a1 * b1;\n    end\n  end\n\n  // PE2\n  always @(posedge clk) begin\n    if(rst) begin\n      b2_reg <= 16'b0;\n      c2_reg <= 32'b0;\n    end\n    else begin\n      b2_reg <= b2;\n      c2_reg <= a2 * b2;\n    end\n  end\n\n  // PE3\n  always @(posedge clk) begin\n    if(rst) begin\n      b3_reg <= 16'b0;\n      c3_reg <= 32'b0;\n    end\n    else begin\n      b3_reg <= b3;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\nendmodule\n\nmodule pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk) begin\n    if(rst) begin\n      c_reg <= 0;\n    end\n    else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);", "raw_response": "\n    \n    wire [31:0] instr;\n    wire [4:0] rd;\n    wire [4:0] rs1;\n    wire [4:0] rs2;\n    wire [5:0] funct;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] result;\n    \n    wire [4:0] pc;\n    wire [31:0] fetched_instr;\n    \n    stage fetch_stage(\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(pc),\n        .fetched_instr(fetched_instr)\n    );\n    \n    stage execute_stage(\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result),\n        .reg_file(reg_file),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .funct(funct)\n    );\n    \n    stage writeback_stage(\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .reg_file(reg_file),\n        .rd(rd)\n    );\n    \n    assign out_reg_file = reg_file[rd];\nendmodule\n\nmodule stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetched_instr <= 0;\n        else\n            fetched_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [5:0] funct\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            op1 <= 0;\n            op2 <= 0;\n            funct <= 0;\n        end else begin\n            op1 <= reg_file[rs1];\n            op2 <= reg_file[rs2];\n            rd <= fetched_instr[11:7];\n            rs1 <= fetched_instr[19:15];\n            rs2 <= fetched_instr[24:20];\n            funct <= fetched_instr[31:26];\n            \n            if (funct == 6'b100000) // Add\n                result <= op1 + op2;\n            else if (funct == 6'b100010) // Sub\n                result <= op1 - op2;\n            else\n                result <= 0;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    input [4:0] rd\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            reg_file[rd] <= 0;\n        else\n            reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);", "raw_response": "\n\n    wire [9:0] accum_data;\n\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_out(accum_data)\n    );\n\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .accum_data(accum_data),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output      [9:0]   data_out\n);\n\n    reg [9:0] accum_data;\n    reg [1:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accum_data <= 10'b0;\n            counter <= 2'b0;\n        end else if (valid_in) begin\n            case (counter)\n                2'b00: accum_data <= accum_data + data_in;\n                2'b01: accum_data <= accum_data + data_in;\n                2'b10: accum_data <= accum_data + data_in;\n                2'b11: accum_data <= accum_data + data_in;\n                default: accum_data <= accum_data;\n            endcase\n            counter <= counter + 1;\n        end\n    end\n\n    assign data_out = accum_data;\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [9:0]   accum_data,\n\n    output              valid_out\n);\n\n    reg valid_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_reg <= 1'b0;\n        end else begin\n            valid_reg <= accum_data[9];\n        end\n    end\n\n    assign valid_out = valid_reg;\n\nendmodule"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);", "raw_response": "\n\n    wire [7:0] abs_dividend, abs_divisor;\n    wire [7:0] neg_divisor_mod;\n    wire [2:0] counter;\n    wire [7:0] quotient, remainder;\n\n    abs_value abs_dividend_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    abs_value abs_divisor_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(abs_divisor)\n    );\n\n    neg_value neg_divisor_mod_inst(\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor_mod)\n    );\n\n    divider_control divider_control_inst(\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .counter_done(divider_control_inst.counter_done),\n        .quotient_reg(quotient),\n        .remainder_reg(remainder)\n    );\n\n    result_management result_management_inst(\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .result_valid(res_valid),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= sign ? -value : value;\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= sign ? -value : value;\n        end\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire [2:0] counter,\n    output reg [2:0] counter_next,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_next <= 3'd0;\n            quotient <= 8'd0;\n            remainder <= 8'd0;\n        end else begin\n            quotient <= quotient + 1;\n            remainder <= remainder - neg_divisor_mod;\n            if (remainder < 0) begin\n                quotient <= quotient - 1;\n                remainder <= remainder + abs_dividend;\n            end\n            counter_next <= counter + 3'd1;\n        end\n    end\n\n    assign counter_done = &counter;\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [7:0] quotient,\n    input wire [7:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (opn_valid && res_ready) begin\n                res_valid <= 1;\n                result <= {remainder, quotient};\n            end else"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);", "raw_response": "\n\n    prep_dividend prep(\n        .A(A),\n        .B(B),\n        .odd(odd)\n    );\n\n    div_op div(\n        .A(prep.A),\n        .B(prep.B),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] odd\n);\n    assign odd = A % B;\nendmodule\n\nmodule div_op(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    integer i;\n\n    always @(*) begin\n        result = 0;\n        odd = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (A[i] == 1) begin\n                result[i] = 1;\n            end\n        end\n\n        for (i = 0; i < 16; i = i + 1) begin\n            if (B[i] == 1) begin\n                odd[i] = 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);", "raw_response": "\n\n    wire [15:0] temp_result;\n\n    // Control unit\n    div_control ctrl (\n        .A(A),\n        .B(B),\n        .result(temp_result),\n        .odd(odd)\n    );\n\n    // Output ports\n    assign result = temp_result;\n\nendmodule\n\n// Divide control unit\nmodule div_control (\n    input wire [15:0] A,   // 16-bit dividend\n    input wire [7:0] B,   // 8-bit divisor\n    output reg [15:0] result, // 16-bit quotient\n    output reg [15:0] odd     // 16-bit remainder\n);\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [4:0] i;\n\n    // Control logic\n    always @(*) begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 16'b0;\n        temp_remainder = 16'b0;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp_dividend >= temp_divisor) begin\n                temp_dividend = temp_dividend - temp_divisor;\n                temp_quotient[i] = 1;\n            end else begin\n                temp_remainder[i] = 1;\n            end\n            temp_divisor = temp_divisor << 1;\n        end\n        result = temp_quotient;\n        odd = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);", "raw_response": "\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_comp;\n    wire [7:0] B_sum;\n\n    assign B_comp = ~B + 1;\n\n    adder_8bit adder_inst(.A(A), .B(B_comp), .B_out(B_out), .D(D), .C_in(1'b0));\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    input C_in;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_sum;\n    wire [7:0] B_carry;\n    wire [7:0] B_out_temp;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .C_in(C_in), .SUM(B_sum[0]), .C_out(B_carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .C_in(B_carry[0]), .SUM(B_sum[1]), .C_out(B_carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .C_in(B_carry[1]), .SUM(B_sum[2]), .C_out(B_carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .C_in(B_carry[2]), .SUM(B_sum[3]), .C_out(B_carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .C_in(B_carry[3]), .SUM(B_sum[4]), .C_out(B_carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .C_in(B_carry[4]), .SUM(B_sum[5]), .C_out(B_carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .C_in(B_carry[5]), .SUM(B_sum[6]), .C_out(B_carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .C_in(B_carry[6]), .SUM(B_sum[7]), .C_out(B_out_temp));\n\n    assign D = B_sum;\n    assign B_out = B_out_temp;\n\nendmodule\n\nmodule full_adder(A, B, C_in, SUM, C_out);\n    input A;\n    input B;\n    input C_in;\n    output SUM;\n    output C_out;\n\n    assign SUM = A ^ B ^ C_in;\n    assign C_out = (A & B) | (B & C_in) | (C_in & A);\n\nendmodule"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);", "raw_response": "\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n    output B_out;\n\n    wire [15:0] S1;\n    wire [15:0] S2;\n    wire B1, B2;\n\n    sub_16bit S1_inst(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1),\n        .B_out(B1)\n    );\n\n    sub_16bit S2_inst(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2),\n        .B_out(B2)\n    );\n\n    assign Diff[15:0] = S1;\n    assign Diff[31:16] = S2;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Diff;\n    output B_out;\n\n    wire [7:0] S1;\n    wire [7:0] S2;\n    wire B1, B2;\n\n    sub_8bit S1_inst(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1),\n        .B_out(B1)\n    );\n\n    sub_8bit S2_inst(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2),\n        .B_out(B2)\n    );\n\n    assign Diff[7:0] = S1;\n    assign Diff[15:8] = S2;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Diff;\n    output B_out;\n\n    wire [3:0] S1;\n    wire [3:0] S2;\n    wire B1, B2;\n\n    sub_4bit S1_inst(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1),\n        .B_out(B1)\n    );\n\n    sub_4bit S2_inst(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2),\n        .B_out(B2)\n    );\n\n    assign Diff[3:0] = S1;\n    assign Diff[7:4] = S2;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] Diff;\n    output B_out;\n\n    wire [1:0] S1;\n    wire [1:0] S2;\n    wire B1, B2;\n\n    sub_2bit S1_inst(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1),\n        .B_out(B1)\n    );\n\n    sub_2bit S2_inst(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2),\n        .B_out(B2)\n    );\n\n    assign Diff[1:0] = S1;\n    assign Diff[3:2] = S2;\n    assign B_out = B1 & B2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;\n    input [1:0] B;\n    output [1"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);", "raw_response": "\ninput [63:0] A, B;\noutput [63:0] D;\noutput B_out;\n\nwire [31:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub32 sub0(\n    .A(A[31:0]),\n    .B(B[31:0]),\n    .D(sub0_D),\n    .B_out(sub0_B_out)\n);\n\nsub32 sub1(\n    .A(A[31:0]),\n    .B(B[31:0]),\n    .D(sub1_D),\n    .B_out(sub1_B_out)\n);\n\nsub16 sub00(\n    .A(sub0_D),\n    .B(sub1_D),\n    .D(D[15:0]),\n    .B_out(B_out)\n);\n\nsub16 sub01(\n    .A(A[47:32]),\n    .B(B[47:32]),\n    .D(D[47:32]),\n    .B_out(B_out)\n);\n\nsub16 sub10(\n    .A(A[63:48]),\n    .B(B[63:48]),\n    .D(D[63:48]),\n    .B_out(B_out)\n);\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\ninput [31:0] A, B;\noutput [31:0] D;\noutput B_out;\n\nwire [15:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub16 sub0(\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .D(sub0_D),\n    .B_out(sub0_B_out)\n);\n\nsub16 sub1(\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .D(sub1_D),\n    .B_out(sub1_B_out)\n);\n\nsub8 sub00(\n    .A(sub0_D),\n    .B(sub1_D),\n    .D(D[7:0]),\n    .B_out(B_out)\n);\n\nsub8 sub01(\n    .A(A[23:8]),\n    .B(B[23:8]),\n    .D(D[23:8]),\n    .B_out(B_out)\n);\n\nsub8 sub10(\n    .A(A[31:24]),\n    .B(B[31:24]),\n    .D(D[31:24]),\n    .B_out(B_out)\n);\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\ninput [15:0] A, B;\noutput [15:0] D;\noutput B_out;\n\nwire [7:0] sub0_D, sub1_D;\nwire sub0_B_out, sub1_B_out;\n\nsub8 sub0(\n    .A(A[7:0]),\n    .B(B[7:0]),\n    .D(sub0_D),\n    .B_out(sub0_B_out)\n);\n\nsub8 sub1(\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .D(sub1_D),\n    .B_out(sub1_B_out)\n);\n\nsub4 sub00(\n    .A(sub0_D),\n    .B(sub1_D),\n    .D(D[3:0]),\n    .B_out(B_out)\n);\n\nsub4 sub01(\n    .A(A[11:4]),\n    .B(B[11:4]),\n    .D(D[11:4]),\n    .B_out("}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);", "raw_response": "\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [3:0] B_out_temp;\n\n    sub_4bit bls0(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out_temp[0]));\n    sub_4bit bls1(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(B_out_temp[1]));\n    sub_4bit bls2(.A(A[5:4]), .B(B[5:4]), .D(D[5:4]), .B_out(B_out_temp[2]));\n    sub_4bit bls3(.A(A[7:6]), .B(B[7:6]), .D(D[7:6]), .B_out(B_out_temp[3]));\n    sub_4bit bls4(.A(A[9:8]), .B(B[9:8]), .D(D[9:8]), .B_out(B_out[0]));\n    sub_4bit bls5(.A(A[11:10]), .B(B[11:10]), .D(D[11:10]), .B_out(B_out[1]));\n    sub_4bit bls6(.A(A[13:12]), .B(B[13:12]), .D(D[13:12]), .B_out(B_out[2]));\n    sub_4bit bls7(.A(A[15:14]), .B(B[15:14]), .D(D[15:14]), .B_out(B_out[3]));\nendmodule\n\nmodule sub_4bit(A, B, D, B_out);\n    input [3:0] A, B;\n    output [3:0] D;\n    output B_out;\n\n    wire [2:0] borrow;\n\n    full_subtractor fsa0(.A(A[0]), .B(B[0]), .D(D[0]), .B_out(borrow[0]));\n    full_subtractor fsa1(.A(A[1]), .B(B[1]), .D(D[1]), .B_out(borrow[1]));\n    full_subtractor fsa2(.A(A[2]), .B(B[2]), .D(D[2]), .B_out(borrow[2]));\n    full_subtractor fsa3(.A(A[3]), .B(B[3]), .D(D[3]), .B_out(B_out));\n\n    assign borrow[0] = (A[0] < B[0]) ? 1'b1 : 1'b0;\n    assign borrow[1] = (A[1] < B[1]) ? borrow[0] | (A[1] < B[0]) : borrow[0];\n    assign borrow[2] = (A[2] < B[2]) ? borrow[1] | (A[2] < B[1]) : borrow[1];\nendmodule\n\nmodule full_subtractor(A, B, D, B_out);\n    input A, B;\n    output D, B_out;\n\n    wire borrow_in;\n\n    assign D = A ^ B ^ borrow_in;\n    assign B_out = (A & B) | (borrow_in & B);\nendmodule"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);", "raw_response": "\n\nwire [31:0] subtraction_result;\n\nsubtractor_32bit sub_inst(\n    .A(A),\n    .B(B),\n    .subtraction_result(subtraction_result)\n);\n\nassign A_greater = (subtraction_result != 0);\nassign A_equal = (~subtraction_result[31] & ~subtraction_result[30] & ~subtraction_result[29] & ~subtraction_result[28] &\n                   ~subtraction_result[27] & ~subtraction_result[26] & ~subtraction_result[25] & ~subtraction_result[24] &\n                   ~subtraction_result[23] & ~subtraction_result[22] & ~subtraction_result[21] & ~subtraction_result[20] &\n                   ~subtraction_result[19] & ~subtraction_result[18] & ~subtraction_result[17] & ~subtraction_result[16] &\n                   ~subtraction_result[15] & ~subtraction_result[14] & ~subtraction_result[13] & ~subtraction_result[12] &\n                   ~subtraction_result[11] & ~subtraction_result[10] & ~subtraction_result[9] & ~subtraction_result[8] &\n                   ~subtraction_result[7] & ~subtraction_result[6] & ~subtraction_result[5] & ~subtraction_result[4] &\n                   ~subtraction_result[3] & ~subtraction_result[2] & ~subtraction_result[1] & ~subtraction_result[0]);\nassign A_less = (subtraction_result[31]);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtraction_result // Result of subtraction (A - B)\n);\n\nassign subtraction_result = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);", "raw_response": "\ninput [32:1] A,B;\noutput [32:1] S;\noutput C32;\n\nwire [15:1] C16;\nwire [7:1] C8;\nwire [3:1] C4;\nwire C2;\n\nCLA1 cl1(A[16:1],B[16:1],C16[1]);\nCLA2 cl2(A[8:1],B[8:1],C16[2]);\nCLA1 cl3(A[24:17],B[24:17],C16[3]);\nCLA2 cl4(A[15:8],B[15:8],C16[4]);\nCLA1 cl5(A[23:16],B[23:16],C16[5]);\nCLA2 cl6(A[7:4],B[7:4],C16[6]);\nCLA1 cl7(A[22:15],B[22:15],C16[7]);\nCLA2 cl8(A[3:2],B[3:2],C16[8]);\nCLA1 cl9(A[21:14],B[21:14],C16[9]);\nCLA2 cl10(A[6:5],B[6:5],C16[10]);\nCLA1 cl11(A[20:13],B[20:13],C16[11]);\nCLA2 cl12(A[5:4],B[5:4],C16[12]);\nCLA1 cl13(A[19:12],B[19:12],C16[13]);\nCLA2 cl14(A[4:3],B[4:3],C16[14]);\nCLA1 cl15(A[18:11],B[18:11],C16[15]);\nCLA2 cl16(A[3:2],B[3:2],C16[16]);\n\nassign C2=A[1]^B[1];\n\ngenvar i;\ngenerate\nfor(i=1;i<16;i=i+2)\nbegin\nassign C16[i+1] = C16[i]^C16[i+1];\nend\nendgenerate\n\nassign C32 = C16[16]^C2;\nassign S = {C32,C16[16],C16[15],C16[14],C16[13],C16[12],C16[11],C16[10],C16[9],C16[8],C16[7],C16[6],C16[5],C16[4],C16[3],C16[2],C16[1],C16[15],C16[14],C16[13],C16[12],C16[11],C16[10],C16[9],C16[8],C16[7],C16[6],C16[5],C16[4],C16[3],C16[2],C16[1],A[16:1],B[16:1]};\n\nendmodule\n\nmodule CLA1(A,B,C);\ninput [15:1] A,B;\noutput C;\nwire [14:1] T;\nwire [7:1] C7;\n\nassign T[15:2]=A[15:2]^B[15:2];\nassign T[1]=A[1]^B[1];\n\ngenvar i;\ngenerate\nfor(i=1;i<8;i=i+2)\nbegin\nassign C7[i+1] = C7[i]^C7[i+1];\nend\nendgenerate\n\nassign C7[1]=T[1];\nassign C7[2]=T[2]^T[3];\nassign C7[3]=T[3]^T[5];\nassign C7[4]=T[5]^T[7];\nassign C7"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);", "raw_response": "\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\nwire [3:0] rca0_sum, rca1_sum;\nwire [3:0] rca0_carry, rca1_carry;\n\nwire [3:0] csa0_sum, csa1_sum, csa2_sum, csa3_sum;\nwire [3:0] csa0_carry, csa1_carry, csa2_carry, csa3_carry;\n\nassign rca0_sum = a[0:3] + b[0:3] + cin;\nassign rca0_carry = {a[0], b[0], 1'b0};\nassign rca1_sum = a[4:7] + b[4:7] + rca0_carry[3];\nassign rca1_carry = {a[4], b[4], rca0_carry[3]};\n\nassign sum_slice = {rca0_sum, rca1_sum};\nassign cout = rca1_carry[3];\n\nassign csa0_sum = {a[8:11], b[8:11], 1'b0};\nassign csa0_carry = {a[8], b[8], 1'b0};\nassign csa1_sum = {a[12:15], b[12:15], csa0_carry[3]};\nassign csa1_carry = {a[12], b[12], csa0_carry[3]};\nassign csa2_sum = {a[0:3], b[0:3], csa1_carry[3]};\nassign csa2_carry = {a[0], b[0], csa1_carry[3]};\nassign csa3_sum = {a[4:7], b[4:7], csa2_carry[3]};\nassign csa3_carry = {a[4], b[4], csa2_carry[3]};\n\nassign sum = {csa3_sum, csa2_sum, csa1_sum, csa0_sum};\n\nendmodule\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\nwire [3:0] rca0_sum, rca1_sum;\nwire [3:0] rca0_carry, rca1_carry;\n\nwire [3:0] csa0_sum, csa1_sum, csa2_sum, csa3_sum;\nwire [3:0] csa0_carry, csa1_carry, csa2_carry, csa3_carry;\n\nassign rca0_sum = a[0:3] + b[0:3] + cin;\nassign rca0_carry = {a[0], b[0], 1'b0};\nassign rca1_sum = a[4:7] + b[4:7] + rca0_carry[3];\nassign rca1_carry = {a[4], b[4], rca0_carry[3]};\n\nassign sum_slice = {rca0_sum, rca1_sum};\nassign cout = rca1_carry[3];\n\nassign csa0_sum = {a[8:11], b[8:11], 1'b0};\nassign csa0_carry = {a[8], b[8], 1'b0};\nassign csa1_sum = {a[12:15], b[12:15], csa0_carry[3]};\nassign csa1_carry = {a[12], b[12], csa0_carry[3]};\nassign csa2_sum = {a"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);", "raw_response": "\n    wire [7:0] carry;\n\n    // Instantiate the 8-bit adder\n    add8 adder_inst1 (.a(a[7:0]), .b(b[7:0]), .Cin(Cin), .y(y[7:0]), .Co(carry[0]));\n    add8 adder_inst2 (.a(a[15:8]), .b(b[15:8]), .Cin(carry[0]), .y(y[15:8]), .Co(carry[1]));\n    assign Co = carry[1];\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [7:0] carry;\n\n    // Instantiate the 4-bit adder\n    adder adder_inst1 (.a(a[3:0]), .b(b[3:0]), .Cin(Cin), .y(y[3:0]), .Co(carry[0]));\n    adder adder_inst2 (.a(a[7:4]), .b(b[7:4]), .Cin(carry[0]), .y(y[7:4]), .Co(carry[1]));\n    assign Co = carry[1];\n\nendmodule\n\nmodule adder (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    // 4-bit adder\n    wire [3:0] carry;\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);", "raw_response": "\n    \n    wire [7:0] carry;\n    \n    FA FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n    FA FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    FA FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    FA FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    FA FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    FA FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    FA FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    FA FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule FA(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);", "raw_response": "\n\n// Define the control unit submodule.\nreg [3:0] ctrl_count; // Shift count register.\nreg done_reg;         // Completion flag.\n\n// Control unit implementation.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ctrl_count <= 0;\n        done_reg <= 0;\n    end else if (start) begin\n        ctrl_count <= 15;\n        done_reg <= 0;\n    end else if (ctrl_count == 0) begin\n        done_reg <= 1;\n    end else begin\n        ctrl_count <= ctrl_count - 1;\n        done_reg <= 0;\n    end\nend\n\n// Define the register unit submodule.\nreg [15:0] reg_a; // Multiplicand register.\nreg [15:0] reg_b; // Multiplier register.\n\n// Register unit implementation.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_a <= 0;\n        reg_b <= 0;\n    end else if (start) begin\n        reg_a <= ain;\n        reg_b <= bin;\n    end\nend\n\n// Define the multiplier unit submodule.\nreg [31:0] mul_reg; // Multiplier register.\n\n// Multiplier unit implementation.\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        mul_reg <= 0;\n    end else begin\n        if (ctrl_count == 15) begin\n            mul_reg <= reg_b << 14; // Initial shift left.\n        end else if (ctrl_count > 0) begin\n            mul_reg <= mul_reg + (reg_b << (15 - ctrl_count)); // Shift and accumulate.\n        end\n    end\nend\n\n// Output assignment.\nassign yout = mul_reg;\nassign done = done_reg;\n\nendmodule\n\n// Control unit submodule.\nmodule ctrl_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [3:0] ctrl_count, // Shift count register.\n    output [3:0] new_ctrl_count, // New shift count output.\n    output done         // Chip output flag signal.\n);\n\nreg [3:0] new_ctrl_count_reg;\nreg done_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        new_ctrl_count_reg <= 0;\n        done_reg <= 0;\n    end else if (start) begin\n        new_ctrl_count_reg <= ctrl_count;\n        done_reg <= 0;\n    end else if (ctrl_count == 0) begin\n        new_ctrl_count_reg <= 0;\n        done_reg <= 1;\n    end else begin\n        new_ctrl_count_reg <= ctrl_count - 1;\n        done_reg <= 0;\n    end\nend\n\nassign new_ctrl_count = new_ctrl_count_reg;\nassign done = done_reg;\n\nendmodule\n\n// Register unit submodule.\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] reg_a, // Multiplicand register.\n    input [15:0] reg_b, // Multiplier register.\n    output [15:0] yout // Register output.\n);\n\nreg [15:0] yout_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        yout_reg <= 0;\n    end else if (start) begin\n        yout_reg <= reg_a;\n    end\nend\n\nassign yout = yout_reg;\n\nendmodule\n\n// Multiplier"}
